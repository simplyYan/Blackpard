function print(msg) {
    console.log(msg)
}

async function scraping(url) {
    try {
      const response = await fetch(url);
      if (!response.ok) {
        throw new Error('The page could not be accessed');
      }
  
      const html = await response.text(); 
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, 'text/html');
  
      const title = doc.querySelector('title').textContent;
      const body = doc.querySelector('body').textContent;
      const a = doc.querySelector('a').textContent;
      const h1 = doc.querySelector('h1').textContent;
      const h2 = doc.querySelector('h2').textContent;
      const h3 = doc.querySelector('h3').textContent;
      const h4 = doc.querySelector('h4').textContent;
      const button = doc.querySelector('button').textContent;
      const paragrafos = doc.querySelectorAll('p');
      const p = Array.from(paragrafos).map(p => p.textContent);
  
      return { titulo, textoParagrafos };
    } catch (error) {
      console.error('Error when scraping:', error);
      return null;
    }
  }
  

    function bool(name, value) {
        if (typeof value !== 'boolean') {
            throw new Error(`The value assigned to ${name} is not of the corresponding type`);
        }
        window[name] = value;
    }
    
    function int(name, value) {
        if (!Number.isInteger(value)) {
            throw new Error(`The value assigned to ${name} is not of the corresponding type`);
        }
        window[name] = value;
    }
    
    function string(name, value) {
        if (typeof value !== 'string') {
            throw new Error(`The value assigned to ${name} is not of the corresponding type`);
        }
        window[name] = value;
    }
    
    function float(name, value) {
        if (typeof value !== 'number' || isNaN(value)) {
            throw new Error(`The value assigned to ${name} is not of the corresponding type`);
        }
        window[name] = value;
    }

    function cache(key, value) {
        this.key = key;
        this.value = value;
    }
  
    cache.prototype.set = function() {
        localStorage.setItem(this.key, this.value)
    }

    cache.prototype.get = function() {
        localStorage.getItem(this.key)
    }

    


function blackfront(html) {
    this.html = html;

}

blackfront.prototype.new = function() {
        
    const novaJanela = window.open('', '_blank');
    if (novaJanela) {
      novaJanela.document.open();
      novaJanela.document.write(this.html);
      novaJanela.document.close();
    } else {
      console.error('Error connecting to the compiler');
    }
}


function vm(filename, filecontent) {
    this.list = ["blackpard_env.cfg"]
    this.filename = filename;
    this.filecontent = filecontent;
    this.filelist = list;
}

vm.prototype.list = function() {
    return this.filelist
}

vm.prototype.writeFile = function() {
    localStorage.setItem(this.filename, this.filecontent)
    this.list.push(this.filename)
    
}

vm.prototype.readFile = function() {
    return localStorage.getItem(this.filename)
}


vm.prototype.appendFile = function() {
var content = localStorage.getItem(this.filename)
var result = content + "\n" + this.filecontent
localStorage.setItem(this.filename, result)
}

vm.prototype.removeFile = function() {
    localStorage.removeItem(this.filename)
}

function encrypt(mensagem, chave) {
    let mensagemCriptografada = '';
    for (let i = 0; i < mensagem.length; i++) {
      const charCode = mensagem.charCodeAt(i) ^ chave.charCodeAt(i % chave.length);
      mensagemCriptografada += String.fromCharCode(charCode);
    }
    return mensagemCriptografada;
  }
  
  function decrypt(mensagemCriptografada, chave) {
    let mensagemOriginal = '';
    for (let i = 0; i < mensagemCriptografada.length; i++) {
      const charCode = mensagemCriptografada.charCodeAt(i) ^ chave.charCodeAt(i % chave.length);
      mensagemOriginal += String.fromCharCode(charCode);
    }
    return mensagemOriginal;
  }

function vmwin(title) {
    this.title = title;
}

vmwin.prototype.title = function() {
    document.title = this.title
}




require=(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
    // Generated by blackpard 1.5.0
    var fold, ref$, nameFromPath, stripString, SourceNode, SourceMapGenerator, sn, snEmpty, snSafe, snRemoveLeft, Node, Negatable, Block, Atom, Literal, Var, Key, Index, Slice, Chain, Call, List, Obj, Prop, Arr, Yield, Unary, Binary, Assign, Import, In, Existence, Fun, Class, Super, Parens, Splat, Jump, Throw, Return, While, For, StepSlice, Try, Switch, Case, If, Label, Cascade, JS, Require, Util, Vars, CopyL, DECLS, UTILS, LEVEL_TOP, LEVEL_PAREN, LEVEL_LIST, LEVEL_COND, LEVEL_OP, LEVEL_CALL, PREC, TAB, ID, SIMPLENUM, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);}, toString$ = {}.toString;
    fold = require('prelude-ls').fold;
    ref$ = require('./util'), nameFromPath = ref$.nameFromPath, stripString = ref$.stripString;
    ref$ = require('source-map'), SourceNode = ref$.SourceNode, SourceMapGenerator = ref$.SourceMapGenerator;
    sn = function(node){
      var parts, res$, i$, to$, result, e;
      node == null && (node = {});
      res$ = [];
      for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      parts = res$;
      try {
        result = new SourceNode(node.line, node.column, null, parts);
        result.displayName = node.constructor.displayName;
        return result;
      } catch (e$) {
        e = e$;
        console.dir(parts);
        throw e;
      }
    };
    snEmpty = function(node){
      var i$, ref$, len$, child;
      if (node instanceof SourceNode) {
        for (i$ = 0, len$ = (ref$ = node.children).length; i$ < len$; ++i$) {
          child = ref$[i$];
          if (!snEmpty(child)) {
            return false;
          }
        }
        return true;
      } else {
        return !node;
      }
    };
    snSafe = function(code){
      if (code instanceof SourceNode) {
        return code;
      } else {
        return code.toString();
      }
    };
    snRemoveLeft = function(node, count){
      var i$, to$, i, child;
      for (i$ = 0, to$ = node.children.length; i$ < to$; ++i$) {
        i = i$;
        child = node.children[i];
        if (child instanceof SourceNode) {
          count = snRemoveLeft(child, count);
        } else {
          child = child.toString();
          node.children[i] = child.slice(count);
          count -= child.length;
        }
        if (count <= 0) {
          return 0;
        }
      }
      return count;
    };
    SourceNode.prototype.replace = function(){
      var args, res$, i$, to$;
      res$ = [];
      for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      args = res$;
      return new SourceNode(this.line, this.column, this.source, (function(){
        var i$, x$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
          x$ = ref$[i$];
          results$.push(x$.replace.apply(x$, args));
        }
        return results$;
      }.call(this)), this.name);
    };
    SourceNode.prototype.setFile = function(filename){
      var i$, ref$, len$, child, results$ = [];
      this.source = filename;
      for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
        child = ref$[i$];
        if (child instanceof SourceNode) {
          results$.push(child.setFile(filename));
        }
      }
      return results$;
    };
    SourceNode.prototype.toStringWithSourceMap = function(){
      var args, res$, i$, to$, gen, genLine, genColumn, stack, code, debugOutput, debugIndent, debugIndentStr, genForNode;
      res$ = [];
      for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      args = res$;
      gen = (function(func, args, ctor) {
        ctor.prototype = func.prototype;
        var child = new ctor, result = func.apply(child, args), t;
        return (t = typeof result)  == "object" || t == "function" ? result || child : child;
      })(SourceMapGenerator, args, function(){});
      genLine = 1;
      genColumn = 0;
      stack = [];
      code = '';
      debugOutput = '';
      debugIndent = '';
      debugIndentStr = '  ';
      genForNode = function(node){
        var valid, i$, ref$, len$, child, cur, to$, i, c, results$ = [];
        if (node instanceof SourceNode) {
          debugOutput += debugIndent + node.displayName;
          valid = node.line && 'column' in node;
          if (valid) {
            stack.push(node);
            debugOutput += '!';
          }
          debugOutput += " " + node.line + ":" + node.column + " " + genLine + ":" + genColumn + "\n";
          debugIndent += debugIndentStr;
          for (i$ = 0, len$ = (ref$ = node.children).length; i$ < len$; ++i$) {
            child = ref$[i$];
            genForNode(child);
          }
          debugIndent = debugIndent.slice(0, debugIndent.length - debugIndentStr.length);
          if (valid) {
            return stack.pop();
          }
        } else {
          debugOutput += debugIndent + "" + JSON.stringify(node) + "\n";
          code += node;
          cur = stack[stack.length - 1];
          if (cur) {
            gen.addMapping({
              source: cur.source,
              original: {
                line: cur.line,
                column: cur.column
              },
              generated: {
                line: genLine,
                column: genColumn
              },
              name: cur.name
            });
          }
          for (i$ = 0, to$ = node.length; i$ < to$; ++i$) {
            i = i$;
            c = node.charAt(i);
            if (c === "\n") {
              genColumn = 0;
              ++genLine;
              if (cur) {
                results$.push(gen.addMapping({
                  source: cur.source,
                  original: {
                    line: cur.line,
                    column: cur.column
                  },
                  generated: {
                    line: genLine,
                    column: genColumn
                  },
                  name: cur.name
                }));
              }
            } else {
              results$.push(++genColumn);
            }
          }
          return results$;
        }
      };
      genForNode(this);
      return {
        code: code,
        map: gen,
        debug: debugOutput
      };
    };
    /* # Use this to track down places where a SourceNode is being converted into a string and causing the location to be lost
    tmp-to-string = SourceNode::to-string
    SourceNode::to-string = (...args) ->
        console.log("toString(): ", new Error().stack)
        tmp-to-string.apply this, args
    */
    (Node = function(){
      throw Error('unimplemented');
    }).prototype = {
      compile: function(options, level){
        var o, node, code, that, i$, len$, tmp;
        o = import$({}, options);
        if (level != null) {
          o.level = level;
        }
        node = this.unfoldSoak(o) || this;
        if (o.level && node.isStatement()) {
          return node.compileClosure(o);
        }
        code = (node.tab = o.indent, node).compileNode(o);
        if (that = node.temps) {
          for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {
            tmp = that[i$];
            o.scope.free(tmp);
          }
        }
        return code;
      },
      compileClosure: function(o){
        var that, fun, call, hasArgs, hasThis, out;
        if (that = this.getJump()) {
          that.carp('inconvertible statement');
        }
        fun = Fun([], Block(this));
        call = Call();
        if (o.inAsync) {
          fun.async = true;
        }
        if (o.inGenerator) {
          fun.generator = true;
        }
        this.traverseChildren(function(it){
          switch (it.value) {
          case 'this':
            hasThis = true;
            break;
          case 'arguments':
            hasArgs = it.value = 'args$';
          }
        });
        if (hasThis) {
          call.args.push(Literal('this'));
          call.method = '.call';
        }
        if (hasArgs) {
          call.args.push(Literal('arguments'));
          fun.params.push(Var('args$'));
        }
        out = Parens(Chain((fun.wrapper = true, fun['void'] = this['void'], fun), [call]), true);
        if (o.inGenerator) {
          out = new Yield('yieldfrom', out);
        } else if (o.inAsync) {
          out = new Yield('await', out);
        }
        return out.compile(o);
      },
      compileBlock: function(o, node){
        var code;
        if (!snEmpty(code = node != null ? node.compile(o, LEVEL_TOP) : void 8)) {
          return sn(null, "{\n", code, "\n" + this.tab + "}");
        } else {
          return sn(node, '{}');
        }
      },
      compileSpreadOver: function(o, list, transform){
        var ob, them, i$, len$, i, node, sp, lat, ref$;
        ob = list instanceof Obj;
        them = list.items;
        for (i$ = 0, len$ = them.length; i$ < len$; ++i$) {
          i = i$;
          node = them[i$];
          if (sp = node instanceof Splat) {
            node = node.it;
          }
          if (ob && !sp) {
            node = node.val;
          }
          node = transform(node);
          if (sp) {
            node = lat = Splat(node);
          }
          if (ob && !sp) {
            them[i].val = node;
          } else {
            them[i] = node;
          }
        }
        if (!lat && (this['void'] || !o.level)) {
          list = (ref$ = Block(ob ? (function(){
            var i$, x$, ref$, len$, results$ = [];
            for (i$ = 0, len$ = (ref$ = them).length; i$ < len$; ++i$) {
              x$ = ref$[i$];
              results$.push(x$.val);
            }
            return results$;
          }()) : them), ref$.front = this.front, ref$['void'] = true, ref$);
        }
        return list.compile(o, LEVEL_PAREN);
      },
      cache: function(o, once, level, tempName){
        var ref$, ref, sub, tempvars;
        if (!this.isComplex()) {
          return [ref$ = level != null ? this.compile(o, level) : this, ref$];
        }
        if (ref = this.getRef()) {
          sub = this;
        } else {
          sub = Assign(ref = Var(o.scope.temporary(tempName)), this);
          if (once) {
            ref.temp = true;
          } else {
            tempvars = [ref.value];
          }
        }
        if (level != null) {
          sub = sub.compile(o, level);
          if (once && tempvars) {
            o.scope.free(ref.value);
          }
          return [sub, ref.value];
        }
        return [sub, ref, tempvars];
      },
      compileLoopReference: function(o, name, ret, safeAccess){
        var ref$, code, asn, tmp;
        if (this instanceof Var && o.scope.check(this.value) || this instanceof Unary && ((ref$ = this.op) === '+' || ref$ === '-') && (-1 / 0 < (ref$ = +this.it.value) && ref$ < 1 / 0) || this instanceof Literal && !this.isComplex()) {
          code = this.compile(o, LEVEL_PAREN);
          if (safeAccess && !(this instanceof Var)) {
            code = "(" + code + ")";
          }
          return [code, code];
        }
        asn = Assign(Var(tmp = o.scope.temporary(name)), this);
        ret || (asn['void'] = true);
        return [tmp, asn.compile(o, ret ? LEVEL_CALL : LEVEL_PAREN)];
      },
      eachChild: function(fn){
        var i$, ref$, len$, name, child, j$, len1$, i, node, that;
        for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
          name = ref$[i$];
          if (child = this[name]) {
            if ('length' in child) {
              for (j$ = 0, len1$ = child.length; j$ < len1$; ++j$) {
                i = j$;
                node = child[j$];
                if (that = fn(node, name, i)) {
                  return that;
                }
              }
            } else {
              if ((that = fn(child, name)) != null) {
                return that;
              }
            }
          }
        }
      },
      traverseChildren: function(fn, xscope){
        var this$ = this;
        return this.eachChild(function(node, name, index){
          var ref$;
          return (ref$ = fn(node, this$, name, index)) != null
            ? ref$
            : node.traverseChildren(fn, xscope);
        });
      },
      rewriteShorthand: function(o, assign){
        var i$, ref$, len$, name, child, j$, len1$, i, node, that;
        for (i$ = 0, len$ = (ref$ = this.children).length; i$ < len$; ++i$) {
          name = ref$[i$];
          if (child = this[name]) {
            if ('length' in child) {
              for (j$ = 0, len1$ = child.length; j$ < len1$; ++j$) {
                i = j$;
                node = child[j$];
                if (that = node.rewriteShorthand(o, assign)) {
                  child[i] = that;
                }
              }
            } else if (that = child.rewriteShorthand(o, assign)) {
              this[name] = that;
            }
          }
        }
      },
      anaphorize: function(){
        var base, name, ref$;
        this.children = this.aTargets;
        if (this.eachChild(hasThat)) {
          if ((base = this)[name = this.aSource] instanceof Existence) {
            base[name].doAnaphorize = true;
          } else if (base[name].value !== 'that') {
            base[name] = Assign(Var('that'), base[name]);
          }
        }
        function hasThat(it){
          var that;
          return it.value === 'that' || ((that = it.aSource)
            ? (that = it[that]) ? hasThat(that) : void 8
            : it.eachChild(hasThat));
        }
        delete this.children;
        return ref$ = this[this.aSource], ref$.cond = true, ref$;
      },
      carp: function(msg, type){
        type == null && (type = SyntaxError);
        throw type(msg + " " + this.lineMsg());
      },
      warn: function(msg){
        if (typeof console != 'undefined' && console !== null) {
          console.warn("WARNING: " + msg + " " + this.lineMsg());
        }
      },
      lineMsg: function(){
        return "on line " + (this.line || this.traverseChildren(function(it){
          return it.line;
        }));
      },
      delegate: function(names, fn){
        var i$, len$;
        for (i$ = 0, len$ = names.length; i$ < len$; ++i$) {
          (fn$.call(this, names[i$]));
        }
        function fn$(name){
          this[name] = function(it){
            return fn.call(this, name, it);
          };
        }
      },
      children: [],
      terminator: ';',
      isComplex: YES,
      isStatement: NO,
      isAssignable: NO,
      isCallable: NO,
      isEmpty: NO,
      isArray: NO,
      isString: NO,
      isRegex: NO,
      isMatcher: function(){
        return this.isString() || this.isRegex();
      },
      assigns: NO,
      ripName: VOID,
      getRef: VOID,
      unfoldSoak: VOID,
      unfoldAssign: VOID,
      unparen: THIS,
      unwrap: THIS,
      maybeKey: VOID,
      varName: String,
      getAccessors: VOID,
      getCall: VOID,
      getDefault: VOID,
      getJump: VOID,
      isNextUnreachable: NO,
      extractKeyRef: function(o, assign){
        return this.maybeKey() || this.carp(assign ? "invalid assign" : "invalid property shorthand");
      },
      invert: function(){
        return Unary('!', this, true);
      },
      invertCheck: function(it){
        if (it.inverted) {
          return this.invert();
        } else {
          return this;
        }
      },
      addElse: function($else){
        this['else'] = $else;
        return this;
      },
      makeReturn: function(ref, obj){
        var items, kv, i, v;
        if (obj) {
          items = this instanceof Arr
            ? (this.items[0] == null || this.items[1] == null && this.carp('must specify both key and value for object comprehension'), this.items)
            : (kv = 'keyValue$', (function(){
              var i$, ref$, len$, results$ = [];
              for (i$ = 0, len$ = (ref$ = [Assign(Var(kv), this), Var(kv)]).length; i$ < len$; ++i$) {
                i = i$;
                v = ref$[i$];
                results$.push(Chain(v).add(Index(Literal(i))));
              }
              return results$;
            }.call(this)));
          return Assign(Chain(Var(ref)).add(Index(items[0], '.', true)), items[1]);
        } else if (ref) {
          return Call.make(JS(ref + '.push'), [this]);
        } else {
          return Return(this);
        }
      },
      show: String,
      toString: function(idt){
        var tree, that;
        idt || (idt = '');
        tree = '\n' + idt + this.constructor.displayName;
        if (that = this.show()) {
          tree += ' ' + that;
        }
        this.eachChild(function(it){
          tree += it.toString(idt + TAB);
        });
        return tree;
      },
      stringify: function(space){
        return JSON.stringify(this, null, space);
      },
      toJSON: function(){
        return import$({
          type: this.constructor.displayName
        }, this);
      }
    };
    exports.parse = function(json){
      return exports.fromJSON(JSON.parse(json));
    };
    exports.fromJSON = (function(){
      function fromJSON(it){
        var that, node, key, val, i$, len$, v, results$ = [];
        if (!(it && typeof it === 'object')) {
          return it;
        }
        if (that = it.type) {
          node = clone$(exports[that].prototype);
          for (key in it) {
            val = it[key];
            node[key] = fromJSON(val);
          }
          return node;
        }
        if (it.length != null) {
          for (i$ = 0, len$ = it.length; i$ < len$; ++i$) {
            v = it[i$];
            results$.push(fromJSON(v));
          }
          return results$;
        } else {
          return it;
        }
      }
      return fromJSON;
    }());
    Negatable = {
      show: function(){
        return this.negated && '!';
      },
      invert: function(){
        this.negated = !this.negated;
        return this;
      }
    };
    exports.Block = Block = (function(superclass){
      var prototype = extend$((import$(Block, superclass).displayName = 'Block', Block), superclass).prototype, constructor = Block;
      function Block(body){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        body || (body = []);
        if ('length' in body) {
          this$.lines = body;
        } else {
          this$.lines = [];
          this$.add(body);
        }
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Block.prototype.children = ['lines'];
      Block.prototype.toJSON = function(){
        delete this.back;
        return superclass.prototype.toJSON.call(this);
      };
      Block.prototype.add = function(it){
        var that, ref$;
        it = it.unparen();
        switch (false) {
        case !(that = this.back):
          that.add(it);
          break;
        case !(that = it.lines):
          (ref$ = this.lines).push.apply(ref$, that);
          break;
        default:
          this.lines.push(it);
          if (that = (ref$ = it.back, delete it.back, ref$)) {
            this.back = that;
          }
        }
        return this;
      };
      Block.prototype.prepend = function(){
        var ref$;
        (ref$ = this.lines).splice.apply(ref$, [this.neck(), 0].concat(arrayFrom$(arguments)));
        return this;
      };
      Block.prototype.pipe = function(target, type){
        var args;
        args = type === '|>' ? this.lines.pop() : target;
        if (toString$.call(args).slice(8, -1) !== 'Array') {
          args = [args];
        }
        switch (type) {
        case '|>':
          this.lines.push(Call.make(target, args, {
            pipe: true
          }));
          break;
        case '<|':
          this.lines.push(Call.make(this.lines.pop(), args));
        }
        return this;
      };
      Block.prototype.unwrap = function(){
        if (this.lines.length === 1) {
          return this.lines[0];
        } else {
          return this;
        }
      };
      Block.prototype.chomp = function(){
        var lines, i, that;
        lines = this.lines;
        i = lines.length;
        while (that = lines[--i]) {
          if (!that.comment) {
            break;
          }
        }
        lines.length = i + 1;
        return this;
      };
      Block.prototype.neck = function(){
        var pos, i$, ref$, len$, x;
        pos = 0;
        for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
          x = ref$[i$];
          if (!(x.comment || x instanceof Literal)) {
            break;
          }
          ++pos;
        }
        return pos;
      };
      Block.prototype.isComplex = function(){
        var ref$;
        return this.lines.length > 1 || ((ref$ = this.lines[0]) != null ? ref$.isComplex() : void 8);
      };
      prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex'], function(it){
        var ref$, ref1$;
        return (ref$ = (ref1$ = this.lines)[ref1$.length - 1]) != null ? ref$[it]() : void 8;
      });
      Block.prototype.getJump = function(it){
        var i$, ref$, len$, node, that;
        for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
          node = ref$[i$];
          if (that = node.getJump(it)) {
            return that;
          }
        }
      };
      Block.prototype.isNextUnreachable = function(){
        var i$, ref$, len$, node;
        for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
          node = ref$[i$];
          if (node.isNextUnreachable()) {
            return true;
          }
        }
        return false;
      };
      Block.prototype.makeReturn = function(){
        var that, ref$, key$;
        this.chomp();
        if (that = (ref$ = this.lines)[key$ = ref$.length - 1] != null ? ref$[key$] = (ref$ = ref$[key$]).makeReturn.apply(ref$, arguments) : void 8) {
          if (that instanceof Return && !that.it) {
            --this.lines.length;
          }
        }
        return this;
      };
      Block.prototype.compile = function(o, level){
        var tab, codes, i$, ref$, len$, node, that, code;
        level == null && (level = o.level);
        if (level) {
          return this.compileExpressions(o, level);
        }
        o.block = this;
        tab = o.indent;
        codes = [];
        for (i$ = 0, len$ = (ref$ = this.lines).length; i$ < len$; ++i$) {
          node = ref$[i$];
          if (that = node.rewriteShorthand(o)) {
            node = that;
          }
          node = node.unfoldSoak(o) || node;
          if (snEmpty(code = (node.front = true, node).compile(o, level))) {
            continue;
          }
          codes.push(tab);
          codes.push(code);
          node.isStatement() || codes.push(node.terminator);
          codes.push('\n');
        }
        codes.pop();
        return sn.apply(null, [null].concat(arrayFrom$(codes)));
      };
      Block.prototype.compileRoot = function(options){
        var o, that, ref$, bare, prefix, ref1$, ref2$, comment, ref3$, code;
        o = (import$({
          level: LEVEL_TOP,
          scope: this.scope = Scope.root = new Scope
        }, options));
        if (that = (ref$ = o.saveScope, delete o.saveScope, ref$)) {
          this.scope = Scope.root = o.scope = that.savedScope || (that.savedScope = o.scope);
        }
        delete o.filename;
        o.indent = (bare = (ref$ = o.bare, delete o.bare, ref$)) ? '' : TAB;
        if (/^\s*(?:#!|javascript:)/.test((ref$ = this.lines[0]) != null ? ref$.code : void 8)) {
          prefix = this.lines.shift().code + '\n';
        }
        if (((ref1$ = this.lines[0]) != null ? (ref2$ = ref1$.code) != null ? ref2$[0] : void 8 : void 8) === '/') {
          comment = this.lines.shift().code + '\n';
        }
        if ((ref3$ = o.eval, delete o.eval, ref3$) && this.chomp().lines.length) {
          if (bare) {
            this.lines.push(Parens(this.lines.pop()));
          } else {
            this.makeReturn();
          }
        }
        code = [this.compileWithDeclarations(o)];
        bare || (code = ["(function(){\n"].concat(arrayFrom$(code), ["\n}).call(this);\n"]));
        return sn(null, prefix || [], options.header || [], comment || [], code);
      };
      Block.prototype.compileWithDeclarations = function(o){
        var pre, i, rest, post, that;
        o.level = LEVEL_TOP;
        pre = [];
        if (i = this.neck()) {
          rest = this.lines.splice(i, 9e9);
          pre = [this.compile(o), "\n"];
          this.lines = rest;
        }
        if (snEmpty(post = this.compile(o))) {
          return sn(this, pre[0] || []);
        }
        return sn.apply(null, [null].concat(arrayFrom$(pre), [(that = this.scope) ? that.emit(post, o.indent) : post]));
      };
      Block.prototype.compileExpressions = function(o, level){
        var lines, i, that, line, code, last, i$, len$, node;
        lines = this.chomp().lines;
        i = -1;
        while (that = lines[++i]) {
          if (that.comment) {
            lines.splice(i--, 1);
          }
        }
        if (!lines.length) {
          lines.push(Literal('void'));
        }
        lines[0].front = this.front;
        lines[lines.length - 1]['void'] = this['void'];
        if (!lines[1]) {
          line = lines[0];
          if (that = line.rewriteShorthand(o)) {
            line = that;
          }
          return line.compile(o, level);
        }
        code = [];
        last = lines.pop();
        for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
          node = lines[i$];
          if (that = node.rewriteShorthand(o)) {
            node = that;
          }
          code.push((node['void'] = true, node).compile(o, LEVEL_PAREN), ', ');
        }
        if (that = last.rewriteShorthand(o)) {
          last = that;
        }
        code.push(last.compile(o, LEVEL_PAREN));
        if (level < LEVEL_LIST) {
          return sn.apply(null, [null].concat(arrayFrom$(code)));
        } else {
          return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
        }
      };
      Block.prototype.rewriteShorthand = VOID;
      return Block;
    }(Node));
    Atom = (function(superclass){
      var prototype = extend$((import$(Atom, superclass).displayName = 'Atom', Atom), superclass).prototype, constructor = Atom;
      Atom.prototype.show = function(){
        return this.value;
      };
      Atom.prototype.isComplex = NO;
      function Atom(){
        Atom.superclass.apply(this, arguments);
      }
      return Atom;
    }(Node));
    exports.Literal = Literal = (function(superclass){
      var prototype = extend$((import$(Literal, superclass).displayName = 'Literal', Literal), superclass).prototype, constructor = Literal;
      function Literal(value){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.value = value;
        if (value.js) {
          return JS(value + "", true);
        }
        if (value === 'super') {
          return new Super;
        }
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Literal.prototype.isEmpty = function(){
        var ref$;
        return (ref$ = this.value) === 'void' || ref$ === 'null';
      };
      Literal.prototype.isCallable = function(){
        var ref$;
        return (ref$ = this.value) === 'this' || ref$ === 'eval' || ref$ === '..';
      };
      Literal.prototype.isString = function(){
        return 0 <= '\'"'.indexOf((this.value + "").charAt());
      };
      Literal.prototype.isRegex = function(){
        return (this.value + "").charAt() === '/';
      };
      Literal.prototype.isComplex = function(){
        return this.isRegex() || this.value === 'debugger';
      };
      Literal.prototype.isWhat = function(){
        switch (false) {
        case !this.isEmpty():
          return 'empty';
        case !this.isCallable():
          return 'callable';
        case !this.isString():
          return 'string';
        case !this.isRegex():
          return 'regex';
        case !this.isComplex():
          return 'complex';
        default:
    
        }
      };
      Literal.prototype.varName = function(){
        if (/^\w+$/.test(this.value)) {
          return '$' + this.value;
        } else {
          return '';
        }
      };
      Literal.prototype.makeReturn = function(it){
        if (!it && this.value === 'debugger') {
          return this;
        } else {
          return superclass.prototype.makeReturn.apply(this, arguments);
        }
      };
      Literal.prototype.maybeKey = function(){
        var ref$;
        if (ID.test(this.value)) {
          return Key(this.value, (ref$ = this.value) !== 'arguments' && ref$ !== 'eval');
        } else {
          return this;
        }
      };
      Literal.prototype.compile = function(o, level){
        var val, ref$;
        level == null && (level = o.level);
        switch (val = this.value + "") {
        case 'this':
          return sn(this, ((ref$ = o.scope.fun) != null ? ref$.bound : void 8) || val);
        case 'void':
          if (!level) {
            return sn(this, '');
          }
          val += ' 8';
          // fallthrough
        case 'null':
          if (level === LEVEL_CALL) {
            this.carp('invalid use of ' + this.value);
          }
          break;
        case 'on':
        case 'yes':
          val = 'true';
          break;
        case 'off':
        case 'no':
          val = 'false';
          break;
        case '*':
          this.carp('stray star');
          break;
        case '..':
          if (!(val = o.ref)) {
            this.carp('stray reference');
          }
          this.cascadee || (val.erred = true);
          break;
        case 'debugger':
          if (level) {
            return sn(this, "(function(){ debugger; }())");
          }
        }
        return sn(this, snSafe(val));
      };
      return Literal;
    }(Atom));
    exports.Var = Var = (function(superclass){
      var prototype = extend$((import$(Var, superclass).displayName = 'Var', Var), superclass).prototype, constructor = Var;
      function Var(value){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.value = value;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      prototype.isAssignable = prototype.isCallable = YES;
      Var.prototype.assigns = function(){
        return [this.value];
      };
      Var.prototype.maybeKey = function(){
        var ref$;
        return ref$ = Key(this.value), ref$.line = this.line, ref$;
      };
      Var.prototype.varName = prototype.show;
      Var.prototype.compile = function(o){
        return sn(this, this.temp
          ? o.scope.free(this.value)
          : this.value);
      };
      return Var;
    }(Atom));
    exports.Key = Key = (function(superclass){
      var prototype = extend$((import$(Key, superclass).displayName = 'Key', Key), superclass).prototype, constructor = Key;
      function Key(name, reserved){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.reserved = reserved || name.reserved;
        this$.name = '' + name;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Key.prototype.isComplex = NO;
      Key.prototype.assigns = function(){
        return [this.name];
      };
      Key.prototype.maybeKey = THIS;
      Key.prototype.varName = function(){
        var name;
        name = this.name;
        if (this.reserved || (name === 'arguments' || name === 'eval')) {
          return "$" + name;
        } else {
          return name;
        }
      };
      Key.prototype.show = function(){
        if (this.reserved) {
          return "'" + this.name + "'";
        } else {
          return this.name;
        }
      };
      Key.prototype.compile = function(){
        return sn(this, this.show());
      };
      return Key;
    }(Node));
    exports.Index = Index = (function(superclass){
      var prototype = extend$((import$(Index, superclass).displayName = 'Index', Index), superclass).prototype, constructor = Index;
      function Index(key, symbol, init){
        var k, this$ = this instanceof ctor$ ? this : new ctor$;
        symbol || (symbol = '.');
        if (init && key instanceof Arr) {
          switch (key.items.length) {
          case 1:
            if (!((k = key.items[0]) instanceof Splat)) {
              key = Parens(k);
            }
          }
        }
        switch (symbol) {
        case '[]':
          this$.vivify = Arr;
          break;
        case '{}':
          this$.vivify = Obj;
          break;
        default:
          if ('=' === symbol.slice(-1)) {
            this$.assign = symbol.slice(1);
          }
        }
        this$.key = key;
        this$.symbol = symbol;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Index.prototype.children = ['key'];
      Index.prototype.show = function(){
        return [this.soak ? '?' : void 8] + this.symbol;
      };
      Index.prototype.isComplex = function(){
        return this.key.isComplex() || this.vivify != null;
      };
      Index.prototype.varName = function(){
        var ref$;
        return ((ref$ = this.key) instanceof Key || ref$ instanceof Literal) && this.key.varName();
      };
      Index.prototype.compile = function(o){
        var code;
        code = this.key.compile(o, LEVEL_PAREN);
        if (this.key instanceof Key && '\'' !== code.toString().charAt(0)) {
          return sn(this, ".", code);
        } else {
          return sn(this, "[", code, "]");
        }
      };
      return Index;
    }(Node));
    exports.Slice = Slice = (function(superclass){
      var prototype = extend$((import$(Slice, superclass).displayName = 'Slice', Slice), superclass).prototype, constructor = Slice;
      function Slice(arg$){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.type = arg$.type, this$.target = arg$.target, this$.from = arg$.from, this$.to = arg$.to;
        this$.from == null && (this$.from = Literal(0));
        if (this$.to && this$.type === 'to') {
          this$.to = Binary('+', this$.to, Literal('1'));
        }
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Slice.prototype.children = ['target', 'from', 'to'];
      Slice.prototype.show = function(){
        return this.type;
      };
      Slice.prototype.compileNode = function(o){
        var args;
        if (this.to && this.type === 'to') {
          this.to = Binary('||', this.to, Literal('9e9'));
        }
        args = [this.target, this.from];
        if (this.to) {
          args.push(this.to);
        }
        return Chain(Var(util('slice'))).add(Index(Key('call'), '.', true)).add(Call(args)).compile(o);
      };
      return Slice;
    }(Node));
    exports.Chain = Chain = (function(superclass){
      var prototype = extend$((import$(Chain, superclass).displayName = 'Chain', Chain), superclass).prototype, constructor = Chain;
      function Chain(head, tails){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        if (!tails && head instanceof Chain) {
          return head;
        }
        this$.head = head;
        this$.tails = tails || [];
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Chain.prototype.children = ['head', 'tails'];
      Chain.prototype.add = function(it){
        var last, ref$, index, ref1$, bi, logics, call, f;
        if (this.tails.length) {
          last = (ref$ = this.tails)[ref$.length - 1];
          if (last instanceof Call && ((ref$ = last.partialized) != null ? ref$.length : void 8) === 1 && it.args.length === 1) {
            index = last.partialized[0].head.value;
            delete last.partialized;
            last.args[index] = it.args[0];
            return this;
          }
        }
        if (this.head instanceof Existence) {
          ref1$ = Chain(this.head.it), this.head = ref1$.head, this.tails = ref1$.tails;
          it.soak = true;
        }
        this.tails.push(it);
        bi = this.head instanceof Parens && this.head.it instanceof Binary && !this.head.it.partial
          ? this.head.it
          : this.head instanceof Binary && !this.head.partial ? this.head : void 8;
        if (this.head instanceof Super) {
          if (!this.head.called && it instanceof Call && !it.method) {
            it.method = '.call';
            it.args.unshift(Literal('this'));
            this.head.called = true;
          } else if (!this.tails[1] && ((ref1$ = it.key) != null ? ref1$.name : void 8) === 'prototype') {
            this.head.sproto = true;
          }
        } else if (it instanceof Call && this.tails.length === 1 && bi && in$(bi.op, logics = ['&&', '||', 'xor'])) {
          call = it;
          f = function(x, key){
            var y;
            y = x[key];
            if (y instanceof Binary && in$(y.op, logics)) {
              f(y, 'first');
              return f(y, 'second');
            } else {
              return x[key] = Chain(y).autoCompare(call.args);
            }
          };
          f(bi, 'first');
          f(bi, 'second');
          return bi;
        }
        return this;
      };
      Chain.prototype.autoCompare = function(target){
        var test;
        if (!this.tails.length) {
          test = this.head;
        }
        switch (false) {
        case !(test instanceof Literal):
          return Binary('===', test, target[0]);
        case !(test instanceof Unary && test.it instanceof Literal):
          return Binary('===', test, target[0]);
        case !(test instanceof Arr || test instanceof Obj):
          return Binary('====', test, target[0]);
        case !(test instanceof Var && test.value === '_'):
          return Literal('true');
        default:
          return this.add(Call(target)) || [];
        }
      };
      Chain.prototype.flipIt = function(){
        this.flip = true;
        return this;
      };
      Chain.prototype.unwrap = function(){
        if (this.tails.length) {
          return this;
        } else {
          return this.head;
        }
      };
      prototype.delegate(['getJump', 'assigns', 'isStatement', 'isString'], function(it, arg){
        return !this.tails.length && this.head[it](arg);
      });
      Chain.prototype.isComplex = function(){
        return this.tails.length || this.head.isComplex();
      };
      Chain.prototype.isCallable = function(){
        var that, ref$;
        if (that = (ref$ = this.tails)[ref$.length - 1]) {
          return !((ref$ = that.key) != null && ref$.items);
        } else {
          return this.head.isCallable();
        }
      };
      Chain.prototype.isArray = function(){
        var that, ref$;
        if (that = (ref$ = this.tails)[ref$.length - 1]) {
          return that.key instanceof Arr;
        } else {
          return this.head.isArray();
        }
      };
      Chain.prototype.isRegex = function(){
        return this.head.value === 'RegExp' && !this.tails[1] && this.tails[0] instanceof Call;
      };
      Chain.prototype.isAssignable = function(){
        var tail, ref$, i$, len$;
        if (!(tail = (ref$ = this.tails)[ref$.length - 1])) {
          return this.head.isAssignable();
        }
        if (!(tail instanceof Index) || tail.key instanceof List || tail.symbol === '.~') {
          return false;
        }
        for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
          tail = ref$[i$];
          if (tail.assign) {
            return false;
          }
        }
        return true;
      };
      Chain.prototype.isSimpleAccess = function(){
        return this.tails.length === 1 && !this.head.isComplex() && !this.tails[0].isComplex();
      };
      Chain.prototype.makeReturn = function(){
        var ref$;
        if (this.tails.length) {
          return superclass.prototype.makeReturn.apply(this, arguments);
        } else {
          return (ref$ = this.head).makeReturn.apply(ref$, arguments);
        }
      };
      Chain.prototype.getCall = function(){
        var tail, ref$;
        return (tail = (ref$ = this.tails)[ref$.length - 1]) instanceof Call && tail;
      };
      Chain.prototype.varName = function(){
        var ref$, ref1$;
        return (ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? ref$.varName() : void 8;
      };
      Chain.prototype.cacheReference = function(o){
        var name, ref$, base, bref, nref, key;
        name = (ref$ = this.tails)[ref$.length - 1];
        if (!this.isAssignable()) {
          return this.unwrap().cache(o, true);
        }
        if (this.tails.length < 2 && !this.head.isComplex() && !(name != null && name.isComplex())) {
          return [this, this];
        }
        base = Chain(this.head, this.tails.slice(0, -1));
        if (base.isComplex()) {
          ref$ = base.unwrap().cache(o, true), base = ref$[0], bref = ref$[1];
          base = Chain(base);
        }
        if (!name) {
          return [base, bref];
        }
        nref = name;
        if (name.symbol !== '.') {
          nref = name;
          name = Index(name.key, '.');
        }
        if (name.isComplex()) {
          ref$ = name.key.unwrap().cache(o, true, void 8, 'key'), key = ref$[0], nref.key = ref$[1];
          name = Index(key);
        }
        return [base.add(name), Chain(bref || base.head, [nref])];
      };
      Chain.prototype.compileNode = function(o){
        var head, tails, that, i$, len$, t, hasPartial, pre, rest, broken, partial, post, context, idt, func, base, news, ref$;
        if (this.flip) {
          util('flip');
          util('curry');
        }
        head = this.head, tails = this.tails;
        head.front = this.front;
        head.newed = this.newed;
        if (!tails.length) {
          return head.compile(o);
        }
        if (that = this.unfoldAssign(o)) {
          return that.compile(o);
        }
        for (i$ = 0, len$ = tails.length; i$ < len$; ++i$) {
          t = tails[i$];
          if (t.partialized) {
            hasPartial = true;
            break;
          }
        }
        if (hasPartial) {
          util('slice');
          pre = [];
          rest = [];
          for (i$ = 0, len$ = tails.length; i$ < len$; ++i$) {
            t = tails[i$];
            broken = broken || t.partialized != null;
            if (broken) {
              rest.push(t);
            } else {
              pre.push(t);
            }
          }
          if (rest != null) {
            partial = rest[0], post = slice$.call(rest, 1);
          }
          this.tails = pre;
          context = pre.length
            ? Chain(head, slice$.call(pre, 0, -1))
            : Literal('this');
          return Chain(Chain(Var(util('partialize'))).add(Index(Key('apply'))).add(Call([context, Arr([this, Arr(partial.args), Arr(partial.partialized)])])), post).compile(o);
        }
        if (tails[0] instanceof Call && !head.isCallable()) {
          this.carp('invalid callee');
        }
        this.expandVivify();
        this.expandBind(o);
        this.expandSplat(o);
        this.expandStar(o);
        if (this.splattedNewArgs) {
          idt = o.indent + TAB;
          func = Chain(this.head, tails.slice(0, -1));
          return sn(null, "(function(func, args, ctor) {\n" + idt + "ctor.prototype = func.prototype;\n" + idt + "var child = new ctor, result = func.apply(child, args), t;\n" + idt + "return (t = typeof result)  == \"object\" || t == \"function\" ? result || child : child;\n" + TAB + "})(", func.compile(o), ", ", this.splattedNewArgs, ", function(){})");
        }
        if (!this.tails.length) {
          return this.head.compile(o);
        }
        base = [this.head.compile(o, LEVEL_CALL)];
        news = [];
        rest = [];
        for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
          t = ref$[i$];
          if (t['new']) {
            news.push('new ');
          }
          rest.push(t.compile(o));
        }
        if ('.' === rest.join("").charAt(0) && SIMPLENUM.test(base[0].toString())) {
          base.push(' ');
        }
        return sn.apply(null, [null].concat(arrayFrom$(news), arrayFrom$(base), arrayFrom$(rest)));
      };
      Chain.prototype.unfoldSoak = function(o){
        var that, ref$, i$, len$, i, node, ref1$, bust, test;
        if (that = this.head.unfoldSoak(o)) {
          (ref$ = that.then.tails).push.apply(ref$, this.tails);
          return that;
        }
        for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
          i = i$;
          node = ref$[i$];
          if (ref1$ = node.soak, delete node.soak, ref1$) {
            bust = Chain(this.head, this.tails.splice(0, i));
            if (node.assign && !bust.isAssignable()) {
              node.carp('invalid accessign');
            }
            if (i && (node.assign || node instanceof Call)) {
              ref1$ = bust.cacheReference(o), test = ref1$[0], bust = ref1$[1];
              if (bust instanceof Chain) {
                (ref1$ = this.tails).unshift.apply(ref1$, bust.tails);
                bust = bust.head;
              }
              this.head = bust;
            } else {
              ref1$ = bust.unwrap().cache(o), test = ref1$[0], this.head = ref1$[1];
            }
            test = node instanceof Call
              ? JS("typeof " + test.compile(o, LEVEL_OP) + " == 'function'")
              : Existence(test);
            return ref1$ = If(test, this), ref1$.soak = true, ref1$.cond = this.cond, ref1$['void'] = this['void'], ref1$;
          }
        }
      };
      Chain.prototype.unfoldAssign = function(o){
        var that, ref$, i$, len$, i, index, op, left, lefts, rites, j$, len1$, node, ref1$;
        if (that = this.head.unfoldAssign(o)) {
          (ref$ = that.right.tails).push.apply(ref$, this.tails);
          return that;
        }
        for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
          i = i$;
          index = ref$[i$];
          if (op = index.assign) {
            index.assign = '';
            left = Chain(this.head, this.tails.splice(0, i)).unwrap();
            if (left instanceof Arr) {
              lefts = left.items;
              rites = (this.head = Arr()).items;
              for (j$ = 0, len1$ = lefts.length; j$ < len1$; ++j$) {
                i = j$;
                node = lefts[j$];
                ref1$ = Chain(node).cacheReference(o), rites[i] = ref1$[0], lefts[i] = ref1$[1];
              }
            } else {
              ref1$ = Chain(left).cacheReference(o), left = ref1$[0], this.head = ref1$[1];
            }
            if (op === '=') {
              op = ':=';
            }
            return ref1$ = Assign(left, this, op), ref1$.access = true, ref1$;
          }
        }
      };
      Chain.prototype.expandSplat = function(o){
        var tails, i, call, args, ctx, ref$;
        tails = this.tails;
        i = -1;
        while (call = tails[++i]) {
          if (!(args = call.args)) {
            continue;
          }
          ctx = call.method === '.call' && (args = args.concat()).shift();
          if (!!snEmpty(args = Splat.compileArray(o, args, true))) {
            continue;
          }
          if (call['new']) {
            this.splattedNewArgs = args;
          } else {
            if (!ctx && tails[i - 1] instanceof Index) {
              ref$ = Chain(this.head, tails.splice(0, i - 1)).cache(o, true), this.head = ref$[0], ctx = ref$[1];
              i = 0;
            }
            call.method = '.apply';
            call.args = [ctx || Literal('null'), JS(args)];
          }
        }
      };
      Chain.prototype.expandVivify = function(){
        var tails, i, that, ref$, ref1$;
        tails = this.tails;
        i = 0;
        while (i < tails.length) {
          if (that = (ref1$ = (ref$ = tails[i++]).vivify, delete ref$.vivify, ref1$)) {
            this.head = Assign(Chain(this.head, tails.splice(0, i)), that(), '=', '||');
            i = 0;
          }
        }
      };
      Chain.prototype.expandBind = function(o){
        var tails, i, that, obj, key, call;
        tails = this.tails;
        i = -1;
        while (that = tails[++i]) {
          if (that.symbol !== '.~') {
            continue;
          }
          that.symbol = '';
          obj = Chain(this.head, tails.splice(0, i)).unwrap();
          key = tails.shift().key;
          call = Call.make(Util('bind'), [obj, (key.reserved = true, key)]);
          this.head = this.newed ? Parens(call, true) : call;
          i = -1;
        }
      };
      Chain.prototype.expandStar = function(o){
        var tails, i, that, stars, ref$, sub, ref, temps, value, i$, len$, star;
        tails = this.tails;
        i = -1;
        while (that = tails[++i]) {
          if (that.args || that.stars || that.key instanceof Key) {
            continue;
          }
          stars = that.stars = [];
          that.eachChild(seek);
          if (!stars.length) {
            continue;
          }
          ref$ = Chain(this.head, tails.splice(0, i)).unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
          value = Chain(ref, [Index(Key('length'))]).compile(o);
          for (i$ = 0, len$ = stars.length; i$ < len$; ++i$) {
            star = stars[i$];
            star.value = value;
            star.isAssignable = YES;
          }
          this.head = JS(sub.compile(o, LEVEL_CALL) + tails.shift().compile(o));
          if (temps) {
            o.scope.free(temps[0]);
          }
          i = -1;
        }
        function seek(it){
          if (it.value === '*') {
            stars.push(it);
          } else if (!(it instanceof Index)) {
            it.eachChild(seek);
          }
        }
      };
      Chain.prototype.rewriteShorthand = function(o, assign){
        var that, i$, ref$, len$, i, item;
        if (that = this.head.rewriteShorthand(o)) {
          this.head = that;
        }
        for (i$ = 0, len$ = (ref$ = this.tails).length; i$ < len$; ++i$) {
          i = i$;
          item = ref$[i$];
          if (that = item.rewriteShorthand(o, assign)) {
            this.tails[i] = that;
          }
        }
        this.expandSlice(o, assign);
        return this.unwrap();
      };
      Chain.prototype.expandSlice = function(o, assign){
        var tails, i, tail, ref$, x;
        tails = this.tails;
        i = -1;
        while (tail = tails[++i]) {
          if ((ref$ = tail.key) != null && ref$.items) {
            if (tails[i + 1] instanceof Call) {
              tail.carp('calling a slice');
            }
            x = tails.splice(0, i + 1);
            x = x.pop().key.toSlice(o, Chain(this.head, x).unwrap(), tail.symbol, assign);
            this.head = (x.front = this.front, x);
            i = -1;
          }
        }
        return this;
      };
      Chain.prototype.extractKeyRef = function(o, assign){
        var ref$, ref1$;
        return ((ref$ = (ref1$ = this.tails)[ref1$.length - 1]) != null ? (ref1$ = ref$.key) != null ? ref1$.extractKeyRef(o, assign) : void 8 : void 8) || superclass.prototype.extractKeyRef.apply(this, arguments);
      };
      return Chain;
    }(Node));
    exports.Call = Call = (function(superclass){
      var prototype = extend$((import$(Call, superclass).displayName = 'Call', Call), superclass).prototype, constructor = Call;
      function Call(args){
        var splat, i$, len$, i, a, ref$, this$ = this instanceof ctor$ ? this : new ctor$;
        args || (args = []);
        if (args.length === 1 && (splat = args[0]) instanceof Splat) {
          if (splat.filler) {
            this$.method = '.call';
            args[0] = Literal('this');
            args[1] = Splat(Literal('arguments'));
          } else if (splat.it instanceof Arr) {
            args = splat.it.items;
          }
        } else {
          for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
            i = i$;
            a = args[i$];
            if (a.value === '_') {
              args[i] = Chain(Literal('void'));
              args[i].placeholder = true;
              ((ref$ = this$.partialized) != null
                ? ref$
                : this$.partialized = []).push(Chain(Literal(i)));
            }
          }
        }
        this$.args = args;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Call.prototype.children = ['args'];
      Call.prototype.show = function(){
        return [this['new']] + [this.method] + [this.soak ? '?' : void 8];
      };
      Call.prototype.compile = function(o){
        var code, i$, ref$, len$, i, a;
        code = [sn(this, this.method || '', '(') + (this.pipe ? "\n" + o.indent : '')];
        for (i$ = 0, len$ = (ref$ = this.args).length; i$ < len$; ++i$) {
          i = i$;
          a = ref$[i$];
          code.push(i ? ', ' : '', a.compile(o, LEVEL_LIST));
        }
        code.push(sn(this, ')'));
        return sn.apply(null, [null].concat(arrayFrom$(code)));
      };
      Call.make = function(callee, args, opts){
        var call;
        call = Call(args);
        if (opts) {
          import$(call, opts);
        }
        return Chain(callee).add(call);
      };
      Call.block = function(fun, args, method){
        var ref$, ref1$;
        return ref$ = Parens(Chain(fun, [(ref1$ = Call(args), ref1$.method = method, ref1$)]), true), ref$.calling = true, ref$;
      };
      Call.back = function(params, node, bound, curried, hushed, generator){
        var fun, ref$, args, index, i$, len$, a;
        fun = Fun(params, void 8, bound, curried, hushed, generator);
        if (node instanceof Label) {
          fun.name = node.label;
          fun.labeled = true;
          node = node.it;
        }
        if (!fun.hushed && (fun.hushed = node.op === '!')) {
          node = node.it;
        }
        if ((ref$ = node.getCall()) != null) {
          ref$.partialized = null;
        }
        args = (node.getCall() || (node = Chain(node).add(Call())).getCall()).args;
        index = 0;
        for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
          a = args[i$];
          if (a.placeholder) {
            break;
          }
          ++index;
        }
        return node.back = (args[index] = fun).body, node;
      };
      Call['let'] = function(args, body){
        var hasYield, hasAwait, params, res$, i$, len$, i, a, that, gotThis;
        hasYield = false;
        hasAwait = false;
        body.traverseChildren(function(child){
          if (child instanceof Yield) {
            switch (child.op) {
            case 'yield':
            case 'yieldfrom':
              hasYield = true;
              break;
            case 'await':
              hasAwait = true;
            }
          }
          if (hasYield && hasAwait) {
            return true;
          }
        });
        res$ = [];
        for (i$ = 0, len$ = args.length; i$ < len$; ++i$) {
          i = i$;
          a = args[i$];
          if (that = a.op === '=' && !a.logic && a.right) {
            args[i] = that;
            if (i === 0 && (gotThis = a.left.value === 'this')) {
              continue;
            }
            res$.push(a.left);
          } else {
            res$.push(Var(a.varName() || a.carp('invalid "let" argument')));
          }
        }
        params = res$;
        gotThis || args.unshift(Literal('this'));
        body = this.block(Fun(params, body, null, null, null, hasYield, hasAwait), args, '.call');
        if (hasYield || hasAwait) {
          return Block(Yield(hasYield ? 'yieldfrom' : 'await', body));
        } else {
          return body;
        }
      };
      return Call;
    }(Node));
    List = (function(superclass){
      var prototype = extend$((import$(List, superclass).displayName = 'List', List), superclass).prototype, constructor = List;
      List.prototype.children = ['items'];
      List.prototype.show = function(){
        return this.name;
      };
      List.prototype.named = function(name){
        this.name = name;
        return this;
      };
      List.prototype.isEmpty = function(){
        return !this.items.length;
      };
      List.prototype.assigns = function(){
        var x$, res$, i$, ref$, len$, node, that, j$, len1$, x;
        res$ = [];
        for (i$ = 0, len$ = (ref$ = this.items).length; i$ < len$; ++i$) {
          node = ref$[i$];
          if (that = node.assigns()) {
            for (j$ = 0, len1$ = that.length; j$ < len1$; ++j$) {
              x = that[j$];
              res$.push(x);
            }
          }
        }
        x$ = res$;
        if (that = this.name) {
          x$.push(that);
        }
        return x$;
      };
      List.compile = function(o, items, deepEq){
        var indent, level, code, i, that, target;
        switch (items.length) {
        case 0:
          return '';
        case 1:
          return items[0].compile(o, LEVEL_LIST);
        }
        indent = o.indent, level = o.level;
        o.indent = indent + TAB;
        o.level = LEVEL_LIST;
        code = [items[i = 0].compile(o)];
        while (that = items[++i]) {
          code.push(', ');
          target = that;
          if (deepEq) {
            if (target instanceof Var && target.value === '_') {
              target = Obj([Prop(Key('__placeholder__'), Literal(true))]);
            } else if (target instanceof Obj || target instanceof Arr) {
              target.deepEq = true;
            }
          }
          code.push(target.compile(o));
        }
        if (~code.join("").indexOf('\n')) {
          code = ["\n" + o.indent].concat(arrayFrom$(code), ["\n" + indent]);
        }
        o.indent = indent;
        o.level = level;
        return sn.apply(null, [this].concat(arrayFrom$(code)));
      };
      List.prototype.toSlice = function(o, base, symbol, assign){
        var items, isObj, ref$, ref, temps, i$, len$, i, item, val, splat, chain;
        items = this.items;
        isObj = this instanceof Obj;
        if (items.length > 1) {
          ref$ = base.cache(o), base = ref$[0], ref = ref$[1], temps = ref$[2];
        } else {
          ref = base;
        }
        for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
          i = i$;
          item = items[i$];
          if (!item.comment) {
            if (isObj) {
              val = item.val;
              if (!(val instanceof List)) {
                (val = val.maybeKey()) || this.carp("value in object slice is not a key");
              }
            } else {
              val = item;
              if (splat = val instanceof Splat) {
                val = val.it;
              }
              if (val.isEmpty()) {
                continue;
              }
            }
            chain = val instanceof List
              ? val.toSlice(o, base, symbol, assign)
              : Chain(base, [Index(val, symbol)]);
            if (isObj) {
              item.val = chain;
            } else {
              items[i] = splat ? Splat(chain) : chain;
            }
            base = ref;
          }
        }
        chain || this.carp('empty slice');
        if (temps) {
          (this.temps || (this.temps = [])).push(temps[0]);
        }
        return this;
      };
      List.prototype.extractKeyRef = function(){
        var that;
        if ((that = this.name) != null) {
          return Key(that);
        } else {
          return superclass.prototype.extractKeyRef.apply(this, arguments);
        }
      };
      function List(){
        List.superclass.apply(this, arguments);
      }
      return List;
    }(Node));
    exports.Obj = Obj = (function(superclass){
      var prototype = extend$((import$(Obj, superclass).displayName = 'Obj', Obj), superclass).prototype, constructor = Obj;
      function Obj(items){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.items = items || [];
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Obj.prototype.asObj = THIS;
      Obj.prototype.compileNode = function(o){
        var items, code, idt, dic, i$, len$, i, node, ref$, rest, multi, key, val;
        if (this.name != null) {
          this.carp("unexpected label");
        }
        items = this.items;
        if (!items.length) {
          return sn(this, this.front ? '({})' : '{}');
        }
        code = [];
        idt = '\n' + (o.indent += TAB);
        dic = {};
        for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
          i = i$;
          node = items[i$];
          if (node.comment) {
            code.push(idt, node.compile(o));
            continue;
          }
          if ((ref$ = node.key) instanceof Splat || ref$ instanceof Parens) {
            rest = items.slice(i);
            break;
          }
          if (node.logic) {
            node.val = (ref$ = node.logic, ref$.first = node.val, ref$);
          }
          if (this.deepEq) {
            if (node.val instanceof Var && node.val.value === '_') {
              node.val = Obj([Prop(Key('__placeholder__'), Literal(true))]);
            } else if ((ref$ = node.val) instanceof Obj || ref$ instanceof Arr) {
              node.val.deepEq = true;
            }
          }
          if (multi) {
            code.push(',');
          } else {
            multi = true;
          }
          code.push(idt);
          key = node.key, val = node.val;
          if (node.accessor) {
            code.push(node.compileAccessor(o, key = key.compile(o)));
          } else {
            val.ripName(key);
            code.push(key = key.compile(o), ": ", val.compile(o, LEVEL_LIST));
          }
          ID.test(key) || (key = Function("return " + key)());
          if (!(dic[key + "."] ^= 1)) {
            node.carp("duplicate property \"" + key + "\"");
          }
        }
        if (code.join("")) {
          code.push('\n' + this.tab);
        }
        code = sn.apply(null, [null, sn(this, "{")].concat(arrayFrom$(code), [sn(this, "}")]));
        rest && (code = Import(JS(code), Obj(rest)).compile((o.indent = this.tab, o)));
        if (this.front && '{' === code.toString().charAt()) {
          return sn(null, "(", code, ")");
        } else {
          return code;
        }
      };
      return Obj;
    }(List));
    exports.Prop = Prop = (function(superclass){
      var prototype = extend$((import$(Prop, superclass).displayName = 'Prop', Prop), superclass).prototype, constructor = Prop;
      function Prop(key, val){
        var that, i$, len$, fun, this$ = this instanceof ctor$ ? this : new ctor$;
        this$.key = key;
        this$.val = val;
        if ((key != null ? key.value : void 8) === '...') {
          this$.key = Splat();
        }
        if (that = val.getAccessors()) {
          this$.val = that;
          for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {
            fun = that[i$];
            fun.x = (fun.hushed = fun.params.length) ? 's' : 'g';
          }
          this$['accessor'] = 'accessor';
        }
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Prop.prototype.children = ['key', 'val', 'logic'];
      Prop.prototype.show = function(){
        return this.accessor;
      };
      Prop.prototype.assigns = function(){
        var ref$;
        return typeof (ref$ = this.val).assigns == 'function' ? ref$.assigns() : void 8;
      };
      Prop.prototype.compileAccessor = function(o, key){
        var funs, code, i$, len$, fun;
        funs = this.val;
        if (funs[1] && funs[0].params.length + funs[1].params.length !== 1) {
          funs[0].carp('invalid accessor parameter');
        }
        code = [];
        for (i$ = 0, len$ = funs.length; i$ < len$; ++i$) {
          fun = funs[i$];
          fun.accessor = true;
          code.push(fun.x, "et ", key, fun.compile(o, LEVEL_LIST).toString().slice(8), ',\n' + o.indent);
        }
        code.pop();
        return sn.apply(null, [null].concat(arrayFrom$(code)));
      };
      Prop.prototype.compileDescriptor = function(o){
        var obj, i$, ref$, len$, fun;
        obj = Obj();
        for (i$ = 0, len$ = (ref$ = this.val).length; i$ < len$; ++i$) {
          fun = ref$[i$];
          obj.items.push(Prop(Key(fun.x + 'et'), fun));
        }
        obj.items.push(Prop(Key('configurable'), Literal(true)));
        obj.items.push(Prop(Key('enumerable'), Literal(true)));
        return obj.compile(o);
      };
      Prop.prototype.rewriteShorthand = function(o, assign){
        var ref$, that;
        superclass.prototype.rewriteShorthand.apply(this, arguments);
        if (this.key == null && this.val instanceof Assign) {
          this.val = this.val.maybeLogic();
        }
        if (this.key == null && this.val instanceof Unary && ((ref$ = this.val.op) === '+' || ref$ === '-')) {
          this.key = this.val.it.maybeKey() || this.carp("invalid property flag shorthand");
          this.val = Literal(this.val.op === '+');
        }
        if (that = this.val instanceof Binary && this.val.getDefault()) {
          this.val = this.val.first;
          this.logic = (that.first = null, that);
        }
        this.key == null && (this.key = this.val.extractKeyRef(o, assign));
      };
      return Prop;
    }(Node));
    exports.Arr = Arr = (function(superclass){
      var prototype = extend$((import$(Arr, superclass).displayName = 'Arr', Arr), superclass).prototype, constructor = Arr;
      function Arr(items){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.items = items || [];
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Arr.prototype.isArray = YES;
      Arr.prototype.asObj = function(){
        var i, item;
        return Obj((function(){
          var i$, ref$, len$, results$ = [];
          for (i$ = 0, len$ = (ref$ = this.items).length; i$ < len$; ++i$) {
            i = i$;
            item = ref$[i$];
            results$.push(Prop(Literal(i), item));
          }
          return results$;
        }.call(this)));
      };
      Arr.prototype.compile = function(o){
        var items, code;
        if (this.name != null) {
          this.carp("unexpected label");
        }
        items = this.items;
        if (!items.length) {
          return sn(this, '[]');
        }
        if (!snEmpty(code = Splat.compileArray(o, items))) {
          return this.newed
            ? sn(this, "(", code, ")")
            : sn(this, code);
        }
        return sn(null, sn(this, "["), List.compile(o, items, this.deepEq), sn(this, "]"));
      };
      Arr.maybe = function(nodes){
        if (nodes.length === 1 && !(nodes[0] instanceof Splat)) {
          return nodes[0];
        }
        return constructor(nodes);
      };
      Arr.wrap = function(it){
        return constructor([Splat((it.isArray = YES, it))]);
      };
      return Arr;
    }(List));
    exports.Yield = Yield = (function(superclass){
      var prototype = extend$((import$(Yield, superclass).displayName = 'Yield', Yield), superclass).prototype, constructor = Yield;
      function Yield(op, it){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.op = op;
        this$.it = it;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Yield.prototype.children = ['it'];
      Yield.prototype.show = function(){
        switch (this.op) {
        case 'yield':
          return '';
        case 'yieldfrom':
          return 'from';
        case 'await':
          return 'await';
        }
      };
      prototype.delegate(['isCallable'], function(){
        return true;
      });
      Yield.prototype.compileNode = function(o){
        var code;
        code = [(function(){
          switch (this.op) {
          case 'yield':
            return 'yield';
          case 'yieldfrom':
            return 'yield*';
          case 'await':
            return 'await';
          }
        }.call(this))];
        if (this.it) {
          code.push(" " + this.it.compile(o, LEVEL_OP + PREC.unary));
        }
        return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
      };
      return Yield;
    }(Node));
    exports.Unary = Unary = (function(superclass){
      var prototype = extend$((import$(Unary, superclass).displayName = 'Unary', Unary), superclass).prototype, constructor = Unary;
      function Unary(op, it, flag){
        var that, i$, ref$, len$, node, this$ = this instanceof ctor$ ? this : new ctor$;
        if (it != null) {
          if (that = !flag && it.unaries) {
            that.push(op);
            return it;
          }
          switch (op) {
          case '!':
            if (flag) {
              break;
            }
            if (it instanceof Fun && !it.hushed) {
              return it.hushed = true, it;
            }
            return it.invert();
          case '++':
          case '--':
            if (flag) {
              this$.post = true;
            }
            break;
          case 'new':
            if (it instanceof Existence && !it.negated) {
              it = Chain(it).add(Call());
            }
            it.newed = true;
            for (i$ = 0, len$ = (ref$ = it.tails || '').length; i$ < len$; ++i$) {
              node = ref$[i$];
              if (node instanceof Call && !node['new']) {
                if (node.method === '.call') {
                  node.args.shift();
                }
                node['new'] = 'new';
                node.method = '';
                return it;
              }
            }
            break;
          case '~':
            if (it instanceof Fun && it.statement && !it.bound) {
              return it.bound = 'this$', it;
            }
          }
        }
        this$.op = op;
        this$.it = it;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Unary.prototype.children = ['it'];
      Unary.prototype.show = function(){
        return [this.post ? '@' : void 8] + this.op;
      };
      Unary.prototype.isCallable = function(){
        var ref$;
        return ((ref$ = this.op) === 'do' || ref$ === 'new' || ref$ === 'delete') || this.it == null;
      };
      Unary.prototype.isArray = function(){
        return this.it instanceof Arr && this.it.items.length || this.it instanceof Chain && this.it.isArray();
      };
      Unary.prototype.isString = function(){
        var ref$;
        return (ref$ = this.op) === 'typeof' || ref$ === 'classof';
      };
      Unary.prototype.invert = function(){
        var ref$;
        if (this.op === '!' && ((ref$ = this.it.op) === '!' || ref$ === '<' || ref$ === '>' || ref$ === '<=' || ref$ === '>=' || ref$ === 'of' || ref$ === 'instanceof')) {
          return this.it;
        }
        return constructor('!', this, true);
      };
      Unary.prototype.unfoldSoak = function(o){
        var ref$;
        return ((ref$ = this.op) === '++' || ref$ === '--' || ref$ === 'delete') && this.it != null && If.unfoldSoak(o, this, 'it');
      };
      Unary.prototype.getAccessors = function(){
        var items;
        if (this.op !== '~') {
          return;
        }
        if (this.it instanceof Fun) {
          return [this.it];
        }
        if (this.it instanceof Arr) {
          items = this.it.items;
          if (!items[2] && items[0] instanceof Fun && items[1] instanceof Fun) {
            return items;
          }
        }
      };
      function crement(it){
        return {
          '++': 'in',
          '--': 'de'
        }[it] + 'crement';
      }
      Unary.prototype.compileNode = function(o){
        var that, op, it, x, code;
        if (this.it == null) {
          return this.compileAsFunc(o);
        }
        if (that = this.compileSpread(o)) {
          return that;
        }
        op = this.op, it = this.it;
        switch (op) {
        case '!':
          it.cond = true;
          break;
        case 'new':
          it.isCallable() || it.carp('invalid constructor');
          break;
        case 'do':
          if (o.level === LEVEL_TOP && it instanceof Fun && it.isStatement()) {
            return sn(this, it.compile(o), " ", Unary('do', Var(it.name)).compile(o));
          }
          x = Parens(it instanceof Existence && !it.negated
            ? Chain(it).add(Call())
            : Call.make(it));
          return sn(this, (x.front = this.front, x.newed = this.newed, x).compile(o));
        case 'delete':
          if (it instanceof Var || !it.isAssignable()) {
            this.carp('invalid delete');
          }
          if (o.level && !this['void']) {
            return this.compilePluck(o);
          }
          break;
        case '++':
        case '--':
          it.isAssignable() || this.carp('invalid ' + crement(op));
          if (that = it instanceof Var && o.scope.checkReadOnly(it.value)) {
            this.carp(crement(op) + " of " + that + " \"" + it.value + "\"", ReferenceError);
          }
          if (this.post) {
            it.front = this.front;
          }
          break;
        case '^^':
          return sn(this, util('clone'), "(", it.compile(o, LEVEL_LIST), ")");
        case 'jsdelete':
          return sn(this, "delete ", it.compile(o, LEVEL_LIST));
        case 'classof':
          return sn(this, util('toString'), ".call(", it.compile(o, LEVEL_LIST), ").slice(8, -1)");
        }
        code = [it.compile(o, LEVEL_OP + PREC.unary)];
        if (this.post) {
          code.push(op);
        } else {
          if ((op === 'new' || op === 'typeof' || op === 'delete') || (op === '+' || op === '-') && op === code.join("").charAt()) {
            op += ' ';
          }
          code.unshift(op);
        }
        if (o.level < LEVEL_CALL) {
          return sn.apply(null, [this].concat(arrayFrom$(code)));
        } else {
          return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
        }
      };
      Unary.prototype.compileSpread = function(o){
        var it, ops;
        it = this.it;
        ops = [this];
        for (; it instanceof constructor; it = it.it) {
          ops.push(it);
        }
        if (!(it instanceof Splat && (it = it.it) instanceof List)) {
          return '';
        }
        return this.compileSpreadOver(o, it, function(node){
          var i$, ref$, op;
          for (i$ = (ref$ = ops).length - 1; i$ >= 0; --i$) {
            op = ref$[i$];
            node = constructor(op.op, node, op.post);
          }
          return node;
        });
      };
      Unary.prototype.compilePluck = function(o){
        var ref$, get, del, code, ref;
        ref$ = Chain(this.it).cacheReference(o), get = ref$[0], del = ref$[1];
        code = [ref = o.scope.temporary(), " = ", get.compile(o, LEVEL_LIST), ", delete ", del.compile(o, LEVEL_LIST), ", ", o.scope.free(ref)];
        if (o.level < LEVEL_LIST) {
          return sn.apply(null, [this].concat(arrayFrom$(code)));
        } else {
          return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
        }
      };
      Unary.prototype.compileAsFunc = function(o){
        if (this.op === '!') {
          return sn(this, util('not'));
        } else {
          return sn(this, "(", Fun([], Block(Unary(this.op, Chain(Var('it'))))).compile(o), ")");
        }
      };
      return Unary;
    }(Node));
    exports.Binary = Binary = (function(superclass){
      var COMPARER, INVERSIONS, prototype = extend$((import$(Binary, superclass).displayName = 'Binary', Binary), superclass).prototype, constructor = Binary;
      function Binary(op, first, second){
        var ref$, this$ = this instanceof ctor$ ? this : new ctor$;
        this$.partial = first == null || second == null;
        if (!this$.partial) {
          if ('=' === op.charAt(op.length - 1) && ((ref$ = op.charAt(op.length - 2)) !== '=' && ref$ !== '<' && ref$ !== '>' && ref$ !== '!')) {
            return Assign(first.unwrap(), second, op);
          }
          switch (op) {
          case 'in':
            return new In(first, second);
          case 'with':
            return new Import(Unary('^^', first), second, false);
          case '<<<':
          case '<<<<':
            return Import(first, second, op === '<<<<');
          case '<|':
            return Block(first).pipe(second, op);
          case '|>':
            return Block(second).pipe(first, '<|');
          case '.':
          case '.~':
            return Chain(first).add(Index(second, op));
          }
        }
        this$.op = op;
        this$.first = first;
        this$.second = second;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Binary.prototype.children = ['first', 'second'];
      Binary.prototype.show = function(){
        return this.op;
      };
      Binary.prototype.isCallable = function(){
        var ref$;
        return this.partial || ((ref$ = this.op) === '&&' || ref$ === '||' || ref$ === '?' || ref$ === '<<' || ref$ === '>>') && this.first.isCallable() && this.second.isCallable();
      };
      Binary.prototype.isArray = function(){
        switch (this.op) {
        case '*':
          return this.first.isArray();
        case '/':
          return this.second.isMatcher();
        }
      };
      Binary.prototype.isString = function(){
        switch (this.op) {
        case '+':
        case '*':
          return this.first.isString() || this.second.isString();
        case '-':
          return this.second.isMatcher();
        }
      };
      COMPARER = /^(?:[!=]=|[<>])=?$/;
      INVERSIONS = {
        '===': '!==',
        '!==': '===',
        '==': '!=',
        '!=': '=='
      };
      Binary.prototype.invert = function(){
        var that;
        if (that = !COMPARER.test(this.second.op) && INVERSIONS[this.op]) {
          this.op = that;
          this.wasInverted = true;
          return this;
        }
        return Unary('!', Parens(this), true);
      };
      Binary.prototype.invertIt = function(){
        this.inverted = true;
        return this;
      };
      Binary.prototype.getDefault = function(){
        switch (this.op) {
        case '?':
        case '||':
        case '&&':
          return this;
        }
      };
      Binary.prototype.xorChildren = function(test){
        var ref$, first;
        if (!(!(first = test(this.first)) !== !(ref$ = test(this.second)) && (first || ref$))) {
          return false;
        }
        return first
          ? [this.first, this.second]
          : [this.second, this.first];
      };
      Binary.prototype.compileNode = function(o){
        var top, rite, items, that, ref$, code, level;
        if (this.partial) {
          return this.compilePartial(o);
        }
        switch (this.op) {
        case '?':
          return this.compileExistence(o);
        case '*':
          if (this.second.isString()) {
            return this.compileJoin(o);
          }
          if (this.first.isString() || this.first.isArray()) {
            return this.compileRepeat(o);
          }
          break;
        case '-':
          if (this.second.isMatcher()) {
            return this.compileRemove(o);
          }
          break;
        case '/':
          if (this.second.isMatcher()) {
            return this.compileSplit(o);
          }
          break;
        case '**':
        case '^':
          return this.compilePow(o);
        case '<?':
        case '>?':
          return this.compileMinMax(o);
        case '<<':
        case '>>':
          return this.compileCompose(o);
        case '++':
          return this.compileConcat(o);
        case '%%':
          return this.compileMod(o);
        case 'xor':
          return this.compileXor(o);
        case '&&':
        case '||':
          if (top = this['void'] || !o.level) {
            this.second['void'] = true;
          }
          if (top || this.cond) {
            this.first.cond = true;
            this.second.cond = true;
          }
          break;
        case 'instanceof':
          rite = this.second, items = rite.items;
          if (rite instanceof Arr) {
            if (items[1]) {
              return this.compileAnyInstanceOf(o, items);
            }
            this.second = items[0] || rite;
          }
          this.second.isCallable() || this.second.carp('invalid instanceof operand');
          break;
        case '====':
        case '!===':
          this.op = this.op.slice(0, 3);
          // fallthrough
        case '<==':
        case '>==':
        case '<<=':
        case '>>=':
          return this.compileDeepEq(o);
        default:
          if (COMPARER.test(this.op)) {
            if (that = ((ref$ = this.op) === '===' || ref$ === '!==') && this.xorChildren(function(it){
              return it.isRegex();
            })) {
              return this.compileRegexEquals(o, that);
            }
            if (this.op === '===' && (this.first instanceof Literal && this.second instanceof Literal) && this.first.isWhat() !== this.second.isWhat()) {
              if (o.warn) {
                this.warn("strict comparison of two different types will always be false: " + this.first.value + " == " + this.second.value);
              }
            }
          }
          if (COMPARER.test(this.op) && COMPARER.test(this.second.op)) {
            return this.compileChain(o);
          }
        }
        this.first.front = this.front;
        code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op]), " ", this.mapOp(this.op), " ", this.second.compile(o, level)];
        if (o.level <= level) {
          return sn.apply(null, [this].concat(arrayFrom$(code)));
        } else {
          return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
        }
      };
      Binary.prototype.mapOp = function(op){
        var that;
        switch (false) {
        case !(that = op.match(/\.([&\|\^]|<<|>>>?)\./)):
          return that[1];
        case op !== 'of':
          return 'in';
        default:
          return op;
        }
      };
      Binary.prototype.compileChain = function(o){
        var code, level, ref$, sub;
        code = [this.first.compile(o, level = LEVEL_OP + PREC[this.op])];
        ref$ = this.second.first.cache(o, true), sub = ref$[0], this.second.first = ref$[1];
        code.push(" ", this.op, " ", sub.compile(o, level), " && ", this.second.compile(o, LEVEL_OP));
        if (o.level <= LEVEL_OP) {
          return sn.apply(null, [this].concat(arrayFrom$(code)));
        } else {
          return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
        }
      };
      Binary.prototype.compileExistence = function(o){
        var x;
        if (this['void'] || !o.level) {
          x = Binary('&&', Existence(this.first, true), this.second);
          return (x['void'] = true, x).compileNode(o);
        }
        x = this.first.cache(o, true);
        return sn(this, If(Existence(x[0]), x[1]).addElse(this.second).compileExpression(o));
      };
      Binary.prototype.compileAnyInstanceOf = function(o, items){
        var ref$, sub, ref, test, i$, len$, item;
        ref$ = this.first.cache(o), sub = ref$[0], ref = ref$[1], this.temps = ref$[2];
        test = Binary('instanceof', sub, items.shift());
        for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
          item = items[i$];
          test = Binary('||', test, Binary('instanceof', ref, item));
        }
        return sn(this, Parens(test).compile(o));
      };
      Binary.prototype.compileMinMax = function(o){
        var lefts, rites, x;
        lefts = this.first.cache(o, true);
        rites = this.second.cache(o, true);
        x = Binary(this.op.charAt(), lefts[0], rites[0]);
        return sn(this, If(x, lefts[1]).addElse(rites[1]).compileExpression(o));
      };
      Binary.prototype.compileMethod = function(o, klass, method, arg){
        var args;
        args = [this.second].concat(arg || []);
        if (this.first["is" + klass]()) {
          return sn(this, Chain(this.first, [Index(Key(method)), Call(args)]).compile(o));
        } else {
          args.unshift(this.first);
          return sn(this, Call.make(JS(util(method) + '.call'), args).compile(o));
        }
      };
      Binary.prototype.compileJoin = function(it){
        return this.compileMethod(it, 'Array', 'join');
      };
      Binary.prototype.compileRemove = function(it){
        return this.compileMethod(it, 'String', 'replace', JS("''"));
      };
      Binary.prototype.compileSplit = function(it){
        return this.compileMethod(it, 'String', 'split');
      };
      Binary.prototype.compileRepeat = function(o){
        var x, items, n, arr, arrCode, refs, i$, len$, i, item, ref$, q;
        x = this.first, items = x.items, n = this.second;
        arr = x.isArray() && 'Array';
        if (items && !snEmpty(arrCode = Splat.compileArray(o, items))) {
          x = JS(arrCode);
          items = null;
        }
        if (arr && !items || !(n instanceof Literal && n.value < 0x20)) {
          return sn(this, Call.make(Util('repeat' + (arr || 'String')), [x, n]).compile(o));
        }
        n = +n.value;
        if (1 <= n && n < 2) {
          return sn(this, x.compile(o));
        }
        if (items) {
          if (n < 1) {
            return sn(this, Block(items).add(JS('[]')).compile(o));
          }
          refs = [];
          for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
            i = i$;
            item = items[i$];
            ref$ = item.cache(o, 1), items[i] = ref$[0], refs[refs.length] = ref$[1];
          }
          items.push((ref$ = JS(), ref$.compile = function(){
            return sn.apply(null, [this].concat(arrayFrom$((repeatArray$([", ", List.compile(o, refs)], n - 1)).slice(1))));
          }, ref$));
          return sn(this, x.compile(o));
        } else if (x instanceof Literal) {
          return sn(this, (q = (x = x.compile(o).toString()).charAt()) + repeatString$(x.slice(1, -1) + "", n) + q);
        } else {
          if (n < 1) {
            return sn(this, Block(x.it).add(JS("''")).compile(o));
          }
          x = (refs = x.cache(o, 1, LEVEL_OP))[0] + repeatString$(" + " + refs[1], n - 1);
          if (o.level < LEVEL_OP + PREC['+']) {
            return sn(this, x);
          } else {
            return sn(this, "(", x, ")");
          }
        }
      };
      Binary.prototype.compilePow = function(o){
        return sn(null, Call.make(CopyL(this, JS('Math.pow')), [this.first, this.second]).compile(o));
      };
      Binary.prototype.compileConcat = function(o){
        var f;
        f = function(x){
          switch (false) {
          case !(x instanceof Binary && x.op === '++'):
            return f(x.first).concat(f(x.second));
          default:
            return [x];
          }
        };
        return sn(null, Chain(this.first).add(CopyL(this, Index(Key('concat'), '.', true))).add(Call(f(this.second))).compile(o));
      };
      Binary.prototype.compileCompose = function(o){
        var op, functions, x;
        op = this.op;
        functions = [this.first];
        x = this.second;
        while (x instanceof Binary && x.op === op && !x.partial) {
          functions.push(x.first);
          x = x.second;
        }
        functions.push(x);
        if (op === '<<') {
          functions.reverse();
        }
        return sn(this, Chain(Var(util('compose'))).add(Call(functions)).compile(o));
      };
      Binary.prototype.compileMod = function(o){
        var ref, code;
        ref = o.scope.temporary();
        code = [sn(this, "(("), this.first.compile(o), sn(this, ") % ("), sn(this, ref, " = "), this.second.compile(o), sn(this, ") + ", ref, ") % ", ref)];
        o.scope.free(ref);
        if (o.level < LEVEL_OP + PREC['%']) {
          return sn.apply(null, [null].concat(arrayFrom$(code)));
        } else {
          return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
        }
      };
      Binary.prototype.compilePartial = function(o){
        var vit, x, y;
        vit = Var('it');
        switch (false) {
        case !(this.first == null && this.second == null):
          x = Var('x$');
          y = Var('y$');
          return sn(this, Fun([x, y], Block(Binary(this.op, x, y).invertCheck(this)), false, true).compile(o));
        case this.first == null:
          return sn(this, "(", Fun([vit], Block(Binary(this.op, this.first, vit).invertCheck(this)), true).compile(o), ")");
        default:
          return sn(this, "(", Fun([vit], Block(Binary(this.op, vit, this.second).invertCheck(this)), true).compile(o), ")");
        }
      };
      Binary.prototype.compileRegexEquals = function(o, arg$){
        var regex, target, method;
        regex = arg$[0], target = arg$[1];
        if (this.op === '===') {
          method = this.wasInverted ? 'test' : 'exec';
          return sn(this, Chain(regex).add(Index(Key(method))).add(Call([target])).compile(o));
        } else {
          return sn(this, Unary('!', Chain(regex).add(Index(Key('test'))).add(Call([target]))).compile(o));
        }
      };
      Binary.prototype.compileDeepEq = function(o){
        var ref$, negate, i$, len$, x, r;
        if ((ref$ = this.op) === '>==' || ref$ === '>>=') {
          ref$ = [this.second, this.first], this.first = ref$[0], this.second = ref$[1];
          this.op = this.op === '>==' ? '<==' : '<<=';
        }
        if (this.op === '!==') {
          this.op = '===';
          negate = true;
        }
        for (i$ = 0, len$ = (ref$ = [this.first, this.second]).length; i$ < len$; ++i$) {
          x = ref$[i$];
          if (x instanceof Obj || x instanceof Arr) {
            x.deepEq = true;
          }
        }
        r = Chain(Var(util('deepEq'))).add(Call([this.first, this.second, Literal("'" + this.op + "'")]));
        return sn(this, (negate ? Unary('!', r) : r).compile(o));
      };
      Binary.prototype.compileXor = function(o){
        var left, right;
        left = Chain(this.first).cacheReference(o);
        right = Chain(this.second).cacheReference(o);
        return sn(this, Binary('&&', Binary('!==', Unary('!', left[0]), Unary('!', right[0])), Parens(Binary('||', left[1], right[1]))).compile(o));
      };
      return Binary;
    }(Node));
    exports.Assign = Assign = (function(superclass){
      var prototype = extend$((import$(Assign, superclass).displayName = 'Assign', Assign), superclass).prototype, constructor = Assign;
      function Assign(left, rite, op, logic, defParam){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.left = left;
        this$.op = op || '=';
        this$.logic = logic || this$.op.logic;
        this$.defParam = defParam;
        this$.opLoc = this$.op;
        this$.op += '';
        this$[rite instanceof Node ? 'right' : 'unaries'] = rite;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Assign.prototype.children = ['left', 'right'];
      Assign.prototype.show = function(){
        return [void 8].concat(this.unaries).reverse().join(' ') + [this.logic] + this.op;
      };
      Assign.prototype.assigns = function(){
        return this.left.assigns();
      };
      Assign.prototype.getRef = function(){
        if (!this.left.isComplex()) {
          return this.left;
        }
      };
      prototype.delegate(['isCallable', 'isRegex'], function(it){
        var ref$;
        return ((ref$ = this.op) === '=' || ref$ === ':=') && this.right && this.right[it]();
      });
      Assign.prototype.isArray = function(){
        switch (this.op) {
        case '=':
        case ':=':
          return this.right && this.right.isArray();
        case '/=':
          return this.right && this.right.isMatcher();
        }
      };
      Assign.prototype.isString = function(){
        switch (this.op) {
        case '=':
        case ':=':
        case '+=':
        case '*=':
          return this.right && this.right.isString();
        case '-=':
          return this.right && this.right.isMatcher();
        }
      };
      Assign.prototype.unfoldSoak = function(o){
        var that, ref$, ref1$, rite, temps;
        if (this.left instanceof Existence) {
          if (that = (ref1$ = (ref$ = this.left = this.left.it).name, delete ref$.name, ref1$)) {
            rite = this.right;
            rite = Assign(this.right = Var(that), rite);
          } else {
            ref$ = this.right.cache(o), rite = ref$[0], this.right = ref$[1], temps = ref$[2];
          }
          return ref$ = If(Existence(rite), this), ref$.temps = temps, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;
        }
        return If.unfoldSoak(o, this, 'left');
      };
      Assign.prototype.unfoldAssign = function(){
        return this.access && this;
      };
      Assign.prototype.compileNode = function(o){
        var left, sp, ref$, i$, len$, op, right, reft, sign, name, lvar, that, protoSplit, dotSplit, code, empty, res;
        if (this.left instanceof Slice && this.op === '=') {
          return this.compileSplice(o);
        }
        left = this.left;
        if (sp = this.left instanceof Splat) {
          left = left.it;
        }
        if (sp) {
          left instanceof List || this.left.carp('invalid splat');
          return this.compileSpread(o, left);
        }
        if (!this.right) {
          left.isAssignable() || left.carp('invalid unary assign');
          ref$ = Chain(left).cacheReference(o), left = ref$[0], this.right = ref$[1];
          for (i$ = 0, len$ = (ref$ = this.unaries).length; i$ < len$; ++i$) {
            op = ref$[i$];
            this.right = Unary(op, this.right);
          }
        }
        if (left.isEmpty()) {
          return sn(null, (ref$ = Parens(this.right), ref$.front = this.front, ref$.newed = this.newed, ref$).compile(o));
        }
        if (left.getDefault()) {
          this.right = Binary(left.op, this.right, left.second);
          left = left.first;
        }
        if (left.items) {
          return this.compileDestructuring(o, left);
        }
        left.isAssignable() || left.carp('invalid assign');
        if (this.logic) {
          return this.compileConditional(o, left);
        }
        op = this.op, right = this.right;
        if (op === '<?=' || op === '>?=') {
          return this.compileMinMax(o, left, right);
        }
        if ((op === '**=' || op === '^=' || op === '%%=' || op === '++=' || op === '|>=') || op === '*=' && right.isString() || (op === '-=' || op === '/=') && right.isMatcher()) {
          ref$ = Chain(left).cacheReference(o), left = ref$[0], reft = ref$[1];
          right = Binary(op.slice(0, -1), reft, right);
          op = ':=';
        }
        if (op === '.&.=' || op === '.|.=' || op === '.^.=' || op === '.<<.=' || op === '.>>.=' || op === '.>>>.=') {
          op = op.slice(1, -2) + '=';
        }
        (right = right.unparen()).ripName(left = left.unwrap());
        if (left instanceof Chain) {
          left.expandVivify();
          if ((left = left.unwrap()) instanceof Assign) {
            ref$ = Chain(left.left).cacheReference(o), left.left = ref$[0], this.left = ref$[1];
            return Block([left, (ref$ = clone$(this), ref$.terminator = '', ref$)]).compile(o);
          }
        }
        sign = sn(this.opLoc, " ", op.replace(':', ''), " ");
        name = (left.front = true, left).compile(o, LEVEL_LIST);
        if (lvar = left instanceof Var) {
          if (op === '=') {
            o.scope.declare(name.toString(), left, this['const'] || !this.defParam && o['const'] && '$' !== name.toString().slice(-1));
          } else if (that = o.scope.checkReadOnly(name.toString())) {
            left.carp("assignment to " + that + " \"" + name + "\"", ReferenceError);
          }
        }
        if (left instanceof Chain && right instanceof Fun) {
          protoSplit = name.toString().split('.prototype.');
          dotSplit = name.toString().split('.');
          if (protoSplit.length > 1) {
            right.inClass = protoSplit[0];
          } else if (dotSplit.length > 1) {
            right.inClassStatic = slice$.call(dotSplit, 0, -1).join('');
          }
        }
        code = !o.level && right instanceof While && !right['else'] && (lvar || left instanceof Chain && left.isSimpleAccess())
          ? (empty = right.objComp ? '{}' : '[]', [res = o.scope.temporary('res'), " = " + empty + ";\n" + this.tab, right.makeReturn(res).compile(o), "\n" + this.tab, name, sign, o.scope.free(res)])
          : [name, sign, right.compile(o, LEVEL_LIST)];
        if (o.level > LEVEL_LIST) {
          code = ["("].concat(arrayFrom$(code), [")"]);
        }
        return sn.apply(null, [null].concat(arrayFrom$(code)));
      };
      Assign.prototype.compileConditional = function(o, left){
        var ref$, lcache, morph;
        if (left instanceof Var && this.logic === '?' && this.op === '=') {
          o.scope.declare(left.value, left);
        }
        ref$ = Chain(left).cacheReference(o), lcache = ref$[0], left = ref$[1];
        o.level += LEVEL_OP < o.level;
        if (this.logic === '?' && ((ref$ = this.op) !== '=' && ref$ !== ':=')) {
          this.logic = '&&';
          lcache = Existence(lcache);
        }
        morph = Binary(this.logic, lcache, (this.logic = false, this.left = left, this));
        return sn(this, (morph['void'] = this['void'], morph).compileNode(o));
      };
      Assign.prototype.compileMinMax = function(o, left, right){
        var lefts, rites, test, put, ref$;
        lefts = Chain(left).cacheReference(o);
        rites = right.cache(o, true);
        test = Binary(this.op.replace('?', ''), lefts[0], rites[0]);
        put = Assign(lefts[1], rites[1], ':=');
        if (this['void'] || !o.level) {
          return Parens(Binary('||', test, put)).compile(o);
        }
        ref$ = test.first.cache(o, true), test.first = ref$[0], left = ref$[1];
        return sn(this, If(test, left).addElse(put).compileExpression(o));
      };
      Assign.prototype.compileDestructuring = function(o, left){
        var items, len, ret, rite, that, cache, rref, destructureArgs, list, code, sep, i$, len$, item;
        items = left.items, len = items.length;
        ret = o.level && !this['void'];
        rite = this.right.compile(o, len === 1 ? LEVEL_CALL : LEVEL_LIST);
        if (that = left.name) {
          cache = sn(this, that, " = ", rite);
          o.scope.declare(rite = that, left);
        } else if ((ret || len > 1) && (!ID.test(rite.toString()) || ((that = left.assigns()) && in$(rite.toString(), that)))) {
          cache = sn(this, rref = o.scope.temporary(), " = ", rite);
          rite = rref;
        }
        if (rite.toString() === 'arguments' && !ret) {
          destructureArgs = true;
          if (!(left instanceof Arr)) {
            this.carp('arguments can only destructure to array');
          }
        }
        list = this["rend" + left.constructor.displayName](o, items, rite, destructureArgs);
        if (rref) {
          o.scope.free(rref);
        }
        if (cache) {
          list.unshift(cache);
        }
        if (ret || !list.length) {
          list.push(rite);
        }
        code = [];
        sep = destructureArgs ? '; ' : ', ';
        for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
          item = list[i$];
          code.push(item, sep);
        }
        code.pop();
        if (list.length < 2 || o.level < LEVEL_LIST) {
          return sn.apply(null, [this].concat(arrayFrom$(code)));
        } else {
          return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
        }
      };
      Assign.prototype.compileSplice = function(o){
        var ref$, fromExpNode, fromExp, rightNode, right, toExp;
        ref$ = Chain(this.left.from).cacheReference(o), fromExpNode = ref$[0], fromExp = ref$[1];
        ref$ = Chain(this.right).cacheReference(o), rightNode = ref$[0], right = ref$[1];
        toExp = Binary('-', this.left.to, fromExp);
        return sn(this, Block([Chain(Var(util('splice'))).add(Index(Key('apply'), '.', true)).add(Call([this.left.target, Chain(Arr([fromExpNode, toExp])).add(Index(Key('concat'), '.', true)).add(Call([rightNode]))])), right]).compile(o, LEVEL_LIST));
      };
      Assign.prototype.compileSpread = function(o, left){
        var that, ref$, rite, rref, this$ = this;
        ref$ = (that = this.unaries)
          ? [that, that]
          : left.items.length <= 1
            ? [ref$ = this.right, ref$]
            : this.right.cache(o, true), rite = ref$[0], rref = ref$[1];
        return this.compileSpreadOver(o, left, function(it){
          var result;
          result = constructor(it, rite, this$.op, this$.logic);
          rite = rref;
          return result;
        });
      };
      Assign.prototype.rendArr = function(o, nodes, rite, destructureArgs){
        var ret, i$, len$, i, node, skip, len, val, ivar, start, inc, rcache, tmp, vtmp, ref$;
        function argsSlice(begin, end){
          return new For({
            ref: true,
            from: begin,
            op: 'til',
            to: end
          }).makeComprehension(Chain(Var('arguments')).add(Index(Literal('..'))), []);
        }
        ret = [];
        for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
          i = i$;
          node = nodes[i$];
          if (node.isEmpty()) {
            continue;
          }
          if (node instanceof Splat) {
            len && node.carp('multiple splat in an assignment');
            skip = (node = node.it).isEmpty();
            if (i + 1 === (len = nodes.length)) {
              if (skip) {
                break;
              }
              if (destructureArgs) {
                val = argsSlice(Literal(i), Chain(Var('arguments')).add(Index(Key('length'))));
              } else {
                val = Arr.wrap(JS(util('slice') + '.call(' + rite + (i ? ", " + i + ")" : ')')));
              }
            } else {
              val = ivar = rite + ".length - " + (len - i - 1);
              if (skip && i + 2 === len) {
                continue;
              }
              start = i + 1;
              (this.temps || (this.temps = [])).push(ivar = o.scope.temporary('i'));
              val = (fn$());
            }
          } else {
            (inc = ivar) && start < i && (inc += " + " + (i - start));
            val = Chain(rcache || (rcache = Literal(rite)), [Index(JS(inc || i))]);
          }
          if (destructureArgs) {
            if (!(node instanceof Var) && val instanceof For) {
              (this.temps || (this.temps = [])).push(tmp = o.scope.temporary('ref'));
              vtmp = Var(tmp);
              ret.push((ref$ = clone$(this), ref$.left = vtmp, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
              ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = vtmp, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
            } else {
              ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_TOP));
            }
          } else {
            ret.push((ref$ = clone$(this), ref$.left = node, ref$.right = val, ref$['void'] = true, ref$).compile(o, LEVEL_PAREN));
          }
        }
        return ret;
        function fn$(){
          switch (false) {
          case !skip:
            return Arr.wrap(JS(i + " < (" + ivar + " = " + val + ") ? " + i + " : (" + ivar + " = " + i + ")"));
          case !destructureArgs:
            return argsSlice(JS(i + " < (" + ivar + " = " + val + ") ? " + i + " : (" + ivar + " = " + i + ")"), Var(ivar));
          default:
            return Arr.wrap(JS(i + " < (" + ivar + " = " + val + ")\ ? " + util('slice') + ".call(" + rite + ", " + i + ", " + ivar + ")\ : (" + ivar + " = " + i + ", [])"));
          }
        }
      };
      Assign.prototype.rendObj = function(o, nodes, rite){
        var keys, pairs, rvar, i$, len$, ref$, key, lval, logic, excludes, val, left, right, results$ = [];
        keys = [];
        pairs = [];
        rvar = Var(rite);
        for (i$ = 0, len$ = nodes.length; i$ < len$; ++i$) {
          ref$ = nodes[i$], key = ref$.key, lval = ref$.val, logic = ref$.logic;
          lval = lval.unparen();
          if (key instanceof Splat) {
            logic != null && this.carp("invalid assign");
            excludes = Obj((fn$.call(this)));
            val = Chain(Var(util('copyWithout'))).add(Call([rvar, excludes]));
          } else {
            keys.push(key);
            if (logic) {
              lval = (logic.first = lval, logic);
            }
            val = Chain(rvar, [Index(key)]);
          }
          pairs.push([lval, val]);
        }
        for (i$ = 0, len$ = pairs.length; i$ < len$; ++i$) {
          ref$ = pairs[i$], left = ref$[0], right = ref$[1];
          results$.push((ref$ = clone$(this), ref$.left = left, ref$.right = right, ref$['void'] = true, ref$.temps = [], ref$).compile(o, LEVEL_PAREN));
        }
        return results$;
        function fn$(){
          var i$, x$, ref$, len$, results$ = [];
          for (i$ = 0, len$ = (ref$ = keys).length; i$ < len$; ++i$) {
            x$ = ref$[i$];
            results$.push(Prop(x$.extractKeyRef(o, true, this), Literal(0)));
          }
          return results$;
        }
      };
      Assign.prototype.rewriteShorthand = function(o, assign){
        var bin, ref$, that, ref1$;
        if (assign) {
          if (this === (bin = this.maybeLogic())) {
            this.carp("invalid assign");
          }
          return (ref$ = bin.rewriteShorthand(o, true)) != null ? ref$ : bin;
        }
        if (that = (ref$ = this.left) != null ? ref$.rewriteShorthand(o, true) : void 8) {
          this.left = that;
        }
        if (that = (ref1$ = this.right) != null ? ref1$.rewriteShorthand(o) : void 8) {
          this.right = that;
        }
      };
      Assign.prototype.maybeLogic = function(){
        if (this.op === '=') {
          return Binary(this.logic || '?', this.left, this.right);
        } else {
          return this;
        }
      };
      return Assign;
    }(Node));
    exports.Import = Import = (function(superclass){
      var prototype = extend$((import$(Import, superclass).displayName = 'Import', Import), superclass).prototype, constructor = Import;
      function Import(left, right, all){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.left = left;
        this$.right = right;
        this$.all = all && 'All';
        if (!all && left instanceof Obj && right.items) {
          return Obj(left.items.concat(right.asObj().items));
        }
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Import.prototype.children = ['left', 'right'];
      Import.prototype.show = function(){
        return this.all;
      };
      prototype.delegate(['isCallable', 'isArray'], function(it){
        return this.left[it]();
      });
      Import.prototype.unfoldSoak = function(o){
        var left, value, ref$, temps;
        left = this.left;
        if (left instanceof Existence && !left.negated) {
          if ((left = left.it) instanceof Var) {
            value = (this.left = left).value;
            if (!o.scope.check(value, true)) {
              left = JS("typeof " + value + " != 'undefined' && " + value);
            }
          } else {
            ref$ = left.cache(o), left = ref$[0], this.left = ref$[1], temps = ref$[2];
          }
          return ref$ = If(left, this), ref$.temps = temps, ref$.soak = true, ref$.cond = this.cond, ref$['void'] = this['void'], ref$;
        }
        return If.unfoldSoak(o, this, 'left') || (this['void'] || !o.level) && If.unfoldSoak(o, this, 'right');
      };
      Import.prototype.compileNode = function(o){
        var right;
        right = this.right;
        if (!this.all) {
          if (right instanceof Chain) {
            right = right.unfoldSoak(o) || right.unfoldAssign(o) || right;
          }
          if (right instanceof List) {
            return this.compileAssign(o, right.asObj().items);
          }
        }
        return CopyL(this, Call.make(Util("import" + (this.all || '')), [this.left, right])).compileNode(o);
      };
      Import.prototype.compileAssign = function(o, items){
        var top, reft, ref$, left, delim, space, code, i$, len$, i, node, com, key, val, logic;
        if (!items.length) {
          return this.left.compile(o);
        }
        top = !o.level;
        if (this.proto || (items.length < 2 && (top || this['void'] || items[0].key instanceof Splat))) {
          reft = this.left;
          if (reft.isComplex()) {
            reft = Parens(reft);
          }
        } else {
          ref$ = this.left.cache(o), left = ref$[0], reft = ref$[1], this.temps = ref$[2];
        }
        ref$ = top
          ? [';', '\n' + this.tab]
          : [',', ' '], delim = ref$[0], space = ref$[1];
        delim += space;
        code = this.temps
          ? [left.compile(o, LEVEL_PAREN), delim]
          : [];
        for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
          i = i$;
          node = items[i$];
          i && code.push(com ? space : delim);
          if (com = node.comment) {
            code.push(node.compile(o));
            continue;
          }
          key = node.key, val = node.val, logic = node.logic;
          if (key instanceof Splat) {
            code.push(CopyL(this, Import(reft, val)).compile(o));
            continue;
          }
          if (node.accessor) {
            if (key instanceof Key) {
              key = JS("'" + key.name + "'");
            }
            code.push("Object.defineProperty(", reft.compile(o, LEVEL_LIST), ", ", key.compile(o, LEVEL_LIST), ", ", node.compileDescriptor(o), ")");
            continue;
          }
          logic && (val = (logic.first = val, logic));
          code.push(Assign(Chain(reft, [Index(key)]), val).compile(o, LEVEL_PAREN));
        }
        if (top) {
          return sn.apply(null, [null].concat(arrayFrom$(code)));
        }
        this['void'] || key instanceof Splat || code.push(com ? ' ' : ', ', reft.compile(o, LEVEL_PAREN));
        if (o.level < LEVEL_LIST) {
          return sn.apply(null, [null].concat(arrayFrom$(code)));
        } else {
          return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
        }
      };
      Import.prototype.rewriteShorthand = function(o, assign){
        var that, ref$, ref1$;
        if (that = (ref$ = this.left) != null ? ref$.rewriteShorthand(o, assign) : void 8) {
          this.left = that;
        }
        if (that = (ref1$ = this.right) != null ? ref1$.rewriteShorthand(o) : void 8) {
          this.right = that;
        }
      };
      return Import;
    }(Node));
    exports.In = In = (function(superclass){
      var prototype = extend$((import$(In, superclass).displayName = 'In', In), superclass).prototype, constructor = In;
      importAll$(prototype, arguments[1]);
      function In(item, array){
        this.item = item;
        this.array = array;
      }
      In.prototype.children = ['item', 'array'];
      In.prototype.compileNode = function(o){
        var array, items, value, code, ref$, sub, ref, cmp, cnj, i$, len$, i, test;
        items = (array = this.array).items;
        if (!(array instanceof Arr)) {
          return sn(this, this.negated ? '!' : '', util('in'), "(", this.item.compile(o, LEVEL_LIST), ", ", array.compile(o, LEVEL_LIST), ")");
        }
        if (items.length === 0) {
          if (o.warn) {
            this.warn("value can never be `in` an empty array");
          }
          value = !!this.negated + "";
          return this.item.isComplex()
            ? sn(this, "(", this.item.compile(o, LEVEL_LIST), ", ", value, ")")
            : sn(this, value);
        }
        code = [];
        ref$ = items.length === 1
          ? [ref$ = this.item.compile(o, LEVEL_PAREN), ref$]
          : this.item.cache(o, false, LEVEL_PAREN), sub = ref$[0], ref = ref$[1];
        ref$ = this.negated
          ? [' !== ', ' && ']
          : [' === ', ' || '], cmp = ref$[0], cnj = ref$[1];
        for (i$ = 0, len$ = items.length; i$ < len$; ++i$) {
          i = i$;
          test = items[i$];
          if (code.length > 0) {
            code.push(cnj);
          }
          if (test instanceof Splat) {
            code.push((ref$ = new In(Var(ref), test.it), ref$.negated = this.negated, ref$).compile(o, LEVEL_TOP));
            if (!(i || sub === ref)) {
              code = ["(" + sub + ", "].concat(arrayFrom$(code), [")"]);
            }
          } else {
            code.push(i || sub === ref
              ? ref
              : "(" + sub + ")", cmp, test.compile(o, LEVEL_OP + PREC['==']));
          }
        }
        sub === ref || o.scope.free(ref);
        if (o.level < LEVEL_OP + PREC[items.length === 1 ? '===' : '||']) {
          return sn.apply(null, [this].concat(arrayFrom$(code)));
        } else {
          return sn.apply(null, [this, "("].concat(arrayFrom$(code), [")"]));
        }
      };
      return In;
    }(Node, Negatable));
    exports.Existence = Existence = (function(superclass){
      var prototype = extend$((import$(Existence, superclass).displayName = 'Existence', Existence), superclass).prototype, constructor = Existence;
      importAll$(prototype, arguments[1]);
      function Existence(it, negated){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.it = it;
        this$.negated = negated;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Existence.prototype.children = ['it'];
      Existence.prototype.compileNode = function(o){
        var node, ref$, code, op, eq, anaphPre, anaphPost, that;
        node = (ref$ = this.it.unwrap(), ref$.front = this.front, ref$);
        code = [node.compile(o, LEVEL_OP + PREC['=='])];
        if (this.doAnaphorize) {
          o.scope.declare('that', Var('that'));
        }
        if (node instanceof Var && !o.scope.check(code.join(""), true)) {
          ref$ = this.negated
            ? ['||', '=']
            : ['&&', '!'], op = ref$[0], eq = ref$[1];
          if (this.doAnaphorize) {
            ref$ = this.negated
              ? [["(that = undefined) || "], []]
              : [[], [" && (that = "].concat(arrayFrom$(code), [", true)"])], anaphPre = ref$[0], anaphPost = ref$[1];
          }
          code = ["typeof "].concat(arrayFrom$(code), [" " + eq + "= 'undefined' " + op + " "], arrayFrom$(code), [" " + eq + "== null"]);
          if ((that = anaphPre) != null) {
            code = that.concat(code);
          }
          if ((that = anaphPost) != null) {
            code = code.concat(that);
          }
        } else {
          if (this.doAnaphorize) {
            code = ["(that = "].concat(arrayFrom$(code), [")"]);
          }
          code.push(" " + (op = this.negated ? '==' : '!=') + " null");
        }
        if (o.level < LEVEL_OP + PREC[op]) {
          return sn.apply(null, [this].concat(arrayFrom$(code)));
        } else {
          return sn(this, "(", code, ")");
        }
      };
      return Existence;
    }(Node, Negatable));
    exports.Fun = Fun = (function(superclass){
      var prototype = extend$((import$(Fun, superclass).displayName = 'Fun', Fun), superclass).prototype, constructor = Fun;
      function Fun(params, body, bound, curried, hushed, generator, async){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.params = params || [];
        this$.body = body || Block();
        this$.bound = bound && 'this$';
        this$.curried = curried || false;
        this$.hushed = hushed != null ? hushed : false;
        this$.generator = generator != null ? generator : false;
        this$.async = async != null ? async : false;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Fun.prototype.children = ['params', 'body'];
      Fun.prototype.show = function(){
        var that;
        return [this.name] + [(that = this.bound) ? "~" + that : void 8];
      };
      Fun.prototype.named = function(it){
        return this.name = it, this.statement = true, this;
      };
      Fun.prototype.isCallable = YES;
      Fun.prototype.isStatement = function(){
        return !!this.statement;
      };
      Fun.prototype.traverseChildren = function(arg$, xscope){
        if (xscope) {
          return superclass.prototype.traverseChildren.apply(this, arguments);
        }
      };
      Fun.prototype.rewriteShorthand = VOID;
      Fun.prototype.makeReturn = function(){
        if (this.statement) {
          return this.returns = true, this;
        } else {
          return superclass.prototype.makeReturn.apply(this, arguments);
        }
      };
      Fun.prototype.ripName = function(it){
        this.name || (this.name = it.varName());
      };
      Fun.prototype.compileNode = function(o){
        var pscope, sscope, scope, that, inLoop, ref$, body, name, tab, code, bodyCode, curryCodeCheck, this$ = this;
        pscope = o.scope;
        sscope = pscope.shared || pscope;
        scope = o.scope = this.body.scope = new Scope(this.wrapper ? pscope : sscope, this.wrapper && sscope);
        scope.fun = this;
        if (that = this.proto) {
          scope.assign('prototype', that.compile(o) + ".prototype");
        }
        if (that = this.cname) {
          scope.assign('constructor', that);
        }
        if (inLoop = (ref$ = o.loop, delete o.loop, ref$)) {
          o.indent = this.tab = '';
        }
        o.indent += TAB;
        body = this.body, name = this.name, tab = this.tab;
        code = ['function'];
        if (this.async) {
          this.ctor && this.carp("a constructor can't be async");
          o.inAsync = true;
          code.unshift('async ');
        } else if (!this.wrapper) {
          o.inAsync = false;
        }
        if (this.generator) {
          this.ctor && this.carp("a constructor can't be a generator");
          o.inGenerator = true;
          code.push('*');
        } else if (!this.wrapper) {
          o.inGenerator = false;
        }
        if (this.bound === 'this$') {
          if (this.ctor) {
            scope.assign('this$', 'this instanceof ctor$ ? this : new ctor$');
            body.lines.push(Return(Literal('this$')));
          } else if (that = (ref$ = sscope.fun) != null ? ref$.bound : void 8) {
            this.bound = that;
          } else if (this.usesThis()) {
            sscope.assign('this$', 'this');
          }
        }
        if (this.statement) {
          name || this.carp('nameless function declaration');
          pscope === o.block.scope || this.carp('misplaced function declaration');
          this.accessor && this.carp('named accessor');
          pscope.add(name, 'function', this);
        }
        if (this.statement || name && this.labeled) {
          code.push(' ', scope.add(name, 'function', this));
        }
        this.hushed || this.ctor || this.newed || body.makeReturn();
        code.push("(", this.compileParams(o, scope), ")");
        code = [sn.apply(null, [this].concat(arrayFrom$(code)))];
        code.push("{");
        if (!snEmpty(bodyCode = body.compileWithDeclarations(o))) {
          code.push("\n", bodyCode, "\n" + tab);
        }
        code.push('}');
        curryCodeCheck = function(){
          if (this$.curried && this$.hasSplats) {
            this$.carp('cannot curry a function with a variable number of arguments');
          }
          if (this$.curried && this$.params.length > 1 && !this$.classBound) {
            if (this$.bound) {
              return [util('curry'), "(("].concat(arrayFrom$(code), ["), true)"]);
            } else {
              return [util('curry'), "("].concat(arrayFrom$(code), [")"]);
            }
          } else {
            return code;
          }
        };
        if (inLoop) {
          return pscope.assign(pscope.temporary('fn'), sn.apply(null, [null].concat(arrayFrom$(curryCodeCheck()))));
        }
        if (this.returns) {
          code.push("\n" + tab + "return ", name, ";");
        } else if (this.bound && this.ctor) {
          code.push(' function ctor$(){} ctor$.prototype = prototype;');
        }
        code = curryCodeCheck();
        if (this.front && !this.statement) {
          return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
        } else {
          return sn.apply(null, [null].concat(arrayFrom$(code)));
        }
      };
      Fun.prototype.compileParams = function(o, scope){
        var params, length, body, i$, p, len$, i, splace, rest, that, names, assigns, vr, df, unaries, hasUnary, v, ref$, ref1$;
        params = this.params, length = params.length, body = this.body;
        for (i$ = params.length - 1; i$ >= 0; --i$) {
          p = params[i$];
          if (!(p.isEmpty() || p.filler)) {
            break;
          }
          --params.length;
        }
        for (i$ = 0, len$ = params.length; i$ < len$; ++i$) {
          i = i$;
          p = params[i$];
          if (p.left instanceof Splat) {
            p.carp('invalid splat');
          }
          if (p instanceof Splat) {
            this.hasSplats = true;
            splace = i;
          } else if (p.op === '=') {
            params[i] = Binary(p.logic || '?', p.left, p.right);
          }
        }
        if (splace != null) {
          rest = params.splice(splace, 9e9);
        } else if (this.accessor) {
          if (that = params[1]) {
            that.carp('excess accessor parameter');
          }
        } else if (!(length || this.wrapper)) {
          if (body.traverseChildren(function(it){
            return it.value === 'it' || null;
          })) {
            params[0] = Var('it');
          }
        }
        names = [];
        assigns = [];
        for (i$ = 0, len$ = params.length; i$ < len$; ++i$) {
          p = params[i$];
          vr = p;
          if (df = vr.getDefault()) {
            vr = vr.first;
          }
          if (vr.isEmpty()) {
            vr = Var(scope.temporary('arg'));
          } else if (vr.value === '..') {
            vr = Var(o.ref = scope.temporary());
          } else if (!(vr instanceof Var)) {
            unaries = [];
            while (vr instanceof Unary) {
              hasUnary = true;
              unaries.push(vr);
              vr = vr.it;
            }
            v = Var((ref1$ = (ref$ = vr.it || vr).name, delete ref$.name, ref1$) || vr.varName() || scope.temporary('arg'));
            assigns.push(Assign(vr, (fn$())));
            vr = v;
          } else if (df) {
            assigns.push(Assign(vr, p.second, '=', p.op, true));
          }
          names.push(scope.add(vr.value, 'arg', p), ', ');
        }
        if (rest) {
          while (splace--) {
            rest.unshift(Arr());
          }
          assigns.push(Assign(Arr(rest), Literal('arguments')));
        }
        if (assigns.length) {
          (ref$ = this.body).prepend.apply(ref$, assigns);
        }
        names.pop();
        return sn.apply(null, [null].concat(arrayFrom$(names)));
        function fn$(){
          switch (false) {
          case !df:
            return Binary(p.op, v, p.second);
          case !hasUnary:
            return fold(function(x, y){
              y.it = x;
              return y;
            }, v, unaries.reverse());
          default:
            return v;
          }
        }
      };
      Fun.prototype.usesThis = function(){
        return Node.prototype.traverseChildren.call(this, function(it){
          switch (false) {
          case !(it instanceof Literal && it.value === 'this'):
            return true;
          case !(it instanceof Fun && it.bound && it.usesThis()):
            return true;
          }
        });
      };
      return Fun;
    }(Node));
    exports.Class = Class = (function(superclass){
      var prototype = extend$((import$(Class, superclass).displayName = 'Class', Class), superclass).prototype, constructor = Class;
      function Class(arg$){
        var body;
        this.title = arg$.title, this.sup = arg$.sup, this.mixins = arg$.mixins, body = arg$.body;
        this.fun = Fun([], body);
      }
      Class.prototype.children = ['title', 'sup', 'mixins', 'fun'];
      Class.prototype.isCallable = YES;
      Class.prototype.ripName = function(it){
        this.name = it.varName();
      };
      Class.prototype.getRef = function(){
        var that, ref$;
        if (that = ((ref$ = this.title) != null ? ref$.varName() : void 8) || this.name) {
          return Var(that);
        }
      };
      Class.prototype.compile = function(o, level){
        var fun, body, lines, title, boundFuncs, curriedBoundFuncs, decl, name, proto, vname, ctorName, ctor, ctorPlace, importProtoObj, i$, len$, i, node, f, args, that, imports, ref$, res$, clas;
        fun = this.fun, body = fun.body, lines = body.lines, title = this.title;
        CopyL(this, fun);
        boundFuncs = [];
        curriedBoundFuncs = [];
        decl = title != null ? title.varName() : void 8;
        name = decl || this.name;
        if (ID.test(name || '')) {
          fun.cname = name;
        } else {
          name = 'constructor';
        }
        proto = Var('prototype');
        vname = fun.proto = Var(fun.bound = name);
        ctorName = 'constructor$$';
        importProtoObj = function(node, i){
          var j, prop, key, i$, ref$, len$, v;
          j = 0;
          for (; j < node.items.length; j++) {
            prop = node.items[j];
            key = prop.key;
            if ((key instanceof Key && key.name === ctorName) || (key instanceof Literal && key.value === "'" + ctorName + "'")) {
              if (ctor) {
                node.carp('redundant constructor');
              }
              ctor = prop.val;
              node.items.splice(j--, 1);
              ctorPlace = i;
            }
            if (!(prop.val instanceof Fun || prop.accessor)) {
              continue;
            }
            if (key.isComplex()) {
              key = Var(o.scope.temporary('key'));
              prop.key = Assign(key, prop.key);
            }
            if (prop.val.bound) {
              if (prop.val.curried) {
                curriedBoundFuncs.push(prop.key);
              } else {
                boundFuncs.push(prop.key);
              }
              prop.val.bound = false;
              prop.val.classBound = true;
            }
            for (i$ = 0, len$ = (ref$ = [].concat(prop.val)).length; i$ < len$; ++i$) {
              v = ref$[i$];
              v.meth = key;
            }
          }
          if (node.items.length) {
            return ref$ = Import(Chain(vname).add(Index(Key('prototype'))), node), ref$.proto = true, ref$;
          } else {
            return Literal('void');
          }
        };
        for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
          i = i$;
          node = lines[i$];
          if (node instanceof Obj) {
            lines[i] = importProtoObj(node, i);
          } else if (node instanceof Fun && !node.statement) {
            ctor && node.carp('redundant constructor');
            ctor = node;
          } else if (node instanceof Assign && node.left instanceof Chain && node.left.head.value === 'this' && node.right instanceof Fun) {
            node.right.stat = node.left.tails[0].key;
          } else {
            node.traverseChildren(fn$);
          }
        }
        ctor || (ctor = lines[lines.length] = this.sup
          ? Fun([], Block(Chain(new Super).add(Call([Splat(Literal('arguments'))]))))
          : Fun());
        if (!(ctor instanceof Fun)) {
          lines.splice(ctorPlace + 1, 0, Assign(Var(ctorName), ctor));
          lines.unshift(ctor = Fun([], Block(Return(Chain(Var(ctorName)).add(Call([Splat('arguments', true)]))))));
        }
        ctor.name = name;
        ctor.ctor = true;
        ctor.statement = true;
        for (i$ = 0, len$ = boundFuncs.length; i$ < len$; ++i$) {
          f = boundFuncs[i$];
          ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(f)), Chain(Var(util('bind'))).add(Call([Literal('this'), Literal("'" + f.name + "'"), Var('prototype')]))));
        }
        for (i$ = 0, len$ = curriedBoundFuncs.length; i$ < len$; ++i$) {
          f = curriedBoundFuncs[i$];
          ctor.body.lines.unshift(Assign(Chain(Literal('this')).add(Index(Key("_" + f.name))), Chain(Var(util('curry'))).add(Call([Chain(Var('prototype')).add(Index(f)), Var('true')]))), Assign(Chain(Literal('this')).add(Index(f)), Chain(Var(util('bind'))).add(Call([Literal('this'), Literal("'_" + f.name + "'")]))));
        }
        lines.push(vname);
        args = [];
        if (that = this.sup) {
          args.push(that);
          imports = Chain(Import(Literal('this'), Var('superclass')));
          fun.proto = Util.Extends(fun.cname ? Block([Assign(imports.add(Index(Key('displayName'))), Literal("'" + name + "'")), Literal(name)]) : imports, (ref$ = fun.params)[ref$.length] = Var('superclass'));
        }
        if (that = this.mixins) {
          res$ = [];
          for (i$ = 0, len$ = that.length; i$ < len$; ++i$) {
            args[args.length] = that[i$];
            res$.push(Import(proto, JS("arguments[" + (args.length - 1) + "]"), true));
          }
          imports = res$;
          body.prepend.apply(body, imports);
        }
        if (fun.cname && !this.sup) {
          body.prepend(Literal(name + ".displayName = '" + name + "'"));
        }
        clas = Parens(Call.make(fun, args), true);
        if (decl && title.isComplex()) {
          clas = Assign(vname, clas);
        }
        if (title) {
          clas = Assign(title, clas);
        }
        return sn(null, clas.compile(o, level));
        function fn$(it){
          var i$, ref$, len$, k, child;
          if (it instanceof Block) {
            for (i$ = 0, len$ = (ref$ = it.lines).length; i$ < len$; ++i$) {
              k = i$;
              child = ref$[i$];
              if (child instanceof Obj) {
                it.lines[k] = importProtoObj(child, i);
              }
            }
          }
        }
      };
      return Class;
    }(Node));
    exports.Super = Super = (function(superclass){
      var prototype = extend$((import$(Super, superclass).displayName = 'Super', Super), superclass).prototype, constructor = Super;
      function Super(){}
      Super.prototype.isCallable = YES;
      Super.prototype.compile = function(o){
        var scope, that, result, ref$;
        scope = o.scope;
        if (!this.sproto) {
          for (; that = !scope.get('superclass') && scope.fun; scope = scope.parent) {
            result = that;
            if (that = result.meth) {
              return sn(this, 'superclass.prototype', Index(that).compile(o));
            }
            if (that = result.stat) {
              return sn(this, 'superclass', Index(that).compile(o));
            }
            if (that = scope.fun.inClass) {
              return sn(this, that, ".superclass.prototype.", scope.fun.name);
            } else if (that = scope.fun.inClassStatic) {
              return sn(this, that, ".superclass.", scope.fun.name);
            }
          }
          if (that = (ref$ = o.scope.fun) != null ? ref$.name : void 8) {
            return sn(this, that, ".superclass");
          }
        }
        return sn(this, 'superclass');
      };
      Super.prototype.maybeKey = function(){
        return Key('super', true);
      };
      return Super;
    }(Node));
    exports.Parens = Parens = (function(superclass){
      var prototype = extend$((import$(Parens, superclass).displayName = 'Parens', Parens), superclass).prototype, constructor = Parens;
      function Parens(it, keep, string, lb, rb){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.it = it;
        this$.keep = keep;
        this$.string = string;
        this$.lb = lb;
        this$.rb = rb;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Parens.prototype.children = ['it'];
      Parens.prototype.show = function(){
        return this.string && '""';
      };
      prototype.delegate(['isComplex', 'isCallable', 'isArray', 'isRegex', 'isNextUnreachable', 'getRef'], function(it){
        return this.it[it]();
      });
      Parens.prototype.isString = function(){
        return this.string || this.it.isString();
      };
      Parens.prototype.unparen = function(){
        if (this.keep) {
          return this;
        } else {
          return this.it.unparen();
        }
      };
      Parens.prototype.compile = function(o, level){
        var it;
        level == null && (level = o.level);
        it = this.it;
        it.cond || (it.cond = this.cond), it['void'] || (it['void'] = this['void']);
        if (this.calling && (!level || this['void'])) {
          it.head.hushed = true;
        }
        if (!(this.keep || this.newed || level >= LEVEL_OP + PREC[it.op])) {
          return (it.front = this.front, it).compile(o, level || LEVEL_PAREN);
        }
        if (it.isStatement()) {
          return it.compileClosure(o);
        } else {
          return sn(null, sn(this.lb, "("), it.compile(o, LEVEL_PAREN), sn(this.rb, ")"));
        }
      };
      Parens.prototype.maybeKey = THIS;
      Parens.prototype.extractKeyRef = function(o, assign, tempOwner){
        var v, ref$, ref, key, val;
        if (tempOwner != null && (v = this.it) instanceof Var && (ref$ = v.temp, delete v.temp, ref$)) {
          (tempOwner.temps || (tempOwner.temps = [])).push(v.value);
        }
        if (this.it instanceof Chain && assign) {
          ref$ = this.it.cacheReference(o), this.it = ref$[0], ref = ref$[1];
          return Parens(ref);
        }
        ref$ = this.it.cache(o, true), key = ref$[0], val = ref$[1];
        if (assign) {
          ref$ = [val, key], key = ref$[0], val = ref$[1];
        }
        this.it = val.unparen();
        return Parens(key);
      };
      Parens.prototype.rewriteShorthand = function(o){
        var that;
        if (that = this.it.rewriteShorthand(o)) {
          this.it = that;
        }
      };
      return Parens;
    }(Node));
    exports.Splat = Splat = (function(superclass){
      var ref$, prototype = extend$((import$(Splat, superclass).displayName = 'Splat', Splat), superclass).prototype, constructor = Splat;
      function Splat(it, filler){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.it = it;
        this$.filler = filler;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      ref$ = Parens.prototype, prototype.children = ref$.children, prototype.isComplex = ref$.isComplex;
      Splat.prototype.isAssignable = YES;
      Splat.prototype.assigns = function(){
        return this.it.assigns();
      };
      Splat.prototype.compile = function(){
        return this.carp('invalid splat');
      };
      Splat.compileArray = function(o, list, apply){
        var index, i$, len$, node, args, atoms, ref$;
        expand(list);
        index = 0;
        for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
          node = list[i$];
          if (node instanceof Splat) {
            break;
          }
          ++index;
        }
        if (index >= list.length) {
          return sn(this, '');
        }
        if (!list[1]) {
          return sn(this, (apply ? Object : ensureArray)(list[0].it).compile(o, LEVEL_LIST));
        }
        args = [];
        atoms = [];
        for (i$ = 0, len$ = (ref$ = list.splice(index, 9e9)).length; i$ < len$; ++i$) {
          node = ref$[i$];
          if (node instanceof Splat) {
            if (atoms.length) {
              args.push(Arr(atoms.splice(0, 9e9)));
            }
            args.push(ensureArray(node.it));
          } else {
            atoms.push(node);
          }
        }
        if (atoms.length) {
          args.push(Arr(atoms));
        }
        return sn(null, (index
          ? Arr(list)
          : args.shift()).compile(o, LEVEL_CALL), sn(this, ".concat("), List.compile(o, args), sn(this, ")"));
      };
      function expand(nodes){
        var index, node, it;
        index = -1;
        while (node = nodes[++index]) {
          if (node instanceof Splat) {
            it = node.it;
            if (it.isEmpty()) {
              nodes.splice(index--, 1);
            } else if (it instanceof Arr) {
              nodes.splice.apply(nodes, [index, 1].concat(arrayFrom$(expand(it.items))));
              index += it.items.length - 1;
            }
          }
        }
        return nodes;
      }
      function ensureArray(node){
        if (node.isArray()) {
          return node;
        }
        util('slice');
        return Call.make(Util('arrayFrom'), [node]);
      }
      return Splat;
    }(Node));
    exports.Jump = Jump = (function(superclass){
      var prototype = extend$((import$(Jump, superclass).displayName = 'Jump', Jump), superclass).prototype, constructor = Jump;
      function Jump(verb, label){
        this.verb = verb;
        this.label = label;
      }
      Jump.prototype.show = function(){
        var that;
        return (this.verb || '') + ((that = this.label) ? ' ' + that : '');
      };
      Jump.prototype.isStatement = YES;
      Jump.prototype.makeReturn = THIS;
      Jump.prototype.isNextUnreachable = YES;
      Jump.prototype.getJump = function(ctx){
        var that, ref$;
        ctx || (ctx = {});
        if (!ctx[this.verb]) {
          return this;
        }
        if (that = this.label) {
          return !in$(that, (ref$ = ctx.labels) != null
            ? ref$
            : ctx.labels = []) && this;
        }
      };
      Jump.prototype.compileNode = function(o){
        var that, ref$;
        if (that = this.label) {
          in$(that, (ref$ = o.labels) != null
            ? ref$
            : o.labels = []) || this.carp("unknown label \"" + that + "\"");
        } else {
          o[this.verb] || this.carp("stray " + this.verb);
        }
        return sn(this, this.show() + ';');
      };
      Jump.extended = function(sub){
        sub.prototype.children = ['it'];
        this[sub.displayName.toLowerCase()] = sub;
      };
      return Jump;
    }(Node));
    exports.Throw = Throw = (function(superclass){
      var prototype = extend$((import$(Throw, superclass).displayName = 'Throw', Throw), superclass).prototype, constructor = Throw;
      function Throw(it){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.it = it;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Throw.prototype.getJump = VOID;
      Throw.prototype.compileNode = function(o){
        var ref$;
        return sn(this, "throw ", ((ref$ = this.it) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || 'null', ";");
      };
      return Throw;
    }(Jump));
    exports.Return = Return = (function(superclass){
      var prototype = extend$((import$(Return, superclass).displayName = 'Return', Return), superclass).prototype, constructor = Return;
      function Return(it){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        if (it && it.value !== 'void') {
          this$.it = it;
        }
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Return.prototype.getJump = THIS;
      Return.prototype.compileNode = function(o){
        var that;
        return sn.apply(null, [this, "return"].concat(
          (that = this.it)
            ? [' ', that.compile(o, LEVEL_PAREN)]
            : [], [";"]
        ));
      };
      return Return;
    }(Jump));
    exports.While = While = (function(superclass){
      var prototype = extend$((import$(While, superclass).displayName = 'While', While), superclass).prototype, constructor = While;
      function While(test, un, mode){
        this.un = un;
        mode && (mode instanceof Node
          ? this.update = mode
          : this.post = true);
        if (this.post || test.value !== '' + !un) {
          this.test = test;
        }
      }
      While.prototype.children = ['test', 'body', 'update', 'else'];
      While.prototype.aSource = 'test';
      While.prototype.aTargets = ['body', 'update'];
      While.prototype.show = function(){
        return [this.un ? '!' : void 8, this.post ? 'do' : void 8].join('');
      };
      prototype.isStatement = prototype.isArray = YES;
      While.prototype.makeComprehension = function(toAdd, loops){
        this.isComprehension = true;
        while (loops.length) {
          toAdd = loops.pop().addBody(Block(toAdd));
          if (!toAdd.isComprehension) {
            toAdd.inComprehension = true;
          }
        }
        return this.addBody(Block(toAdd));
      };
      While.prototype.getJump = function(ctx){
        var i$, ref$, ref1$, len$, node;
        ctx || (ctx = {});
        ctx['continue'] = true;
        ctx['break'] = true;
        for (i$ = 0, len$ = (ref$ = ((ref1$ = this.body) != null ? ref1$.lines : void 8) || []).length; i$ < len$; ++i$) {
          node = ref$[i$];
          if (node.getJump(ctx)) {
            return node;
          }
        }
      };
      While.prototype.addBody = function(body){
        var top;
        this.body = body;
        if (this.guard) {
          this.body = Block(If(this.guard, this.body));
        }
        top = this.body.lines[0];
        if ((top != null ? top.verb : void 8) === 'continue' && !top.label) {
          this.body.lines.length = 0;
        }
        return this;
      };
      While.prototype.addGuard = function(guard){
        this.guard = guard;
        return this;
      };
      While.prototype.addObjComp = function(objComp){
        this.objComp = objComp != null ? objComp : true;
        return this;
      };
      While.prototype.makeReturn = function(it){
        var last, ref$, ref1$, ref2$;
        if (this.hasReturned) {
          return this;
        }
        if (it) {
          if (this.objComp) {
            this.body = Block(this.body.makeReturn(it, true));
          } else {
            if (!(this.body || this.index)) {
              this.addBody(Block(Var(this.index = 'ridx$')));
            }
            last = (ref$ = this.body.lines) != null ? ref$[ref$.length - 1] : void 8;
            if ((this.isComprehension || this.inComprehension) && !(last != null && last.isComprehension)) {
              (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
              if ((ref1$ = this['else']) != null) {
                ref1$.makeReturn.apply(ref1$, arguments);
              }
              this.hasReturned = true;
            } else {
              this.resVar = it;
              if ((ref2$ = this['else']) != null) {
                ref2$.makeReturn.apply(ref2$, arguments);
              }
            }
          }
        } else {
          this.getJump() || (this.returns = true);
        }
        return this;
      };
      While.prototype.compileNode = function(o){
        var test, ref$, head, that;
        o.loop = true;
        this.test && (this.un
          ? this.test = this.test.invert()
          : this.anaphorize());
        if (this.post) {
          return sn(null, sn(this, 'do {'), this.compileBody((o.indent += TAB, o)));
        }
        test = ((ref$ = this.test) != null ? ref$.compile(o, LEVEL_PAREN) : void 8) || '';
        if (!(this.update || this['else'])) {
          head = !snEmpty(test)
            ? [sn(this, "while ("), test]
            : [sn(this, 'for (;;')];
        } else {
          head = [sn(this, 'for (')];
          if (this['else']) {
            head.push(this.yet = o.scope.temporary('yet'), " = true");
          }
          head.push(sn(this, ";"), test.toString() && ' ', test, sn(this, ";"));
          if (that = this.update) {
            head.push(' ', that.compile(o, LEVEL_PAREN));
          }
        }
        return sn.apply(null, [null].concat(arrayFrom$(head), [sn(this, ') {'), this.compileBody((o.indent += TAB, o))]));
      };
      While.prototype.compileBody = function(o){
        var lines, yet, tab, code, ret, mid, empty, _resultName, getResultName, last, hasLoop, res, temp, key$, ref$, bodyCode, this$ = this;
        o['break'] = o['continue'] = true;
        lines = this.body.lines, yet = this.yet, tab = this.tab;
        code = [];
        ret = [];
        mid = [];
        empty = this.objComp ? '{}' : '[]';
        getResultName = function(){
          return _resultName != null
            ? _resultName
            : _resultName = o.scope.temporary(this$.objComp ? 'resultObj' : 'results');
        };
        last = lines != null ? lines[lines.length - 1] : void 8;
        if (!(this.isComprehension || this.inComprehension) || (last != null && last.isComprehension)) {
          hasLoop = false;
          if (last != null) {
            last.traverseChildren(function(it){
              var ref$;
              if (it instanceof Block && (ref$ = it.lines)[ref$.length - 1] instanceof While) {
                hasLoop = true;
              }
            });
          }
          if (this.returns && !this.resVar) {
            this.resVar = res = o.scope.assign(getResultName(), empty);
          }
          if (this.resVar && (last instanceof While || hasLoop)) {
            temp = o.scope.temporary('lresult');
            lines.unshift(Assign(Var(temp), lines[lines.length - 1].objComp
              ? Obj()
              : Arr(), '='));
            if (lines[key$ = lines.length - 1] != null) {
              lines[key$] = lines[key$].makeReturn(temp);
            }
            mid.push(TAB, Chain(Var(this.resVar)).add(Index(Key('push'), '.', true)).add(Call([Chain(Var(temp))])).compile(o), ";\n" + this.tab);
          } else {
            this.hasReturned = true;
            if (this.resVar) {
              this.body.makeReturn(this.resVar);
            }
          }
        }
        if (this.returns) {
          if ((!last instanceof While && !this.hasReturned) || this.isComprehension || this.inComprehension) {
            if (lines[key$ = lines.length - 1] != null) {
              lines[key$] = lines[key$].makeReturn(res = o.scope.assign(getResultName(), empty), this.objComp);
            }
          }
          ret.push("\n" + this.tab + "return ", res || empty, ";");
          if ((ref$ = this['else']) != null) {
            ref$.makeReturn();
          }
        }
        yet && lines.unshift(JS(yet + " = false;"));
        if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
          code.push("\n", bodyCode, "\n" + tab);
        }
        code.push.apply(code, mid);
        code.push('}');
        if (this.post) {
          code.push(sn(this, " while ("), this.test.compile((o.tab = tab, o), LEVEL_PAREN), sn(this, ");"));
        }
        if (yet) {
          code.push(sn(this, " if ("), yet, sn(this, ") "), this.compileBlock(o, Block(this['else'])));
          o.scope.free(yet);
        }
        return sn.apply(null, [null].concat(arrayFrom$(code), arrayFrom$(ret)));
      };
      return While;
    }(Node));
    exports.For = For = (function(superclass){
      var prototype = extend$((import$(For, superclass).displayName = 'For', For), superclass).prototype, constructor = For;
      function For(it){
        var i$, x$, ref$, len$;
        importAll$(this, it);
        if (this.item instanceof Var && !this.item.value) {
          this.item = null;
        }
        for (i$ = 0, len$ = (ref$ = this.kind || []).length; i$ < len$; ++i$) {
          x$ = ref$[i$];
          this[x$] = true;
        }
        if (this.own && !this.object) {
          this.carp('`for own` requires `of`');
        }
      }
      For.prototype.children = ['item', 'source', 'from', 'to', 'step', 'body'];
      For.prototype.aSource = null;
      For.prototype.show = function(){
        return ((this.kind || []).concat(this.index)).join(' ');
      };
      For.prototype.addBody = function(body){
        var ref$, that, assignments, x$, assigned, name, ref1$;
        if (this['let']) {
          if (ref$ = this.ref, delete this.ref, ref$) {
            this.item = Literal('..');
          }
          if (that = (ref$ = this.item) != null ? ref$.rewriteShorthand() : void 8) {
            this.item = that;
          }
          assignments = (x$ = [], (that = this.index) && x$.push(Assign(Var(that), Literal('index$$'))), (that = this.item) && x$.push(Assign(that, Literal('item$$'))), x$);
          body = Block(this.guard
            ? (assigned = (function(){
              var i$, x$, ref$, len$, j$, ref1$, len1$, results$ = [];
              for (i$ = 0, len$ = (ref$ = assignments).length; i$ < len$; ++i$) {
                x$ = ref$[i$];
                if (that = x$.assigns()) {
                  for (j$ = 0, len1$ = (ref1$ = that).length; j$ < len1$; ++j$) {
                    name = ref1$[j$];
                    results$.push(Var(name));
                  }
                }
              }
              return results$;
            }()), assignments.concat([If((ref1$ = this.guard, delete this.guard, ref1$), Call['let'](assigned, body))]))
            : Call['let'](assignments, body));
        }
        superclass.prototype.addBody.call(this, body);
        if (this['let']) {
          delete this.index;
          delete this.item;
        }
        return this;
      };
      For.prototype.isNextUnreachable = NO;
      For.prototype.compileNode = function(o){
        var temps, idx, ref$, pvar, step, tvar, tail, fvar, vars, eq, cond, svar, srcPart, lvar, head, that, body;
        o.loop = true;
        temps = this.temps = [];
        if (this.object && this.index) {
          o.scope.declare(idx = this.index);
        } else {
          temps.push(idx = o.scope.temporary('i'));
        }
        if (!this.body) {
          this.addBody(Block(Var(idx)));
        }
        if (!this.object) {
          ref$ = (this.step || Literal(1)).compileLoopReference(o, 'step'), pvar = ref$[0], step = ref$[1];
          pvar === step || temps.push(pvar);
        }
        if (this.from) {
          if (this.ref) {
            this.item = Var(idx);
          }
          ref$ = this.to.compileLoopReference(o, 'to'), tvar = ref$[0], tail = ref$[1];
          fvar = this.from.compile(o, LEVEL_LIST);
          vars = idx + " = " + fvar;
          if (tail !== tvar) {
            vars += ", " + tail;
            temps.push(tvar);
          }
          if (!this.step && +fvar > +tvar) {
            pvar = step = -1;
          }
          eq = this.op === 'til' ? '' : '=';
          cond = +pvar
            ? idx + " " + '<>'.charAt(pvar < 0) + eq + " " + tvar
            : pvar + " < 0 ? " + idx + " >" + eq + " " + tvar + " : " + idx + " <" + eq + " " + tvar;
        } else {
          if (this.ref) {
            this.item = Var(o.scope.temporary('x'));
          }
          if (this.item || this.object && this.own || this['let']) {
            ref$ = this.source.compileLoopReference(o, 'ref', !this.object, true), svar = ref$[0], srcPart = ref$[1];
            svar === srcPart || temps.push(svar);
          } else {
            svar = srcPart = this.source.compile(o, LEVEL_PAREN);
          }
          if (!this.object) {
            if (0 > pvar && ~~pvar === +pvar) {
              vars = idx + " = " + srcPart + ".length - 1";
              cond = idx + " >= 0";
            } else {
              temps.push(lvar = o.scope.temporary('len'));
              vars = idx + " = 0, " + lvar + " = " + srcPart + ".length";
              cond = idx + " < " + lvar;
            }
          }
        }
        this['else'] && (this.yet = o.scope.temporary('yet'));
        head = [sn(this, 'for (')];
        if (this.object) {
          head.push(idx, " in ");
        }
        if (that = this.yet) {
          head.push(that, " = true, ");
        }
        if (this.object) {
          head.push(srcPart);
        } else {
          step === pvar || (vars += ', ' + step);
          head.push(vars, "; ", cond, "; " + (1 == Math.abs(pvar)
            ? (pvar < 0 ? '--' : '++') + idx
            : idx + (pvar < 0
              ? ' -= ' + pvar.toString().slice(1)
              : ' += ' + pvar)));
        }
        this.own && head.push(sn(this, ") if ("), o.scope.assign('own$', '{}.hasOwnProperty'), ".call(", svar, ", ", idx, ")");
        head.push(sn(this, ') {'));
        if (this['let']) {
          this.body.traverseChildren(function(it){
            switch (it.value) {
            case 'index$$':
              it.value = idx;
              break;
            case 'item$$':
              it.value = svar + "[" + idx + "]";
            }
          });
        }
        o.indent += TAB;
        if (this.index && !this.object) {
          head.push('\n' + o.indent, Assign(Var(this.index), JS(idx)).compile(o, LEVEL_TOP), ';');
        }
        if (this.item && !this.item.isEmpty() && !this.from) {
          head.push('\n' + o.indent, Assign(this.item, JS(svar + "[" + idx + "]")).compile(o, LEVEL_TOP), ';');
        }
        if (this.ref) {
          o.ref = this.item.value;
        }
        body = this.compileBody(o);
        if ((this.item || (this.index && !this.object)) && '}' === body.toString().charAt(0)) {
          head.push('\n' + this.tab);
        }
        return sn.apply(null, [null].concat(arrayFrom$(head), [body]));
      };
      return For;
    }(While));
    exports.StepSlice = StepSlice = (function(superclass){
      var prototype = extend$((import$(StepSlice, superclass).displayName = 'StepSlice', StepSlice), superclass).prototype, constructor = StepSlice;
      StepSlice.prototype.makeReturn = function(makeReturnArg){
        this.makeReturnArg = makeReturnArg;
        return superclass.prototype.makeReturn.apply(this, arguments);
      };
      StepSlice.prototype.compileNode = function(o){
        var ref$, sub, ref, temps, code;
        this.index = o.scope.temporary('x');
        ref$ = this.target.unwrap().cache(o), sub = ref$[0], ref = ref$[1], temps = ref$[2];
        this.guard = Binary('<', Literal(this.index), Chain(ref).add(Index(Key('length'))));
        this.makeComprehension(Chain(ref).add(Index(Literal(this.index))), this);
        if (this.makeReturnArg != null) {
          this.makeReturn(this.makeReturnArg);
        }
        code = [];
        if (temps) {
          code.push(sub.compile(o), ';' + '\n' + o.indent);
        }
        code.push(superclass.prototype.compileNode.apply(this, arguments));
        return sn.apply(null, [this].concat(arrayFrom$(code)));
      };
      function StepSlice(){
        StepSlice.superclass.apply(this, arguments);
      }
      return StepSlice;
    }(For));
    exports.Try = Try = (function(superclass){
      var prototype = extend$((import$(Try, superclass).displayName = 'Try', Try), superclass).prototype, constructor = Try;
      function Try(attempt, thrown, recovery, ensure){
        var ref$;
        this.attempt = attempt;
        this.thrown = thrown;
        this.recovery = recovery;
        this.ensure = ensure;
        if ((ref$ = this.recovery) != null) {
          ref$.lines.unshift(Assign(this.thrown || Var('e'), Var('e$')));
        }
      }
      Try.prototype.children = ['attempt', 'recovery', 'ensure'];
      Try.prototype.show = function(){
        return this.thrown;
      };
      Try.prototype.isStatement = YES;
      Try.prototype.isCallable = function(){
        var ref$;
        return ((ref$ = this.recovery) != null ? ref$.isCallable() : void 8) && this.attempt.isCallable();
      };
      Try.prototype.getJump = function(it){
        var ref$;
        return this.attempt.getJump(it) || ((ref$ = this.recovery) != null ? ref$.getJump(it) : void 8);
      };
      Try.prototype.isNextUnreachable = function(){
        var ref$, that;
        return ((ref$ = this.ensure) != null ? ref$.isNextUnreachable() : void 8) || this.attempt.isNextUnreachable() && ((that = this.recovery) != null ? that.isNextUnreachable() : true);
      };
      Try.prototype.makeReturn = function(){
        var ref$;
        this.attempt = (ref$ = this.attempt).makeReturn.apply(ref$, arguments);
        if (this.recovery != null) {
          this.recovery = (ref$ = this.recovery).makeReturn.apply(ref$, arguments);
        }
        return this;
      };
      Try.prototype.compileNode = function(o){
        var code, that;
        o.indent += TAB;
        code = [sn(this, 'try '), this.compileBlock(o, this.attempt)];
        if (that = this.recovery || !this.ensure && JS('')) {
          code.push(sn(that, ' catch (e$) '), this.compileBlock(o, that));
        }
        if (that = this.ensure) {
          code.push(sn(that, ' finally '), this.compileBlock(o, that));
        }
        return sn.apply(null, [null].concat(arrayFrom$(code)));
      };
      return Try;
    }(Node));
    exports.Switch = Switch = (function(superclass){
      var prototype = extend$((import$(Switch, superclass).displayName = 'Switch', Switch), superclass).prototype, constructor = Switch;
      function Switch(type, topic, cases, $default){
        var last, ref$;
        this.type = type;
        this.topic = topic;
        this.cases = cases;
        this['default'] = $default;
        if (type === 'match') {
          if (topic) {
            this.topic = Arr(topic);
          }
        } else {
          if (topic) {
            if (topic.length > 1) {
              throw "can't have more than one topic in switch statement";
            }
            this.topic = this.topic[0];
          }
        }
        if (this.cases.length && (last = (ref$ = this.cases)[ref$.length - 1]).tests.length === 1 && last.tests[0] instanceof Var && last.tests[0].value === '_') {
          this.cases.pop();
          this['default'] = last.body;
        }
      }
      Switch.prototype.children = ['topic', 'cases', 'default'];
      Switch.prototype.aSource = 'topic';
      Switch.prototype.aTargets = ['cases', 'default'];
      Switch.prototype.show = function(){
        return this.type;
      };
      Switch.prototype.isStatement = YES;
      Switch.prototype.isCallable = function(){
        var i$, ref$, len$, c;
        for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
          c = ref$[i$];
          if (!c.isCallable()) {
            return false;
          }
        }
        if (this['default']) {
          return this['default'].isCallable();
        } else {
          return true;
        }
      };
      Switch.prototype.getJump = function(ctx){
        var i$, ref$, len$, c, that;
        ctx || (ctx = {});
        ctx['break'] = true;
        for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
          c = ref$[i$];
          if (that = c.body.getJump(ctx)) {
            return that;
          }
        }
        return (ref$ = this['default']) != null ? ref$.getJump(ctx) : void 8;
      };
      Switch.prototype.isNextUnreachable = function(){
        var i$, ref$, len$, c;
        for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
          c = ref$[i$];
          if (!c.body.isNextUnreachable()) {
            return false;
          }
        }
        return (ref$ = this['default']) != null ? ref$.isNextUnreachable() : void 8;
      };
      Switch.prototype.makeReturn = function(){
        var i$, ref$, len$, c;
        for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
          c = ref$[i$];
          c.makeReturn.apply(c, arguments);
        }
        if ((ref$ = this['default']) != null) {
          ref$.makeReturn.apply(ref$, arguments);
        }
        return this;
      };
      Switch.prototype.compileNode = function(o){
        var tab, topic, ref$, targetNode, target, t, code, stop, i$, len$, i, c, that;
        tab = this.tab;
        topic = this.type === 'match'
          ? (this.topic && (ref$ = Chain(this.topic).cacheReference(o), targetNode = ref$[0], target = ref$[1]), t = target
            ? [targetNode]
            : [], Block(t.concat([Literal('false')])).compile(o, LEVEL_PAREN))
          : !!this.topic && this.anaphorize().compile(o, LEVEL_PAREN);
        code = [sn(this, "switch (", snSafe(topic), ") {\n")];
        stop = this['default'] || this.cases.length - 1;
        o['break'] = true;
        for (i$ = 0, len$ = (ref$ = this.cases).length; i$ < len$; ++i$) {
          i = i$;
          c = ref$[i$];
          code.push(c.compileCase(o, tab, i === stop, this.type === 'match' || !topic, this.type, target));
        }
        if (this['default']) {
          o.indent = tab + TAB;
          if (that = this['default'].compile(o, LEVEL_TOP)) {
            code.push(tab + "default:\n", that, "\n");
          }
        }
        return sn.apply(null, [null].concat(arrayFrom$(code), [tab + '}']));
      };
      return Switch;
    }(Node));
    exports.Case = Case = (function(superclass){
      var prototype = extend$((import$(Case, superclass).displayName = 'Case', Case), superclass).prototype, constructor = Case;
      function Case(tests, body){
        this.tests = tests;
        this.body = body;
      }
      Case.prototype.children = ['tests', 'body'];
      Case.prototype.isCallable = function(){
        return this.body.isCallable();
      };
      Case.prototype.makeReturn = function(){
        var ref$, ref1$;
        if (((ref$ = (ref1$ = this.body.lines)[ref1$.length - 1]) != null ? ref$.value : void 8) !== 'fallthrough') {
          (ref1$ = this.body).makeReturn.apply(ref1$, arguments);
        }
        return this;
      };
      Case.prototype.compileCase = function(o, tab, nobr, bool, type, target){
        var tests, i$, ref$, len$, test, j$, ref1$, len1$, t, i, tar, binary, that, code, lines, last, ft, bodyCode;
        tests = [];
        for (i$ = 0, len$ = (ref$ = this.tests).length; i$ < len$; ++i$) {
          test = ref$[i$];
          if (test instanceof Arr && type !== 'match') {
            for (j$ = 0, len1$ = (ref1$ = test.items).length; j$ < len1$; ++j$) {
              t = ref1$[j$];
              tests.push(t);
            }
          } else {
            tests.push(test);
          }
        }
        tests.length || tests.push(Literal('void'));
        if (type === 'match') {
          for (i$ = 0, len$ = tests.length; i$ < len$; ++i$) {
            i = i$;
            test = tests[i$];
            tar = Chain(target).add(Index(Literal(i), '.', true));
            tests[i] = Parens(Chain(test).autoCompare(target ? [tar] : null));
          }
        }
        if (bool) {
          binary = type === 'match' ? '&&' : '||';
          t = tests[0];
          i = 0;
          while (that = tests[++i]) {
            t = Binary(binary, t, that);
          }
          tests = [(this.t = t, this.aSource = 't', this.aTargets = ['body'], this).anaphorize().invert()];
        }
        code = [];
        for (i$ = 0, len$ = tests.length; i$ < len$; ++i$) {
          t = tests[i$];
          code.push(tab, sn(t, "case ", t.compile(o, LEVEL_PAREN), ":\n"));
        }
        lines = this.body.lines;
        last = lines[lines.length - 1];
        if (ft = (last != null ? last.value : void 8) === 'fallthrough') {
          lines[lines.length - 1] = JS('// fallthrough');
        }
        o.indent = tab += TAB;
        if (!snEmpty(bodyCode = this.body.compile(o, LEVEL_TOP))) {
          code.push(bodyCode, '\n');
        }
        if (!(nobr || ft || (last != null && last.isNextUnreachable()))) {
          code.push(tab + 'break;\n');
        }
        return sn.apply(null, [null].concat(arrayFrom$(code)));
      };
      return Case;
    }(Node));
    exports.If = If = (function(superclass){
      var prototype = extend$((import$(If, superclass).displayName = 'If', If), superclass).prototype, constructor = If;
      function If($if, then, un){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$['if'] = $if;
        this$.then = then;
        this$.un = un;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      If.prototype.children = ['if', 'then', 'else'];
      If.prototype.aSource = 'if';
      If.prototype.aTargets = ['then'];
      If.prototype.show = function(){
        return this.un && '!';
      };
      If.prototype.terminator = '';
      prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex', 'isNextUnreachable'], function(it){
        var ref$;
        return ((ref$ = this['else']) != null ? ref$[it]() : void 8) && this.then[it]();
      });
      If.prototype.getJump = function(it){
        var ref$;
        return this.then.getJump(it) || ((ref$ = this['else']) != null ? ref$.getJump(it) : void 8);
      };
      If.prototype.makeReturn = function(){
        var ref$;
        this.then = (ref$ = this.then).makeReturn.apply(ref$, arguments);
        if (this['else'] != null) {
          this['else'] = (ref$ = this['else']).makeReturn.apply(ref$, arguments);
        }
        return this;
      };
      If.prototype.compileNode = function(o){
        if (this.un) {
          this['if'] = this['if'].invert();
        } else {
          this.soak || this.anaphorize();
        }
        if (o.level) {
          return this.compileExpression(o);
        } else {
          return this.compileStatement(o);
        }
      };
      If.prototype.compileStatement = function(o){
        var code, els;
        code = [sn(this, "if (", this['if'].compile(o, LEVEL_PAREN), ") ")];
        o.indent += TAB;
        code.push(this.compileBlock(o, Block(this.then)));
        if (!(els = this['else'])) {
          return sn.apply(null, [null].concat(arrayFrom$(code)));
        }
        return sn.apply(null, [null].concat(
          arrayFrom$(code), [
            sn(els, ' else '), els instanceof constructor
              ? els.compile((o.indent = this.tab, o), LEVEL_TOP)
              : this.compileBlock(o, els)
          ]
        ));
      };
      If.prototype.compileExpression = function(o){
        var thn, els, code, pad;
        thn = this.then, els = this['else'] || Literal('void');
        this['void'] && (thn['void'] = els['void'] = true);
        if (!this['else'] && (this.cond || this['void'])) {
          return Parens(Binary('&&', this['if'], thn)).compile(o);
        }
        code = [sn(this, this['if'].compile(o, LEVEL_COND))];
        pad = els.isComplex() ? '\n' + (o.indent += TAB) : ' ';
        code.push(pad + "", sn(thn, "? "), thn.compile(o, LEVEL_LIST), pad + "", sn(els, ": "), els.compile(o, LEVEL_LIST));
        if (o.level < LEVEL_COND) {
          return sn.apply(null, [null].concat(arrayFrom$(code)));
        } else {
          return sn(null, "(", code, ")");
        }
      };
      If.unfoldSoak = function(o, parent, name){
        var that;
        if (that = parent[name].unfoldSoak(o)) {
          parent[name] = that.then;
          return that.cond = parent.cond, that['void'] = parent['void'], that.then = Chain(parent), that;
        }
      };
      return If;
    }(Node));
    exports.Label = Label = (function(superclass){
      var ref$, prototype = extend$((import$(Label, superclass).displayName = 'Label', Label), superclass).prototype, constructor = Label;
      function Label(label, it){
        var fun;
        this.label = label || '_';
        this.it = it;
        if (this.it.curried) {
          this.carp("can't use label with a curried function (attempted label '" + this.label + "')");
        }
        if (fun = (it instanceof Fun || it instanceof Class) && it || it.calling && it.it.head) {
          fun.name || (fun.name = this.label, fun.labeled = true);
          return it;
        }
      }
      ref$ = Parens.prototype, prototype.children = ref$.children, prototype.isCallable = ref$.isCallable, prototype.isArray = ref$.isArray;
      Label.prototype.show = function(){
        return this.label;
      };
      Label.prototype.isStatement = YES;
      Label.prototype.getJump = function(ctx){
        var ref$;
        ctx || (ctx = {});
        ((ref$ = ctx.labels) != null
          ? ref$
          : ctx.labels = []).push(this.label);
        return this.it.getJump((ctx['break'] = true, ctx));
      };
      Label.prototype.makeReturn = function(){
        var ref$;
        this.it = (ref$ = this.it).makeReturn.apply(ref$, arguments);
        return this;
      };
      Label.prototype.compileNode = function(o){
        var label, it, labels;
        label = this.label, it = this.it;
        labels = o.labels = arrayFrom$(o.labels || []);
        if (in$(label, labels)) {
          this.carp("duplicate label \"" + label + "\"");
        }
        labels.push(label);
        it.isStatement() || (it = Block(it));
        return sn(null, sn(this, label, ": "), it instanceof Block
          ? (o.indent += TAB, this.compileBlock(o, it))
          : it.compile(o));
      };
      return Label;
    }(Node));
    exports.Cascade = Cascade = (function(superclass){
      var prototype = extend$((import$(Cascade, superclass).displayName = 'Cascade', Cascade), superclass).prototype, constructor = Cascade;
      function Cascade(input, output, prog1){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.input = input;
        this$.output = output;
        this$.prog1 = prog1;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Cascade.prototype.show = function(){
        return this.prog1;
      };
      Cascade.prototype.children = ['input', 'output'];
      Cascade.prototype.terminator = '';
      prototype.delegate(['isCallable', 'isArray', 'isString', 'isRegex'], function(it){
        return this[this.prog1 ? 'input' : 'output'][it]();
      });
      Cascade.prototype.getJump = function(it){
        return this.output.getJump(it);
      };
      Cascade.prototype.makeReturn = function(ret){
        this.ret = ret;
        return this;
      };
      Cascade.prototype.compileNode = function(o){
        var level, input, output, prog1, ref, ref$, code, out;
        level = o.level;
        input = this.input, output = this.output, prog1 = this.prog1, ref = this.ref;
        if (prog1 && ('ret' in this || level && !this['void'])) {
          output.add((ref$ = Literal('..'), ref$.cascadee = true, ref$));
        }
        if ('ret' in this) {
          output = output.makeReturn(this.ret);
        }
        if (ref) {
          prog1 || (output = Assign(Var(ref), output));
        } else {
          ref = o.scope.temporary('x');
        }
        if (input instanceof Cascade) {
          input.ref = ref;
        } else {
          input && (input = Assign(Var(ref), input));
        }
        o.level && (o.level = LEVEL_PAREN);
        code = [input.compile(o)];
        out = Block(output).compile((o.ref = new String(ref), o));
        if (prog1 === 'cascade' && !o.ref.erred) {
          this.carp("unreferred cascadee");
        }
        if (!level) {
          return sn.apply(null, [null].concat(arrayFrom$(code), [input.terminator, "\n", out]));
        }
        code.push(", ", out);
        if (level > LEVEL_PAREN) {
          return sn.apply(null, [null, "("].concat(arrayFrom$(code), [")"]));
        } else {
          return sn.apply(null, [null].concat(arrayFrom$(code)));
        }
      };
      return Cascade;
    }(Node));
    exports.JS = JS = (function(superclass){
      var prototype = extend$((import$(JS, superclass).displayName = 'JS', JS), superclass).prototype, constructor = JS;
      function JS(code, literal, comment){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.code = code;
        this$.literal = literal;
        this$.comment = comment;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      JS.prototype.show = function(){
        if (this.comment) {
          return this.code;
        } else {
          return "`" + this.code + "`";
        }
      };
      JS.prototype.terminator = '';
      prototype.isAssignable = prototype.isCallable = function(){
        return !this.comment;
      };
      JS.prototype.compile = function(it){
        return sn(this, snSafe(this.literal
          ? entab(this.code, it.indent)
          : this.code));
      };
      return JS;
    }(Node));
    exports.Require = Require = (function(superclass){
      var prototype = extend$((import$(Require, superclass).displayName = 'Require', Require), superclass).prototype, constructor = Require;
      function Require(body){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.body = body;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Require.prototype.children = ['body'];
      Require.prototype.compile = function(o){
        var getValue, processItem, code, i$, ref$, len$, item, this$ = this;
        getValue = function(item, throwError){
          switch (false) {
          case !(item instanceof Key):
            return item.name;
          case !(item instanceof Var):
            return item.value;
          case !(item instanceof Literal):
            return item.value;
          default:
            if (throwError) {
              return this$.carp('invalid require! argument');
            } else {
              return item;
            }
          }
        };
        processItem = function(item){
          var ref$, asg, value, asgValue, toAsg, main;
          ref$ = (function(){
            var ref$;
            switch (false) {
            case !(item instanceof Prop):
              return [
                item.val, (ref$ = item.key) != null
                  ? ref$
                  : item.val
              ];
            default:
              return [item, item];
            }
          }()), asg = ref$[0], value = ref$[1];
          asgValue = getValue(asg);
          toAsg = toString$.call(asgValue).slice(8, -1) === 'String' ? CopyL(asg, Var(nameFromPath(asgValue))) : asg;
          value = stripString(getValue(value, true));
          main = Chain(CopyL(this, Var('require'))).add(Call([Literal("'" + value + "'")]));
          return sn(item, Assign(toAsg, main).compile(o));
        };
        if (this.body.items != null) {
          code = [];
          for (i$ = 0, len$ = (ref$ = this.body.items).length; i$ < len$; ++i$) {
            item = ref$[i$];
            code.push(processItem(item), ";\n" + o.indent);
          }
          code.pop();
          return sn.apply(null, [null].concat(arrayFrom$(code)));
        } else {
          return sn(null, processItem(this.body));
        }
      };
      return Require;
    }(Node));
    exports.Util = Util = (function(superclass){
      var prototype = extend$((import$(Util, superclass).displayName = 'Util', Util), superclass).prototype, constructor = Util;
      function Util(verb){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.verb = verb;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Util.prototype.show = Jump.prototype.show;
      Util.prototype.isCallable = YES;
      Util.prototype.compile = function(){
        return sn(this, util(this.verb));
      };
      Util.Extends = function(){
        return Call.make(Util('extend'), [arguments[0], arguments[1]]);
      };
      return Util;
    }(Node));
    exports.Vars = Vars = (function(superclass){
      var prototype = extend$((import$(Vars, superclass).displayName = 'Vars', Vars), superclass).prototype, constructor = Vars;
      function Vars(vars){
        var this$ = this instanceof ctor$ ? this : new ctor$;
        this$.vars = vars;
        return this$;
      } function ctor$(){} ctor$.prototype = prototype;
      Vars.prototype.children = ['vars'];
      Vars.prototype.makeReturn = THIS;
      Vars.prototype.compile = function(o, level){
        var i$, ref$, len$, v, value;
        for (i$ = 0, len$ = (ref$ = this.vars).length; i$ < len$; ++i$) {
          v = ref$[i$], value = v.value;
          if (!(v instanceof Var)) {
            v.carp('invalid variable declaration');
          }
          if (o.scope.check(value)) {
            v.carp("redeclaration of \"" + value + "\"");
          }
          o.scope.declare(value, v);
        }
        return sn(this, Literal('void').compile(o, level));
      };
      return Vars;
    }(Node));
    exports.L = function(a, b, node){
      if (node && typeof node === "object") {
        node.first_line = a.first_line + 1;
        node.first_column = a.first_column;
        node.last_line = b.last_line + 1;
        node.last_column = b.last_column;
        node.line = a.first_line + 1;
        node.column = a.first_column;
      }
      return node;
    };
    exports.CopyL = CopyL = function(a, node){
      if (node && typeof node === "object") {
        node.first_line = a.first_line;
        node.first_column = a.first_column;
        node.last_line = a.last_line;
        node.last_column = a.last_column;
        node.line = a.line;
        node.column = a.column;
      }
      return node;
    };
    exports.Box = function(v){
      if (typeof v === "object") {
        return v;
      } else {
        return new v.constructor(v);
      }
    };
    exports.Decl = function(type, nodes, lno){
      if (!nodes[0]) {
        throw SyntaxError("empty " + type + " on line " + lno);
      }
      return DECLS[type](nodes);
    };
    DECLS = {
      'export': function(lines){
        var i, out, node, that, ref$;
        i = -1;
        out = Util('out');
        while (node = lines[++i]) {
          if (node instanceof Block) {
            lines.splice.apply(lines, [i--, 1].concat(arrayFrom$(node.lines)));
            continue;
          }
          if (that = node instanceof Fun && node.name) {
            lines.splice(i++, 0, Assign(Chain(out, [Index(Key(that))]), Var(that)));
            continue;
          }
          lines[i] = (that = node.varName() || node instanceof Assign && node.left.varName() || node instanceof Class && ((ref$ = node.title) != null ? ref$.varName() : void 8))
            ? Assign(Chain(out, [Index(Key(that))]), node)
            : Import(out, node);
        }
        return Block(lines);
      },
      'import': function(lines, all){
        var i$, len$, i, line;
        for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
          i = i$;
          line = lines[i$];
          lines[i] = Import(Literal('this'), line, all);
        }
        return Block(lines);
      },
      importAll: function(it){
        return this['import'](it, true);
      },
      'const': function(lines){
        var i$, len$, node;
        for (i$ = 0, len$ = lines.length; i$ < len$; ++i$) {
          node = lines[i$];
          node.op === '=' || node.carp('invalid constant variable declaration');
          node['const'] = true;
        }
        return Block(lines);
      },
      'var': Vars
    };
    function Scope(parent, shared){
      this.parent = parent;
      this.shared = shared;
      this.variables = {};
    }
    ref$ = Scope.prototype;
    ref$.READ_ONLY = {
      'const': 'constant',
      'function': 'function',
      undefined: 'undeclared'
    };
    ref$.add = function(name, type, node){
      var t, that;
      if (node && (t = this.variables[name + "."])) {
        if (that = this.READ_ONLY[t] || this.READ_ONLY[type]) {
          node.carp("redeclaration of " + that + " \"" + name + "\"");
        } else if (t === type && type === 'arg') {
          node.carp("duplicate parameter \"" + name + "\"");
        } else if (t === 'upvar') {
          node.carp("accidental shadow of \"" + name + "\"");
        }
        if (t === 'arg' || t === 'function') {
          return name;
        }
      }
      this.variables[name + "."] = type;
      return name;
    };
    ref$.get = function(name){
      return this.variables[name + "."];
    };
    ref$.declare = function(name, node, constant){
      var that, scope;
      if (that = this.shared) {
        if (this.check(name)) {
          return;
        }
        scope = that;
      } else {
        scope = this;
      }
      return scope.add(name, constant ? 'const' : 'var', node);
    };
    ref$.assign = function(name, value){
      return this.add(name, {
        value: value
      });
    };
    ref$.temporary = function(name){
      var ref$;
      name || (name = 'ref');
      while ((ref$ = this.variables[name + "$."]) !== 'reuse' && ref$ !== void 8) {
        name = name.length < 2 && name < 'z'
          ? String.fromCharCode(name.charCodeAt() + 1)
          : name.replace(/\d*$/, fn$);
      }
      return this.add(name + '$', 'var');
      function fn$(it){
        return ++it;
      }
    };
    ref$.free = function(name){
      return this.add(name, 'reuse');
    };
    ref$.check = function(name, above){
      var type, ref$;
      if ((type = this.variables[name + "."]) || !above) {
        return type;
      }
      return (ref$ = this.parent) != null ? ref$.check(name, above) : void 8;
    };
    ref$.checkReadOnly = function(name){
      var that, ref$, key$;
      if (that = this.READ_ONLY[this.check(name, true)]) {
        return that;
      }
      (ref$ = this.variables)[key$ = name + "."] || (ref$[key$] = 'upvar');
      return '';
    };
    ref$.emit = function(code, tab){
      var vrs, asn, fun, name, ref$, type, that, val, declCode;
      vrs = [];
      asn = [];
      fun = [];
      for (name in ref$ = this.variables) {
        type = ref$[name];
        name = name.slice(0, -1);
        if (type === 'var' || type === 'const' || type === 'reuse') {
          vrs.push(name, ", ");
        } else if (that = type.value) {
          if (~(val = entab(that, tab)).toString().lastIndexOf('function(', 0)) {
            if (val instanceof SourceNode) {
              snRemoveLeft(val, 8);
            } else {
              val = val.slice(8);
            }
            fun.push("function ", name, val, "\n" + tab);
          } else {
            asn.push(name, " = ", val, ", ");
          }
        }
      }
      declCode = vrs.concat(asn);
      declCode.pop();
      fun.pop();
      if (declCode.length > 0) {
        code = sn.apply(null, [this, tab + "var "].concat(arrayFrom$(declCode), [";\n", code]));
      }
      if (fun.length > 0) {
        return sn.apply(null, [this, code, "\n" + tab].concat(arrayFrom$(fun)));
      } else {
        return sn(this, code);
      }
    };
    function YES(){
      return true;
    }
    function NO(){
      return false;
    }
    function THIS(){
      return this;
    }
    function VOID(){}
    UTILS = {
      clone: 'function(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}',
      extend: 'function(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new fun).constructor = sub;\n  if (typeof sup.extended == \'function\') sup.extended(sub);\n  return sub;\n}',
      bind: 'function(obj, key, target){\n  return function(){ return (target || obj)[key].apply(obj, arguments) };\n}',
      'import': 'function(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n  return obj;\n}',
      importAll: 'function(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}',
      copyWithout: 'function(src, ex){\n  var obj = {}, own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key) && !own.call(ex, key)) obj[key] = src[key];\n  return obj;\n}',
      repeatString: 'function(str, n){\n  for (var r = \'\'; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;\n  return r;\n}',
      repeatArray: 'function(arr, n){\n  for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))\n    if (n & 1) r.push.apply(r, arr);\n  return r;\n}',
      'in': 'function(x, xs){\n  var i = -1, l = xs.length >>> 0;\n  while (++i < l) if (x === xs[i]) return true;\n  return false;\n}',
      out: 'typeof exports != \'undefined\' && exports || this',
      curry: 'function(f, bound){\n  var context,\n  _curry = function(args) {\n    return f.length > 1 ? function(){\n      var params = args ? args.concat() : [];\n      context = bound ? context || this : this;\n      return params.push.apply(params, arguments) <\n          f.length && arguments.length ?\n        _curry.call(context, params) : f.apply(context, params);\n    } : f;\n  };\n  return _curry();\n}',
      flip: 'function(f){\n  return curry$(function (x, y) { return f(y, x); });\n}',
      partialize: 'function(f, args, where){\n  var context = this;\n  return function(){\n    var params = slice$.call(arguments), i,\n        len = params.length, wlen = where.length,\n        ta = args ? args.concat() : [], tw = where ? where.concat() : [];\n    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }\n    return len < wlen && len ?\n      partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);\n  };\n}',
      not: 'function(x){ return !x; }',
      compose: 'function() {\n  var functions = arguments;\n  return function() {\n    var i, result;\n    result = functions[0].apply(this, arguments);\n    for (i = 1; i < functions.length; ++i) {\n      result = functions[i](result);\n    }\n    return result;\n  };\n}',
      deepEq: 'function(x, y, type){\n  var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,\n      has = function (obj, key) { return hasOwnProperty.call(obj, key); };\n  var first = true;\n  return eq(x, y, []);\n  function eq(a, b, stack) {\n    var className, length, size, result, alength, blength, r, key, ref, sizeB;\n    if (a == null || b == null) { return a === b; }\n    if (a.__placeholder__ || b.__placeholder__) { return true; }\n    if (a === b) { return a !== 0 || 1 / a == 1 / b; }\n    className = toString.call(a);\n    if (toString.call(b) != className) { return false; }\n    switch (className) {\n      case \'[object String]\': return a == String(b);\n      case \'[object Number]\':\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case \'[object Date]\':\n      case \'[object Boolean]\':\n        return +a == +b;\n      case \'[object RegExp]\':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != \'object\' || typeof b != \'object\') { return false; }\n    length = stack.length;\n    while (length--) { if (stack[length] == a) { return true; } }\n    stack.push(a);\n    size = 0;\n    result = true;\n    if (className == \'[object Array]\') {\n      alength = a.length;\n      blength = b.length;\n      if (first) {\n        switch (type) {\n        case \'===\': result = alength === blength; break;\n        case \'<==\': result = alength <= blength; break;\n        case \'<<=\': result = alength < blength; break;\n        }\n        size = alength;\n        first = false;\n      } else {\n        result = alength === blength;\n        size = alength;\n      }\n      if (result) {\n        while (size--) {\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }\n        }\n      }\n    } else {\n      if (\'constructor\' in a != \'constructor\' in b || a.constructor != b.constructor) {\n        return false;\n      }\n      for (key in a) {\n        if (has(a, key)) {\n          size++;\n          if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }\n        }\n      }\n      if (result) {\n        sizeB = 0;\n        for (key in b) {\n          if (has(b, key)) { ++sizeB; }\n        }\n        if (first) {\n          if (type === \'<<=\') {\n            result = size < sizeB;\n          } else if (type === \'<==\') {\n            result = size <= sizeB\n          } else {\n            result = size === sizeB;\n          }\n        } else {\n          first = false;\n          result = size === sizeB;\n        }\n      }\n    }\n    stack.pop();\n    return result;\n  }\n}',
      arrayFrom: 'Array.from || function(x){return slice$.call(x);}',
      split: "''.split",
      replace: "''.replace",
      toString: '{}.toString',
      join: '[].join',
      slice: '[].slice',
      splice: '[].splice'
    };
    LEVEL_TOP = 0;
    LEVEL_PAREN = 1;
    LEVEL_LIST = 2;
    LEVEL_COND = 3;
    LEVEL_OP = 4;
    LEVEL_CALL = 5;
    (function(){
      this['&&'] = this['||'] = this['xor'] = 0.2;
      this['.&.'] = this['.^.'] = this['.|.'] = 0.3;
      this['=='] = this['!='] = this['~='] = this['!~='] = this['==='] = this['!=='] = 0.4;
      this['<'] = this['>'] = this['<='] = this['>='] = this.of = this['instanceof'] = 0.5;
      this['<<='] = this['>>='] = this['<=='] = this['>=='] = this['++'] = 0.5;
      this['.<<.'] = this['.>>.'] = this['.>>>.'] = 0.6;
      this['+'] = this['-'] = 0.7;
      this['*'] = this['/'] = this['%'] = 0.8;
    }.call(PREC = {
      unary: 0.9
    }));
    TAB = '  ';
    ID = /^(?!\d)[\w$\xAA-\uFFDC]+$/;
    SIMPLENUM = /^\d+$/;
    function util(it){
      return Scope.root.assign(it + '$', UTILS[it]);
    }
    function entab(code, tab){
      return code.replace(/\n/g, '\n' + tab);
    }
    function import$(obj, src){
      var own = {}.hasOwnProperty;
      for (var key in src) if (own.call(src, key)) obj[key] = src[key];
      return obj;
    }
    function clone$(it){
      function fun(){} fun.prototype = it;
      return new fun;
    }
    function extend$(sub, sup){
      function fun(){} fun.prototype = (sub.superclass = sup).prototype;
      (sub.prototype = new fun).constructor = sub;
      if (typeof sup.extended == 'function') sup.extended(sub);
      return sub;
    }
    function in$(x, xs){
      var i = -1, l = xs.length >>> 0;
      while (++i < l) if (x === xs[i]) return true;
      return false;
    }
    function repeatArray$(arr, n){
      for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))
        if (n & 1) r.push.apply(r, arr);
      return r;
    }
    function repeatString$(str, n){
      for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;
      return r;
    }
    function importAll$(obj, src){
      for (var key in src) obj[key] = src[key];
      return obj;
    }
    },{"./util":6,"prelude-ls":19,"source-map":31}],2:[function(require,module,exports){
    (function (Buffer){
    // Generated by blackpard 1.5.0
    var lexer, parser, ast, SourceNode, path, bufferFrom, toString$ = {}.toString;
    lexer = require('./lexer');
    parser = require('./parser').parser;
    ast = require('./ast');
    SourceNode = require('source-map').SourceNode;
    path = require('path');
    parser.yy = ast;
    parser.lexer = {
      lex: function(){
        var ref$, tag, first_line, first_column, last_line, last_column;
        ref$ = this.tokens[++this.pos] || [''], tag = ref$[0], this.yytext = ref$[1], first_line = ref$[2], first_column = ref$[3];
        ref$ = this.tokens[this.pos + 1] || [''], last_line = ref$[2], last_column = ref$[3];
        this.yylineno = first_line;
        this.yylloc = {
          first_line: first_line,
          first_column: first_column,
          last_line: last_line,
          last_column: last_column
        };
        return tag;
      },
      setInput: function(it){
        this.pos = -1;
        return this.tokens = it;
      },
      upcomingInput: function(){
        return '';
      }
    };
    bufferFrom = Buffer.alloc && Buffer.from || function(it){
      return new Buffer(it);
    };
    exports.VERSION = '1.6.0';
    exports.compile = function(code, options){
      var result, ast, output, filename, outputFilename, ref$, mapPath, e, that;
      options == null && (options = {});
      options.warn == null && (options.warn = true);
      options.header == null && (options.header = true);
      if (options.header === true) {
        options.header = "// Generated by blackpard " + exports.VERSION + "\n";
      }
      try {
        if (options.json) {
          result = Function(exports.compile(code, {
            bare: true,
            run: true,
            print: true
          }))();
          return JSON.stringify(result, null, 2) + "\n";
        } else {
          ast = parser.parse(lexer.lex(code));
          if (options.run && options.print) {
            ast.makeReturn();
          }
          output = ast.compileRoot(options);
          if (options.map && options.map !== 'none') {
            filename = options.filename, outputFilename = options.outputFilename;
            if (!filename) {
              filename = "unnamed-" + Math.floor(Math.random() * 4294967296).toString(16) + ".ls";
            }
            output.setFile(path.basename(filename));
            result = output.toStringWithSourceMap();
            if (options.map === 'embedded') {
              result.map.setSourceContent(filename, code);
            }
            if ((ref$ = options.map) === 'linked' || ref$ === 'debug') {
              mapPath = path.basename(outputFilename) + ".map";
              result.code += "\n//# sourceMappingURL=" + mapPath + "\n";
            } else {
              result.code += "\n//# sourceMappingURL=data:application/json;base64," + bufferFrom(result.map.toString()).toString('base64') + "\n";
            }
            return result;
          } else {
            return output.toString();
          }
        }
      } catch (e$) {
        e = e$;
        if (that = options.filename) {
          e.message += "\nat " + that;
        }
        throw e;
      }
    };
    exports.ast = function(it){
      return parser.parse(typeof it === 'string' ? lexer.lex(it) : it);
    };
    exports.tokens = lexer.lex;
    exports.lex = function(it){
      return lexer.lex(it, {
        raw: true
      });
    };
    exports.run = function(code, options){
      var output, ref$;
      output = exports.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$));
      return Function(toString$.call(output).slice(8, -1) === 'String'
        ? output
        : output.code)();
    };
    exports.tokens.rewrite = lexer.rewrite;
    importAll$(exports.ast, parser.yy);
    if (require.extensions) {
      require('./node')(exports);
    } else {
      exports.require = require;
    }
    function import$(obj, src){
      var own = {}.hasOwnProperty;
      for (var key in src) if (own.call(src, key)) obj[key] = src[key];
      return obj;
    }
    function importAll$(obj, src){
      for (var key in src) obj[key] = src[key];
      return obj;
    }
    }).call(this,require("buffer").Buffer)
    },{"./ast":1,"./lexer":3,"./node":4,"./parser":5,"buffer":9,"path":13,"source-map":31}],3:[function(require,module,exports){
    // Generated by blackpard 1.5.0
    var string, TABS, unlines, enlines, enslash, reslash, camelize, deheregex, character, KEYWORDS_SHARED, KEYWORDS_UNUSED, JS_KEYWORDS, LS_KEYWORDS, ID, SYMBOL, SPACE, MULTIDENT, SIMPLESTR, JSTOKEN, BSTOKEN, NUMBER, NUMBER_OMIT, REGEX, HEREGEX_OMIT, LASTDENT, INLINEDENT, NONASCII, OPENERS, CLOSERS, INVERSES, i, o, c, CHAIN, ARG, BLOCK_USERS, slice$ = [].slice, arrayFrom$ = Array.from || function(x){return slice$.call(x);};
    exports.lex = function(code, options){
      return clone$(exports).tokenize(code || '', options || {});
    };
    exports.rewrite = function(it){
      var ref$;
      it || (it = this.tokens);
      firstPass(it);
      addImplicitIndentation(it);
      rewriteBlockless(it);
      addImplicitParentheses(it);
      addImplicitBraces(it);
      expandLiterals(it);
      if (((ref$ = it[0]) != null ? ref$[0] : void 8) === 'NEWLINE') {
        it.shift();
      }
      return it;
    };
    exports.tokenize = function(code, o){
      var i, prevIndex, c, charsConsumed, that;
      this.inter || (code = code.replace(/[\r\u2028\u2029\uFEFF]/g, ''));
      code = '\n' + code;
      this.tokens = [this.last = ['NEWLINE', '\n', 0, 0]];
      this.line = ~-o.line;
      this.column = o.column || 0;
      this.dents = [];
      this.closes = [];
      this.parens = [];
      this.flags = [];
      i = 0;
      prevIndex = i;
      this.charsCounted = 0;
      this.isAtPrefix = true;
      while (c = code.charAt(i)) {
        charsConsumed = i - prevIndex;
        prevIndex = i;
        if (this.charsCounted > charsConsumed) {
          throw new Error('Location information out-of-sync in lexer');
        }
        this.column += charsConsumed - this.charsCounted;
        this.charsCounted = 0;
        switch (c) {
        case ' ':
          i += this.doSpace(code, i);
          break;
        case '\n':
          i += this.doLine(code, i);
          break;
        case '\\':
          i += this.doBackslash(code, i);
          break;
        case '\'':
        case '"':
          i += this.doString(code, i, c);
          break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          i += this.doNumber(code, i);
          break;
        case '/':
          switch (code.charAt(i + 1)) {
          case '*':
            i += this.doComment(code, i);
            break;
          case '/':
            i += this.doHeregex(code, i);
            break;
          default:
            i += this.doRegex(code, i) || this.doLiteral(code, i);
          }
          break;
        case '`':
          if ('`' === code.charAt(i + 1)) {
            i += this.doJS(code, i);
          } else {
            i += this.doLiteral(code, i);
          }
          break;
        default:
          i += this.doID(code, i) || this.doLiteral(code, i) || this.doSpace(code, i);
        }
      }
      this.dedent(this.dent);
      if (that = this.closes.pop()) {
        this.carp("missing `" + that + "`");
      }
      if (this.inter) {
        this.rest == null && this.carp('unterminated interpolation');
      } else {
        this.last.spaced = true;
        this.newline();
      }
      o.raw || this.rewrite();
      return this.tokens;
    };
    exports.dent = 0;
    exports.identifiers = {};
    exports.reset = function(){
      this.dent = 0;
      this.identifiers = {};
    };
    exports.hasOwn = Object.prototype.hasOwnProperty;
    exports.checkConsistency = function(camel, id){
      if (this.hasOwn.call(this.identifiers, camel) && this.identifiers[camel] !== id) {
        throw new ReferenceError("Inconsistent use of " + camel + " as " + id + " on line " + (-~this.line));
      } else {
        return this.identifiers[camel] = id;
      }
    };
    exports.doID = function(code, index){
      var regexMatch, input, id, e, last, ref$, tag, ref1$, that;
      input = (regexMatch = (ID.lastIndex = index, ID).exec(code))[0];
      if (!input) {
        return 0;
      }
      id = camelize(regexMatch[1]);
      if (/-/.test(regexMatch[1])) {
        this.checkConsistency(id, regexMatch[1]);
      }
      if (NONASCII.test(id)) {
        try {
          Function("var " + id);
        } catch (e$) {
          e = e$;
          this.carp("invalid identifier '" + id + "'");
        }
      }
      last = this.last;
      if (regexMatch[2] || last[0] === 'DOT' || this.adi()) {
        this.token('ID', in$(id, JS_KEYWORDS) ? (ref$ = Object(id), ref$.reserved = true, ref$) : id);
        if (regexMatch[2]) {
          this.token(':', ':');
        }
        return input.length;
      }
      switch (id) {
      case 'true':
      case 'false':
      case 'on':
      case 'off':
      case 'yes':
      case 'no':
      case 'null':
      case 'void':
      case 'arguments':
      case 'debugger':
        tag = 'LITERAL';
        break;
      case 'new':
      case 'do':
      case 'typeof':
      case 'delete':
        tag = 'UNARY';
        break;
      case 'yield':
      case 'await':
        tag = 'YIELD';
        break;
      case 'return':
      case 'throw':
        tag = 'HURL';
        break;
      case 'break':
      case 'continue':
        tag = 'JUMP';
        break;
      case 'this':
      case 'eval':
      case 'super':
        return this.token('LITERAL', id, true).length;
      case 'for':
        id = [];
        this.fset('for', true);
        this.fset('to', false);
        this.fset('by', true);
        break;
      case 'then':
        this.fset('for', false);
        this.fset('to', false);
        break;
      case 'catch':
      case 'function':
        id = '';
        break;
      case 'in':
      case 'of':
        if (this.fget('for')) {
          this.fset('for', false);
          if (id === 'in') {
            this.fset('by', true);
            id = '';
            if (last[0] === 'ID' && ((ref$ = (ref1$ = this.tokens)[ref1$.length - 2][0]) === ',' || ref$ === ']' || ref$ === '}')) {
              id = this.tokens.pop()[1];
              if ((ref$ = this.tokens)[ref$.length - 1][0] === ',') {
                this.tokens.pop();
              }
            }
          }
          break;
        }
        // fallthrough
      case 'instanceof':
        if (last[1] === '!') {
          id = this.tokens.pop()[1] + id;
        }
        tag = (ref$ = this.tokens)[ref$.length - 1][0] === '(' ? 'BIOPR' : 'RELATION';
        break;
      case 'not':
        if (last.alias && last[1] === '===') {
          return last[1] = '!==', 3;
        }
        tag = 'UNARY';
        id = '!';
        break;
      case 'and':
      case 'or':
      case 'xor':
      case 'is':
      case 'isnt':
        this.unline();
        tag = id === 'is' || id === 'isnt' ? 'COMPARE' : 'LOGIC';
        if (last[0] === '(') {
          tag = 'BIOP';
        }
        this.token(tag, (function(){
          switch (id) {
          case 'is':
            return '===';
          case 'isnt':
            return '!==';
          case 'or':
            return '||';
          case 'and':
            return '&&';
          case 'xor':
            return 'xor';
          }
        }()));
        this.last.alias = true;
        return id.length;
      case 'unless':
        tag = 'IF';
        break;
      case 'until':
        tag = 'WHILE';
        break;
      case 'import':
        if (last[0] === '(') {
          id = '<<<';
          tag = 'BIOP';
        } else {
          if (able(this.tokens)) {
            id = '<<<';
          } else {
            tag = 'DECL';
          }
        }
        break;
      case 'export':
      case 'const':
      case 'var':
        tag = 'DECL';
        break;
      case 'with':
        tag = (function(){
          switch (false) {
          case !able(this.tokens):
            return 'CLONEPORT';
          case last[0] !== '(':
            return 'BIOP';
          default:
            return 'WITH';
          }
        }.call(this));
        break;
      case 'when':
        tag = 'CASE';
        // fallthrough
      case 'case':
        if (this.doCase()) {
          return input.length;
        }
        break;
      case 'match':
        tag = 'SWITCH';
        break;
      case 'loop':
        this.token('WHILE', id);
        this.token('LITERAL', 'true');
        return input.length;
      case 'let':
      case 'own':
        if (last[0] === 'FOR' && !in$(id, last[1])) {
          last[1].push(id);
          return 3;
        }
        // fallthrough
      default:
        if (in$(id, KEYWORDS_SHARED)) {
          break;
        }
        if (in$(id, KEYWORDS_UNUSED)) {
          this.carp("reserved word '" + id + "'");
        }
        if (!last[1] && ((ref$ = last[0]) === 'FUNCTION' || ref$ === 'GENERATOR' || ref$ === 'LABEL')) {
          last[1] = id;
          last.spaced = false;
          return input.length;
        }
        tag = 'ID';
        switch (id) {
        case 'otherwise':
          if ((ref$ = last[0]) === 'CASE' || ref$ === '|') {
            last[0] = 'DEFAULT';
            return id.length;
          }
          break;
        case 'all':
          if (that = last[1] === '<<<' && '<' || last[1] === 'import' && 'All') {
            last[1] += that;
            return 3;
          }
          break;
        case 'from':
          if (last[1] === 'yield') {
            last[1] += 'from';
            return 4;
          }
          this.forange() && (tag = 'FROM');
          break;
        case 'to':
        case 'til':
          this.forange() && this.tokens.push(['FROM', '', this.line, this.column], ['STRNUM', '0', this.line, this.column]);
          if (this.fget('from')) {
            this.fset('from', false);
            this.fset('by', true);
            tag = 'TO';
          } else if (!last.callable && last[0] === 'STRNUM' && (ref$ = this.tokens)[ref$.length - 2][0] === '[') {
            last[0] = 'RANGE';
            last.op = id;
            return id.length;
          } else if (in$(']', this.closes)) {
            this.token('TO', id);
            return id.length;
          }
          break;
        case 'by':
          if (last[0] === 'STRNUM' && (ref$ = this.tokens)[ref$.length - 2][0] === 'RANGE' && (ref$ = this.tokens)[ref$.length - 3][0] === '[') {
            tag = 'RANGE_BY';
          } else if (in$(']', this.closes)) {
            tag = 'BY';
          } else if (this.fget('by') && last[0] !== 'FOR') {
            tag = 'BY';
            this.fset('by', false);
          }
          break;
        case 'ever':
          if (last[0] === 'FOR') {
            this.fset('for', false);
            last[0] = 'WHILE';
            tag = 'LITERAL';
            id = 'true';
          }
        }
      }
      tag || (tag = regexMatch[1].toUpperCase());
      if ((tag === 'COMPARE' || tag === 'LOGIC' || tag === 'RELATION') && last[0] === '(') {
        tag = tag === 'RELATION' ? 'BIOPR' : 'BIOP';
      }
      if (tag === 'THEN' || tag === 'IF' || tag === 'WHILE') {
        this.fset('for', false);
        this.fset('by', false);
      }
      if (tag === 'RELATION' || tag === 'THEN' || tag === 'ELSE' || tag === 'CASE' || tag === 'DEFAULT' || tag === 'CATCH' || tag === 'FINALLY' || tag === 'IN' || tag === 'OF' || tag === 'FROM' || tag === 'TO' || tag === 'BY' || tag === 'EXTENDS' || tag === 'IMPLEMENTS' || tag === 'WHERE') {
        this.unline();
      }
      this.token(tag, id);
      return input.length;
    };
    exports.doNumber = function(code, lastIndex){
      var input, regexMatch, last, radix, num, rnum, bound, ref$;
      NUMBER.lastIndex = lastIndex;
      if (!(input = (regexMatch = NUMBER.exec(code))[0])) {
        return 0;
      }
      last = this.last;
      if (regexMatch[5] && (last[0] === 'DOT' || this.adi())) {
        this.token('STRNUM', regexMatch[4].replace(NUMBER_OMIT, ''));
        return regexMatch[4].length;
      }
      if (radix = regexMatch[1]) {
        num = parseInt(rnum = regexMatch[2].replace(NUMBER_OMIT, ''), radix);
        bound = false;
        if (radix > 36 || radix < 2) {
          if (/[0-9]/.exec(rnum)) {
            this.carp("invalid number base " + radix + " (with number " + rnum + "),base must be from 2 to 36");
          } else {
            bound = true;
          }
        }
        if (isNaN(num) || num === parseInt(rnum.slice(0, -1), radix)) {
          this.strnum(regexMatch[1]);
          this.token('DOT', '.~');
          this.token('ID', regexMatch[2]);
          return input.length;
        }
        num += '';
      } else {
        num = (regexMatch[3] || input).replace(NUMBER_OMIT, '');
        if (regexMatch[3] && num.charAt() === '0' && ((ref$ = num.charAt(1)) !== '' && ref$ !== '.')) {
          this.carp("deprecated octal literal " + regexMatch[4]);
        }
      }
      if (!last.spaced && last[0] === '+-') {
        last[0] = 'STRNUM';
        last[1] += num;
        return input.length;
      }
      this.strnum(num);
      return input.length;
    };
    exports.doString = function(code, index, q){
      var parts, str;
      if (q === code.charAt(index + 1)) {
        return q === code.charAt(index + 2)
          ? this.doHeredoc(code, index, q)
          : (this.strnum(q + q), 2);
      }
      if (q === '"') {
        parts = this.interpolate(code, index, q);
        this.addInterpolated(parts, unlines);
        return parts.size;
      }
      str = (SIMPLESTR.lastIndex = index, SIMPLESTR).exec(code)[0] || this.carp('unterminated string');
      this.strnum(unlines(this.string(q, str.slice(1, -1))));
      return this.countLines(str).length;
    };
    exports.doHeredoc = function(code, index, q){
      var end, raw, doc, parts, tabs, i$, len$, i, t;
      if (q === '\'') {
        ~(end = code.indexOf(q + q + q, index + 3)) || this.carp('unterminated heredoc');
        raw = code.slice(index + 3, end);
        doc = raw.replace(LASTDENT, '');
        this.strnum(enlines(this.string(q, lchomp(detab(doc, heretabs(doc))))));
        return this.countLines(raw).length + 6;
      }
      parts = this.interpolate(code, index, q + q + q);
      tabs = heretabs(code.slice(index + 3, index + parts.size - 3).replace(LASTDENT, ''));
      for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {
        i = i$;
        t = parts[i$];
        if (t[0] === 'S') {
          if (i + 1 === parts.length) {
            t[1] = t[1].replace(LASTDENT, '');
          }
          t[1] = detab(t[1], tabs);
          if (i === 0) {
            t[1] = lchomp(t[1]);
          }
        }
      }
      this.addInterpolated(parts, enlines);
      return parts.size;
    };
    exports.doComment = function(code, index){
      var comment, end, ref$;
      comment = ~(end = code.indexOf('*/', index + 2))
        ? code.slice(index, end + 2)
        : code.slice(index) + '*/';
      if ((ref$ = this.last[0]) === 'NEWLINE' || ref$ === 'INDENT' || ref$ === 'THEN') {
        this.token('COMMENT', detab(comment, this.dent));
        this.token('NEWLINE', '\n');
      }
      return this.countLines(comment).length;
    };
    exports.doJS = function(code, lastIndex){
      var js, ref$;
      JSTOKEN.lastIndex = lastIndex;
      js = JSTOKEN.exec(code)[0] || this.carp('unterminated JS literal');
      this.token('LITERAL', (ref$ = Object(detab(js.slice(2, -2), this.dent)), ref$.js = true, ref$), true);
      return this.countLines(js).length;
    };
    exports.doRegex = function(code, index){
      var divisible, ref$, input, body, flag;
      if (divisible = able(this.tokens) || this.last[0] === 'CREMENT') {
        if (!this.last.spaced || ((ref$ = code.charAt(index + 1)) === ' ' || ref$ === '=')) {
          return 0;
        }
      }
      ref$ = (REGEX.lastIndex = index, REGEX).exec(code), input = ref$[0], body = ref$[1], flag = ref$[2];
      if (input) {
        this.regex(body, flag);
      } else if (!divisible && this.last[0] !== '(') {
        this.carp('unterminated regex');
      }
      return input.length;
    };
    exports.doHeregex = function(code, index){
      var tokens, last, parts, rest, flag, i$, i, t, dynaflag, len$, val, one;
      tokens = this.tokens, last = this.last;
      parts = this.interpolate(code, index, '//');
      rest = code.slice(index + parts.size);
      flag = this.validate(/^(?:[gimy]{1,4}|[?$]?)/.exec(rest)[0]);
      if (parts[1]) {
        if (flag === '$') {
          this.adi();
          this.token('(', '"');
        } else {
          tokens.push(['ID', 'RegExp', last[2], last[3]], ['CALL(', '', last[2], last[3]]);
          if (flag === '?') {
            for (i$ = parts.length - 1; i$ >= 0; --i$) {
              i = i$;
              t = parts[i$];
              if (t[0] === 'TOKENS') {
                dynaflag = parts.splice(i, 1)[0][1];
                break;
              }
            }
          }
        }
        for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {
          i = i$;
          t = parts[i$];
          if (t[0] === 'TOKENS') {
            tokens.push.apply(tokens, t[1]);
          } else {
            val = deheregex(t[1]);
            if (one && !val) {
              continue;
            }
            one = tokens.push((t[0] = 'STRNUM', t[1] = this.string('\'', enslash(val)), t));
          }
          tokens.push(['+-', '+', tokens[tokens.length - 1][2], tokens[tokens.length - 1][3]]);
        }
        --tokens.length;
        if (dynaflag || flag >= 'g') {
          this.token(',', ',');
          if (dynaflag) {
            tokens.push.apply(tokens, dynaflag);
          } else {
            this.token('STRNUM', "'" + flag + "'");
          }
        }
        this.token(flag === '$' ? ')' : ')CALL', '');
      } else {
        this.regex(reslash(deheregex(parts[0][1])), flag);
      }
      return parts.size + flag.length;
    };
    exports.doBackslash = function(code, lastIndex){
      var ref$, input, word;
      BSTOKEN.lastIndex = lastIndex;
      ref$ = BSTOKEN.exec(code), input = ref$[0], word = ref$[1];
      if (word) {
        this.strnum(this.string('\'', word));
      } else {
        this.countLines(input);
      }
      return input.length;
    };
    exports.doLine = function(code, index){
      var ref$, input, tabs, length, last, that, delta, tag, val;
      ref$ = (MULTIDENT.lastIndex = index, MULTIDENT).exec(code), input = ref$[0], tabs = ref$[1];
      length = this.countLines(input).length;
      last = this.last;
      last.eol = true;
      last.spaced = true;
      if (index + length >= code.length) {
        return length;
      }
      if (that = tabs && (this.emender || (this.emender = RegExp('[^' + tabs.charAt() + ']'))).exec(tabs)) {
        this.carp("contaminated indent " + escape(that));
      }
      if (0 > (delta = tabs.length - this.dent)) {
        this.dedent(-delta);
        this.newline();
      } else {
        tag = last[0], val = last[1];
        if (tag === 'ASSIGN' && ((ref$ = val + '') !== '=' && ref$ !== ':=' && ref$ !== '+=') || tag === 'CREMENT' && val === '++' && (ref$ = this.tokens)[ref$.length - 2].spaced || (tag === '+-' || tag === 'PIPE' || tag === 'BACKPIPE' || tag === 'COMPOSE' || tag === 'DOT' || tag === 'LOGIC' || tag === 'MATH' || tag === 'COMPARE' || tag === 'RELATION' || tag === 'SHIFT' || tag === 'IN' || tag === 'OF' || tag === 'TO' || tag === 'BY' || tag === 'FROM' || tag === 'EXTENDS' || tag === 'IMPLEMENTS')) {
          return length;
        }
        if (delta) {
          this.indent(delta);
        } else {
          this.newline();
        }
      }
      this.fset('for', false);
      this.fset('by', false);
      return length;
    };
    exports.doSpace = function(code, lastIndex){
      var input;
      SPACE.lastIndex = lastIndex;
      if (input = SPACE.exec(code)[0]) {
        this.last.spaced = true;
      }
      return input.length;
    };
    exports.doCase = function(){
      var ref$, ref1$;
      this.fset('for', false);
      if (((ref$ = this.last[0]) === 'ASSIGN' || ref$ === '->' || ref$ === ':') || (this.last[0] === 'INDENT' && ((ref$ = (ref1$ = this.tokens)[ref1$.length - 2][0]) === 'ASSIGN' || ref$ === '->' || ref$ === ':'))) {
        this.token('SWITCH', 'switch');
        return this.token('CASE', 'case');
      }
    };
    exports.doLiteral = function(code, index){
      var sym, tag, val, ref$, that;
      if (!(sym = (SYMBOL.lastIndex = index, SYMBOL).exec(code)[0])) {
        return 0;
      }
      switch (tag = val = sym) {
      case '|':
        tag = 'CASE';
        if (this.doCase()) {
          return sym.length;
        }
        break;
      case '|>':
        tag = 'PIPE';
        break;
      case '`':
        tag = 'BACKTICK';
        break;
      case '<<':
      case '>>':
        tag = 'COMPOSE';
        break;
      case '<|':
        tag = 'BACKPIPE';
        break;
      case '+':
      case '-':
        tag = '+-';
        break;
      case '&&':
      case '||':
        tag = 'LOGIC';
        break;
      case '.&.':
      case '.|.':
      case '.^.':
        tag = 'BITWISE';
        break;
      case '^^':
        tag = 'CLONE';
        break;
      case '**':
      case '^':
        tag = 'POWER';
        break;
      case '?':
        if (this.last[0] === '(') {
          this.token('PARAM(', '(');
          this.token(')PARAM', ')');
          this.token('->', '->');
          this.token('ID', 'it');
        } else {
          if (this.last.spaced) {
            tag = 'LOGIC';
          }
        }
        break;
      case '/':
      case '%':
      case '%%':
        tag = 'MATH';
        break;
      case '++':
      case '--':
        tag = 'CREMENT';
        break;
      case '<<<':
      case '<<<<':
        tag = 'IMPORT';
        break;
      case ';':
        tag = 'NEWLINE';
        this.fset('by', false);
        break;
      case '..':
        this.token('LITERAL', '..', true);
        return 2;
      case '.':
        if (this.last[1] === '?') {
          this.last[0] = '?';
        }
        tag = 'DOT';
        break;
      case ',':
        switch (this.last[0]) {
        case ',':
        case '[':
        case '(':
        case 'CALL(':
          this.token('LITERAL', 'void');
          break;
        case 'FOR':
        case 'OWN':
          this.token('ID', '');
        }
        break;
      case '!=':
      case '~=':
        if (!(able(this.tokens) || ((ref$ = this.last[0]) === '(' || ref$ === 'CREMENT'))) {
          this.tokens.push(val === '!='
            ? ['UNARY', '!', this.line, this.column]
            : ['UNARY', '~', this.line, this.column], ['ASSIGN', '=', this.line, this.column]);
          return 2;
        }
        // fallthrough
      case '!~=':
      case '==':
        val = (function(){
          switch (val) {
          case '~=':
            return '==';
          case '!~=':
            return '!=';
          case '==':
            return '===';
          case '!=':
            return '!==';
          }
        }());
        tag = 'COMPARE';
        break;
      case '===':
      case '!==':
        val += '=';
        // fallthrough
      case '<':
      case '>':
      case '<=':
      case '>=':
      case '<==':
      case '>==':
      case '>>=':
      case '<<=':
        tag = 'COMPARE';
        break;
      case '.<<.':
      case '.>>.':
      case '.>>>.':
      case '<?':
      case '>?':
        tag = 'SHIFT';
        break;
      case '(':
        if (!(((ref$ = this.last[0]) === 'FUNCTION' || ref$ === 'GENERATOR' || ref$ === 'LET') || this.able(true) || this.last[1] === '.@')) {
          this.token('(', '(');
          this.closes.push(')');
          this.parens.push(this.last);
          return 1;
        }
        tag = 'CALL(';
        this.closes.push(')CALL');
        break;
      case '[':
      case '{':
        this.adi();
        this.closes.push(']}'.charAt(val === '{'));
        break;
      case '}':
        if (this.inter && val !== (ref$ = this.closes)[ref$.length - 1]) {
          this.rest = code.slice(index + 1);
          return 9e9;
        }
        // fallthrough
      case ']':
      case ')':
        if (tag === ')' && ((ref$ = this.last[0]) === '+-' || ref$ === 'COMPARE' || ref$ === 'LOGIC' || ref$ === 'MATH' || ref$ === 'POWER' || ref$ === 'SHIFT' || ref$ === 'BITWISE' || ref$ === 'CONCAT' || ref$ === 'COMPOSE' || ref$ === 'RELATION' || ref$ === 'PIPE' || ref$ === 'BACKPIPE' || ref$ === 'IMPORT' || ref$ === 'CLONEPORT' || ref$ === 'ASSIGN')) {
          (ref$ = this.tokens)[ref$.length - 1][0] = (function(){
            switch (this.last[0]) {
            case 'RELATION':
              return 'BIOPR';
            case 'PIPE':
              this.parameters(false, -1);
              return 'BIOPP';
            default:
              return 'BIOP';
            }
          }.call(this));
        }
        if (')' === (tag = val = this.pair(val))) {
          this.lpar = this.parens.pop();
        }
        break;
      case '=':
      case ':':
        if (val === ':') {
          switch (this.last[0]) {
          case 'ID':
          case 'STRNUM':
          case ')':
            break;
          case '...':
            this.last[0] = 'STRNUM';
            break;
          default:
            tag = 'LABEL';
            val = '';
          }
          this.token(tag, val);
          return sym.length;
        }
        // fallthrough
      case ':=':
      case '+=':
      case '-=':
      case '*=':
      case '/=':
      case '%=':
      case '%%=':
      case '<?=':
      case '>?=':
      case '**=':
      case '^=':
      case '.&.=':
      case '.|.=':
      case '.^.=':
      case '.<<.=':
      case '.>>.=':
      case '.>>>.=':
      case '++=':
      case '|>=':
        if (this.last[1] === '.' || this.last[0] === '?' && this.adi()) {
          this.last[1] += val;
          return val.length;
        }
        if (this.last[0] === 'LOGIC') {
          (val = Object(val)).logic = this.tokens.pop()[1];
        } else if ((val === '+=' || val === '-=') && !able(this.tokens) && ((ref$ = this.last[0]) !== '+-' && ref$ !== 'UNARY' && ref$ !== 'LABEL')) {
          this.token('UNARY', val.charAt());
          val = '=';
        }
        tag = 'ASSIGN';
        break;
      case '::=':
        this.token('DOT', '.');
        this.token('ID', 'prototype');
        this.token('IMPORT', '<<');
        return sym.length;
      case '*':
        if (this.last[0] === 'FUNCTION') {
          this.last[0] = 'GENERATOR';
          return sym.length;
        }
        if (that = ((ref$ = this.last[0]) === 'NEWLINE' || ref$ === 'INDENT' || ref$ === 'THEN' || ref$ === '=>') && (INLINEDENT.lastIndex = index + 1, INLINEDENT).exec(code)[0].length) {
          this.tokens.push(['LITERAL', 'void', this.line, this.column], ['ASSIGN', '=', this.line, this.column]);
          this.indent(index + that - 1 - this.dent - code.lastIndexOf('\n', index - 1));
          return that;
        }
        tag = able(this.tokens) || this.last[0] === 'CREMENT' && able(this.tokens, this.tokens.length - 1) || this.last[0] === '(' ? 'MATH' : 'STRNUM';
        break;
      case '@':
        this.adi();
        if (this.last[0] === 'DOT' && this.last[1] === '.' && (ref$ = this.tokens)[ref$.length - 2][0] === 'ID' && (ref$ = this.tokens)[ref$.length - 2][1] === 'constructor') {
          this.tokens.pop();
          this.tokens.pop();
          this.token('LITERAL', 'this', true);
          this.adi();
          this.token('ID', 'constructor', true);
        } else {
          this.token('LITERAL', 'this', true);
        }
        return 1;
      case '@@':
        this.adi();
        this.token('ID', 'constructor', true);
        return 2;
      case '&':
        this.token('LITERAL', 'arguments');
        return 1;
      case '!':
        switch (false) {
        default:
          if (!this.last.spaced) {
            if (this.last[1] === 'require') {
              this.last[0] = 'REQUIRE';
              this.last[1] = 'require!';
            } else if (able(this.tokens, null, true)) {
              this.token('CALL(', '!');
              this.token(')CALL', ')');
            } else if (this.last[1] === 'typeof') {
              this.last[1] = 'classof';
            } else if (this.last[1] === 'delete') {
              this.last[1] = 'jsdelete';
            } else {
              break;
            }
            return 1;
          }
        }
        tag = 'UNARY';
        break;
      case '|':
        tag = 'BITWISE';
        break;
      case '~':
        if (this.dotcat(val)) {
          return 1;
        }
        tag = 'UNARY';
        break;
      case '::':
        this.adi();
        val = 'prototype';
        tag = 'ID';
        break;
      case '=>':
        this.unline();
        this.fset('for', false);
        tag = 'THEN';
        break;
      default:
        if (/^!?(?:--?|~~?)>>?\*?$/.test(val)) {
          this.parameters(tag = '->');
        } else if (/^\*?<(?:--?|~~?)!?$/.test(val)) {
          this.parameters(tag = '<-');
        } else {
          switch (val.charAt(0)) {
          case '(':
            this.token('CALL(', '(');
            tag = ')CALL';
            val = ')';
            break;
          case '<':
            if (val.length < 4) {
              this.carp('unterminated words');
            }
            this.token('WORDS', val.slice(2, -2), this.adi());
            return this.countLines(val).length;
          }
        }
      }
      if ((tag === '+-' || tag === 'COMPARE' || tag === 'LOGIC' || tag === 'MATH' || tag === 'POWER' || tag === 'SHIFT' || tag === 'BITWISE' || tag === 'CONCAT' || tag === 'RELATION' || tag === 'PIPE' || tag === 'BACKPIPE' || tag === 'COMPOSE' || tag === 'IMPORT') && this.last[0] === '(') {
        tag = tag === 'BACKPIPE' ? 'BIOPBP' : 'BIOP';
      }
      if (tag === ',' || tag === 'CASE' || tag === 'PIPE' || tag === 'BACKPIPE' || tag === 'COMPOSE' || tag === 'DOT' || tag === 'LOGIC' || tag === 'COMPARE' || tag === 'MATH' || tag === 'POWER' || tag === 'IMPORT' || tag === 'SHIFT' || tag === 'BITWISE') {
        this.unline();
      }
      this.token(tag, val);
      return sym.length;
    };
    exports.token = function(tag, value, callable){
      this.tokens.push(this.last = [tag, value, this.line, this.column]);
      if (callable) {
        this.last.callable = true;
      }
      return value;
    };
    exports.indent = function(delta){
      this.dent += delta;
      this.dents.push(this.token('INDENT', delta));
      this.closes.push('DEDENT');
    };
    exports.dedent = function(debt){
      var dent;
      this.dent -= debt;
      while (debt > 0 && (dent = this.dents.pop())) {
        if (debt < dent && !this.inter) {
          this.carp("unmatched dedent (" + debt + " for " + dent + ")");
        }
        this.pair('DEDENT');
        debt -= typeof dent === 'number' ? this.token('DEDENT', dent) : dent;
      }
    };
    exports.newline = function(){
      var ref$;
      if (!(this.last[0] === 'NEWLINE' && this.last[1] === '\n')) {
        this.tokens.push(this.last = (ref$ = ['NEWLINE', '\n', this.line, this.column], ref$.spaced = true, ref$));
      }
    };
    exports.unline = function(){
      var ref$;
      if (!this.tokens[1]) {
        return;
      }
      switch (this.last[0]) {
      case 'INDENT':
        (ref$ = this.dents)[ref$.length - 1] += '';
        // fallthrough
      case 'NEWLINE':
        this.tokens.length--;
      }
    };
    exports.parameters = function(arrow, offset){
      var i$, ref$, i, t, ref1$;
      if (this.last[0] === ')' && ')' === this.last[1]) {
        this.lpar[0] = 'PARAM(';
        this.last[0] = ')PARAM';
        return;
      }
      if (arrow === '->') {
        this.token('PARAM(', '');
      } else {
        for (i$ = (ref$ = this.tokens).length - 1; i$ >= 0; --i$) {
          i = i$;
          t = ref$[i$];
          if ((ref1$ = t[0]) === 'NEWLINE' || ref1$ === 'INDENT' || ref1$ === 'THEN' || ref1$ === '=>' || ref1$ === '(') {
            break;
          }
        }
        this.tokens.splice(i + 1, 0, ['PARAM(', '', t[2], t[3]]);
      }
      if (offset) {
        this.tokens.splice(this.tokens.length + offset, 0, [')PARAM', '', t[2], t[3]]);
      } else {
        this.token(')PARAM', '');
      }
    };
    exports.interpolate = function(str, idx, end){
      var parts, end0, pos, i, ref$, oldLine, oldColumn, ch, c1, id, stringified, length, tag, e, delta, nested, clone, ref1$;
      parts = [];
      end0 = end.charAt(0);
      pos = 0;
      i = -1;
      str = str.slice(idx + end.length);
      ref$ = [this.line, this.column], oldLine = ref$[0], oldColumn = ref$[1];
      this.countLines(end);
      while (ch = str.charAt(++i)) {
        switch (ch) {
        case end0:
          if (end !== str.slice(i, i + end.length)) {
            continue;
          }
          parts.push(['S', this.countLines(str.slice(0, i)), oldLine, oldColumn]);
          this.countLines(end);
          return parts.size = pos + i + end.length * 2, parts;
        case '#':
          c1 = str.charAt(i + 1);
          id = c1 === '@' && c1 || (ID.lastIndex = i + 1, ID).exec(str)[1];
          if (!(id || c1 === '{')) {
            continue;
          }
          break;
        case '\\':
          ++i;
          // fallthrough
        default:
          continue;
        }
        if (i || nested && !stringified) {
          stringified = parts.push(['S', this.countLines(str.slice(0, i)), oldLine, oldColumn]);
          ref$ = [this.line, this.column], oldLine = ref$[0], oldColumn = ref$[1];
        }
        if (id) {
          length = id.length;
          if (id === '@') {
            id = 'this';
          }
          if (id === 'this') {
            tag = 'LITERAL';
          } else {
            id = camelize(id);
            try {
              Function("'use strict'; var " + id);
            } catch (e$) {
              e = e$;
              this.carp("invalid variable interpolation '" + id + "'");
            }
            tag = 'ID';
          }
          str = str.slice(delta = i + 1 + length);
          parts.push(['TOKENS', nested = [[tag, id, this.line, this.column]]]);
        } else {
          clone = (ref$ = clone$(exports), ref$.inter = true, ref$.emender = this.emender, ref$);
          nested = clone.tokenize(str.slice(i + 2), {
            line: this.line,
            column: this.column + 2,
            raw: true
          });
          delta = str.length - clone.rest.length;
          this.countLines(str.slice(i, delta));
          str = clone.rest;
          while (((ref$ = nested[0]) != null ? ref$[0] : void 8) === 'NEWLINE') {
            nested.shift();
          }
          if (nested.length) {
            nested.unshift(['(', '(', oldLine, oldColumn]);
            nested.push([')', ')', this.line, this.column - 1]);
            parts.push(['TOKENS', nested]);
          }
          ref1$ = [this.line, this.column], oldLine = ref1$[0], oldColumn = ref1$[1];
        }
        pos += delta;
        i = -1;
      }
      this.carp("missing `" + end + "`");
    };
    exports.addInterpolated = function(parts, nlines){
      var tokens, last, ref$, left, right, joint, callable, i$, len$, i, t;
      if (!parts[1]) {
        return this.strnum(nlines(this.string('"', parts[0][1])));
      }
      tokens = this.tokens, last = this.last;
      ref$ = !last.spaced && last[1] === '%'
        ? (--tokens.length, this.last = last = tokens[tokens.length - 1], ['[', ']', [',', ',']])
        : ['(', ')', ['+-', '+']], left = ref$[0], right = ref$[1], joint = ref$[2];
      callable = this.adi();
      tokens.push([left, '"', last[2], last[3]]);
      for (i$ = 0, len$ = parts.length; i$ < len$; ++i$) {
        i = i$;
        t = parts[i$];
        if (t[0] === 'TOKENS') {
          tokens.push.apply(tokens, t[1]);
        } else {
          if (i > 1 && !t[1]) {
            continue;
          }
          tokens.push(['STRNUM', nlines(this.string('"', t[1])), t[2], t[3]]);
        }
        tokens.push(joint.concat(tokens[tokens.length - 1][2], tokens[tokens.length - 1][3]));
      }
      --tokens.length;
      this.token(right, '', callable);
    };
    exports.strnum = function(it){
      this.token('STRNUM', it, this.adi() || this.last[0] === 'DOT');
    };
    exports.regex = function(body, flag){
      var e;
      try {
        RegExp(body);
      } catch (e$) {
        e = e$;
        this.carp(e.message);
      }
      if (flag === '$') {
        return this.strnum(this.string('\'', enslash(body)));
      }
      return this.token('LITERAL', "/" + (body || '(?:)') + "/" + this.validate(flag));
    };
    exports.adi = function(){
      if (this.last.spaced) {
        return;
      }
      if (!able(this.tokens)) {
        return;
      }
      return this.token('DOT', '.');
    };
    exports.dotcat = function(it){
      if (this.last[1] === '.' || this.adi()) {
        return this.last[1] += it;
      }
    };
    exports.pair = function(it){
      var wanted, ref$;
      if (!(it === (wanted = (ref$ = this.closes)[ref$.length - 1]) || ')CALL' === wanted && it === ')')) {
        if ('DEDENT' !== wanted) {
          this.carp("unmatched `" + it + "`");
        }
        this.dedent((ref$ = this.dents)[ref$.length - 1]);
        return this.pair(it);
      }
      this.unline();
      this.fclear();
      return this.closes.pop();
    };
    exports.able = function(call){
      return !this.last.spaced && able(this.tokens, null, call);
    };
    exports.countLines = function(it){
      var pos;
      if (!this.isAtPrefix) {
        this.column += it.length;
      }
      while (pos = 1 + it.indexOf('\n', pos)) {
        if (!this.isAtPrefix) {
          this.column = 0;
        }
        this.column += it.length - pos;
        ++this.line;
        this.isAtPrefix = false;
      }
      this.charsCounted += it.length;
      return it;
    };
    exports.forange = function(){
      var ref$, ref1$, ref2$;
      if (((ref$ = (ref1$ = this.tokens)[ref1$.length - 2 - ((ref2$ = this.last[0]) === 'NEWLINE' || ref2$ === 'INDENT')]) != null ? ref$[0] : void 8) === 'FOR' || this.last[0] === 'FOR') {
        this.fset('for', false);
        this.fset('from', true);
        return true;
      } else {
        return false;
      }
    };
    exports.validate = function(flag){
      var that;
      if (that = flag && /(.).*\1/.exec(flag)) {
        this.carp("duplicate regex flag `" + that[1] + "`");
      }
      return flag;
    };
    exports.fget = function(key){
      var ref$;
      return (ref$ = this.flags[this.closes.length]) != null ? ref$[key] : void 8;
    };
    exports.fset = function(key, val){
      var ref$, key$;
      ((ref$ = this.flags)[key$ = this.closes.length] || (ref$[key$] = {}))[key] = val;
    };
    exports.fclear = function(){
      this.flags.splice(this.closes.length);
    };
    exports.carp = function(it){
      carp(it, this.line);
    };
    exports.string = function(q, body){
      return string(q, body, this.line);
    };
    function carp(msg, lno){
      throw SyntaxError(msg + " on line " + (-~lno));
    }
    function able(tokens, i, call){
      var token, tag;
      i == null && (i = tokens.length);
      tag = (token = tokens[i - 1])[0];
      return (tag === 'ID' || tag === ']' || tag === '?') || (call
        ? token.callable || (tag === ')' || tag === ')CALL' || tag === 'BIOPBP') && token[1]
        : tag === '}' || tag === ')' || tag === ')CALL' || tag === 'STRNUM' || tag === 'LITERAL' || tag === 'WORDS');
    }
    string = (function(re){
      return function(q, body, lno){
        body = body.replace(re, function(it, oct, xu, rest){
          if (it === q || it === '\\') {
            return '\\' + it;
          }
          if (oct) {
            return '\\x' + (0x100 + parseInt(oct, 8)).toString(16).slice(1);
          }
          if (xu) {
            carp('malformed character escape sequence', lno);
          }
          if (!rest || q === rest) {
            return it;
          } else {
            return rest;
          }
        });
        return q + body + q;
      };
    }.call(this, /['"]|\\(?:([0-3]?[0-7]{2}|[1-7]|0(?=[89]))|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|([xu])|[\\0bfnrtv]|[^\n\S]|([\w\W]))?/g));
    function heretabs(doc){
      var dent, that, ref$;
      dent = 0 / 0;
      while (that = TABS.exec(doc)) {
        dent <= (ref$ = that[0].length - 1) || (dent = ref$);
      }
      return dent;
    }
    TABS = /\n(?!$)[^\n\S]*/mg;
    function detab(str, len){
      if (len) {
        return str.replace(detab[len] || (detab[len] = RegExp('\\n[^\\n\\S]{1,' + len + '}', 'g')), '\n');
      } else {
        return str;
      }
    }
    unlines = function(it){
      return it.replace(/\n[^\n\S]*/g, '');
    };
    enlines = function(it){
      return it.replace(/\n/g, '\\n');
    };
    enslash = function(it){
      return it.replace(/\\/g, '\\\\');
    };
    reslash = function(it){
      return it.replace(/(\\.)|\//g, function(){
        return arguments[1] || '\\/';
      });
    };
    camelize = function(it){
      return it.replace(/-[a-z]/ig, function(it){
        return it.charAt(1).toUpperCase();
      });
    };
    deheregex = function(it){
      return it.replace(/\s+(?:#.*)?|(\\[\s\S])/g, function(arg$, bs){
        bs || (bs = '');
        if ('\n' === bs.charAt(1)) {
          return '\\n';
        } else {
          return bs;
        }
      });
    };
    function lchomp(it){
      return it.slice(1 + it.lastIndexOf('\n', 0));
    }
    function decode(val, lno){
      if (!isNaN(val)) {
        return [+val];
      }
      val = val.length > 8
        ? 'ng'
        : Function('return ' + val)();
      val.length === 1 || carp('bad string in range', lno);
      return [val.charCodeAt(), true];
    }
    function uxxxx(it){
      return '"\\u' + ('000' + it.toString(16)).slice(-4) + '"';
    }
    character = typeof JSON == 'undefined' || JSON === null
      ? uxxxx
      : function(it){
        switch (it) {
        case 0x2028:
        case 0x2029:
          return uxxxx(it);
        default:
          return JSON.stringify(String.fromCharCode(it));
        }
      };
    function firstPass(tokens){
      var prev, i, token, tag, val, line, column, next, parens, i$, j, ts, ref$;
      prev = ['NEWLINE', '\n', 0];
      i = 0;
      while (token = tokens[++i]) {
        tag = token[0], val = token[1], line = token[2], column = token[3];
        switch (tag) {
        case 'ASSIGN':
          if (in$(prev[1], LS_KEYWORDS) && tokens[i - 2][0] !== 'DOT') {
            carp("cannot assign to reserved word '" + prev[1] + "'", line);
          }
          break;
        case 'DOT':
          switch (false) {
          case !(prev[0] === ']' && tokens[i - 2][0] === '[' && tokens[i - 3][0] === 'DOT'):
            tokens.splice(i - 2, 3);
            tokens[i - 3][1] = '[]';
            i -= 3;
            break;
          case !(prev[0] === '}' && tokens[i - 2][0] === '{' && tokens[i - 3][0] === 'DOT'):
            tokens.splice(i - 2, 3);
            tokens[i - 3][1] = '{}';
            i -= 3;
            break;
          case !(val === '.' && token.spaced && prev.spaced):
            tokens[i] = ['COMPOSE', '<<', line, column];
            break;
          default:
            next = tokens[i + 1];
            if (prev[0] === '(' && next[0] === ')') {
              tokens[i][0] = 'BIOP';
            } else if (prev[0] === '(') {
              tokens.splice(i, 0, ['PARAM(', '(', line, column], [')PARAM', ')', line, column], ['->', '~>', line, column], ['ID', 'it', line, column]);
            } else if (next[0] === ')') {
              tokens.splice(i + 1, 0, ['[', '[', line, column], ['ID', 'it', line, column], [']', ']', line, column]);
              parens = 1;
              LOOP: for (i$ = i + 1; i$ >= 0; --i$) {
                j = i$;
                switch (tokens[j][0]) {
                case ')':
                  ++parens;
                  break;
                case '(':
                  if (--parens === 0) {
                    tokens.splice(j + 1, 0, ['PARAM(', '(', line, column], ['ID', 'it', line, column], [')PARAM', ')', line, column], ['->', '~>', line, column]);
                    break LOOP;
                  }
                }
              }
            }
          }
          break;
        case 'CREMENT':
          if (!(val === '++' && (next = tokens[i + 1]))) {
            break;
          }
          ts = ['ID', 'LITERAL', 'STRNUM'];
          if (prev.spaced && token.spaced || !(prev.spaced || token.spaced) && in$(prev[0], ts) && in$(next[0], ts)) {
            tokens[i][0] = 'CONCAT';
          }
          if (prev[0] === '(' && next[0] === ')' || prev[0] === '(' && token.spaced || next[0] === ')' && prev.spaced) {
            tokens[i][0] = 'BIOP';
          }
          break;
        case 'ID':
          if (val !== 'async') {
            break;
          }
          next = tokens[i + 1];
          if ((ref$ = next[0]) === 'FUNCTION' || ref$ === 'GENERATOR') {
            token[0] = 'ASYNC';
          }
        }
        prev = token;
        continue;
      }
    }
    function rewriteBlockless(tokens){
      var i, token, tag;
      i = -1;
      while (token = tokens[++i]) {
        tag = token[0];
        if (tag === 'IF' || tag === 'CLASS' || tag === 'CATCH') {
          detectEnd(tokens, i + 1, ok, go);
        }
      }
      function ok(it){
        var ref$;
        return (ref$ = it[0]) === 'NEWLINE' || ref$ === 'INDENT';
      }
      function go(it, i){
        var lno, cno;
        if (tag === 'IF') {
          if (it[0] !== 'INDENT' || !it[1] && !it.then || in$(tokens[i - 1][0], BLOCK_USERS)) {
            token[0] = 'POST_IF';
          }
        } else if (it[0] !== 'INDENT') {
          tokens.splice(i, 0, ['INDENT', 0, lno = tokens[i - 1][2], cno = tokens[i - 1][3]], ['DEDENT', 0, lno, cno]);
        }
      }
    }
    function addImplicitIndentation(tokens){
      var i, token, tag, next, indent, dedent, ref$, ref1$, idx;
      i = 0;
      while (token = tokens[++i]) {
        tag = token[0];
        if (tag !== '->' && tag !== 'THEN' && tag !== 'ELSE' && tag !== 'DEFAULT' && tag !== 'TRY' && tag !== 'FINALLY' && tag !== 'DECL') {
          continue;
        }
        switch (next = tokens[i + 1][0]) {
        case 'IF':
          if (tag === 'ELSE') {
            continue;
          }
          break;
        case 'INDENT':
        case 'THEN':
          if (tag === 'THEN') {
            tokens.splice(i--, 1);
          }
          continue;
        }
        indent = ['INDENT', 0, token[2], token[3]];
        dedent = ['DEDENT', 0];
        if (tag === 'THEN') {
          (tokens[i] = indent).then = true;
        } else {
          tokens.splice(++i, 0, indent);
        }
        switch (false) {
        case tag !== 'DECL':
          break;
        case next !== 'DOT' && next !== '?' && next !== ',' && next !== 'PIPE' && next !== 'BACKPIPE':
          --i;
          // fallthrough
        case !((next === 'ID' || next === 'STRNUM' || next === 'LITERAL') && ',' === ((ref$ = tokens[i + 2]) != null ? ref$[0] : void 8)):
          go(0, i += 2);
          ++i;
          continue;
        case !((next === '(' || next === '[' || next === '{') && ',' === ((ref1$ = tokens[idx = 1 + indexOfPair(tokens, i + 1)]) != null ? ref1$[0] : void 8)):
          go(0, idx);
          ++i;
          continue;
        }
        detectEnd(tokens, i + 1, ok, go);
      }
      function ok(token, i){
        var t0, t;
        t0 = token[0];
        t = tag;
        if (tag === t0 || tag === 'THEN' && t0 === 'SWITCH') {
          tag = '';
        }
        switch (t0) {
        case 'NEWLINE':
          return token[1] !== ';';
        case 'DOT':
        case '?':
        case ',':
        case 'PIPE':
        case 'BACKPIPE':
          return tokens[i - 1].eol;
        case 'ELSE':
          return t === 'THEN';
        case 'CATCH':
          return t === 'TRY';
        case 'FINALLY':
          return t === 'TRY' || t === 'CATCH' || t === 'THEN';
        case 'CASE':
        case 'DEFAULT':
          return t === 'CASE' || t === 'THEN';
        }
      }
      function go(arg$, i){
        var prev;
        prev = tokens[i - 1];
        tokens.splice(prev[0] === ',' ? i - 1 : i, 0, (dedent[2] = prev[2], dedent[3] = prev[3], dedent));
      }
    }
    function addImplicitParentheses(tokens){
      var i, brackets, token, endi, ref$, tpair, tag, prev, ref1$, skipBlock, seenSwitch;
      i = 0;
      brackets = [];
      while (token = tokens[++i]) {
        if (token[1] === 'do' && tokens[i + 1][0] === 'INDENT') {
          endi = indexOfPair(tokens, i + 1);
          if (tokens[endi + 1][0] === 'NEWLINE' && ((ref$ = tokens[endi + 2]) != null ? ref$[0] : void 8) === 'WHILE') {
            token[0] = 'DO';
            tokens[endi + 2].done = true;
            tokens.splice(endi + 1, 1);
          } else {
            (token = tokens[1 + i])[0] = '(';
            (tpair = tokens[endi])[0] = ')';
            token.doblock = true;
            tokens.splice(i, 1);
          }
        }
        tag = token[0];
        prev = tokens[i - 1];
        tag === '[' && brackets.push(prev[0] === 'DOT');
        if (prev[0] === ']') {
          if (brackets.pop()) {
            prev.index = true;
          } else {
            continue;
          }
        }
        if (!(((ref1$ = prev[0]) === 'FUNCTION' || ref1$ === 'GENERATOR' || ref1$ === 'LET' || ref1$ === 'WHERE') || prev.spaced && able(tokens, i, true))) {
          continue;
        }
        if (token.doblock) {
          token[0] = 'CALL(';
          tpair[0] = ')CALL';
          continue;
        }
        if (!exp(token)) {
          continue;
        }
        if (tag === 'CREMENT') {
          if (token.spaced || !in$((ref1$ = tokens[i + 1]) != null ? ref1$[0] : void 8, CHAIN)) {
            continue;
          }
        }
        skipBlock = seenSwitch = false;
        tokens.splice(i++, 0, ['CALL(', '', token[2], token[3]]);
        detectEnd(tokens, i, ok, go);
      }
      function exp(token){
        var tag;
        tag = token[0];
        return in$(tag, ARG) || !token.spaced && (tag === '+-' || tag === 'CLONE');
      }
      function ok(token, i){
        var tag, ref$, pre;
        tag = token[0];
        if (tag === 'POST_IF' || tag === 'PIPE' || tag === 'BACKPIPE') {
          return true;
        }
        if (!skipBlock) {
          if (token.alias && ((ref$ = token[1]) === '&&' || ref$ === '||' || ref$ === 'xor') || (tag === 'TO' || tag === 'BY' || tag === 'IMPLEMENTS')) {
            return true;
          }
        }
        pre = tokens[i - 1];
        switch (tag) {
        case 'NEWLINE':
          return pre[0] !== ',';
        case 'DOT':
        case '?':
          return !skipBlock && (pre.spaced || pre[0] === 'DEDENT');
        case 'SWITCH':
          seenSwitch = true;
          // fallthrough
        case 'IF':
        case 'CLASS':
        case 'FUNCTION':
        case 'GENERATOR':
        case 'LET':
        case 'WITH':
        case 'CATCH':
          skipBlock = true;
          break;
        case 'CASE':
          if (seenSwitch) {
            skipBlock = true;
          } else {
            return true;
          }
          break;
        case 'INDENT':
          if (skipBlock) {
            return skipBlock = false;
          }
          return !in$(pre[0], BLOCK_USERS);
        case 'WHILE':
          if (token.done) {
            return false;
          }
          // fallthrough
        case 'FOR':
          skipBlock = true;
          return able(tokens, i) || pre[0] === 'CREMENT' || pre[0] === '...' && pre.spaced;
        }
        return false;
      }
      function go(token, i){
        tokens.splice(i, 0, [')CALL', '', tokens[i - 1][2], tokens[i - 1][3]]);
      }
    }
    function addImplicitBraces(tokens){
      var stack, i, token, tag, start, paren, index, pre, ref$, inline, ref1$;
      stack = [];
      i = 0;
      while (token = tokens[++i]) {
        if (':' !== (tag = token[0])) {
          switch (false) {
          case !in$(tag, CLOSERS):
            start = stack.pop();
            break;
          case !in$(tag, OPENERS):
            if (tag === 'INDENT' && tokens[i - 1][0] === '{') {
              tag = '{';
            }
            stack.push([tag, i]);
          }
          continue;
        }
        paren = tokens[i - 1][0] === ')';
        index = paren
          ? start[1]
          : i - 1;
        pre = tokens[index - 1];
        if (!(((ref$ = pre[0]) === ':' || ref$ === 'ASSIGN' || ref$ === 'IMPORT') || ((ref$ = stack[stack.length - 1]) != null ? ref$[0] : void 8) !== '{')) {
          continue;
        }
        stack.push(['{']);
        inline = !pre.doblock && ((ref1$ = pre[0]) !== 'NEWLINE' && ref1$ !== 'INDENT');
        while (((ref1$ = tokens[index - 2]) != null ? ref1$[0] : void 8) === 'COMMENT') {
          index -= 2;
        }
        tokens.splice(index, 0, ['{', '{', tokens[index][2], tokens[index][3]]);
        detectEnd(tokens, ++i + 1, ok, go);
      }
      function ok(token, i){
        var tag, t1, ref$, ref1$;
        switch (tag = token[0]) {
        case ',':
          break;
        case 'NEWLINE':
          if (inline) {
            return true;
          }
          break;
        case 'DEDENT':
          return true;
        case 'POST_IF':
        case 'FOR':
        case 'WHILE':
          return inline;
        default:
          return false;
        }
        t1 = (ref$ = tokens[i + 1]) != null ? ref$[0] : void 8;
        return t1 !== (tag === ',' ? 'NEWLINE' : 'COMMENT') && ':' !== ((ref1$ = tokens[t1 === '('
          ? 1 + indexOfPair(tokens, i + 1)
          : i + 2]) != null ? ref1$[0] : void 8);
      }
      function go(token, i){
        tokens.splice(i, 0, ['}', '', token[2], token[3]]);
      }
    }
    function expandLiterals(tokens){
      var i, fromNum, token, sig, ref$, ref1$, lno, cno, ref2$, ref3$, ref4$, char, toNum, tochar, byNum, byp, ref5$, ts, enc, add, i$, n, ref6$, ref7$, len$, word, that;
      i = 0;
      while (token = tokens[++i]) {
        switch (token[0]) {
        case 'STRNUM':
          if (~'-+'.indexOf(sig = token[1].charAt(0))) {
            token[1] = token[1].slice(1);
            tokens.splice(i++, 0, ['+-', sig, token[2], token[3]]);
          }
          if (token.callable) {
            continue;
          }
          break;
        case 'TO':
        case 'TIL':
          if (!(tokens[i - 1][0] === '[' && ((tokens[i + 2][0] === ']' && (((ref$ = tokens[i + 1][1].charAt(0)) === '\'' || ref$ === '"') || +tokens[i + 1][1] >= 0)) || (tokens[i + 2][0] === 'BY' && ((ref$ = tokens[i + 3]) != null ? ref$[0] : void 8) === 'STRNUM' && ((ref1$ = tokens[i + 4]) != null ? ref1$[0] : void 8) === ']')))) {
            continue;
          }
          if (tokens[i + 2][0] === 'BY') {
            tokens[i + 2][0] = 'RANGE_BY';
          }
          token.op = token[1];
          fromNum = 0;
          // fallthrough
        case 'RANGE':
          lno = token[2];
          cno = token[3];
          if (fromNum != null || (tokens[i - 1][0] === '[' && tokens[i + 1][0] === 'STRNUM' && ((tokens[i + 2][0] === ']' && (((ref2$ = tokens[i + 1][1].charAt(0)) === '\'' || ref2$ === '"') || +tokens[i + 1][1] >= 0)) || (tokens[i + 2][0] === 'RANGE_BY' && ((ref2$ = tokens[i + 3]) != null ? ref2$[0] : void 8) === 'STRNUM' && ((ref3$ = tokens[i + 4]) != null ? ref3$[0] : void 8) === ']')))) {
            if (fromNum == null) {
              ref4$ = decode(token[1], lno), fromNum = ref4$[0], char = ref4$[1];
            }
            ref4$ = decode(tokens[i + 1][1], lno), toNum = ref4$[0], tochar = ref4$[1];
            if (toNum == null || char ^ tochar) {
              carp('bad "to" in range', lno);
            }
            byNum = 1;
            if (byp = ((ref4$ = tokens[i + 2]) != null ? ref4$[0] : void 8) === 'RANGE_BY') {
              if (!(byNum = +((ref5$ = tokens[i + 3]) != null ? ref5$[1] : void 8))) {
                carp('bad "by" in range', tokens[i + 2][2]);
              }
            } else if (fromNum > toNum) {
              byNum = -1;
            }
            ts = [];
            enc = char ? character : String;
            add = fn$;
            if (token.op === 'to') {
              for (i$ = fromNum; byNum < 0 ? i$ >= toNum : i$ <= toNum; i$ += byNum) {
                n = i$;
                add();
              }
            } else {
              for (i$ = fromNum; byNum < 0 ? i$ > toNum : i$ < toNum; i$ += byNum) {
                n = i$;
                add();
              }
            }
            ts.pop() || carp('empty range', lno);
            tokens.splice.apply(tokens, [i, 2 + 2 * byp].concat(arrayFrom$(ts)));
            i += ts.length - 1;
          } else {
            token[0] = 'STRNUM';
            if (((ref6$ = tokens[i + 2]) != null ? ref6$[0] : void 8) === 'RANGE_BY') {
              tokens.splice(i + 2, 1, ['BY', 'by', lno, cno]);
            }
            tokens.splice(i + 1, 0, ['TO', token.op, lno, cno]);
          }
          fromNum = null;
          break;
        case 'WORDS':
          ts = [['[', '[', lno = token[2], cno = token[3]]];
          for (i$ = 0, len$ = (ref7$ = token[1].match(/\S+/g) || '').length; i$ < len$; ++i$) {
            word = ref7$[i$];
            ts.push(['STRNUM', string('\'', word, lno), lno, cno], [',', ',', lno, cno]);
          }
          tokens.splice.apply(tokens, [i, 1].concat(arrayFrom$(ts), [[']', ']', lno, cno]]));
          i += ts.length;
          break;
        case 'INDENT':
          if (that = tokens[i - 1]) {
            if (that[1] === 'new') {
              tokens.splice(i++, 0, ['PARAM(', '', token[2], token[3]], [')PARAM', '', token[2], token[3]], ['->', '', token[2], token[3]]);
            } else if ((ref7$ = that[0]) === 'FUNCTION' || ref7$ === 'GENERATOR' || ref7$ === 'LET') {
              tokens.splice(i, 0, ['CALL(', '', token[2], token[3]], [')CALL', '', token[2], token[3]]);
              i += 2;
            }
          }
          continue;
        case 'LITERAL':
        case '}':
          break;
        case ')':
        case ')CALL':
          if (token[1]) {
            continue;
          }
          break;
        case ']':
          if (token.index) {
            continue;
          }
          break;
        case 'CREMENT':
          if (!able(tokens, i)) {
            continue;
          }
          break;
        case 'BIOP':
          if (!token.spaced && ((ref7$ = token[1]) === '+' || ref7$ === '-') && tokens[i + 1][0] !== ')') {
            tokens[i][0] = '+-';
          }
          continue;
        default:
          continue;
        }
        if (token.spaced && in$(tokens[i + 1][0], ARG)) {
          tokens.splice(++i, 0, [',', ',', token[2], token[3]]);
        }
      }
      function fn$(){
        if (0x10000 < ts.push(['STRNUM', enc(n), lno, cno], [',', ',', lno, cno])) {
          carp('range limit exceeded', lno);
        }
      }
    }
    function detectEnd(tokens, i, ok, go){
      var levels, token, tag;
      levels = 0;
      for (; token = tokens[i]; ++i) {
        if (!levels && ok(token, i)) {
          return go(token, i);
        }
        tag = token[0];
        if (0 > (levels += in$(tag, OPENERS) || -in$(tag, CLOSERS))) {
          return go(token, i);
        }
      }
    }
    function indexOfPair(tokens, i){
      var level, end, start, that;
      level = 1;
      end = INVERSES[start = tokens[i][0]];
      while (that = tokens[++i]) {
        switch (that[0]) {
        case start:
          ++level;
          break;
        case end:
          if (!--level) {
            return i;
          }
        }
      }
      return -1;
    }
    KEYWORDS_SHARED = ['true', 'false', 'null', 'this', 'void', 'super', 'return', 'throw', 'break', 'continue', 'if', 'else', 'for', 'while', 'switch', 'case', 'default', 'try', 'catch', 'finally', 'function', 'class', 'extends', 'implements', 'new', 'do', 'delete', 'typeof', 'in', 'instanceof', 'let', 'with', 'var', 'const', 'import', 'export', 'debugger', 'yield'];
    KEYWORDS_UNUSED = ['enum', 'interface', 'package', 'private', 'protected', 'public', 'static'];
    JS_KEYWORDS = KEYWORDS_SHARED.concat(KEYWORDS_UNUSED);
    LS_KEYWORDS = ['xor', 'match', 'where'];
    ID = /((?!\s)[a-z_$\xAA-\uFFDC](?:(?!\s)[\w$\xAA-\uFFDC]|-[a-z])*)([^\n\S]*:(?![:=]))?|/ig;
    SYMBOL = /[-\/^]=|[%+:*]{1,2}=|\|>=|\.(?:[&\|\^]|<<|>>>?)\.=?|\.{1,3}|\^\^|\*?<(?:--?|~~?)!?|!?(?:--?|~~?)>>?\*?|([-+&|:])\1|%%|&|\([^\n\S]*\)|[!=]==?|!?\~=|@@?|<\[(?:[\s\S]*?\]>)?|<<<<?|<\||[<>]==|<<=|>>=|<<|>>|[<>]\??=?|\|>|\||=>|\*\*|\^|`|[^\s#]?/g;
    SPACE = /[^\n\S]*(?:#.*)?/g;
    MULTIDENT = /(?:\s*#.*)*(?:\n([^\n\S]*))*/g;
    SIMPLESTR = /'[^\\']*(?:\\[\s\S][^\\']*)*'|/g;
    JSTOKEN = /``[^\\`]*(?:\\[\s\S][^\\`]*)*``|/g;
    BSTOKEN = RegExp('\\\\(?:(\\S[^\\s,;)}\\]]*)|(?:' + SPACE.source + '\\n?)*)', 'g');
    NUMBER = /0x[\dA-Fa-f][\dA-Fa-f_]*|(\d*)~([\dA-Za-z]\w*)|((\d[\d_]*)(\.\d[\d_]*)?(?:e[+-]?\d[\d_]*)?)[$\w]*|/g;
    NUMBER_OMIT = /_+/g;
    REGEX = /\/([^[\/\n\\]*(?:(?:\\.|\[[^\]\n\\]*(?:\\.[^\]\n\\]*)*\])[^[\/\n\\]*)*)\/([gimy]{1,4}|\$?)|/g;
    HEREGEX_OMIT = /\s+(?:#.*)?/g;
    LASTDENT = /\n[^\n\S]*$/;
    INLINEDENT = /[^\n\S]*[^#\s]?/g;
    NONASCII = /[\x80-\uFFFF]/;
    OPENERS = ['(', '[', '{', 'CALL(', 'PARAM(', 'INDENT'];
    CLOSERS = [')', ']', '}', ')CALL', ')PARAM', 'DEDENT'];
    INVERSES = import$((function(){
      var i$, ref$, len$, resultObj$ = {};
      for (i$ = 0, len$ = (ref$ = OPENERS).length; i$ < len$; ++i$) {
        i = i$;
        o = ref$[i$];
        resultObj$[o] = CLOSERS[i];
      }
      return resultObj$;
    }()), (function(){
      var i$, ref$, len$, resultObj$ = {};
      for (i$ = 0, len$ = (ref$ = CLOSERS).length; i$ < len$; ++i$) {
        i = i$;
        c = ref$[i$];
        resultObj$[c] = OPENERS[i];
      }
      return resultObj$;
    }()));
    CHAIN = ['(', '{', '[', 'ID', 'STRNUM', 'LITERAL', 'LET', 'WITH', 'WORDS'];
    ARG = CHAIN.concat(['...', 'UNARY', 'YIELD', 'CREMENT', 'PARAM(', 'FUNCTION', 'GENERATOR', 'IF', 'SWITCH', 'TRY', 'CLASS', 'RANGE', 'LABEL', 'DECL', 'DO', 'BIOPBP']);
    BLOCK_USERS = [',', ':', '->', 'ELSE', 'ASSIGN', 'IMPORT', 'UNARY', 'DEFAULT', 'TRY', 'FINALLY', 'HURL', 'DECL', 'DO', 'LET', 'FUNCTION', 'GENERATOR', '...'];
    function clone$(it){
      function fun(){} fun.prototype = it;
      return new fun;
    }
    function in$(x, xs){
      var i = -1, l = xs.length >>> 0;
      while (++i < l) if (x === xs[i]) return true;
      return false;
    }
    function import$(obj, src){
      var own = {}.hasOwnProperty;
      for (var key in src) if (own.call(src, key)) obj[key] = src[key];
      return obj;
    }
    },{}],4:[function(require,module,exports){
    (function (global){
    // Generated by blackpard 1.5.0
    module.exports = function(blackpard){
      var fs, path, events;
      fs = require('fs');
      path = require('path');
      events = require('events');
      blackpard.run = function(code, options, arg$){
        var filename, ref$, js, context, main, dirname, that, e;
        if (options != null) {
          filename = options.filename;
        }
        ref$ = arg$ != null
          ? arg$
          : {}, js = ref$.js, context = ref$.context;
        main = require.main;
        dirname = filename
          ? path.dirname(fs.realpathSync(filename = path.resolve(filename)))
          : filename = '.';
        main.paths = main.constructor._nodeModulePaths(dirname);
        main.filename = filename;
        if (!js) {
          code = blackpard.compile(code, (ref$ = {}, import$(ref$, options), ref$.bare = true, ref$));
          if (that = code.code) {
            code = that;
          }
        }
        if (context) {
          global.__runContext = context;
          code = "return (function() {\n" + code + "\n}).call(global.__runContext);";
        }
        filename += '(js)';
        try {
          return main._compile(code, filename);
        } catch (e$) {
          e = e$;
          throw hackTrace(e, code, filename);
        }
      };
      importAll$(blackpard, events.EventEmitter.prototype);
      require.extensions['.ls'] = function(module, filename){
        var file, js, e;
        file = fs.readFileSync(filename, 'utf8');
        js = '.json.ls' === filename.substr(-8)
          ? 'module.exports = ' + blackpard.compile(file, {
            filename: filename,
            json: true
          })
          : blackpard.compile(file, {
            filename: filename,
            bare: true,
            map: "embedded"
          }).code;
        try {
          return module._compile(js, filename);
        } catch (e$) {
          e = e$;
          throw hackTrace(e, js, filename);
        }
      };
    };
    function hackTrace(error, js, filename){
      var stack, traces, i$, len$, i, trace, index, lno, end, length, lines, j$, ref$, n;
      if (error != null) {
        stack = error.stack;
      }
      if (!stack) {
        return error;
      }
      traces = stack.split('\n');
      if (!(traces.length > 1)) {
        return error;
      }
      for (i$ = 0, len$ = traces.length; i$ < len$; ++i$) {
        i = i$;
        trace = traces[i$];
        if (0 > (index = trace.indexOf("(" + filename + ":"))) {
          continue;
        }
        lno = (/:(\d+):/.exec(trace.slice(index + filename.length)) || '')[1];
        if (!(lno = +lno)) {
          continue;
        }
        end = lno + 4;
        length = ('' + end).length;
        lines || (lines = js.split('\n'));
        for (j$ = 1 > (ref$ = lno - 4) ? 1 : ref$; j$ <= end; ++j$) {
          n = j$;
          traces[i] += "\n" + ('    ' + n).slice(-length) + "" + '|+'.charAt(n === lno) + " " + [lines[n - 1]];
        }
      }
      return error.stack = traces.join('\n'), error;
    }
    function import$(obj, src){
      var own = {}.hasOwnProperty;
      for (var key in src) if (own.call(src, key)) obj[key] = src[key];
      return obj;
    }
    function importAll$(obj, src){
      for (var key in src) obj[key] = src[key];
      return obj;
    }
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"events":10,"fs":8,"path":13}],5:[function(require,module,exports){
    (function (process){
    /* parser generated by jison 0.4.18 */
    /*
      Returns a Parser object of the following structure:
    
      Parser: {
        yy: {}
      }
    
      Parser.prototype: {
        yy: {},
        trace: function(),
        symbols_: {associative list: name ==> number},
        terminals_: {associative list: number ==> name},
        productions_: [...],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
        table: [...],
        defaultActions: {...},
        parseError: function(str, hash),
        parse: function(input),
    
        lexer: {
            EOF: 1,
            parseError: function(str, hash),
            setInput: function(input),
            input: function(),
            unput: function(str),
            more: function(),
            less: function(n),
            pastInput: function(),
            upcomingInput: function(),
            showPosition: function(),
            test_match: function(regex_match_array, rule_index),
            next: function(),
            lex: function(),
            begin: function(condition),
            popState: function(),
            _currentRules: function(),
            topState: function(),
            pushState: function(condition),
    
            options: {
                ranges: boolean           (optional: true ==> token location info will include a .range[] member)
                flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
                backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
            },
    
            performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
            rules: [...],
            conditions: {associative list: name ==> set},
        }
      }
    
    
      token location info (@$, _$, etc.): {
        first_line: n,
        last_line: n,
        first_column: n,
        last_column: n,
        range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
      }
    
    
      the parseError function receives a 'hash' object with these members for lexer and parser errors: {
        text:        (matched text)
        token:       (the produced terminal token, if any)
        line:        (yylineno)
      }
      while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
        loc:         (yylloc)
        expected:    (string describing the set of expected tokens)
        recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
      }
    */
    var parser = (function(){
    var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[2,60],$V1=[1,31],$V2=[1,34],$V3=[1,35],$V4=[1,36],$V5=[1,37],$V6=[1,38],$V7=[1,8],$V8=[1,15],$V9=[1,14],$Va=[1,39],$Vb=[1,41],$Vc=[1,29],$Vd=[1,6],$Ve=[1,10],$Vf=[1,9],$Vg=[1,11],$Vh=[1,16],$Vi=[1,17],$Vj=[1,18],$Vk=[1,19],$Vl=[1,20],$Vm=[1,21],$Vn=[1,22],$Vo=[1,23],$Vp=[1,44],$Vq=[1,24],$Vr=[1,25],$Vs=[1,26],$Vt=[1,27],$Vu=[1,28],$Vv=[1,30],$Vw=[1,43],$Vx=[1,45],$Vy=[1,20,25,47],$Vz=[20,47],$VA=[2,64],$VB=[1,49],$VC=[1,50],$VD=[1,51],$VE=[1,52],$VF=[1,53],$VG=[1,54],$VH=[1,55],$VI=[1,56],$VJ=[1,57],$VK=[1,58],$VL=[1,59],$VM=[1,60],$VN=[1,61],$VO=[1,62],$VP=[1,63],$VQ=[30,46,47,48],$VR=[2,50],$VS=[1,68],$VT=[1,67],$VU=[1,12,19,20,22,24,25,26,30,33,34,35,46,47,48,58,59,62,63,64,65,66,67,68,69,70,71,72,79,81,82,102,105],$VV=[2,75],$VW=[1,77],$VX=[1,78],$VY=[1,73],$VZ=[1,79],$V_=[1,71],$V$=[1,72],$V01=[1,74],$V11=[1,75],$V21=[1,83],$V31=[1,87],$V41=[1,86],$V51=[1,84],$V61=[1,95],$V71=[1,109],$V81=[48,105],$V91=[2,201],$Va1=[1,113],$Vb1=[2,1],$Vc1=[1,9,12,13,19,20,22,24,25,26,30,32,33,34,35,37,46,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,96,102,103,104,105],$Vd1=[2,2],$Ve1=[19,46,47,48],$Vf1=[1,120],$Vg1=[1,119],$Vh1=[22,46,47],$Vi1=[2,156],$Vj1=[1,130],$Vk1=[1,125],$Vl1=[1,128],$Vm1=[1,129],$Vn1=[25,47],$Vo1=[1,9,12,13,19,20,22,24,25,26,30,32,33,34,35,37,46,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,96,99,102,103,104,105],$Vp1=[30,47,48],$Vq1=[2,58],$Vr1=[1,169],$Vs1=[12,19,20,30,46,47,48],$Vt1=[2,55],$Vu1=[2,71],$Vv1=[12,46,47,48],$Vw1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,58,59,62,63,64,66,67,68,70,71,72,79,81,82,102,105],$Vx1=[20,46,47,48],$Vy1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,79,81,82,102,105],$Vz1=[1,206],$VA1=[1,12,19,20,22,24,25,26,30,33,34,35,46,47,48,58,59,62,63,64,65,66,67,68,69,70,71,72,79,81,102,105],$VB1=[1,209],$VC1=[46,48,82],$VD1=[2,203],$VE1=[1,215],$VF1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,71,72,79,81,82,102,105],$VG1=[19,47,48],$VH1=[1,227],$VI1=[20,22,46,47],$VJ1=[9,13,20,22,32,33,37,46,47,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,96],$VK1=[2,165],$VL1=[1,251],$VM1=[19,20,22,47,48,81,102],$VN1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,58,62,63,66,67,68,70,71,72,79,81,82,102,105],$VO1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,63,67,71,72,79,81,82,102,105],$VP1=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,62,63,67,70,71,72,79,81,82,102,105],$VQ1=[1,264],$VR1=[1,265],$VS1=[2,59],$VT1=[12,47,48],$VU1=[20,47,48],$VV1=[1,302],$VW1=[1,303],$VX1=[1,311],$VY1=[4,7,14,16,21,23,29,31,32,38,41,44,48,49,59,60,61,75,76,77,78,80,81,83,84,85,90,93,97,102],$VZ1=[1,336],$V_1=[1,337],$V$1=[1,12,19,20,22,24,25,26,30,33,34,35,46,47,48,58,59,62,63,64,65,66,67,68,69,70,71,72,79,81,82,88,89,102,105],$V02=[2,46],$V12=[1,369];
    var parser = {trace: function trace () { },
    yy: {},
    symbols_: {"error":2,"Chain":3,"ID":4,"KeyLike":5,"List":6,"LITERAL":7,"Index":8,"CALL(":9,"ArgList":10,"OptComma":11,")CALL":12,"?":13,"LET":14,"Block":15,"[":16,"Expression":17,"LoopHeads":18,"]":19,"DEDENT":20,"{":21,"}":22,"(":23,"BIOP":24,")":25,"BIOPR":26,"BIOPBP":27,"BIOPP":28,"PARAM(":29,")PARAM":30,"UNARY":31,"CREMENT":32,"BACKTICK":33,"TO":34,"BY":35,"FROM":36,"DOT":37,"WITH":38,"LoopHead":39,"Else":40,"STRNUM":41,"Parenthetical":42,"Properties":43,"LABEL":44,"Arg":45,",":46,"NEWLINE":47,"INDENT":48,"...":49,"Lines":50,"Line":51,"<-":52,"COMMENT":53,"REQUIRE":54,"SplatChain":55,"CLONEPORT":56,"ASSIGN":57,"IMPORT":58,"+-":59,"CLONE":60,"YIELD":61,"COMPARE":62,"LOGIC":63,"MATH":64,"POWER":65,"SHIFT":66,"BITWISE":67,"CONCAT":68,"COMPOSE":69,"RELATION":70,"PIPE":71,"BACKPIPE":72,"!?":73,"->":74,"FUNCTION":75,"GENERATOR":76,"ASYNC":77,"IF":78,"POST_IF":79,"DO":80,"WHILE":81,"CASE":82,"HURL":83,"JUMP":84,"SWITCH":85,"Exprs":86,"Cases":87,"DEFAULT":88,"ELSE":89,"TRY":90,"CATCH":91,"FINALLY":92,"CLASS":93,"OptExtends":94,"OptImplements":95,"EXTENDS":96,"DECL":97,"KeyColon":98,":":99,"Property":100,"Body":101,"FOR":102,"IN":103,"OF":104,"IMPLEMENTS":105,"Root":106,"$accept":0,"$end":1},
    terminals_: {2:"error",4:"ID",7:"LITERAL",9:"CALL(",12:")CALL",13:"?",14:"LET",16:"[",19:"]",20:"DEDENT",21:"{",22:"}",23:"(",24:"BIOP",25:")",26:"BIOPR",27:"BIOPBP",28:"BIOPP",29:"PARAM(",30:")PARAM",31:"UNARY",32:"CREMENT",33:"BACKTICK",34:"TO",35:"BY",36:"FROM",37:"DOT",38:"WITH",41:"STRNUM",44:"LABEL",46:",",47:"NEWLINE",48:"INDENT",49:"...",52:"<-",53:"COMMENT",54:"REQUIRE",56:"CLONEPORT",57:"ASSIGN",58:"IMPORT",59:"+-",60:"CLONE",61:"YIELD",62:"COMPARE",63:"LOGIC",64:"MATH",65:"POWER",66:"SHIFT",67:"BITWISE",68:"CONCAT",69:"COMPOSE",70:"RELATION",71:"PIPE",72:"BACKPIPE",73:"!?",74:"->",75:"FUNCTION",76:"GENERATOR",77:"ASYNC",78:"IF",79:"POST_IF",80:"DO",81:"WHILE",82:"CASE",83:"HURL",84:"JUMP",85:"SWITCH",88:"DEFAULT",89:"ELSE",90:"TRY",91:"CATCH",92:"FINALLY",93:"CLASS",96:"EXTENDS",97:"DECL",99:":",102:"FOR",103:"IN",104:"OF",105:"IMPLEMENTS"},
    productions_: [0,[3,1],[3,1],[3,1],[3,1],[3,2],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[3,3],[3,3],[5,1],[5,1],[8,2],[8,2],[8,2],[6,4],[6,4],[6,5],[6,5],[10,0],[10,1],[10,3],[10,4],[10,6],[45,1],[45,2],[45,1],[11,0],[11,1],[50,0],[50,1],[50,3],[50,2],[51,1],[51,2],[51,6],[51,1],[51,1],[51,2],[15,3],[55,2],[17,3],[17,3],[17,5],[17,1],[17,3],[17,3],[17,6],[17,3],[17,6],[17,2],[17,2],[17,3],[17,2],[17,3],[17,3],[17,3],[17,4],[17,4],[17,4],[17,2],[17,2],[17,2],[17,3],[17,3],[17,3],[17,6],[17,5],[17,1],[17,2],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,2],[17,6],[17,6],[17,6],[17,7],[17,7],[17,4],[17,3],[17,4],[17,6],[17,2],[17,5],[17,1],[17,1],[17,2],[17,3],[17,5],[17,5],[17,2],[17,4],[17,4],[17,2],[17,2],[17,4],[17,6],[17,5],[17,7],[17,4],[17,5],[17,4],[17,3],[17,2],[17,2],[17,5],[86,1],[86,3],[98,2],[98,2],[100,2],[100,5],[100,1],[100,2],[100,1],[43,0],[43,1],[43,3],[43,4],[43,4],[42,3],[101,1],[101,1],[101,3],[40,0],[40,2],[40,5],[39,4],[39,6],[39,6],[39,8],[39,2],[39,4],[39,4],[39,6],[39,4],[39,6],[39,6],[39,8],[39,6],[39,5],[39,8],[39,7],[39,8],[39,7],[39,10],[39,9],[39,10],[39,9],[39,2],[39,4],[39,4],[39,6],[18,1],[18,2],[18,3],[18,3],[87,3],[87,4],[94,2],[94,0],[95,2],[95,0],[106,1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
    /* this == yyval */
    
    var $0 = $$.length - 1;
    switch (yystate) {
    case 1:
    this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Var($$[$0]))));
    break;
    case 2: case 3:
    this.$ = yy.L(_$[$0], _$[$0],yy.Chain($$[$0]));
    break;
    case 4:
    this.$ = yy.L(_$[$0], _$[$0],yy.Chain(yy.L(_$[$0],_$[$0],yy.Literal($$[$0]))));
    break;
    case 5:
    this.$ = yy.L(_$[$0-1], _$[$0],$$[$0-1].add($$[$0]));
    break;
    case 6:
    this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-4].add(yy.L(_$[$0-3],_$[$0], yy.Call($$[$0-2]))));
    break;
    case 7:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0], yy.Existence($$[$0-1].unwrap()))));
    break;
    case 8:
    this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], yy.Call['let']($$[$0-3], $$[$0]))));
    break;
    case 9:
    this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0], $$[$0-1][0].makeComprehension($$[$0-2], $$[$0-1].slice(1)))));
    break;
    case 10:
    this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], $$[$0-2][0].makeComprehension($$[$0-3], $$[$0-2].slice(1)))));
    break;
    case 11:
    this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], $$[$0-1][0].addObjComp().makeComprehension(yy.L(_$[$0-4],_$[$0-4],yy.Arr($$[$0-4])), $$[$0-1].slice(1)))));
    break;
    case 12: case 18: case 20:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1]))));
    break;
    case 13:
    this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],yy.Binary($$[$0-2], void 8, $$[$0-1]))));
    break;
    case 14:
    this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2]))));
    break;
    case 15:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],'!' === $$[$0-1].charAt(0)
            ? yy.Binary($$[$0-1].slice(1)).invertIt()
            : yy.Binary($$[$0-1]))));
    break;
    case 16:
    this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-2],'!' === $$[$0-2].charAt(0)
            ? yy.Binary($$[$0-2].slice(1), void 8, $$[$0-1]).invertIt()
            : yy.Binary($$[$0-2], void 8, $$[$0-1]))));
    break;
    case 17:
    this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],'!' === $$[$0-1].charAt(0)
            ? yy.Binary($$[$0-1].slice(1), $$[$0-2]).invertIt()
            : yy.Binary($$[$0-1], $$[$0-2]))));
    break;
    case 19:
    this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-5],yy.Binary($$[$0-5], void 8, $$[$0-3]))));
    break;
    case 21:
    this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-4]))));
    break;
    case 22: case 23:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-1],_$[$0-1],yy.Unary($$[$0-1]))));
    break;
    case 24:
    this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain($$[$0-2]));
    break;
    case 25:
    this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], $$[$0-2].add(yy.L(_$[$0-4],_$[$0-4],yy.Call([$$[$0-4]]))))));
    break;
    case 26:
    this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-3],yy.Chain(yy.Var('flip$'))).add(yy.L(_$[$0-3],_$[$0-3],yy.Call([$$[$0-3]])))).flipIt().add(yy.L(_$[$0-1],_$[$0-1],yy.Call([$$[$0-1]]))));
    break;
    case 27:
    this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-3],_$[$0-1], new yy.For({
            from: $$[$0-3],
            op: $$[$0-2],
            to: $$[$0-1],
            inComprehension: true
          }))));
    break;
    case 28:
    this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0-1], new yy.For({
            from: $$[$0-5],
            op: $$[$0-4],
            to: $$[$0-3],
            step: $$[$0-1],
            inComprehension: true
          }))));
    break;
    case 29:
    this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], new yy.For({
            from: $$[$0-3],
            op: $$[$0-2],
            to: $$[$0-1],
            inComprehension: true
          }))));
    break;
    case 30:
    this.$ = yy.L(_$[$0-7], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0-1], new yy.For({
            from: $$[$0-5],
            op: $$[$0-4],
            to: $$[$0-3],
            step: $$[$0-1],
            inComprehension: true
          }))));
    break;
    case 31:
    this.$ = yy.L(_$[$0-3], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], new yy.For({
            from: yy.Chain(yy.Literal(0)),
            op: $$[$0-2],
            to: $$[$0-1],
            inComprehension: true
          }))));
    break;
    case 32:
    this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0-1], new yy.For({
            from: yy.Chain(yy.Literal(0)),
            op: $$[$0-4],
            to: $$[$0-3],
            step: $$[$0-1],
            inComprehension: true
          }))));
    break;
    case 33:
    this.$ = yy.L(_$[$0-8], _$[$0],yy.Chain(yy.L(_$[$0-8],_$[$0], new yy.StepSlice({
            op: $$[$0-4],
            target: $$[$0-8],
            from: $$[$0-5],
            to: $$[$0-3],
            step: $$[$0-1]
          }))));
    break;
    case 34:
    this.$ = yy.L(_$[$0-7], _$[$0],yy.Chain(yy.L(_$[$0-7],_$[$0], new yy.StepSlice({
            op: $$[$0-4],
            target: $$[$0-7],
            from: yy.Literal(0),
            to: $$[$0-3],
            step: $$[$0-1]
          }))));
    break;
    case 35:
    this.$ = yy.L(_$[$0-6], _$[$0],yy.Chain(yy.L(_$[$0-6],_$[$0], yy.Slice({
            type: $$[$0-2],
            target: $$[$0-6],
            from: $$[$0-3],
            to: $$[$0-1]
          }))));
    break;
    case 36:
    this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0], yy.Slice({
            type: $$[$0-1],
            target: $$[$0-5],
            from: $$[$0-2]
          }))));
    break;
    case 37:
    this.$ = yy.L(_$[$0-5], _$[$0],yy.Chain(yy.L(_$[$0-5],_$[$0], yy.Slice({
            type: $$[$0-2],
            target: $$[$0-5],
            to: $$[$0-1]
          }))));
    break;
    case 38:
    this.$ = yy.L(_$[$0-4], _$[$0],yy.Chain(yy.L(_$[$0-4],_$[$0], yy.Slice({
            type: $$[$0-1],
            target: $$[$0-4]
          }))));
    break;
    case 39:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain(yy.L(_$[$0-2],_$[$0-1], yy.Cascade($$[$0-1], $$[$0], 'with'))));
    break;
    case 40:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Chain($$[$0-2].addBody($$[$0-1]).addElse($$[$0])));
    break;
    case 41:
    this.$ = yy.L(_$[$0], _$[$0],yy.Literal($$[$0]));
    break;
    case 42: case 55: case 58: case 59: case 63: case 64: case 162: case 163:
    
    break;
    case 43:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Index(yy.L(_$[$0],_$[$0],yy.Key($$[$0])), $$[$0-1], true));
    break;
    case 44: case 45:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Index($$[$0], $$[$0-1], true));
    break;
    case 46:
    this.$ = yy.L(_$[$0-3], _$[$0],yy.Arr($$[$0-2]));
    break;
    case 47:
    this.$ = yy.L(_$[$0-3], _$[$0],yy.Obj($$[$0-2]));
    break;
    case 48:
    this.$ = yy.L(_$[$0-4], _$[$0],yy.Arr($$[$0-3]).named($$[$0]));
    break;
    case 49:
    this.$ = yy.L(_$[$0-4], _$[$0],yy.Obj($$[$0-3]).named($$[$0]));
    break;
    case 50: case 156:
    this.$ = yy.L(_$[$0], _$[$0],[]);
    break;
    case 51: case 147: case 157: case 194:
    this.$ = yy.L(_$[$0], _$[$0],[$$[$0]]);
    break;
    case 52: case 148: case 158: case 196: case 197:
    this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].concat($$[$0]));
    break;
    case 53: case 159:
    this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat($$[$0]));
    break;
    case 54:
    this.$ = yy.L(_$[$0-5], _$[$0-2],$$[$0-5].concat($$[$0-2]));
    break;
    case 56:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0]));
    break;
    case 57:
    this.$ = yy.L(_$[$0], _$[$0],yy.Splat(yy.L(_$[$0],_$[$0],yy.Arr()), true));
    break;
    case 60:
    this.$ = yy.L(_$[$0], _$[$0],yy.Block());
    break;
    case 61:
    this.$ = yy.L(_$[$0], _$[$0],yy.Block($$[$0]));
    break;
    case 62: case 164:
    this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-2].add($$[$0]));
    break;
    case 65:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Cascade($$[$0-1], $$[$0], 'cascade'));
    break;
    case 66:
    this.$ = yy.L(_$[$0-5], _$[$0],yy.Call.back($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.test($$[$0-1])));
    break;
    case 67: case 155:
    this.$ = yy.L(_$[$0], _$[$0],yy.JS($$[$0], true, true));
    break;
    case 68:
    this.$ = yy.L(_$[$0], _$[$0],yy.Throw(yy.L(_$[$0],_$[$0],yy.JS("Error('unimplemented')"))));
    break;
    case 69:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Require($$[$0].unwrap()));
    break;
    case 70:
    this.$ = yy.L(_$[$0-2], _$[$0],$$[$0-1]);
    break;
    case 71:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Splat($$[$0].unwrap()));
    break;
    case 72:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Import(yy.L(_$[$0-2],_$[$0-1], yy.Unary('^^', $$[$0-2], {
            prec: 'yy.UNARY'
          })), $$[$0], false));
    break;
    case 73:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Import(yy.L(_$[$0-2],_$[$0-1], yy.Unary('^^', $$[$0-2], {
            prec: 'yy.UNARY'
          })), $$[$0].unwrap(), false));
    break;
    case 74:
    this.$ = yy.L(_$[$0-4], _$[$0],$$[$0-2].add(yy.L(_$[$0-4],_$[$0], yy.Call([$$[$0-4], $$[$0]]))));
    break;
    case 75:
    this.$ = yy.L(_$[$0], _$[$0],$$[$0].unwrap());
    break;
    case 76:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2].unwrap(), $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
    break;
    case 77:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0-2], $$[$0], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
    break;
    case 78:
    this.$ = yy.L(_$[$0-5], _$[$0],yy.Assign($$[$0-5].unwrap(), yy.Arr.maybe($$[$0-2]), yy.L(_$[$0-4],_$[$0-4],yy.Box($$[$0-4]))));
    break;
    case 79:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Import($$[$0-2], $$[$0], $$[$0-1] === '<<<<'));
    break;
    case 80:
    this.$ = yy.L(_$[$0-5], _$[$0],yy.Import($$[$0-5], yy.Arr.maybe($$[$0-2]), $$[$0-4] === '<<<<'));
    break;
    case 81:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Unary($$[$0-1], $$[$0].unwrap()));
    break;
    case 82:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Unary($$[$0], $$[$0-1].unwrap(), true));
    break;
    case 83:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Unary($$[$0-2], yy.Splat($$[$0].unwrap())));
    break;
    case 84:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Unary($$[$0], $$[$0-1], true));
    break;
    case 85: case 86: case 87:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Assign($$[$0].unwrap(), [$$[$0-2]], yy.L(_$[$0-1],_$[$0-1],yy.Box($$[$0-1]))));
    break;
    case 88: case 89: case 90:
    this.$ = yy.L(_$[$0-3], _$[$0],yy.Assign(yy.Splat($$[$0].unwrap()), [$$[$0-3]], yy.L(_$[$0-2],_$[$0-2],yy.Box($$[$0-2]))));
    break;
    case 91: case 92: case 93:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Unary($$[$0-1], $$[$0]));
    break;
    case 94: case 95: case 96:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Unary($$[$0-2], yy.Splat($$[$0])));
    break;
    case 97:
    this.$ = yy.L(_$[$0-5], _$[$0],yy.Unary($$[$0-5], yy.Splat(yy.Arr($$[$0-2]))));
    break;
    case 98:
    this.$ = yy.L(_$[$0-4], _$[$0],yy.Unary($$[$0-4], yy.Arr.maybe($$[$0-2])));
    break;
    case 99:
    this.$ = yy.L(_$[$0], _$[$0],yy.Yield($$[$0]));
    break;
    case 100:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Yield($$[$0-1], $$[$0]));
    break;
    case 101: case 102: case 103: case 104: case 105: case 106: case 107: case 108: case 109:
    this.$ = (yy.L(_$[$0-1],_$[$0-1],yy.Binary($$[$0-1], $$[$0-2], $$[$0])));
    break;
    case 110:
    this.$ = yy.L(_$[$0-2], _$[$0],'!' === $$[$0-1].charAt(0)
            ? yy.Binary($$[$0-1].slice(1), $$[$0-2], $$[$0]).invert()
            : yy.Binary($$[$0-1], $$[$0-2], $$[$0]));
    break;
    case 111:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Block($$[$0-2]).pipe($$[$0], $$[$0-1]));
    break;
    case 112:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Block($$[$0-2]).pipe([$$[$0]], $$[$0-1]));
    break;
    case 113:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Existence($$[$0-1].unwrap(), true));
    break;
    case 114:
    this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-4], $$[$0], /~/.test($$[$0-1]), /--|~~/.test($$[$0-1]), /!/.test($$[$0-1]), /\*/.test($$[$0-1]), />>/.test($$[$0-1])));
    break;
    case 115:
    this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0]).named($$[$0-5]));
    break;
    case 116:
    this.$ = yy.L(_$[$0-5], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true, false).named($$[$0-5]));
    break;
    case 117:
    this.$ = yy.L(_$[$0-6], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, false, true).named($$[$0-5]));
    break;
    case 118:
    this.$ = yy.L(_$[$0-6], _$[$0],yy.Fun($$[$0-3], $$[$0], false, false, false, true, true).named($$[$0-5]));
    break;
    case 119:
    this.$ = (yy.L(_$[$0-3],_$[$0-2], yy.If($$[$0-2], $$[$0-1], $$[$0-3] === 'unless')).addElse($$[$0]));
    break;
    case 120:
    this.$ = (yy.L(_$[$0-1],_$[$0], yy.If($$[$0], $$[$0-2], $$[$0-1] === 'unless')));
    break;
    case 121:
    this.$ = yy.L(_$[$0-3], _$[$0],new yy.While($$[$0], $$[$0-1] === 'until', true).addBody($$[$0-2]));
    break;
    case 122:
    this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-2], $$[$0-3] === 'until', true).addGuard($$[$0]).addBody($$[$0-4]));
    break;
    case 123:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Jump[$$[$0-1]]($$[$0]));
    break;
    case 124:
    this.$ = yy.L(_$[$0-4], _$[$0],yy.Jump[$$[$0-4]](yy.Arr.maybe($$[$0-2])));
    break;
    case 125:
    this.$ = yy.L(_$[$0], _$[$0],yy.Jump[$$[$0]]());
    break;
    case 126:
    this.$ = yy.L(_$[$0], _$[$0],new yy.Jump($$[$0]));
    break;
    case 127:
    this.$ = yy.L(_$[$0-1], _$[$0],new yy.Jump($$[$0-1], $$[$0]));
    break;
    case 128:
    this.$ = yy.L(_$[$0-2], _$[$0],new yy.Switch($$[$0-2], $$[$0-1], $$[$0]));
    break;
    case 129: case 130:
    this.$ = yy.L(_$[$0-4], _$[$0],new yy.Switch($$[$0-4], $$[$0-3], $$[$0-2], $$[$0]));
    break;
    case 131:
    this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, $$[$0]));
    break;
    case 132: case 133:
    this.$ = yy.L(_$[$0-3], _$[$0],new yy.Switch($$[$0-3], null, $$[$0-2], $$[$0]));
    break;
    case 134:
    this.$ = yy.L(_$[$0-1], _$[$0],new yy.Switch($$[$0-1], null, [], $$[$0]));
    break;
    case 135:
    this.$ = yy.L(_$[$0-1], _$[$0],new yy.Try($$[$0]));
    break;
    case 136:
    this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
    break;
    case 137:
    this.$ = yy.L(_$[$0-5], _$[$0],new yy.Try($$[$0-4], void 8, yy.L(_$[$0-3],_$[$0-3],$$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
    break;
    case 138:
    this.$ = yy.L(_$[$0-4], _$[$0],new yy.Try($$[$0-3], $$[$0-1], yy.L(_$[$0-2],_$[$0-1], $$[$0])));
    break;
    case 139:
    this.$ = yy.L(_$[$0-6], _$[$0],new yy.Try($$[$0-5], $$[$0-3], yy.L(_$[$0-4],_$[$0-3], $$[$0-2]), yy.L(_$[$0-1],_$[$0-1],$$[$0])));
    break;
    case 140:
    this.$ = yy.L(_$[$0-3], _$[$0],new yy.Try($$[$0-2], void 8, void 8, yy.L(_$[$0-1],_$[$0-1],$$[$0])));
    break;
    case 141:
    this.$ = yy.L(_$[$0-4], _$[$0],new yy.Class({
            title: $$[$0-3].unwrap(),
            sup: $$[$0-2],
            mixins: $$[$0-1],
            body: $$[$0]
          }));
    break;
    case 142:
    this.$ = yy.L(_$[$0-3], _$[$0],new yy.Class({
            sup: $$[$0-2],
            mixins: $$[$0-1],
            body: $$[$0]
          }));
    break;
    case 143:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Util.Extends($$[$0-2].unwrap(), $$[$0]));
    break;
    case 144: case 145:
    this.$ = yy.L(_$[$0-1], _$[$0],new yy.Label($$[$0-1], $$[$0]));
    break;
    case 146:
    this.$ = yy.L(_$[$0-4], _$[$0],yy.Decl($$[$0-4], $$[$0-2], yylineno + 1));
    break;
    case 149:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Key($$[$0-1]));
    break;
    case 150:
    this.$ = yy.L(_$[$0-1], _$[$0],$$[$0-1]);
    break;
    case 151:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Prop($$[$0-1], $$[$0]));
    break;
    case 152:
    this.$ = yy.L(_$[$0-4], _$[$0],yy.Prop($$[$0-4], yy.Arr.maybe($$[$0-2])));
    break;
    case 153:
    this.$ = yy.L(_$[$0], _$[$0],yy.Prop(null, $$[$0]));
    break;
    case 154:
    this.$ = yy.L(_$[$0-1], _$[$0],yy.Prop(yy.Splat(), $$[$0]));
    break;
    case 160:
    this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-2]);
    break;
    case 161:
    this.$ = yy.L(_$[$0-2], _$[$0],yy.Parens($$[$0-1].chomp().unwrap(), false, $$[$0-2] === '"', yy.L(_$[$0-2],_$[$0-2],{}), yy.L(_$[$0],_$[$0],{})));
    break;
    case 165: case 201: case 203:
    this.$ = yy.L(_$[$0], _$[$0],null);
    break;
    case 166: case 200: case 202:
    this.$ = yy.L(_$[$0-1], _$[$0],$$[$0]);
    break;
    case 167:
    this.$ = yy.L(_$[$0-4], _$[$0],yy.If($$[$0-2], $$[$0-1], $$[$0-3] === 'unless').addElse($$[$0]));
    break;
    case 168:
    this.$ = yy.L(_$[$0-3], _$[$0],new yy.For({
            kind: $$[$0-3],
            item: $$[$0-2].unwrap(),
            index: $$[$0-1],
            source: $$[$0]
          }));
    break;
    case 169:
    this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
            kind: $$[$0-5],
            item: $$[$0-4].unwrap(),
            index: $$[$0-3],
            source: $$[$0-2],
            guard: $$[$0]
          }));
    break;
    case 170:
    this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
            kind: $$[$0-5],
            item: $$[$0-4].unwrap(),
            index: $$[$0-3],
            source: $$[$0-2],
            step: $$[$0]
          }));
    break;
    case 171:
    this.$ = yy.L(_$[$0-7], _$[$0],new yy.For({
            kind: $$[$0-7],
            item: $$[$0-6].unwrap(),
            index: $$[$0-5],
            source: $$[$0-4],
            step: $$[$0-2],
            guard: $$[$0]
          }));
    break;
    case 172:
    this.$ = yy.L(_$[$0-1], _$[$0],new yy.For({
            kind: $$[$0-1],
            source: $$[$0],
            ref: true
          }));
    break;
    case 173:
    this.$ = yy.L(_$[$0-3], _$[$0],new yy.For({
            kind: $$[$0-3],
            source: $$[$0-2],
            ref: true,
            guard: $$[$0]
          }));
    break;
    case 174:
    this.$ = yy.L(_$[$0-3], _$[$0],new yy.For({
            kind: $$[$0-3],
            source: $$[$0-2],
            ref: true,
            step: $$[$0]
          }));
    break;
    case 175:
    this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
            kind: $$[$0-5],
            source: $$[$0-4],
            ref: true,
            step: $$[$0-2],
            guard: $$[$0]
          }));
    break;
    case 176:
    this.$ = yy.L(_$[$0-3], _$[$0],new yy.For({
            object: true,
            kind: $$[$0-3],
            index: $$[$0-2],
            source: $$[$0]
          }));
    break;
    case 177:
    this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
            object: true,
            kind: $$[$0-5],
            index: $$[$0-4],
            source: $$[$0-2],
            guard: $$[$0]
          }));
    break;
    case 178:
    this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
            object: true,
            kind: $$[$0-5],
            index: $$[$0-4],
            item: $$[$0-2].unwrap(),
            source: $$[$0]
          }));
    break;
    case 179:
    this.$ = yy.L(_$[$0-7], _$[$0],new yy.For({
            object: true,
            kind: $$[$0-7],
            index: $$[$0-6],
            item: $$[$0-4].unwrap(),
            source: $$[$0-2],
            guard: $$[$0]
          }));
    break;
    case 180:
    this.$ = yy.L(_$[$0-5], _$[$0],new yy.For({
            kind: $$[$0-5],
            index: $$[$0-4],
            from: $$[$0-2],
            op: $$[$0-1],
            to: $$[$0]
          }));
    break;
    case 181:
    this.$ = yy.L(_$[$0-4], _$[$0],new yy.For({
            kind: $$[$0-4],
            from: $$[$0-2],
            op: $$[$0-1],
            to: $$[$0],
            ref: true
          }));
    break;
    case 182:
    this.$ = yy.L(_$[$0-7], _$[$0],new yy.For({
            kind: $$[$0-7],
            index: $$[$0-6],
            from: $$[$0-4],
            op: $$[$0-3],
            to: $$[$0-2],
            guard: $$[$0]
          }));
    break;
    case 183:
    this.$ = yy.L(_$[$0-6], _$[$0],new yy.For({
            kind: $$[$0-6],
            from: $$[$0-4],
            op: $$[$0-3],
            to: $$[$0-2],
            guard: $$[$0],
            ref: true
          }));
    break;
    case 184:
    this.$ = yy.L(_$[$0-7], _$[$0],new yy.For({
            kind: $$[$0-7],
            index: $$[$0-6],
            from: $$[$0-4],
            op: $$[$0-3],
            to: $$[$0-2],
            step: $$[$0]
          }));
    break;
    case 185:
    this.$ = yy.L(_$[$0-6], _$[$0],new yy.For({
            kind: $$[$0-6],
            from: $$[$0-4],
            op: $$[$0-3],
            to: $$[$0-2],
            step: $$[$0],
            ref: true
          }));
    break;
    case 186:
    this.$ = yy.L(_$[$0-9], _$[$0],new yy.For({
            kind: $$[$0-9],
            index: $$[$0-8],
            from: $$[$0-6],
            op: $$[$0-5],
            to: $$[$0-4],
            step: $$[$0-2],
            guard: $$[$0]
          }));
    break;
    case 187:
    this.$ = yy.L(_$[$0-8], _$[$0],new yy.For({
            kind: $$[$0-8],
            from: $$[$0-6],
            op: $$[$0-5],
            to: $$[$0-4],
            step: $$[$0-2],
            guard: $$[$0],
            ref: true
          }));
    break;
    case 188:
    this.$ = yy.L(_$[$0-9], _$[$0],new yy.For({
            kind: $$[$0-9],
            index: $$[$0-8],
            from: $$[$0-6],
            op: $$[$0-5],
            to: $$[$0-4],
            guard: $$[$0-2],
            step: $$[$0]
          }));
    break;
    case 189:
    this.$ = yy.L(_$[$0-8], _$[$0],new yy.For({
            kind: $$[$0-8],
            from: $$[$0-6],
            op: $$[$0-5],
            to: $$[$0-4],
            guard: $$[$0-2],
            step: $$[$0],
            ref: true
          }));
    break;
    case 190:
    this.$ = yy.L(_$[$0-1], _$[$0],new yy.While($$[$0], $$[$0-1] === 'until'));
    break;
    case 191:
    this.$ = yy.L(_$[$0-3], _$[$0],new yy.While($$[$0-2], $$[$0-3] === 'until').addGuard($$[$0]));
    break;
    case 192:
    this.$ = yy.L(_$[$0-3], _$[$0],new yy.While($$[$0-2], $$[$0-3] === 'until', $$[$0]));
    break;
    case 193:
    this.$ = yy.L(_$[$0-5], _$[$0],new yy.While($$[$0-4], $$[$0-5] === 'until', $$[$0-2]).addGuard($$[$0]));
    break;
    case 195:
    this.$ = yy.L(_$[$0-1], _$[$0],$$[$0-1].concat($$[$0]));
    break;
    case 198:
    this.$ = yy.L(_$[$0-2], _$[$0],[yy.L(_$[$0-2],_$[$0-1], new yy.Case($$[$0-1], $$[$0]))]);
    break;
    case 199:
    this.$ = yy.L(_$[$0-3], _$[$0],$$[$0-3].concat(yy.L(_$[$0-2],_$[$0-1], new yy.Case($$[$0-1], $$[$0]))));
    break;
    case 204:
    return this.$
    break;
    }
    },
    table: [o([1,47],$V0,{106:1,101:2,50:3,15:4,51:5,17:7,3:12,55:13,5:32,6:33,39:40,42:42,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$V7,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:$Vd,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{1:[3]},{1:[2,204]},o($Vr,[2,162],{47:$Vx}),o($Vr,[2,163],{47:[1,46]}),o($Vy,[2,61]),o($Vz,$V0,{51:5,17:7,3:12,55:13,5:32,6:33,39:40,42:42,50:47,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$V7,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vy,$VA,{15:48,33:$VB,48:$Vd,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VQ,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,10:64,45:65,17:66,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vy,[2,67]),o($Vy,[2,68],{5:32,6:33,39:40,42:42,3:69,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,41:$Vb,81:$Vp,102:$Vw}),{3:70,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($VU,$VV,{8:76,9:$VW,13:$VX,32:$VY,37:$VZ,56:$V_,57:$V$,73:$V01,96:$V11}),{32:[1,81],57:[1,80]},{3:82,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,49:$V21,81:$Vp,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:85,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:$V31,49:$V41,55:13,57:$V51,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:89,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:[1,90],55:13,57:[1,88],59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:92,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:[1,93],55:13,57:[1,91],59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o([1,12,19,20,22,24,25,26,30,33,34,35,46,47,48,58,62,63,64,65,66,67,68,69,70,71,72,79,82,105],[2,99],{3:12,55:13,5:32,6:33,39:40,42:42,17:94,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$V61,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{9:[1,96]},{9:[1,97]},{75:[1,98],76:[1,99]},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:100,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:101,48:$Vd},o([1,12,19,20,22,24,25,26,30,33,34,35,46,47,58,62,63,64,65,66,67,68,69,70,71,72,79,82,105],[2,125],{3:12,55:13,5:32,6:33,39:40,42:42,17:102,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:[1,103],49:$V61,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VU,[2,126],{4:[1,104]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,15:107,16:$V4,17:108,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:$Vd,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,82:$V71,83:$Vq,84:$Vr,85:$Vs,86:105,87:106,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:110,48:$Vd},o($V81,$V91,{5:32,6:33,39:40,42:42,3:111,94:112,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,41:$Vb,81:$Vp,96:$Va1,102:$Vw}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,15:115,16:$V4,17:114,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:$Vd,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{48:[1,116]},o([1,9,12,13,19,20,22,24,25,26,30,32,33,34,35,37,46,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,96,102,104,105],$Vb1),o($Vc1,$Vd1),o($Vc1,[2,3]),o($Vc1,[2,4]),{9:[1,117]},o($Ve1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:118,10:121,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,34:$Vf1,36:$Vg1,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vh1,$Vi1,{3:12,55:13,6:33,39:40,42:42,43:123,100:124,98:126,17:127,5:131,4:$Vj1,7:$V2,14:$V3,16:[1,122],21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:$Vk1,49:$Vl1,53:$Vm1,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vn1,$V0,{50:3,15:4,51:5,3:12,55:13,5:32,6:33,39:40,42:42,17:133,101:141,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,24:[1,132],26:[1,134],27:[1,135],28:[1,136],29:[1,137],31:[1,138],32:[1,139],33:[1,140],38:$Va,41:$Vb,44:$Vc,48:$Vd,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:142,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:143,48:$Vd},o($Vo1,[2,41]),o($Vo1,[2,42]),{3:144,4:[1,146],5:32,6:33,7:$V2,14:$V3,16:$V4,17:145,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,36:[1,147],38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:148,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vy,[2,63],{17:7,3:12,55:13,5:32,6:33,39:40,42:42,51:149,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$V7,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o([1,25,47],$V0,{51:5,17:7,3:12,55:13,5:32,6:33,39:40,42:42,50:150,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$V7,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{20:[1,151],47:$Vx},o($Vy,[2,65]),{3:152,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:153,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:[1,154],49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:155,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:156,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:157,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:158,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:159,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:160,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:161,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:162,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:163,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:164,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:165,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:166,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:167,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vp1,$Vq1,{11:168,46:$Vr1}),o($Vs1,[2,51]),o($Vs1,$Vt1,{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($Vs1,[2,57],{55:13,5:32,6:33,39:40,42:42,17:170,3:171,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$V61,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VQ,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:172,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o([32,57],$Vu1,{8:76,9:$VW,13:$VX,37:$VZ}),o($Vy,[2,69],{8:76,9:$VW,13:$VX,37:$VZ}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,15:174,16:$V4,17:173,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:$Vd,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:175,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:[1,176],49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,82]),o($VU,[2,113]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:177,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,5]),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:178,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vc1,[2,7]),{4:[1,180],5:181,6:182,16:[1,179],21:[1,183],23:[1,184],41:$Vb,42:42},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:185,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,84]),o($VU,[2,81],{8:76,9:$VW,13:$VX,37:$VZ}),{3:186,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},{3:187,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,49:[1,188],81:$Vp,102:$Vw},o($Vw1,[2,91],{33:$VB,65:$VH,69:$VL}),{3:171,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:189,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:[1,190],49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:191,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{3:192,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,49:[1,193],81:$Vp,102:$Vw},o($Vw1,[2,92],{33:$VB,65:$VH,69:$VL}),{3:171,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:194,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:195,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,49:[1,196],81:$Vp,102:$Vw},o($Vw1,[2,93],{33:$VB,65:$VH,69:$VL}),{3:171,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:197,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vy1,[2,100],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),{3:69,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:198,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:199,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{9:[1,200]},{9:[1,201]},{15:202,33:$VB,48:$Vd,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{81:[1,203]},o($Vy1,[2,123],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:204,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VU,[2,127]),{46:$Vz1,82:$V71,87:205},o($VA1,[2,131],{82:$VB1,88:[1,207],89:[1,208]}),o($VU,[2,134]),o($VC1,[2,147],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:108,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,86:210,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,135],{91:[1,211],92:[1,212]}),o($V81,$V91,{8:76,94:213,9:$VW,13:$VX,37:$VZ,96:$Va1}),{48:$VD1,95:214,105:$VE1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:216,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VF1,[2,144],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM}),o($VU,[2,145]),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:217,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:218,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Ve1,$Vt1,{18:219,39:221,33:$VB,34:[1,220],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,81:$Vp,102:$Vw}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:222,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:223,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VG1,$Vq1,{11:224,46:$Vr1}),o($Ve1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:118,10:225,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,34:$Vf1,36:$Vg1,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o([22,47],$Vq1,{11:226,46:$VH1}),o($VI1,[2,157]),o([20,46,47],$Vi1,{3:12,55:13,6:33,39:40,42:42,100:124,98:126,17:127,5:131,43:228,4:$Vj1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:$Vk1,49:$Vl1,53:$Vm1,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:229,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:[1,230],49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VI1,[2,153],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),{3:171,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:231,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VI1,[2,155]),o($VJ1,$Vb1,{99:[1,232]}),o($VJ1,$Vd1,{99:[1,233]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:235,21:$V5,23:$V6,25:[1,234],29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vn1,$VA,{15:48,24:[1,236],26:[1,237],33:[1,238],48:$Vd,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:240,21:$V5,23:$V6,25:[1,239],29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{9:[1,242],25:[1,241]},{25:[1,243]},o($VQ,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:244,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:85,21:$V5,23:$V6,25:[1,245],29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,48:$V31,49:$V41,55:13,57:$V51,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:82,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,25:[1,246],38:$Va,39:40,41:$Vb,42:42,49:$V21,81:$Vp,102:$Vw},{3:247,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},{25:[1,248]},{15:249,33:$VB,48:$Vd,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,$VK1,{40:250,89:$VL1}),o([19,20,22,33,35,47,48,58,59,62,63,64,65,66,67,68,69,70,71,72,79,81,82,102],$VV,{8:76,9:$VW,13:$VX,32:$VY,37:$VZ,56:$V_,57:$V$,73:$V01,96:$V11,103:[1,252]}),o($VM1,[2,172],{33:$VB,35:[1,254],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,253]}),o([9,13,19,20,22,32,33,35,37,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,96,102,103],$Vb1,{36:[1,257],46:[1,256],104:[1,255]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:258,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,190],{33:$VB,46:[1,260],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,259]}),o($Vy,[2,62]),o($Vr,[2,164],{47:$Vx}),o([1,9,12,13,19,20,22,24,25,26,30,32,33,34,35,37,46,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,88,89,91,92,96,102,103,104,105],[2,70]),{8:76,9:$VW,13:$VX,33:[1,261],37:$VZ},o($VN1,[2,79],{33:$VB,59:$VD,64:$VG,65:$VH,69:$VL}),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:262,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o([1,12,19,20,22,24,25,26,30,34,35,46,47,48,58,59,62,63,66,67,68,70,71,72,79,81,82,102,105],[2,101],{33:$VB,64:$VG,65:$VH,69:$VL}),o($VO1,[2,102],{33:$VB,58:$VC,59:$VD,62:$VE,64:$VG,65:$VH,66:$VI,68:$VK,69:$VL,70:$VM}),o($VF1,[2,103],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM}),o($Vw1,[2,104],{33:$VB,65:$VH,69:$VL}),o($Vw1,[2,105],{33:$VB,65:$VH,69:$VL}),o($VN1,[2,106],{33:$VB,59:$VD,64:$VG,65:$VH,69:$VL}),o($VO1,[2,107],{33:$VB,58:$VC,59:$VD,62:$VE,64:$VG,65:$VH,66:$VI,68:$VK,69:$VL,70:$VM}),o($VP1,[2,108],{33:$VB,58:$VC,59:$VD,64:$VG,65:$VH,66:$VI,68:$VK,69:$VL}),o([1,12,19,20,22,24,25,26,30,34,35,46,47,48,58,59,62,63,64,65,66,67,68,70,71,72,79,81,82,102,105],[2,109],{33:$VB,69:$VL}),o($VP1,[2,110],{33:$VB,58:$VC,59:$VD,64:$VG,65:$VH,66:$VI,68:$VK,69:$VL}),o($VF1,[2,111],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM}),o($Vy1,[2,112],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),o($Vy1,[2,120],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),{30:[1,263],47:$VQ1,48:$VR1},o([12,19,20,30,47,48],$VS1,{3:12,55:13,5:32,6:33,39:40,42:42,17:66,45:266,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vs1,[2,56],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VU,$VV,{8:76,9:$VW,13:$VX,32:$Vu1,57:$Vu1,37:$VZ,56:$V_,73:$V01,96:$V11}),o($Vp1,$Vq1,{11:267,46:$Vr1}),o($VN1,[2,72],{33:$VB,59:$VD,64:$VG,65:$VH,69:$VL}),o($VU,[2,73]),o($Vy1,[2,76],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:268,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VF1,[2,143],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM}),o($VT1,$Vq1,{11:269,46:$Vr1}),o($Ve1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,10:121,17:270,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,34:[1,271],38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vc1,[2,43]),o($Vc1,[2,44]),o($Vc1,[2,45]),o($Vh1,$Vi1,{3:12,55:13,6:33,39:40,42:42,43:123,100:124,98:126,17:127,5:131,4:$Vj1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:$Vk1,49:$Vl1,53:$Vm1,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vn1,$V0,{50:3,15:4,51:5,17:7,3:12,55:13,5:32,6:33,39:40,42:42,101:141,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$V7,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,48:$Vd,49:$Ve,53:$Vf,54:$Vg,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vy1,[2,77],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO}),o($VU,[2,83],{8:76,9:$VW,13:$VX,37:$VZ}),o($VU,[2,85],{8:76,9:$VW,13:$VX,37:$VZ}),{3:272,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($Vw1,[2,94],{33:$VB,65:$VH,69:$VL}),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:273,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VU1,$Vq1,{11:274,46:$Vr1}),o($VU,[2,86],{8:76,9:$VW,13:$VX,37:$VZ}),{3:275,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($Vw1,[2,95],{33:$VB,65:$VH,69:$VL}),o($VU,[2,87],{8:76,9:$VW,13:$VX,37:$VZ}),{3:276,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($Vw1,[2,96],{33:$VB,65:$VH,69:$VL}),o($VT1,$Vq1,{11:277,46:$Vr1}),o($VT1,$Vq1,{11:278,46:$Vr1}),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:279,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:280,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VU,$VK1,{40:281,89:$VL1}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:282,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU1,$Vq1,{11:283,46:$Vr1}),o($VA1,[2,128],{82:$VB1,88:[1,284],89:[1,285]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:286,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:287,48:$Vd},{15:288,48:$Vd},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:108,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,86:289,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:290,46:$Vz1,48:$Vd},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,15:291,16:$V4,17:66,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,45:292,48:$Vd,49:$VT,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:293,48:$Vd},{48:$VD1,95:294,105:$VE1},{15:295,48:$Vd},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:108,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,86:296,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($V81,[2,200],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VU1,$Vq1,{11:297,46:$Vr1}),o($VT1,$Vq1,{11:298,46:$Vr1}),{19:[1,299],20:[1,300],39:301,47:$VV1,48:$VW1,81:$Vp,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:304,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,194]),{33:$VB,34:[1,305],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{19:[1,306],33:$VB,35:[1,307],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{19:[1,308],47:$VQ1,48:$VR1},o($VG1,$Vq1,{11:309,46:$Vr1}),{22:[1,310],47:$VX1},o([20,22,47],$VS1,{3:12,55:13,6:33,39:40,42:42,98:126,17:127,5:131,100:312,4:$Vj1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$Vl1,53:$Vm1,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vz,$Vq1,{11:313,46:$VH1}),o($VI1,[2,151],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:314,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($VI1,[2,154],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VY1,[2,149]),o($VY1,[2,150]),o($Vc1,[2,12]),{25:[1,315],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{25:[1,316]},{25:[1,317]},{3:318,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},o($Vc1,[2,15]),{25:[1,319],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,18]),o($Vv1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:320,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vc1,[2,20]),o($Vp1,$Vq1,{11:321,46:$Vr1}),o($Vc1,[2,22]),o($Vc1,[2,23]),{8:76,9:$VW,13:$VX,33:[1,322],37:$VZ},o($Vo1,[2,161]),o($Vc1,[2,39]),o($Vc1,[2,40]),{15:323,48:$Vd,78:[1,324]},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:325,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:326,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:327,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:328,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:329,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,38:$Va,39:40,41:$Vb,42:42,81:$Vp,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:330,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{33:$VB,34:[1,331],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:332,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:333,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:334,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU1,$Vq1,{11:335,46:$Vr1}),{52:$VZ1,74:$V_1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:66,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,45:338,49:$VT,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vx1,$VR,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:339,4:$V1,7:$V2,14:$V3,16:$V4,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,41:$Vb,44:$Vc,49:$VT,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw}),o($Vs1,[2,52]),{30:[1,340],47:$VQ1,48:$VR1},o($VU1,$Vq1,{11:341,46:$Vr1}),{12:[1,342],47:$VQ1,48:$VR1},o($Ve1,$Vt1,{33:$VB,34:[1,343],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:344,19:[1,345],21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,88],{8:76,9:$VW,13:$VX,37:$VZ}),o($VU1,$Vq1,{11:346,46:$Vr1}),{20:[1,347],47:$VQ1,48:$VR1},o($VU,[2,89],{8:76,9:$VW,13:$VX,37:$VZ}),o($VU,[2,90],{8:76,9:$VW,13:$VX,37:$VZ}),{12:[1,348],47:$VQ1,48:$VR1},{12:[1,349],47:$VQ1,48:$VR1},o($VT1,$Vq1,{11:350,46:$Vr1}),o($VT1,$Vq1,{11:351,46:$Vr1}),o($VU,[2,119]),o([1,12,19,20,22,24,25,26,30,34,35,46,47,48,71,72,79,81,102,105],[2,121],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,82:[1,352]}),{20:[1,353],47:$VQ1,48:$VR1},{15:354,48:$Vd},{15:355,48:$Vd},o($VC1,[2,148],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VU,[2,132]),o($VU,[2,133]),{15:356,46:$Vz1,48:$Vd},o($V$1,[2,198]),o($VU,[2,136],{92:[1,357]}),{15:358,48:$Vd},o($VU,[2,140]),{15:359,48:$Vd},o($VU,[2,142]),{46:$Vz1,48:[2,202]},{20:[1,360],47:$VQ1,48:$VR1},{12:[1,361],47:$VQ1,48:$VR1},o($Vc1,[2,9]),{19:[1,362]},o($VM1,[2,195]),{39:363,81:$Vp,102:$Vw},{39:364,81:$Vp,102:$Vw},{19:[1,365],33:$VB,35:[1,366],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:367,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,31]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:368,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,$V02,{44:$V12}),{19:[1,370],47:$VQ1,48:$VR1},o($Vc1,[2,47],{44:[1,371]}),{3:12,4:$Vj1,5:131,6:33,7:$V2,14:$V3,16:$V4,17:127,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$Vl1,53:$Vm1,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,98:126,100:372,102:$Vw},o($VI1,[2,158]),{20:[1,373],47:$VX1},o($VU1,$Vq1,{11:374,46:$Vr1}),o($Vc1,[2,13]),o($Vc1,[2,14]),o($Vc1,[2,17]),{8:76,9:$VW,13:$VX,33:[1,375],37:$VZ},o($Vc1,[2,16]),o($VT1,$Vq1,{11:376,46:$Vr1}),{30:[1,377],47:$VQ1,48:$VR1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:379,21:$V5,23:$V6,25:[1,378],29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,166]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:380,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,168],{33:$VB,35:[1,382],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,381]}),o($VM1,[2,173],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,174],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,383]}),o($VM1,[2,176],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,384]}),{8:76,9:$VW,13:$VX,37:$VZ,104:[1,385]},{33:$VB,34:[1,386],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:387,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,191],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,192],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,388]}),o($VU,[2,74]),{20:[1,389],47:$VQ1,48:$VR1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:390,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{15:391,48:$Vd},o($Vs1,[2,53]),o($VU1,$Vq1,{11:392,46:$Vr1}),{74:$V_1},{20:[1,393],47:$VQ1,48:$VR1},o($Vc1,[2,6]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:394,19:[1,395],21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{19:[1,397],33:$VB,35:[1,396],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,38]),{20:[1,398],47:$VQ1,48:$VR1},o($VU,[2,98]),{15:399,48:$Vd},{15:400,48:$Vd},{12:[1,401],47:$VQ1,48:$VR1},{12:[1,402],47:$VQ1,48:$VR1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:403,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,124]),o($VU,[2,129]),o($VU,[2,130]),o($V$1,[2,199]),{15:404,48:$Vd},o($VU,[2,138],{92:[1,405]}),o($VU,[2,141]),o($VU,[2,146]),{15:406,48:$Vd},o($Vc1,[2,10]),o($VM1,[2,196]),o($VM1,[2,197]),o($Vc1,[2,27]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:407,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{19:[1,408],33:$VB,35:[1,409],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{19:[1,410],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,48]),o([9,13,22,32,33,37,46,47,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,96],$V02,{39:221,18:411,44:$V12,81:$Vp,102:$Vw}),o($Vc1,[2,49]),o($VI1,[2,159]),o($VI1,[2,160]),{20:[1,412],47:$VQ1,48:$VR1},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:334,21:$V5,23:$V6,25:[1,413],29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{12:[1,414],47:$VQ1,48:$VR1},{28:[1,415],52:$VZ1,74:$V_1},o($Vc1,[2,24]),{25:[1,416],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{15:417,33:$VB,48:$Vd,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:418,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:419,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:420,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:421,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:422,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:423,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,181],{33:$VB,35:[1,425],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,424]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:426,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VU,[2,80]),o($Vy,[2,66],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VU,[2,114]),{20:[1,427],47:$VQ1,48:$VR1},o($VU,[2,78]),{19:[1,429],33:$VB,35:[1,428],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,36]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:430,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,37]),o($VU,[2,97]),o($VU,[2,115]),o($VU,[2,116]),{15:431,48:$Vd},{15:432,48:$Vd},o($VF1,[2,122],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM}),o($VU,[2,137]),{15:433,48:$Vd},o($Vc1,[2,8]),{19:[1,434],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,29]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:435,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,32]),{22:[1,436],39:301,47:$VV1,48:$VW1,81:$Vp,102:$Vw},o($VI1,[2,152]),o($Vc1,[2,25]),{25:[1,437]},{25:[1,438]},o($Vc1,[2,26]),o($Vc1,$VK1,{40:439,89:$VL1}),o($VM1,[2,169],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,170],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,440]}),o($VM1,[2,175],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,177],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,178],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,441]}),o($VM1,[2,180],{33:$VB,35:[1,443],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,442]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:444,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:445,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,193],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($Vs1,[2,54]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:446,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,35]),{19:[1,447],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($VU,[2,117]),o($VU,[2,118]),o($VU,[2,139]),o($Vc1,[2,28]),{19:[1,448],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,11]),o($Vc1,[2,19]),o($Vc1,[2,21]),o($Vc1,[2,167]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:449,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:450,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:451,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:452,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,183],{33:$VB,35:[1,453],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,185],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,454]}),{19:[1,455],33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP},o($Vc1,[2,34]),o($Vc1,[2,30]),o($VM1,[2,171],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,179],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,182],{33:$VB,35:[1,456],58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,184],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP,82:[1,457]}),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:458,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:459,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($Vc1,[2,33]),{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:460,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},{3:12,4:$V1,5:32,6:33,7:$V2,14:$V3,16:$V4,17:461,21:$V5,23:$V6,29:$VS,31:$V8,32:$V9,38:$Va,39:40,41:$Vb,42:42,44:$Vc,49:$V61,55:13,59:$Vh,60:$Vi,61:$Vj,75:$Vk,76:$Vl,77:$Vm,78:$Vn,80:$Vo,81:$Vp,83:$Vq,84:$Vr,85:$Vs,90:$Vt,93:$Vu,97:$Vv,102:$Vw},o($VM1,[2,189],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,187],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,188],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP}),o($VM1,[2,186],{33:$VB,58:$VC,59:$VD,62:$VE,63:$VF,64:$VG,65:$VH,66:$VI,67:$VJ,68:$VK,69:$VL,70:$VM,71:$VN,72:$VO,79:$VP})],
    defaultActions: {2:[2,204]},
    parseError: function parseError (str, hash) {
        if (hash.recoverable) {
            this.trace(str);
        } else {
            var error = new Error(str);
            error.hash = hash;
            throw error;
        }
    },
    parse: function parse(input) {
        var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
        var args = lstack.slice.call(arguments, 1);
        var lexer = Object.create(this.lexer);
        var sharedState = { yy: {} };
        for (var k in this.yy) {
            if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
                sharedState.yy[k] = this.yy[k];
            }
        }
        lexer.setInput(input, sharedState.yy);
        sharedState.yy.lexer = lexer;
        sharedState.yy.parser = this;
        if (typeof lexer.yylloc == 'undefined') {
            lexer.yylloc = {};
        }
        var yyloc = lexer.yylloc;
        lstack.push(yyloc);
        var ranges = lexer.options && lexer.options.ranges;
        if (typeof sharedState.yy.parseError === 'function') {
            this.parseError = sharedState.yy.parseError;
        } else {
            this.parseError = Object.getPrototypeOf(this).parseError;
        }
        function popStack(n) {
            stack.length = stack.length - 2 * n;
            vstack.length = vstack.length - n;
            lstack.length = lstack.length - n;
        }
        _token_stack:
            var lex = function () {
                var token;
                token = lexer.lex() || EOF;
                if (typeof token !== 'number') {
                    token = self.symbols_[token] || token;
                }
                return token;
            };
        var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
        while (true) {
            state = stack[stack.length - 1];
            if (this.defaultActions[state]) {
                action = this.defaultActions[state];
            } else {
                if (symbol === null || typeof symbol == 'undefined') {
                    symbol = lex();
                }
                action = table[state] && table[state][symbol];
            }
                        if (typeof action === 'undefined' || !action.length || !action[0]) {
                    var errStr = '';
                    expected = [];
                    for (p in table[state]) {
                        if (this.terminals_[p] && p > TERROR) {
                            expected.push('\'' + this.terminals_[p] + '\'');
                        }
                    }
                    if (lexer.showPosition) {
                        errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                    } else {
                        errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                    }
                    this.parseError(errStr, {
                        text: lexer.match,
                        token: this.terminals_[symbol] || symbol,
                        line: lexer.yylineno,
                        loc: yyloc,
                        expected: expected
                    });
                }
            if (action[0] instanceof Array && action.length > 1) {
                throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
            }
            switch (action[0]) {
            case 1:
                stack.push(symbol);
                vstack.push(lexer.yytext);
                lstack.push(lexer.yylloc);
                stack.push(action[1]);
                symbol = null;
                if (!preErrorSymbol) {
                    yyleng = lexer.yyleng;
                    yytext = lexer.yytext;
                    yylineno = lexer.yylineno;
                    yyloc = lexer.yylloc;
                    if (recovering > 0) {
                        recovering--;
                    }
                } else {
                    symbol = preErrorSymbol;
                    preErrorSymbol = null;
                }
                break;
            case 2:
                len = this.productions_[action[1]][1];
                yyval.$ = vstack[vstack.length - len];
                yyval._$ = {
                    first_line: lstack[lstack.length - (len || 1)].first_line,
                    last_line: lstack[lstack.length - 1].last_line,
                    first_column: lstack[lstack.length - (len || 1)].first_column,
                    last_column: lstack[lstack.length - 1].last_column
                };
                if (ranges) {
                    yyval._$.range = [
                        lstack[lstack.length - (len || 1)].range[0],
                        lstack[lstack.length - 1].range[1]
                    ];
                }
                r = this.performAction.apply(yyval, [
                    yytext,
                    yyleng,
                    yylineno,
                    sharedState.yy,
                    action[1],
                    vstack,
                    lstack
                ].concat(args));
                if (typeof r !== 'undefined') {
                    return r;
                }
                if (len) {
                    stack = stack.slice(0, -1 * len * 2);
                    vstack = vstack.slice(0, -1 * len);
                    lstack = lstack.slice(0, -1 * len);
                }
                stack.push(this.productions_[action[1]][0]);
                vstack.push(yyval.$);
                lstack.push(yyval._$);
                newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
                stack.push(newState);
                break;
            case 3:
                return true;
            }
        }
        return true;
    }};
    
    function Parser () {
      this.yy = {};
    }
    Parser.prototype = parser;parser.Parser = Parser;
    return new Parser;
    })();
    
    
    if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
    exports.parser = parser;
    exports.Parser = parser.Parser;
    exports.parse = function () { return parser.parse.apply(parser, arguments); };
    exports.main = function commonjsMain (args) {
        if (!args[1]) {
            console.log('Usage: '+args[0]+' FILE');
            process.exit(1);
        }
        var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
        return exports.parser.parse(source);
    };
    if (typeof module !== 'undefined' && require.main === module) {
      exports.main(process.argv.slice(1));
    }
    }
    
    }).call(this,require('_process'))
    },{"_process":20,"fs":8,"path":13}],6:[function(require,module,exports){
    // Generated by blackpard 1.5.0
    var path, stripString, nameFromPath;
    path = require('path');
    stripString = function(val){
      var that;
      if (that = /^['"](.*)['"]$/.exec(val.trim())) {
        return that[1];
      } else {
        return val;
      }
    };
    nameFromPath = function(modulePath){
      return path.basename(stripString(modulePath)).split('.')[0].replace(/-[a-z]/ig, function(it){
        return it.charAt(1).toUpperCase();
      });
    };
    module.exports = {
      nameFromPath: nameFromPath,
      stripString: stripString
    };
    },{"path":13}],7:[function(require,module,exports){
    'use strict'
    
    exports.byteLength = byteLength
    exports.toByteArray = toByteArray
    exports.fromByteArray = fromByteArray
    
    var lookup = []
    var revLookup = []
    var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
    
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i]
      revLookup[code.charCodeAt(i)] = i
    }
    
    // Support decoding URL-safe base64 strings, as Node.js does.
    // See: https://en.wikipedia.org/wiki/Base64#URL_applications
    revLookup['-'.charCodeAt(0)] = 62
    revLookup['_'.charCodeAt(0)] = 63
    
    function getLens (b64) {
      var len = b64.length
    
      if (len % 4 > 0) {
        throw new Error('Invalid string. Length must be a multiple of 4')
      }
    
      // Trim off extra bytes after placeholder bytes are found
      // See: https://github.com/beatgammit/base64-js/issues/42
      var validLen = b64.indexOf('=')
      if (validLen === -1) validLen = len
    
      var placeHoldersLen = validLen === len
        ? 0
        : 4 - (validLen % 4)
    
      return [validLen, placeHoldersLen]
    }
    
    // base64 is 4/3 + up to two characters of the original data
    function byteLength (b64) {
      var lens = getLens(b64)
      var validLen = lens[0]
      var placeHoldersLen = lens[1]
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }
    
    function _byteLength (b64, validLen, placeHoldersLen) {
      return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
    }
    
    function toByteArray (b64) {
      var tmp
      var lens = getLens(b64)
      var validLen = lens[0]
      var placeHoldersLen = lens[1]
    
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))
    
      var curByte = 0
    
      // if there are placeholders, only get up to the last complete 4 chars
      var len = placeHoldersLen > 0
        ? validLen - 4
        : validLen
    
      for (var i = 0; i < len; i += 4) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 18) |
          (revLookup[b64.charCodeAt(i + 1)] << 12) |
          (revLookup[b64.charCodeAt(i + 2)] << 6) |
          revLookup[b64.charCodeAt(i + 3)]
        arr[curByte++] = (tmp >> 16) & 0xFF
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
      }
    
      if (placeHoldersLen === 2) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 2) |
          (revLookup[b64.charCodeAt(i + 1)] >> 4)
        arr[curByte++] = tmp & 0xFF
      }
    
      if (placeHoldersLen === 1) {
        tmp =
          (revLookup[b64.charCodeAt(i)] << 10) |
          (revLookup[b64.charCodeAt(i + 1)] << 4) |
          (revLookup[b64.charCodeAt(i + 2)] >> 2)
        arr[curByte++] = (tmp >> 8) & 0xFF
        arr[curByte++] = tmp & 0xFF
      }
    
      return arr
    }
    
    function tripletToBase64 (num) {
      return lookup[num >> 18 & 0x3F] +
        lookup[num >> 12 & 0x3F] +
        lookup[num >> 6 & 0x3F] +
        lookup[num & 0x3F]
    }
    
    function encodeChunk (uint8, start, end) {
      var tmp
      var output = []
      for (var i = start; i < end; i += 3) {
        tmp =
          ((uint8[i] << 16) & 0xFF0000) +
          ((uint8[i + 1] << 8) & 0xFF00) +
          (uint8[i + 2] & 0xFF)
        output.push(tripletToBase64(tmp))
      }
      return output.join('')
    }
    
    function fromByteArray (uint8) {
      var tmp
      var len = uint8.length
      var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
      var parts = []
      var maxChunkLength = 16383 // must be multiple of 3
    
      // go through the array every three bytes, we'll deal with trailing stuff later
      for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
        parts.push(encodeChunk(
          uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
        ))
      }
    
      // pad the end with zeros, but make sure to not forget the extra bytes
      if (extraBytes === 1) {
        tmp = uint8[len - 1]
        parts.push(
          lookup[tmp >> 2] +
          lookup[(tmp << 4) & 0x3F] +
          '=='
        )
      } else if (extraBytes === 2) {
        tmp = (uint8[len - 2] << 8) + uint8[len - 1]
        parts.push(
          lookup[tmp >> 10] +
          lookup[(tmp >> 4) & 0x3F] +
          lookup[(tmp << 2) & 0x3F] +
          '='
        )
      }
    
      return parts.join('')
    }
    
    },{}],8:[function(require,module,exports){
    
    },{}],9:[function(require,module,exports){
    (function (global){
    /*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
     * @license  MIT
     */
    /* eslint-disable no-proto */
    
    'use strict'
    
    var base64 = require('base64-js')
    var ieee754 = require('ieee754')
    var isArray = require('isarray')
    
    exports.Buffer = Buffer
    exports.SlowBuffer = SlowBuffer
    exports.INSPECT_MAX_BYTES = 50
    
    /**
     * If `Buffer.TYPED_ARRAY_SUPPORT`:
     *   === true    Use Uint8Array implementation (fastest)
     *   === false   Use Object implementation (most compatible, even IE6)
     *
     * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
     * Opera 11.6+, iOS 4.2+.
     *
     * Due to various browser bugs, sometimes the Object implementation will be used even
     * when the browser supports typed arrays.
     *
     * Note:
     *
     *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
     *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
     *
     *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
     *
     *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
     *     incorrect length in some situations.
    
     * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
     * get the Object implementation, which is slower but behaves correctly.
     */
    Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
      ? global.TYPED_ARRAY_SUPPORT
      : typedArraySupport()
    
    /*
     * Export kMaxLength after typed array support is determined.
     */
    exports.kMaxLength = kMaxLength()
    
    function typedArraySupport () {
      try {
        var arr = new Uint8Array(1)
        arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
        return arr.foo() === 42 && // typed array instances can be augmented
            typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
            arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
      } catch (e) {
        return false
      }
    }
    
    function kMaxLength () {
      return Buffer.TYPED_ARRAY_SUPPORT
        ? 0x7fffffff
        : 0x3fffffff
    }
    
    function createBuffer (that, length) {
      if (kMaxLength() < length) {
        throw new RangeError('Invalid typed array length')
      }
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = new Uint8Array(length)
        that.__proto__ = Buffer.prototype
      } else {
        // Fallback: Return an object instance of the Buffer class
        if (that === null) {
          that = new Buffer(length)
        }
        that.length = length
      }
    
      return that
    }
    
    /**
     * The Buffer constructor returns instances of `Uint8Array` that have their
     * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
     * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
     * and the `Uint8Array` methods. Square bracket notation works as expected -- it
     * returns a single octet.
     *
     * The `Uint8Array` prototype remains unmodified.
     */
    
    function Buffer (arg, encodingOrOffset, length) {
      if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
        return new Buffer(arg, encodingOrOffset, length)
      }
    
      // Common case.
      if (typeof arg === 'number') {
        if (typeof encodingOrOffset === 'string') {
          throw new Error(
            'If encoding is specified then the first argument must be a string'
          )
        }
        return allocUnsafe(this, arg)
      }
      return from(this, arg, encodingOrOffset, length)
    }
    
    Buffer.poolSize = 8192 // not used by this implementation
    
    // TODO: Legacy, not needed anymore. Remove in next major version.
    Buffer._augment = function (arr) {
      arr.__proto__ = Buffer.prototype
      return arr
    }
    
    function from (that, value, encodingOrOffset, length) {
      if (typeof value === 'number') {
        throw new TypeError('"value" argument must not be a number')
      }
    
      if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
        return fromArrayBuffer(that, value, encodingOrOffset, length)
      }
    
      if (typeof value === 'string') {
        return fromString(that, value, encodingOrOffset)
      }
    
      return fromObject(that, value)
    }
    
    /**
     * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
     * if value is a number.
     * Buffer.from(str[, encoding])
     * Buffer.from(array)
     * Buffer.from(buffer)
     * Buffer.from(arrayBuffer[, byteOffset[, length]])
     **/
    Buffer.from = function (value, encodingOrOffset, length) {
      return from(null, value, encodingOrOffset, length)
    }
    
    if (Buffer.TYPED_ARRAY_SUPPORT) {
      Buffer.prototype.__proto__ = Uint8Array.prototype
      Buffer.__proto__ = Uint8Array
      if (typeof Symbol !== 'undefined' && Symbol.species &&
          Buffer[Symbol.species] === Buffer) {
        // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
        Object.defineProperty(Buffer, Symbol.species, {
          value: null,
          configurable: true
        })
      }
    }
    
    function assertSize (size) {
      if (typeof size !== 'number') {
        throw new TypeError('"size" argument must be a number')
      } else if (size < 0) {
        throw new RangeError('"size" argument must not be negative')
      }
    }
    
    function alloc (that, size, fill, encoding) {
      assertSize(size)
      if (size <= 0) {
        return createBuffer(that, size)
      }
      if (fill !== undefined) {
        // Only pay attention to encoding if it's a string. This
        // prevents accidentally sending in a number that would
        // be interpretted as a start offset.
        return typeof encoding === 'string'
          ? createBuffer(that, size).fill(fill, encoding)
          : createBuffer(that, size).fill(fill)
      }
      return createBuffer(that, size)
    }
    
    /**
     * Creates a new filled Buffer instance.
     * alloc(size[, fill[, encoding]])
     **/
    Buffer.alloc = function (size, fill, encoding) {
      return alloc(null, size, fill, encoding)
    }
    
    function allocUnsafe (that, size) {
      assertSize(size)
      that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
      if (!Buffer.TYPED_ARRAY_SUPPORT) {
        for (var i = 0; i < size; ++i) {
          that[i] = 0
        }
      }
      return that
    }
    
    /**
     * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
     * */
    Buffer.allocUnsafe = function (size) {
      return allocUnsafe(null, size)
    }
    /**
     * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
     */
    Buffer.allocUnsafeSlow = function (size) {
      return allocUnsafe(null, size)
    }
    
    function fromString (that, string, encoding) {
      if (typeof encoding !== 'string' || encoding === '') {
        encoding = 'utf8'
      }
    
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding')
      }
    
      var length = byteLength(string, encoding) | 0
      that = createBuffer(that, length)
    
      var actual = that.write(string, encoding)
    
      if (actual !== length) {
        // Writing a hex string, for example, that contains invalid characters will
        // cause everything after the first invalid character to be ignored. (e.g.
        // 'abxxcd' will be treated as 'ab')
        that = that.slice(0, actual)
      }
    
      return that
    }
    
    function fromArrayLike (that, array) {
      var length = array.length < 0 ? 0 : checked(array.length) | 0
      that = createBuffer(that, length)
      for (var i = 0; i < length; i += 1) {
        that[i] = array[i] & 255
      }
      return that
    }
    
    function fromArrayBuffer (that, array, byteOffset, length) {
      array.byteLength // this throws if `array` is not a valid ArrayBuffer
    
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('\'offset\' is out of bounds')
      }
    
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('\'length\' is out of bounds')
      }
    
      if (byteOffset === undefined && length === undefined) {
        array = new Uint8Array(array)
      } else if (length === undefined) {
        array = new Uint8Array(array, byteOffset)
      } else {
        array = new Uint8Array(array, byteOffset, length)
      }
    
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        // Return an augmented `Uint8Array` instance, for best performance
        that = array
        that.__proto__ = Buffer.prototype
      } else {
        // Fallback: Return an object instance of the Buffer class
        that = fromArrayLike(that, array)
      }
      return that
    }
    
    function fromObject (that, obj) {
      if (Buffer.isBuffer(obj)) {
        var len = checked(obj.length) | 0
        that = createBuffer(that, len)
    
        if (that.length === 0) {
          return that
        }
    
        obj.copy(that, 0, 0, len)
        return that
      }
    
      if (obj) {
        if ((typeof ArrayBuffer !== 'undefined' &&
            obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
          if (typeof obj.length !== 'number' || isnan(obj.length)) {
            return createBuffer(that, 0)
          }
          return fromArrayLike(that, obj)
        }
    
        if (obj.type === 'Buffer' && isArray(obj.data)) {
          return fromArrayLike(that, obj.data)
        }
      }
    
      throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
    }
    
    function checked (length) {
      // Note: cannot use `length < kMaxLength()` here because that fails when
      // length is NaN (which is otherwise coerced to zero.)
      if (length >= kMaxLength()) {
        throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                             'size: 0x' + kMaxLength().toString(16) + ' bytes')
      }
      return length | 0
    }
    
    function SlowBuffer (length) {
      if (+length != length) { // eslint-disable-line eqeqeq
        length = 0
      }
      return Buffer.alloc(+length)
    }
    
    Buffer.isBuffer = function isBuffer (b) {
      return !!(b != null && b._isBuffer)
    }
    
    Buffer.compare = function compare (a, b) {
      if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        throw new TypeError('Arguments must be Buffers')
      }
    
      if (a === b) return 0
    
      var x = a.length
      var y = b.length
    
      for (var i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i]
          y = b[i]
          break
        }
      }
    
      if (x < y) return -1
      if (y < x) return 1
      return 0
    }
    
    Buffer.isEncoding = function isEncoding (encoding) {
      switch (String(encoding).toLowerCase()) {
        case 'hex':
        case 'utf8':
        case 'utf-8':
        case 'ascii':
        case 'latin1':
        case 'binary':
        case 'base64':
        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return true
        default:
          return false
      }
    }
    
    Buffer.concat = function concat (list, length) {
      if (!isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers')
      }
    
      if (list.length === 0) {
        return Buffer.alloc(0)
      }
    
      var i
      if (length === undefined) {
        length = 0
        for (i = 0; i < list.length; ++i) {
          length += list[i].length
        }
      }
    
      var buffer = Buffer.allocUnsafe(length)
      var pos = 0
      for (i = 0; i < list.length; ++i) {
        var buf = list[i]
        if (!Buffer.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers')
        }
        buf.copy(buffer, pos)
        pos += buf.length
      }
      return buffer
    }
    
    function byteLength (string, encoding) {
      if (Buffer.isBuffer(string)) {
        return string.length
      }
      if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
          (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
        return string.byteLength
      }
      if (typeof string !== 'string') {
        string = '' + string
      }
    
      var len = string.length
      if (len === 0) return 0
    
      // Use a for loop to avoid recursion
      var loweredCase = false
      for (;;) {
        switch (encoding) {
          case 'ascii':
          case 'latin1':
          case 'binary':
            return len
          case 'utf8':
          case 'utf-8':
          case undefined:
            return utf8ToBytes(string).length
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return len * 2
          case 'hex':
            return len >>> 1
          case 'base64':
            return base64ToBytes(string).length
          default:
            if (loweredCase) return utf8ToBytes(string).length // assume utf8
            encoding = ('' + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }
    Buffer.byteLength = byteLength
    
    function slowToString (encoding, start, end) {
      var loweredCase = false
    
      // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
      // property of a typed array.
    
      // This behaves neither like String nor Uint8Array in that we set start/end
      // to their upper/lower bounds if the value passed is out of range.
      // undefined is handled specially as per ECMA-262 6th Edition,
      // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
      if (start === undefined || start < 0) {
        start = 0
      }
      // Return early if start > this.length. Done here to prevent potential uint32
      // coercion fail below.
      if (start > this.length) {
        return ''
      }
    
      if (end === undefined || end > this.length) {
        end = this.length
      }
    
      if (end <= 0) {
        return ''
      }
    
      // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
      end >>>= 0
      start >>>= 0
    
      if (end <= start) {
        return ''
      }
    
      if (!encoding) encoding = 'utf8'
    
      while (true) {
        switch (encoding) {
          case 'hex':
            return hexSlice(this, start, end)
    
          case 'utf8':
          case 'utf-8':
            return utf8Slice(this, start, end)
    
          case 'ascii':
            return asciiSlice(this, start, end)
    
          case 'latin1':
          case 'binary':
            return latin1Slice(this, start, end)
    
          case 'base64':
            return base64Slice(this, start, end)
    
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return utf16leSlice(this, start, end)
    
          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = (encoding + '').toLowerCase()
            loweredCase = true
        }
      }
    }
    
    // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
    // Buffer instances.
    Buffer.prototype._isBuffer = true
    
    function swap (b, n, m) {
      var i = b[n]
      b[n] = b[m]
      b[m] = i
    }
    
    Buffer.prototype.swap16 = function swap16 () {
      var len = this.length
      if (len % 2 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 16-bits')
      }
      for (var i = 0; i < len; i += 2) {
        swap(this, i, i + 1)
      }
      return this
    }
    
    Buffer.prototype.swap32 = function swap32 () {
      var len = this.length
      if (len % 4 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 32-bits')
      }
      for (var i = 0; i < len; i += 4) {
        swap(this, i, i + 3)
        swap(this, i + 1, i + 2)
      }
      return this
    }
    
    Buffer.prototype.swap64 = function swap64 () {
      var len = this.length
      if (len % 8 !== 0) {
        throw new RangeError('Buffer size must be a multiple of 64-bits')
      }
      for (var i = 0; i < len; i += 8) {
        swap(this, i, i + 7)
        swap(this, i + 1, i + 6)
        swap(this, i + 2, i + 5)
        swap(this, i + 3, i + 4)
      }
      return this
    }
    
    Buffer.prototype.toString = function toString () {
      var length = this.length | 0
      if (length === 0) return ''
      if (arguments.length === 0) return utf8Slice(this, 0, length)
      return slowToString.apply(this, arguments)
    }
    
    Buffer.prototype.equals = function equals (b) {
      if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
      if (this === b) return true
      return Buffer.compare(this, b) === 0
    }
    
    Buffer.prototype.inspect = function inspect () {
      var str = ''
      var max = exports.INSPECT_MAX_BYTES
      if (this.length > 0) {
        str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
        if (this.length > max) str += ' ... '
      }
      return '<Buffer ' + str + '>'
    }
    
    Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
      if (!Buffer.isBuffer(target)) {
        throw new TypeError('Argument must be a Buffer')
      }
    
      if (start === undefined) {
        start = 0
      }
      if (end === undefined) {
        end = target ? target.length : 0
      }
      if (thisStart === undefined) {
        thisStart = 0
      }
      if (thisEnd === undefined) {
        thisEnd = this.length
      }
    
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError('out of range index')
      }
    
      if (thisStart >= thisEnd && start >= end) {
        return 0
      }
      if (thisStart >= thisEnd) {
        return -1
      }
      if (start >= end) {
        return 1
      }
    
      start >>>= 0
      end >>>= 0
      thisStart >>>= 0
      thisEnd >>>= 0
    
      if (this === target) return 0
    
      var x = thisEnd - thisStart
      var y = end - start
      var len = Math.min(x, y)
    
      var thisCopy = this.slice(thisStart, thisEnd)
      var targetCopy = target.slice(start, end)
    
      for (var i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i]
          y = targetCopy[i]
          break
        }
      }
    
      if (x < y) return -1
      if (y < x) return 1
      return 0
    }
    
    // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
    // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
    //
    // Arguments:
    // - buffer - a Buffer to search
    // - val - a string, Buffer, or number
    // - byteOffset - an index into `buffer`; will be clamped to an int32
    // - encoding - an optional encoding, relevant is val is a string
    // - dir - true for indexOf, false for lastIndexOf
    function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
      // Empty buffer means no match
      if (buffer.length === 0) return -1
    
      // Normalize byteOffset
      if (typeof byteOffset === 'string') {
        encoding = byteOffset
        byteOffset = 0
      } else if (byteOffset > 0x7fffffff) {
        byteOffset = 0x7fffffff
      } else if (byteOffset < -0x80000000) {
        byteOffset = -0x80000000
      }
      byteOffset = +byteOffset  // Coerce to Number.
      if (isNaN(byteOffset)) {
        // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
        byteOffset = dir ? 0 : (buffer.length - 1)
      }
    
      // Normalize byteOffset: negative offsets start from the end of the buffer
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset
      if (byteOffset >= buffer.length) {
        if (dir) return -1
        else byteOffset = buffer.length - 1
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0
        else return -1
      }
    
      // Normalize val
      if (typeof val === 'string') {
        val = Buffer.from(val, encoding)
      }
    
      // Finally, search either indexOf (if dir is true) or lastIndexOf
      if (Buffer.isBuffer(val)) {
        // Special case: looking for empty string/buffer always fails
        if (val.length === 0) {
          return -1
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
      } else if (typeof val === 'number') {
        val = val & 0xFF // Search for a byte value [0-255]
        if (Buffer.TYPED_ARRAY_SUPPORT &&
            typeof Uint8Array.prototype.indexOf === 'function') {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
          }
        }
        return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
      }
    
      throw new TypeError('val must be string, number or Buffer')
    }
    
    function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
      var indexSize = 1
      var arrLength = arr.length
      var valLength = val.length
    
      if (encoding !== undefined) {
        encoding = String(encoding).toLowerCase()
        if (encoding === 'ucs2' || encoding === 'ucs-2' ||
            encoding === 'utf16le' || encoding === 'utf-16le') {
          if (arr.length < 2 || val.length < 2) {
            return -1
          }
          indexSize = 2
          arrLength /= 2
          valLength /= 2
          byteOffset /= 2
        }
      }
    
      function read (buf, i) {
        if (indexSize === 1) {
          return buf[i]
        } else {
          return buf.readUInt16BE(i * indexSize)
        }
      }
    
      var i
      if (dir) {
        var foundIndex = -1
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
          } else {
            if (foundIndex !== -1) i -= i - foundIndex
            foundIndex = -1
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
        for (i = byteOffset; i >= 0; i--) {
          var found = true
          for (var j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false
              break
            }
          }
          if (found) return i
        }
      }
    
      return -1
    }
    
    Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1
    }
    
    Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
    }
    
    Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
    }
    
    function hexWrite (buf, string, offset, length) {
      offset = Number(offset) || 0
      var remaining = buf.length - offset
      if (!length) {
        length = remaining
      } else {
        length = Number(length)
        if (length > remaining) {
          length = remaining
        }
      }
    
      // must be an even number of digits
      var strLen = string.length
      if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
    
      if (length > strLen / 2) {
        length = strLen / 2
      }
      for (var i = 0; i < length; ++i) {
        var parsed = parseInt(string.substr(i * 2, 2), 16)
        if (isNaN(parsed)) return i
        buf[offset + i] = parsed
      }
      return i
    }
    
    function utf8Write (buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
    }
    
    function asciiWrite (buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length)
    }
    
    function latin1Write (buf, string, offset, length) {
      return asciiWrite(buf, string, offset, length)
    }
    
    function base64Write (buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length)
    }
    
    function ucs2Write (buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
    }
    
    Buffer.prototype.write = function write (string, offset, length, encoding) {
      // Buffer#write(string)
      if (offset === undefined) {
        encoding = 'utf8'
        length = this.length
        offset = 0
      // Buffer#write(string, encoding)
      } else if (length === undefined && typeof offset === 'string') {
        encoding = offset
        length = this.length
        offset = 0
      // Buffer#write(string, offset[, length][, encoding])
      } else if (isFinite(offset)) {
        offset = offset | 0
        if (isFinite(length)) {
          length = length | 0
          if (encoding === undefined) encoding = 'utf8'
        } else {
          encoding = length
          length = undefined
        }
      // legacy write(string, encoding, offset, length) - remove in v0.13
      } else {
        throw new Error(
          'Buffer.write(string, encoding, offset[, length]) is no longer supported'
        )
      }
    
      var remaining = this.length - offset
      if (length === undefined || length > remaining) length = remaining
    
      if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
        throw new RangeError('Attempt to write outside buffer bounds')
      }
    
      if (!encoding) encoding = 'utf8'
    
      var loweredCase = false
      for (;;) {
        switch (encoding) {
          case 'hex':
            return hexWrite(this, string, offset, length)
    
          case 'utf8':
          case 'utf-8':
            return utf8Write(this, string, offset, length)
    
          case 'ascii':
            return asciiWrite(this, string, offset, length)
    
          case 'latin1':
          case 'binary':
            return latin1Write(this, string, offset, length)
    
          case 'base64':
            // Warning: maxLength not taken into account in base64Write
            return base64Write(this, string, offset, length)
    
          case 'ucs2':
          case 'ucs-2':
          case 'utf16le':
          case 'utf-16le':
            return ucs2Write(this, string, offset, length)
    
          default:
            if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
            encoding = ('' + encoding).toLowerCase()
            loweredCase = true
        }
      }
    }
    
    Buffer.prototype.toJSON = function toJSON () {
      return {
        type: 'Buffer',
        data: Array.prototype.slice.call(this._arr || this, 0)
      }
    }
    
    function base64Slice (buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf)
      } else {
        return base64.fromByteArray(buf.slice(start, end))
      }
    }
    
    function utf8Slice (buf, start, end) {
      end = Math.min(buf.length, end)
      var res = []
    
      var i = start
      while (i < end) {
        var firstByte = buf[i]
        var codePoint = null
        var bytesPerSequence = (firstByte > 0xEF) ? 4
          : (firstByte > 0xDF) ? 3
          : (firstByte > 0xBF) ? 2
          : 1
    
        if (i + bytesPerSequence <= end) {
          var secondByte, thirdByte, fourthByte, tempCodePoint
    
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 0x80) {
                codePoint = firstByte
              }
              break
            case 2:
              secondByte = buf[i + 1]
              if ((secondByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
                if (tempCodePoint > 0x7F) {
                  codePoint = tempCodePoint
                }
              }
              break
            case 3:
              secondByte = buf[i + 1]
              thirdByte = buf[i + 2]
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
                if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                  codePoint = tempCodePoint
                }
              }
              break
            case 4:
              secondByte = buf[i + 1]
              thirdByte = buf[i + 2]
              fourthByte = buf[i + 3]
              if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
                if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                  codePoint = tempCodePoint
                }
              }
          }
        }
    
        if (codePoint === null) {
          // we did not generate a valid codePoint so insert a
          // replacement char (U+FFFD) and advance only 1 byte
          codePoint = 0xFFFD
          bytesPerSequence = 1
        } else if (codePoint > 0xFFFF) {
          // encode to utf16 (surrogate pair dance)
          codePoint -= 0x10000
          res.push(codePoint >>> 10 & 0x3FF | 0xD800)
          codePoint = 0xDC00 | codePoint & 0x3FF
        }
    
        res.push(codePoint)
        i += bytesPerSequence
      }
    
      return decodeCodePointsArray(res)
    }
    
    // Based on http://stackoverflow.com/a/22747272/680742, the browser with
    // the lowest limit is Chrome, with 0x10000 args.
    // We go 1 magnitude less, for safety
    var MAX_ARGUMENTS_LENGTH = 0x1000
    
    function decodeCodePointsArray (codePoints) {
      var len = codePoints.length
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
      }
    
      // Decode in chunks to avoid "call stack size exceeded".
      var res = ''
      var i = 0
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        )
      }
      return res
    }
    
    function asciiSlice (buf, start, end) {
      var ret = ''
      end = Math.min(buf.length, end)
    
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 0x7F)
      }
      return ret
    }
    
    function latin1Slice (buf, start, end) {
      var ret = ''
      end = Math.min(buf.length, end)
    
      for (var i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i])
      }
      return ret
    }
    
    function hexSlice (buf, start, end) {
      var len = buf.length
    
      if (!start || start < 0) start = 0
      if (!end || end < 0 || end > len) end = len
    
      var out = ''
      for (var i = start; i < end; ++i) {
        out += toHex(buf[i])
      }
      return out
    }
    
    function utf16leSlice (buf, start, end) {
      var bytes = buf.slice(start, end)
      var res = ''
      for (var i = 0; i < bytes.length; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
      }
      return res
    }
    
    Buffer.prototype.slice = function slice (start, end) {
      var len = this.length
      start = ~~start
      end = end === undefined ? len : ~~end
    
      if (start < 0) {
        start += len
        if (start < 0) start = 0
      } else if (start > len) {
        start = len
      }
    
      if (end < 0) {
        end += len
        if (end < 0) end = 0
      } else if (end > len) {
        end = len
      }
    
      if (end < start) end = start
    
      var newBuf
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        newBuf = this.subarray(start, end)
        newBuf.__proto__ = Buffer.prototype
      } else {
        var sliceLen = end - start
        newBuf = new Buffer(sliceLen, undefined)
        for (var i = 0; i < sliceLen; ++i) {
          newBuf[i] = this[i + start]
        }
      }
    
      return newBuf
    }
    
    /*
     * Need to make sure that buffer isn't trying to write out of bounds.
     */
    function checkOffset (offset, ext, length) {
      if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
      if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
    }
    
    Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul
      }
    
      return val
    }
    
    Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) {
        checkOffset(offset, byteLength, this.length)
      }
    
      var val = this[offset + --byteLength]
      var mul = 1
      while (byteLength > 0 && (mul *= 0x100)) {
        val += this[offset + --byteLength] * mul
      }
    
      return val
    }
    
    Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length)
      return this[offset]
    }
    
    Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      return this[offset] | (this[offset + 1] << 8)
    }
    
    Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      return (this[offset] << 8) | this[offset + 1]
    }
    
    Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return ((this[offset]) |
          (this[offset + 1] << 8) |
          (this[offset + 2] << 16)) +
          (this[offset + 3] * 0x1000000)
    }
    
    Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset] * 0x1000000) +
        ((this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        this[offset + 3])
    }
    
    Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      var val = this[offset]
      var mul = 1
      var i = 0
      while (++i < byteLength && (mul *= 0x100)) {
        val += this[offset + i] * mul
      }
      mul *= 0x80
    
      if (val >= mul) val -= Math.pow(2, 8 * byteLength)
    
      return val
    }
    
    Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) checkOffset(offset, byteLength, this.length)
    
      var i = byteLength
      var mul = 1
      var val = this[offset + --i]
      while (i > 0 && (mul *= 0x100)) {
        val += this[offset + --i] * mul
      }
      mul *= 0x80
    
      if (val >= mul) val -= Math.pow(2, 8 * byteLength)
    
      return val
    }
    
    Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 1, this.length)
      if (!(this[offset] & 0x80)) return (this[offset])
      return ((0xff - this[offset] + 1) * -1)
    }
    
    Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      var val = this[offset] | (this[offset + 1] << 8)
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    }
    
    Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 2, this.length)
      var val = this[offset + 1] | (this[offset] << 8)
      return (val & 0x8000) ? val | 0xFFFF0000 : val
    }
    
    Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset]) |
        (this[offset + 1] << 8) |
        (this[offset + 2] << 16) |
        (this[offset + 3] << 24)
    }
    
    Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
    
      return (this[offset] << 24) |
        (this[offset + 1] << 16) |
        (this[offset + 2] << 8) |
        (this[offset + 3])
    }
    
    Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
      return ieee754.read(this, offset, true, 23, 4)
    }
    
    Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 4, this.length)
      return ieee754.read(this, offset, false, 23, 4)
    }
    
    Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length)
      return ieee754.read(this, offset, true, 52, 8)
    }
    
    Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
      if (!noAssert) checkOffset(offset, 8, this.length)
      return ieee754.read(this, offset, false, 52, 8)
    }
    
    function checkInt (buf, value, offset, ext, max, min) {
      if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
    }
    
    Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1
        checkInt(this, value, offset, byteLength, maxBytes, 0)
      }
    
      var mul = 1
      var i = 0
      this[offset] = value & 0xFF
      while (++i < byteLength && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      byteLength = byteLength | 0
      if (!noAssert) {
        var maxBytes = Math.pow(2, 8 * byteLength) - 1
        checkInt(this, value, offset, byteLength, maxBytes, 0)
      }
    
      var i = byteLength - 1
      var mul = 1
      this[offset + i] = value & 0xFF
      while (--i >= 0 && (mul *= 0x100)) {
        this[offset + i] = (value / mul) & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
      this[offset] = (value & 0xff)
      return offset + 1
    }
    
    function objectWriteUInt16 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffff + value + 1
      for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
        buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
          (littleEndian ? i : 1 - i) * 8
      }
    }
    
    Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
      } else {
        objectWriteUInt16(this, value, offset, true)
      }
      return offset + 2
    }
    
    Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8)
        this[offset + 1] = (value & 0xff)
      } else {
        objectWriteUInt16(this, value, offset, false)
      }
      return offset + 2
    }
    
    function objectWriteUInt32 (buf, value, offset, littleEndian) {
      if (value < 0) value = 0xffffffff + value + 1
      for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
        buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
      }
    }
    
    Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset + 3] = (value >>> 24)
        this[offset + 2] = (value >>> 16)
        this[offset + 1] = (value >>> 8)
        this[offset] = (value & 0xff)
      } else {
        objectWriteUInt32(this, value, offset, true)
      }
      return offset + 4
    }
    
    Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24)
        this[offset + 1] = (value >>> 16)
        this[offset + 2] = (value >>> 8)
        this[offset + 3] = (value & 0xff)
      } else {
        objectWriteUInt32(this, value, offset, false)
      }
      return offset + 4
    }
    
    Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1)
    
        checkInt(this, value, offset, byteLength, limit - 1, -limit)
      }
    
      var i = 0
      var mul = 1
      var sub = 0
      this[offset] = value & 0xFF
      while (++i < byteLength && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) {
        var limit = Math.pow(2, 8 * byteLength - 1)
    
        checkInt(this, value, offset, byteLength, limit - 1, -limit)
      }
    
      var i = byteLength - 1
      var mul = 1
      var sub = 0
      this[offset + i] = value & 0xFF
      while (--i >= 0 && (mul *= 0x100)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1
        }
        this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
      }
    
      return offset + byteLength
    }
    
    Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
      if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
      if (value < 0) value = 0xff + value + 1
      this[offset] = (value & 0xff)
      return offset + 1
    }
    
    Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
      } else {
        objectWriteUInt16(this, value, offset, true)
      }
      return offset + 2
    }
    
    Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 8)
        this[offset + 1] = (value & 0xff)
      } else {
        objectWriteUInt16(this, value, offset, false)
      }
      return offset + 2
    }
    
    Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value & 0xff)
        this[offset + 1] = (value >>> 8)
        this[offset + 2] = (value >>> 16)
        this[offset + 3] = (value >>> 24)
      } else {
        objectWriteUInt32(this, value, offset, true)
      }
      return offset + 4
    }
    
    Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
      value = +value
      offset = offset | 0
      if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
      if (value < 0) value = 0xffffffff + value + 1
      if (Buffer.TYPED_ARRAY_SUPPORT) {
        this[offset] = (value >>> 24)
        this[offset + 1] = (value >>> 16)
        this[offset + 2] = (value >>> 8)
        this[offset + 3] = (value & 0xff)
      } else {
        objectWriteUInt32(this, value, offset, false)
      }
      return offset + 4
    }
    
    function checkIEEE754 (buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError('Index out of range')
      if (offset < 0) throw new RangeError('Index out of range')
    }
    
    function writeFloat (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4)
      return offset + 4
    }
    
    Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert)
    }
    
    Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert)
    }
    
    function writeDouble (buf, value, offset, littleEndian, noAssert) {
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8)
      return offset + 8
    }
    
    Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert)
    }
    
    Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert)
    }
    
    // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
    Buffer.prototype.copy = function copy (target, targetStart, start, end) {
      if (!start) start = 0
      if (!end && end !== 0) end = this.length
      if (targetStart >= target.length) targetStart = target.length
      if (!targetStart) targetStart = 0
      if (end > 0 && end < start) end = start
    
      // Copy 0 bytes; we're done
      if (end === start) return 0
      if (target.length === 0 || this.length === 0) return 0
    
      // Fatal error conditions
      if (targetStart < 0) {
        throw new RangeError('targetStart out of bounds')
      }
      if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
      if (end < 0) throw new RangeError('sourceEnd out of bounds')
    
      // Are we oob?
      if (end > this.length) end = this.length
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start
      }
    
      var len = end - start
      var i
    
      if (this === target && start < targetStart && targetStart < end) {
        // descending copy from end
        for (i = len - 1; i >= 0; --i) {
          target[i + targetStart] = this[i + start]
        }
      } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
        // ascending copy from start
        for (i = 0; i < len; ++i) {
          target[i + targetStart] = this[i + start]
        }
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, start + len),
          targetStart
        )
      }
    
      return len
    }
    
    // Usage:
    //    buffer.fill(number[, offset[, end]])
    //    buffer.fill(buffer[, offset[, end]])
    //    buffer.fill(string[, offset[, end]][, encoding])
    Buffer.prototype.fill = function fill (val, start, end, encoding) {
      // Handle string cases:
      if (typeof val === 'string') {
        if (typeof start === 'string') {
          encoding = start
          start = 0
          end = this.length
        } else if (typeof end === 'string') {
          encoding = end
          end = this.length
        }
        if (val.length === 1) {
          var code = val.charCodeAt(0)
          if (code < 256) {
            val = code
          }
        }
        if (encoding !== undefined && typeof encoding !== 'string') {
          throw new TypeError('encoding must be a string')
        }
        if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
          throw new TypeError('Unknown encoding: ' + encoding)
        }
      } else if (typeof val === 'number') {
        val = val & 255
      }
    
      // Invalid ranges are not set to a default, so can range check early.
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError('Out of range index')
      }
    
      if (end <= start) {
        return this
      }
    
      start = start >>> 0
      end = end === undefined ? this.length : end >>> 0
    
      if (!val) val = 0
    
      var i
      if (typeof val === 'number') {
        for (i = start; i < end; ++i) {
          this[i] = val
        }
      } else {
        var bytes = Buffer.isBuffer(val)
          ? val
          : utf8ToBytes(new Buffer(val, encoding).toString())
        var len = bytes.length
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len]
        }
      }
    
      return this
    }
    
    // HELPER FUNCTIONS
    // ================
    
    var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
    
    function base64clean (str) {
      // Node strips out invalid characters like \n and \t from the string, base64-js does not
      str = stringtrim(str).replace(INVALID_BASE64_RE, '')
      // Node converts strings with length < 2 to ''
      if (str.length < 2) return ''
      // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
      while (str.length % 4 !== 0) {
        str = str + '='
      }
      return str
    }
    
    function stringtrim (str) {
      if (str.trim) return str.trim()
      return str.replace(/^\s+|\s+$/g, '')
    }
    
    function toHex (n) {
      if (n < 16) return '0' + n.toString(16)
      return n.toString(16)
    }
    
    function utf8ToBytes (string, units) {
      units = units || Infinity
      var codePoint
      var length = string.length
      var leadSurrogate = null
      var bytes = []
    
      for (var i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i)
    
        // is surrogate component
        if (codePoint > 0xD7FF && codePoint < 0xE000) {
          // last char was a lead
          if (!leadSurrogate) {
            // no lead yet
            if (codePoint > 0xDBFF) {
              // unexpected trail
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              continue
            } else if (i + 1 === length) {
              // unpaired lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
              continue
            }
    
            // valid lead
            leadSurrogate = codePoint
    
            continue
          }
    
          // 2 leads in a row
          if (codePoint < 0xDC00) {
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
            leadSurrogate = codePoint
            continue
          }
    
          // valid surrogate pair
          codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
        } else if (leadSurrogate) {
          // valid bmp char, but last char was a lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        }
    
        leadSurrogate = null
    
        // encode utf8
        if (codePoint < 0x80) {
          if ((units -= 1) < 0) break
          bytes.push(codePoint)
        } else if (codePoint < 0x800) {
          if ((units -= 2) < 0) break
          bytes.push(
            codePoint >> 0x6 | 0xC0,
            codePoint & 0x3F | 0x80
          )
        } else if (codePoint < 0x10000) {
          if ((units -= 3) < 0) break
          bytes.push(
            codePoint >> 0xC | 0xE0,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          )
        } else if (codePoint < 0x110000) {
          if ((units -= 4) < 0) break
          bytes.push(
            codePoint >> 0x12 | 0xF0,
            codePoint >> 0xC & 0x3F | 0x80,
            codePoint >> 0x6 & 0x3F | 0x80,
            codePoint & 0x3F | 0x80
          )
        } else {
          throw new Error('Invalid code point')
        }
      }
    
      return bytes
    }
    
    function asciiToBytes (str) {
      var byteArray = []
      for (var i = 0; i < str.length; ++i) {
        // Node's code seems to be doing this and not & 0x7F..
        byteArray.push(str.charCodeAt(i) & 0xFF)
      }
      return byteArray
    }
    
    function utf16leToBytes (str, units) {
      var c, hi, lo
      var byteArray = []
      for (var i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break
    
        c = str.charCodeAt(i)
        hi = c >> 8
        lo = c % 256
        byteArray.push(lo)
        byteArray.push(hi)
      }
    
      return byteArray
    }
    
    function base64ToBytes (str) {
      return base64.toByteArray(base64clean(str))
    }
    
    function blitBuffer (src, dst, offset, length) {
      for (var i = 0; i < length; ++i) {
        if ((i + offset >= dst.length) || (i >= src.length)) break
        dst[i + offset] = src[i]
      }
      return i
    }
    
    function isnan (val) {
      return val !== val // eslint-disable-line no-self-compare
    }
    
    }).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
    },{"base64-js":7,"ieee754":11,"isarray":12}],10:[function(require,module,exports){
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    function EventEmitter() {
      this._events = this._events || {};
      this._maxListeners = this._maxListeners || undefined;
    }
    module.exports = EventEmitter;
    
    // Backwards-compat with node 0.10.x
    EventEmitter.EventEmitter = EventEmitter;
    
    EventEmitter.prototype._events = undefined;
    EventEmitter.prototype._maxListeners = undefined;
    
    // By default EventEmitters will print a warning if more than 10 listeners are
    // added to it. This is a useful default which helps finding memory leaks.
    EventEmitter.defaultMaxListeners = 10;
    
    // Obviously not all Emitters should be limited to 10. This function allows
    // that to be increased. Set to zero for unlimited.
    EventEmitter.prototype.setMaxListeners = function(n) {
      if (!isNumber(n) || n < 0 || isNaN(n))
        throw TypeError('n must be a positive number');
      this._maxListeners = n;
      return this;
    };
    
    EventEmitter.prototype.emit = function(type) {
      var er, handler, len, args, i, listeners;
    
      if (!this._events)
        this._events = {};
    
      // If there is no 'error' event listener then throw.
      if (type === 'error') {
        if (!this._events.error ||
            (isObject(this._events.error) && !this._events.error.length)) {
          er = arguments[1];
          if (er instanceof Error) {
            throw er; // Unhandled 'error' event
          } else {
            // At least give some kind of context to the user
            var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
            err.context = er;
            throw err;
          }
        }
      }
    
      handler = this._events[type];
    
      if (isUndefined(handler))
        return false;
    
      if (isFunction(handler)) {
        switch (arguments.length) {
          // fast cases
          case 1:
            handler.call(this);
            break;
          case 2:
            handler.call(this, arguments[1]);
            break;
          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
          // slower
          default:
            args = Array.prototype.slice.call(arguments, 1);
            handler.apply(this, args);
        }
      } else if (isObject(handler)) {
        args = Array.prototype.slice.call(arguments, 1);
        listeners = handler.slice();
        len = listeners.length;
        for (i = 0; i < len; i++)
          listeners[i].apply(this, args);
      }
    
      return true;
    };
    
    EventEmitter.prototype.addListener = function(type, listener) {
      var m;
    
      if (!isFunction(listener))
        throw TypeError('listener must be a function');
    
      if (!this._events)
        this._events = {};
    
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (this._events.newListener)
        this.emit('newListener', type,
                  isFunction(listener.listener) ?
                  listener.listener : listener);
    
      if (!this._events[type])
        // Optimize the case of one listener. Don't need the extra array object.
        this._events[type] = listener;
      else if (isObject(this._events[type]))
        // If we've already got an array, just append.
        this._events[type].push(listener);
      else
        // Adding the second element, need to change to array.
        this._events[type] = [this._events[type], listener];
    
      // Check for listener leak
      if (isObject(this._events[type]) && !this._events[type].warned) {
        if (!isUndefined(this._maxListeners)) {
          m = this._maxListeners;
        } else {
          m = EventEmitter.defaultMaxListeners;
        }
    
        if (m && m > 0 && this._events[type].length > m) {
          this._events[type].warned = true;
          console.error('(node) warning: possible EventEmitter memory ' +
                        'leak detected. %d listeners added. ' +
                        'Use emitter.setMaxListeners() to increase limit.',
                        this._events[type].length);
          if (typeof console.trace === 'function') {
            // not supported in IE 10
            console.trace();
          }
        }
      }
    
      return this;
    };
    
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    
    EventEmitter.prototype.once = function(type, listener) {
      if (!isFunction(listener))
        throw TypeError('listener must be a function');
    
      var fired = false;
    
      function g() {
        this.removeListener(type, g);
    
        if (!fired) {
          fired = true;
          listener.apply(this, arguments);
        }
      }
    
      g.listener = listener;
      this.on(type, g);
    
      return this;
    };
    
    // emits a 'removeListener' event iff the listener was removed
    EventEmitter.prototype.removeListener = function(type, listener) {
      var list, position, length, i;
    
      if (!isFunction(listener))
        throw TypeError('listener must be a function');
    
      if (!this._events || !this._events[type])
        return this;
    
      list = this._events[type];
      length = list.length;
      position = -1;
    
      if (list === listener ||
          (isFunction(list.listener) && list.listener === listener)) {
        delete this._events[type];
        if (this._events.removeListener)
          this.emit('removeListener', type, listener);
    
      } else if (isObject(list)) {
        for (i = length; i-- > 0;) {
          if (list[i] === listener ||
              (list[i].listener && list[i].listener === listener)) {
            position = i;
            break;
          }
        }
    
        if (position < 0)
          return this;
    
        if (list.length === 1) {
          list.length = 0;
          delete this._events[type];
        } else {
          list.splice(position, 1);
        }
    
        if (this._events.removeListener)
          this.emit('removeListener', type, listener);
      }
    
      return this;
    };
    
    EventEmitter.prototype.removeAllListeners = function(type) {
      var key, listeners;
    
      if (!this._events)
        return this;
    
      // not listening for removeListener, no need to emit
      if (!this._events.removeListener) {
        if (arguments.length === 0)
          this._events = {};
        else if (this._events[type])
          delete this._events[type];
        return this;
      }
    
      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        for (key in this._events) {
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = {};
        return this;
      }
    
      listeners = this._events[type];
    
      if (isFunction(listeners)) {
        this.removeListener(type, listeners);
      } else if (listeners) {
        // LIFO order
        while (listeners.length)
          this.removeListener(type, listeners[listeners.length - 1]);
      }
      delete this._events[type];
    
      return this;
    };
    
    EventEmitter.prototype.listeners = function(type) {
      var ret;
      if (!this._events || !this._events[type])
        ret = [];
      else if (isFunction(this._events[type]))
        ret = [this._events[type]];
      else
        ret = this._events[type].slice();
      return ret;
    };
    
    EventEmitter.prototype.listenerCount = function(type) {
      if (this._events) {
        var evlistener = this._events[type];
    
        if (isFunction(evlistener))
          return 1;
        else if (evlistener)
          return evlistener.length;
      }
      return 0;
    };
    
    EventEmitter.listenerCount = function(emitter, type) {
      return emitter.listenerCount(type);
    };
    
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    
    function isUndefined(arg) {
      return arg === void 0;
    }
    
    },{}],11:[function(require,module,exports){
    exports.read = function (buffer, offset, isLE, mLen, nBytes) {
      var e, m
      var eLen = (nBytes * 8) - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var nBits = -7
      var i = isLE ? (nBytes - 1) : 0
      var d = isLE ? -1 : 1
      var s = buffer[offset + i]
    
      i += d
    
      e = s & ((1 << (-nBits)) - 1)
      s >>= (-nBits)
      nBits += eLen
      for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}
    
      m = e & ((1 << (-nBits)) - 1)
      e >>= (-nBits)
      nBits += mLen
      for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}
    
      if (e === 0) {
        e = 1 - eBias
      } else if (e === eMax) {
        return m ? NaN : ((s ? -1 : 1) * Infinity)
      } else {
        m = m + Math.pow(2, mLen)
        e = e - eBias
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
    }
    
    exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c
      var eLen = (nBytes * 8) - mLen - 1
      var eMax = (1 << eLen) - 1
      var eBias = eMax >> 1
      var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
      var i = isLE ? 0 : (nBytes - 1)
      var d = isLE ? 1 : -1
      var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
    
      value = Math.abs(value)
    
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0
        e = eMax
      } else {
        e = Math.floor(Math.log(value) / Math.LN2)
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--
          c *= 2
        }
        if (e + eBias >= 1) {
          value += rt / c
        } else {
          value += rt * Math.pow(2, 1 - eBias)
        }
        if (value * c >= 2) {
          e++
          c /= 2
        }
    
        if (e + eBias >= eMax) {
          m = 0
          e = eMax
        } else if (e + eBias >= 1) {
          m = ((value * c) - 1) * Math.pow(2, mLen)
          e = e + eBias
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
          e = 0
        }
      }
    
      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
    
      e = (e << mLen) | m
      eLen += mLen
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
    
      buffer[offset + i - d] |= s * 128
    }
    
    },{}],12:[function(require,module,exports){
    var toString = {}.toString;
    
    module.exports = Array.isArray || function (arr) {
      return toString.call(arr) == '[object Array]';
    };
    
    },{}],13:[function(require,module,exports){
    (function (process){
    // .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
    // backported and transplited with Babel, with backwards-compat fixes
    
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    
    // resolves . and .. elements in a path array with directory names there
    // must be no slashes, empty elements, or device names (c:\) in the array
    // (so also no leading and trailing slashes - it does not distinguish
    // relative and absolute paths)
    function normalizeArray(parts, allowAboveRoot) {
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = parts.length - 1; i >= 0; i--) {
        var last = parts[i];
        if (last === '.') {
          parts.splice(i, 1);
        } else if (last === '..') {
          parts.splice(i, 1);
          up++;
        } else if (up) {
          parts.splice(i, 1);
          up--;
        }
      }
    
      // if the path is allowed to go above the root, restore leading ..s
      if (allowAboveRoot) {
        for (; up--; up) {
          parts.unshift('..');
        }
      }
    
      return parts;
    }
    
    // path.resolve([from ...], to)
    // posix version
    exports.resolve = function() {
      var resolvedPath = '',
          resolvedAbsolute = false;
    
      for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
        var path = (i >= 0) ? arguments[i] : process.cwd();
    
        // Skip empty and invalid entries
        if (typeof path !== 'string') {
          throw new TypeError('Arguments to path.resolve must be strings');
        } else if (!path) {
          continue;
        }
    
        resolvedPath = path + '/' + resolvedPath;
        resolvedAbsolute = path.charAt(0) === '/';
      }
    
      // At this point the path should be resolved to a full absolute path, but
      // handle relative paths to be safe (might happen when process.cwd() fails)
    
      // Normalize the path
      resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
        return !!p;
      }), !resolvedAbsolute).join('/');
    
      return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
    };
    
    // path.normalize(path)
    // posix version
    exports.normalize = function(path) {
      var isAbsolute = exports.isAbsolute(path),
          trailingSlash = substr(path, -1) === '/';
    
      // Normalize the path
      path = normalizeArray(filter(path.split('/'), function(p) {
        return !!p;
      }), !isAbsolute).join('/');
    
      if (!path && !isAbsolute) {
        path = '.';
      }
      if (path && trailingSlash) {
        path += '/';
      }
    
      return (isAbsolute ? '/' : '') + path;
    };
    
    // posix version
    exports.isAbsolute = function(path) {
      return path.charAt(0) === '/';
    };
    
    // posix version
    exports.join = function() {
      var paths = Array.prototype.slice.call(arguments, 0);
      return exports.normalize(filter(paths, function(p, index) {
        if (typeof p !== 'string') {
          throw new TypeError('Arguments to path.join must be strings');
        }
        return p;
      }).join('/'));
    };
    
    
    // path.relative(from, to)
    // posix version
    exports.relative = function(from, to) {
      from = exports.resolve(from).substr(1);
      to = exports.resolve(to).substr(1);
    
      function trim(arr) {
        var start = 0;
        for (; start < arr.length; start++) {
          if (arr[start] !== '') break;
        }
    
        var end = arr.length - 1;
        for (; end >= 0; end--) {
          if (arr[end] !== '') break;
        }
    
        if (start > end) return [];
        return arr.slice(start, end - start + 1);
      }
    
      var fromParts = trim(from.split('/'));
      var toParts = trim(to.split('/'));
    
      var length = Math.min(fromParts.length, toParts.length);
      var samePartsLength = length;
      for (var i = 0; i < length; i++) {
        if (fromParts[i] !== toParts[i]) {
          samePartsLength = i;
          break;
        }
      }
    
      var outputParts = [];
      for (var i = samePartsLength; i < fromParts.length; i++) {
        outputParts.push('..');
      }
    
      outputParts = outputParts.concat(toParts.slice(samePartsLength));
    
      return outputParts.join('/');
    };
    
    exports.sep = '/';
    exports.delimiter = ':';
    
    exports.dirname = function (path) {
      if (typeof path !== 'string') path = path + '';
      if (path.length === 0) return '.';
      var code = path.charCodeAt(0);
      var hasRoot = code === 47 /*/*/;
      var end = -1;
      var matchedSlash = true;
      for (var i = path.length - 1; i >= 1; --i) {
        code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            if (!matchedSlash) {
              end = i;
              break;
            }
          } else {
          // We saw the first non-path separator
          matchedSlash = false;
        }
      }
    
      if (end === -1) return hasRoot ? '/' : '.';
      if (hasRoot && end === 1) {
        // return '//';
        // Backwards-compat fix:
        return '/';
      }
      return path.slice(0, end);
    };
    
    function basename(path) {
      if (typeof path !== 'string') path = path + '';
    
      var start = 0;
      var end = -1;
      var matchedSlash = true;
      var i;
    
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }
    
      if (end === -1) return '';
      return path.slice(start, end);
    }
    
    // Uses a mixed approach for backwards-compatibility, as ext behavior changed
    // in new Node.js versions, so only basename() above is backported here
    exports.basename = function (path, ext) {
      var f = basename(path);
      if (ext && f.substr(-1 * ext.length) === ext) {
        f = f.substr(0, f.length - ext.length);
      }
      return f;
    };
    
    exports.extname = function (path) {
      if (typeof path !== 'string') path = path + '';
      var startDot = -1;
      var startPart = 0;
      var end = -1;
      var matchedSlash = true;
      // Track the state of characters (if any) we see before our first dot and
      // after any path separator we find
      var preDotState = 0;
      for (var i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              startPart = i + 1;
              break;
            }
            continue;
          }
        if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // extension
          matchedSlash = false;
          end = i + 1;
        }
        if (code === 46 /*.*/) {
            // If this is our first dot, mark it as the start of our extension
            if (startDot === -1)
              startDot = i;
            else if (preDotState !== 1)
              preDotState = 1;
        } else if (startDot !== -1) {
          // We saw a non-dot and non-path separator before our dot, so we should
          // have a good chance at having a non-empty extension
          preDotState = -1;
        }
      }
    
      if (startDot === -1 || end === -1 ||
          // We saw a non-dot character immediately before the dot
          preDotState === 0 ||
          // The (right-most) trimmed path component is exactly '..'
          preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return '';
      }
      return path.slice(startDot, end);
    };
    
    function filter (xs, f) {
        if (xs.filter) return xs.filter(f);
        var res = [];
        for (var i = 0; i < xs.length; i++) {
            if (f(xs[i], i, xs)) res.push(xs[i]);
        }
        return res;
    }
    
    // String.prototype.substr - negative index don't work in IE8
    var substr = 'ab'.substr(-1) === 'b'
        ? function (str, start, len) { return str.substr(start, len) }
        : function (str, start, len) {
            if (start < 0) start = str.length + start;
            return str.substr(start, len);
        }
    ;
    
    }).call(this,require('_process'))
    },{"_process":20}],14:[function(require,module,exports){
    // Generated by blackpard 1.4.0
    var apply, curry, flip, fix, over, memoize, slice$ = [].slice, toString$ = {}.toString;
    apply = curry$(function(f, list){
      return f.apply(null, list);
    });
    curry = function(f){
      return curry$(f);
    };
    flip = curry$(function(f, x, y){
      return f(y, x);
    });
    fix = function(f){
      return function(g){
        return function(){
          return f(g(g)).apply(null, arguments);
        };
      }(function(g){
        return function(){
          return f(g(g)).apply(null, arguments);
        };
      });
    };
    over = curry$(function(f, g, x, y){
      return f(g(x), g(y));
    });
    memoize = function(f){
      var memo;
      memo = {};
      return function(){
        var args, key, arg;
        args = slice$.call(arguments);
        key = (function(){
          var i$, ref$, len$, results$ = [];
          for (i$ = 0, len$ = (ref$ = args).length; i$ < len$; ++i$) {
            arg = ref$[i$];
            results$.push(arg + toString$.call(arg).slice(8, -1));
          }
          return results$;
        }()).join('');
        return memo[key] = key in memo
          ? memo[key]
          : f.apply(null, args);
      };
    };
    module.exports = {
      curry: curry,
      flip: flip,
      fix: fix,
      apply: apply,
      over: over,
      memoize: memoize
    };
    function curry$(f, bound){
      var context,
      _curry = function(args) {
        return f.length > 1 ? function(){
          var params = args ? args.concat() : [];
          context = bound ? context || this : this;
          return params.push.apply(params, arguments) <
              f.length && arguments.length ?
            _curry.call(context, params) : f.apply(context, params);
        } : f;
      };
      return _curry();
    }
    },{}],15:[function(require,module,exports){
    // Generated by blackpard 1.4.0
    var each, map, compact, filter, reject, partition, find, head, first, tail, last, initial, empty, reverse, unique, uniqueBy, fold, foldl, fold1, foldl1, foldr, foldr1, unfoldr, concat, concatMap, flatten, difference, intersection, union, countBy, groupBy, andList, orList, any, all, sort, sortWith, sortBy, sum, product, mean, average, maximum, minimum, maximumBy, minimumBy, scan, scanl, scan1, scanl1, scanr, scanr1, slice, take, drop, splitAt, takeWhile, dropWhile, span, breakList, zip, zipWith, zipAll, zipAllWith, at, elemIndex, elemIndices, findIndex, findIndices, toString$ = {}.toString, slice$ = [].slice;
    each = curry$(function(f, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        f(x);
      }
      return xs;
    });
    map = curry$(function(f, xs){
      var i$, len$, x, results$ = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        results$.push(f(x));
      }
      return results$;
    });
    compact = function(xs){
      var i$, len$, x, results$ = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (x) {
          results$.push(x);
        }
      }
      return results$;
    };
    filter = curry$(function(f, xs){
      var i$, len$, x, results$ = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (f(x)) {
          results$.push(x);
        }
      }
      return results$;
    });
    reject = curry$(function(f, xs){
      var i$, len$, x, results$ = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (!f(x)) {
          results$.push(x);
        }
      }
      return results$;
    });
    partition = curry$(function(f, xs){
      var passed, failed, i$, len$, x;
      passed = [];
      failed = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        (f(x) ? passed : failed).push(x);
      }
      return [passed, failed];
    });
    find = curry$(function(f, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (f(x)) {
          return x;
        }
      }
    });
    head = first = function(xs){
      return xs[0];
    };
    tail = function(xs){
      if (!xs.length) {
        return;
      }
      return xs.slice(1);
    };
    last = function(xs){
      return xs[xs.length - 1];
    };
    initial = function(xs){
      if (!xs.length) {
        return;
      }
      return xs.slice(0, -1);
    };
    empty = function(xs){
      return !xs.length;
    };
    reverse = function(xs){
      return xs.concat().reverse();
    };
    unique = function(xs){
      var result, i$, len$, x;
      result = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (!in$(x, result)) {
          result.push(x);
        }
      }
      return result;
    };
    uniqueBy = curry$(function(f, xs){
      var seen, i$, len$, x, val, results$ = [];
      seen = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        val = f(x);
        if (in$(val, seen)) {
          continue;
        }
        seen.push(val);
        results$.push(x);
      }
      return results$;
    });
    fold = foldl = curry$(function(f, memo, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        memo = f(memo, x);
      }
      return memo;
    });
    fold1 = foldl1 = curry$(function(f, xs){
      return fold(f, xs[0], xs.slice(1));
    });
    foldr = curry$(function(f, memo, xs){
      var i$, x;
      for (i$ = xs.length - 1; i$ >= 0; --i$) {
        x = xs[i$];
        memo = f(x, memo);
      }
      return memo;
    });
    foldr1 = curry$(function(f, xs){
      return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
    });
    unfoldr = curry$(function(f, b){
      var result, x, that;
      result = [];
      x = b;
      while ((that = f(x)) != null) {
        result.push(that[0]);
        x = that[1];
      }
      return result;
    });
    concat = function(xss){
      return [].concat.apply([], xss);
    };
    concatMap = curry$(function(f, xs){
      var x;
      return [].concat.apply([], (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
          x = ref$[i$];
          results$.push(f(x));
        }
        return results$;
      }()));
    });
    flatten = function(xs){
      var x;
      return [].concat.apply([], (function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
          x = ref$[i$];
          if (toString$.call(x).slice(8, -1) === 'Array') {
            results$.push(flatten(x));
          } else {
            results$.push(x);
          }
        }
        return results$;
      }()));
    };
    difference = function(xs){
      var yss, results, i$, len$, x, j$, len1$, ys;
      yss = slice$.call(arguments, 1);
      results = [];
      outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
          ys = yss[j$];
          if (in$(x, ys)) {
            continue outer;
          }
        }
        results.push(x);
      }
      return results;
    };
    intersection = function(xs){
      var yss, results, i$, len$, x, j$, len1$, ys;
      yss = slice$.call(arguments, 1);
      results = [];
      outer: for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
          ys = yss[j$];
          if (!in$(x, ys)) {
            continue outer;
          }
        }
        results.push(x);
      }
      return results;
    };
    union = function(){
      var xss, results, i$, len$, xs, j$, len1$, x;
      xss = slice$.call(arguments);
      results = [];
      for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
        xs = xss[i$];
        for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
          x = xs[j$];
          if (!in$(x, results)) {
            results.push(x);
          }
        }
      }
      return results;
    };
    countBy = curry$(function(f, xs){
      var results, i$, len$, x, key;
      results = {};
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        key = f(x);
        if (key in results) {
          results[key] += 1;
        } else {
          results[key] = 1;
        }
      }
      return results;
    });
    groupBy = curry$(function(f, xs){
      var results, i$, len$, x, key;
      results = {};
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        key = f(x);
        if (key in results) {
          results[key].push(x);
        } else {
          results[key] = [x];
        }
      }
      return results;
    });
    andList = function(xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (!x) {
          return false;
        }
      }
      return true;
    };
    orList = function(xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (x) {
          return true;
        }
      }
      return false;
    };
    any = curry$(function(f, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (f(x)) {
          return true;
        }
      }
      return false;
    });
    all = curry$(function(f, xs){
      var i$, len$, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        if (!f(x)) {
          return false;
        }
      }
      return true;
    });
    sort = function(xs){
      return xs.concat().sort(function(x, y){
        if (x > y) {
          return 1;
        } else if (x < y) {
          return -1;
        } else {
          return 0;
        }
      });
    };
    sortWith = curry$(function(f, xs){
      return xs.concat().sort(f);
    });
    sortBy = curry$(function(f, xs){
      return xs.concat().sort(function(x, y){
        if (f(x) > f(y)) {
          return 1;
        } else if (f(x) < f(y)) {
          return -1;
        } else {
          return 0;
        }
      });
    });
    sum = function(xs){
      var result, i$, len$, x;
      result = 0;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        result += x;
      }
      return result;
    };
    product = function(xs){
      var result, i$, len$, x;
      result = 1;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        result *= x;
      }
      return result;
    };
    mean = average = function(xs){
      var sum, i$, len$, x;
      sum = 0;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        sum += x;
      }
      return sum / xs.length;
    };
    maximum = function(xs){
      var max, i$, ref$, len$, x;
      max = xs[0];
      for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (x > max) {
          max = x;
        }
      }
      return max;
    };
    minimum = function(xs){
      var min, i$, ref$, len$, x;
      min = xs[0];
      for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (x < min) {
          min = x;
        }
      }
      return min;
    };
    maximumBy = curry$(function(f, xs){
      var max, i$, ref$, len$, x;
      max = xs[0];
      for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (f(x) > f(max)) {
          max = x;
        }
      }
      return max;
    });
    minimumBy = curry$(function(f, xs){
      var min, i$, ref$, len$, x;
      min = xs[0];
      for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (f(x) < f(min)) {
          min = x;
        }
      }
      return min;
    });
    scan = scanl = curry$(function(f, memo, xs){
      var last, x;
      last = memo;
      return [memo].concat((function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
          x = ref$[i$];
          results$.push(last = f(last, x));
        }
        return results$;
      }()));
    });
    scan1 = scanl1 = curry$(function(f, xs){
      if (!xs.length) {
        return;
      }
      return scan(f, xs[0], xs.slice(1));
    });
    scanr = curry$(function(f, memo, xs){
      xs = xs.concat().reverse();
      return scan(f, memo, xs).reverse();
    });
    scanr1 = curry$(function(f, xs){
      if (!xs.length) {
        return;
      }
      xs = xs.concat().reverse();
      return scan(f, xs[0], xs.slice(1)).reverse();
    });
    slice = curry$(function(x, y, xs){
      return xs.slice(x, y);
    });
    take = curry$(function(n, xs){
      if (n <= 0) {
        return xs.slice(0, 0);
      } else {
        return xs.slice(0, n);
      }
    });
    drop = curry$(function(n, xs){
      if (n <= 0) {
        return xs;
      } else {
        return xs.slice(n);
      }
    });
    splitAt = curry$(function(n, xs){
      return [take(n, xs), drop(n, xs)];
    });
    takeWhile = curry$(function(p, xs){
      var len, i;
      len = xs.length;
      if (!len) {
        return xs;
      }
      i = 0;
      while (i < len && p(xs[i])) {
        i += 1;
      }
      return xs.slice(0, i);
    });
    dropWhile = curry$(function(p, xs){
      var len, i;
      len = xs.length;
      if (!len) {
        return xs;
      }
      i = 0;
      while (i < len && p(xs[i])) {
        i += 1;
      }
      return xs.slice(i);
    });
    span = curry$(function(p, xs){
      return [takeWhile(p, xs), dropWhile(p, xs)];
    });
    breakList = curry$(function(p, xs){
      return span(compose$(p, not$), xs);
    });
    zip = curry$(function(xs, ys){
      var result, len, i$, len$, i, x;
      result = [];
      len = ys.length;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        i = i$;
        x = xs[i$];
        if (i === len) {
          break;
        }
        result.push([x, ys[i]]);
      }
      return result;
    });
    zipWith = curry$(function(f, xs, ys){
      var result, len, i$, len$, i, x;
      result = [];
      len = ys.length;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        i = i$;
        x = xs[i$];
        if (i === len) {
          break;
        }
        result.push(f(x, ys[i]));
      }
      return result;
    });
    zipAll = function(){
      var xss, minLength, i$, len$, xs, ref$, i, lresult$, j$, results$ = [];
      xss = slice$.call(arguments);
      minLength = undefined;
      for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
        xs = xss[i$];
        minLength <= (ref$ = xs.length) || (minLength = ref$);
      }
      for (i$ = 0; i$ < minLength; ++i$) {
        i = i$;
        lresult$ = [];
        for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
          xs = xss[j$];
          lresult$.push(xs[i]);
        }
        results$.push(lresult$);
      }
      return results$;
    };
    zipAllWith = function(f){
      var xss, minLength, i$, len$, xs, ref$, i, results$ = [];
      xss = slice$.call(arguments, 1);
      minLength = undefined;
      for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
        xs = xss[i$];
        minLength <= (ref$ = xs.length) || (minLength = ref$);
      }
      for (i$ = 0; i$ < minLength; ++i$) {
        i = i$;
        results$.push(f.apply(null, (fn$())));
      }
      return results$;
      function fn$(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = xss).length; i$ < len$; ++i$) {
          xs = ref$[i$];
          results$.push(xs[i]);
        }
        return results$;
      }
    };
    at = curry$(function(n, xs){
      if (n < 0) {
        return xs[xs.length + n];
      } else {
        return xs[n];
      }
    });
    elemIndex = curry$(function(el, xs){
      var i$, len$, i, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        i = i$;
        x = xs[i$];
        if (x === el) {
          return i;
        }
      }
    });
    elemIndices = curry$(function(el, xs){
      var i$, len$, i, x, results$ = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        i = i$;
        x = xs[i$];
        if (x === el) {
          results$.push(i);
        }
      }
      return results$;
    });
    findIndex = curry$(function(f, xs){
      var i$, len$, i, x;
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        i = i$;
        x = xs[i$];
        if (f(x)) {
          return i;
        }
      }
    });
    findIndices = curry$(function(f, xs){
      var i$, len$, i, x, results$ = [];
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        i = i$;
        x = xs[i$];
        if (f(x)) {
          results$.push(i);
        }
      }
      return results$;
    });
    module.exports = {
      each: each,
      map: map,
      filter: filter,
      compact: compact,
      reject: reject,
      partition: partition,
      find: find,
      head: head,
      first: first,
      tail: tail,
      last: last,
      initial: initial,
      empty: empty,
      reverse: reverse,
      difference: difference,
      intersection: intersection,
      union: union,
      countBy: countBy,
      groupBy: groupBy,
      fold: fold,
      fold1: fold1,
      foldl: foldl,
      foldl1: foldl1,
      foldr: foldr,
      foldr1: foldr1,
      unfoldr: unfoldr,
      andList: andList,
      orList: orList,
      any: any,
      all: all,
      unique: unique,
      uniqueBy: uniqueBy,
      sort: sort,
      sortWith: sortWith,
      sortBy: sortBy,
      sum: sum,
      product: product,
      mean: mean,
      average: average,
      concat: concat,
      concatMap: concatMap,
      flatten: flatten,
      maximum: maximum,
      minimum: minimum,
      maximumBy: maximumBy,
      minimumBy: minimumBy,
      scan: scan,
      scan1: scan1,
      scanl: scanl,
      scanl1: scanl1,
      scanr: scanr,
      scanr1: scanr1,
      slice: slice,
      take: take,
      drop: drop,
      splitAt: splitAt,
      takeWhile: takeWhile,
      dropWhile: dropWhile,
      span: span,
      breakList: breakList,
      zip: zip,
      zipWith: zipWith,
      zipAll: zipAll,
      zipAllWith: zipAllWith,
      at: at,
      elemIndex: elemIndex,
      elemIndices: elemIndices,
      findIndex: findIndex,
      findIndices: findIndices
    };
    function curry$(f, bound){
      var context,
      _curry = function(args) {
        return f.length > 1 ? function(){
          var params = args ? args.concat() : [];
          context = bound ? context || this : this;
          return params.push.apply(params, arguments) <
              f.length && arguments.length ?
            _curry.call(context, params) : f.apply(context, params);
        } : f;
      };
      return _curry();
    }
    function in$(x, xs){
      var i = -1, l = xs.length >>> 0;
      while (++i < l) if (x === xs[i]) return true;
      return false;
    }
    function compose$() {
      var functions = arguments;
      return function() {
        var i, result;
        result = functions[0].apply(this, arguments);
        for (i = 1; i < functions.length; ++i) {
          result = functions[i](result);
        }
        return result;
      };
    }
    function not$(x){ return !x; }
    },{}],16:[function(require,module,exports){
    // Generated by blackpard 1.4.0
    var max, min, negate, abs, signum, quot, rem, div, mod, recip, pi, tau, exp, sqrt, ln, pow, sin, tan, cos, asin, acos, atan, atan2, truncate, round, ceiling, floor, isItNaN, even, odd, gcd, lcm;
    max = curry$(function(x$, y$){
      return x$ > y$ ? x$ : y$;
    });
    min = curry$(function(x$, y$){
      return x$ < y$ ? x$ : y$;
    });
    negate = function(x){
      return -x;
    };
    abs = Math.abs;
    signum = function(x){
      if (x < 0) {
        return -1;
      } else if (x > 0) {
        return 1;
      } else {
        return 0;
      }
    };
    quot = curry$(function(x, y){
      return ~~(x / y);
    });
    rem = curry$(function(x$, y$){
      return x$ % y$;
    });
    div = curry$(function(x, y){
      return Math.floor(x / y);
    });
    mod = curry$(function(x$, y$){
      var ref$;
      return (((x$) % (ref$ = y$) + ref$) % ref$);
    });
    recip = (function(it){
      return 1 / it;
    });
    pi = Math.PI;
    tau = pi * 2;
    exp = Math.exp;
    sqrt = Math.sqrt;
    ln = Math.log;
    pow = curry$(function(x$, y$){
      return Math.pow(x$, y$);
    });
    sin = Math.sin;
    tan = Math.tan;
    cos = Math.cos;
    asin = Math.asin;
    acos = Math.acos;
    atan = Math.atan;
    atan2 = curry$(function(x, y){
      return Math.atan2(x, y);
    });
    truncate = function(x){
      return ~~x;
    };
    round = Math.round;
    ceiling = Math.ceil;
    floor = Math.floor;
    isItNaN = function(x){
      return x !== x;
    };
    even = function(x){
      return x % 2 === 0;
    };
    odd = function(x){
      return x % 2 !== 0;
    };
    gcd = curry$(function(x, y){
      var z;
      x = Math.abs(x);
      y = Math.abs(y);
      while (y !== 0) {
        z = x % y;
        x = y;
        y = z;
      }
      return x;
    });
    lcm = curry$(function(x, y){
      return Math.abs(Math.floor(x / gcd(x, y) * y));
    });
    module.exports = {
      max: max,
      min: min,
      negate: negate,
      abs: abs,
      signum: signum,
      quot: quot,
      rem: rem,
      div: div,
      mod: mod,
      recip: recip,
      pi: pi,
      tau: tau,
      exp: exp,
      sqrt: sqrt,
      ln: ln,
      pow: pow,
      sin: sin,
      tan: tan,
      cos: cos,
      acos: acos,
      asin: asin,
      atan: atan,
      atan2: atan2,
      truncate: truncate,
      round: round,
      ceiling: ceiling,
      floor: floor,
      isItNaN: isItNaN,
      even: even,
      odd: odd,
      gcd: gcd,
      lcm: lcm
    };
    function curry$(f, bound){
      var context,
      _curry = function(args) {
        return f.length > 1 ? function(){
          var params = args ? args.concat() : [];
          context = bound ? context || this : this;
          return params.push.apply(params, arguments) <
              f.length && arguments.length ?
            _curry.call(context, params) : f.apply(context, params);
        } : f;
      };
      return _curry();
    }
    },{}],17:[function(require,module,exports){
    // Generated by blackpard 1.4.0
    var values, keys, pairsToObj, objToPairs, listsToObj, objToLists, empty, each, map, compact, filter, reject, partition, find;
    values = function(object){
      var i$, x, results$ = [];
      for (i$ in object) {
        x = object[i$];
        results$.push(x);
      }
      return results$;
    };
    keys = function(object){
      var x, results$ = [];
      for (x in object) {
        results$.push(x);
      }
      return results$;
    };
    pairsToObj = function(object){
      var i$, len$, x, resultObj$ = {};
      for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
        x = object[i$];
        resultObj$[x[0]] = x[1];
      }
      return resultObj$;
    };
    objToPairs = function(object){
      var key, value, results$ = [];
      for (key in object) {
        value = object[key];
        results$.push([key, value]);
      }
      return results$;
    };
    listsToObj = curry$(function(keys, values){
      var i$, len$, i, key, resultObj$ = {};
      for (i$ = 0, len$ = keys.length; i$ < len$; ++i$) {
        i = i$;
        key = keys[i$];
        resultObj$[key] = values[i];
      }
      return resultObj$;
    });
    objToLists = function(object){
      var keys, values, key, value;
      keys = [];
      values = [];
      for (key in object) {
        value = object[key];
        keys.push(key);
        values.push(value);
      }
      return [keys, values];
    };
    empty = function(object){
      var x;
      for (x in object) {
        return false;
      }
      return true;
    };
    each = curry$(function(f, object){
      var i$, x;
      for (i$ in object) {
        x = object[i$];
        f(x);
      }
      return object;
    });
    map = curry$(function(f, object){
      var k, x, resultObj$ = {};
      for (k in object) {
        x = object[k];
        resultObj$[k] = f(x);
      }
      return resultObj$;
    });
    compact = function(object){
      var k, x, resultObj$ = {};
      for (k in object) {
        x = object[k];
        if (x) {
          resultObj$[k] = x;
        }
      }
      return resultObj$;
    };
    filter = curry$(function(f, object){
      var k, x, resultObj$ = {};
      for (k in object) {
        x = object[k];
        if (f(x)) {
          resultObj$[k] = x;
        }
      }
      return resultObj$;
    });
    reject = curry$(function(f, object){
      var k, x, resultObj$ = {};
      for (k in object) {
        x = object[k];
        if (!f(x)) {
          resultObj$[k] = x;
        }
      }
      return resultObj$;
    });
    partition = curry$(function(f, object){
      var passed, failed, k, x;
      passed = {};
      failed = {};
      for (k in object) {
        x = object[k];
        (f(x) ? passed : failed)[k] = x;
      }
      return [passed, failed];
    });
    find = curry$(function(f, object){
      var i$, x;
      for (i$ in object) {
        x = object[i$];
        if (f(x)) {
          return x;
        }
      }
    });
    module.exports = {
      values: values,
      keys: keys,
      pairsToObj: pairsToObj,
      objToPairs: objToPairs,
      listsToObj: listsToObj,
      objToLists: objToLists,
      empty: empty,
      each: each,
      map: map,
      filter: filter,
      compact: compact,
      reject: reject,
      partition: partition,
      find: find
    };
    function curry$(f, bound){
      var context,
      _curry = function(args) {
        return f.length > 1 ? function(){
          var params = args ? args.concat() : [];
          context = bound ? context || this : this;
          return params.push.apply(params, arguments) <
              f.length && arguments.length ?
            _curry.call(context, params) : f.apply(context, params);
        } : f;
      };
      return _curry();
    }
    },{}],18:[function(require,module,exports){
    // Generated by blackpard 1.4.0
    var split, join, lines, unlines, words, unwords, chars, unchars, reverse, repeat, capitalize, camelize, dasherize;
    split = curry$(function(sep, str){
      return str.split(sep);
    });
    join = curry$(function(sep, xs){
      return xs.join(sep);
    });
    lines = function(str){
      if (!str.length) {
        return [];
      }
      return str.split('\n');
    };
    unlines = function(it){
      return it.join('\n');
    };
    words = function(str){
      if (!str.length) {
        return [];
      }
      return str.split(/[ ]+/);
    };
    unwords = function(it){
      return it.join(' ');
    };
    chars = function(it){
      return it.split('');
    };
    unchars = function(it){
      return it.join('');
    };
    reverse = function(str){
      return str.split('').reverse().join('');
    };
    repeat = curry$(function(n, str){
      var result, i$;
      result = '';
      for (i$ = 0; i$ < n; ++i$) {
        result += str;
      }
      return result;
    });
    capitalize = function(str){
      return str.charAt(0).toUpperCase() + str.slice(1);
    };
    camelize = function(it){
      return it.replace(/[-_]+(.)?/g, function(arg$, c){
        return (c != null ? c : '').toUpperCase();
      });
    };
    dasherize = function(str){
      return str.replace(/([^-A-Z])([A-Z]+)/g, function(arg$, lower, upper){
        return lower + "-" + (upper.length > 1
          ? upper
          : upper.toLowerCase());
      }).replace(/^([A-Z]+)/, function(arg$, upper){
        if (upper.length > 1) {
          return upper + "-";
        } else {
          return upper.toLowerCase();
        }
      });
    };
    module.exports = {
      split: split,
      join: join,
      lines: lines,
      unlines: unlines,
      words: words,
      unwords: unwords,
      chars: chars,
      unchars: unchars,
      reverse: reverse,
      repeat: repeat,
      capitalize: capitalize,
      camelize: camelize,
      dasherize: dasherize
    };
    function curry$(f, bound){
      var context,
      _curry = function(args) {
        return f.length > 1 ? function(){
          var params = args ? args.concat() : [];
          context = bound ? context || this : this;
          return params.push.apply(params, arguments) <
              f.length && arguments.length ?
            _curry.call(context, params) : f.apply(context, params);
        } : f;
      };
      return _curry();
    }
    },{}],19:[function(require,module,exports){
    // Generated by blackpard 1.4.0
    var Func, List, Obj, Str, Num, id, isType, replicate, prelude, toString$ = {}.toString;
    Func = require('./Func.js');
    List = require('./List.js');
    Obj = require('./Obj.js');
    Str = require('./Str.js');
    Num = require('./Num.js');
    id = function(x){
      return x;
    };
    isType = curry$(function(type, x){
      return toString$.call(x).slice(8, -1) === type;
    });
    replicate = curry$(function(n, x){
      var i$, results$ = [];
      for (i$ = 0; i$ < n; ++i$) {
        results$.push(x);
      }
      return results$;
    });
    Str.empty = List.empty;
    Str.slice = List.slice;
    Str.take = List.take;
    Str.drop = List.drop;
    Str.splitAt = List.splitAt;
    Str.takeWhile = List.takeWhile;
    Str.dropWhile = List.dropWhile;
    Str.span = List.span;
    Str.breakStr = List.breakList;
    prelude = {
      Func: Func,
      List: List,
      Obj: Obj,
      Str: Str,
      Num: Num,
      id: id,
      isType: isType,
      replicate: replicate
    };
    prelude.each = List.each;
    prelude.map = List.map;
    prelude.filter = List.filter;
    prelude.compact = List.compact;
    prelude.reject = List.reject;
    prelude.partition = List.partition;
    prelude.find = List.find;
    prelude.head = List.head;
    prelude.first = List.first;
    prelude.tail = List.tail;
    prelude.last = List.last;
    prelude.initial = List.initial;
    prelude.empty = List.empty;
    prelude.reverse = List.reverse;
    prelude.difference = List.difference;
    prelude.intersection = List.intersection;
    prelude.union = List.union;
    prelude.countBy = List.countBy;
    prelude.groupBy = List.groupBy;
    prelude.fold = List.fold;
    prelude.foldl = List.foldl;
    prelude.fold1 = List.fold1;
    prelude.foldl1 = List.foldl1;
    prelude.foldr = List.foldr;
    prelude.foldr1 = List.foldr1;
    prelude.unfoldr = List.unfoldr;
    prelude.andList = List.andList;
    prelude.orList = List.orList;
    prelude.any = List.any;
    prelude.all = List.all;
    prelude.unique = List.unique;
    prelude.uniqueBy = List.uniqueBy;
    prelude.sort = List.sort;
    prelude.sortWith = List.sortWith;
    prelude.sortBy = List.sortBy;
    prelude.sum = List.sum;
    prelude.product = List.product;
    prelude.mean = List.mean;
    prelude.average = List.average;
    prelude.concat = List.concat;
    prelude.concatMap = List.concatMap;
    prelude.flatten = List.flatten;
    prelude.maximum = List.maximum;
    prelude.minimum = List.minimum;
    prelude.maximumBy = List.maximumBy;
    prelude.minimumBy = List.minimumBy;
    prelude.scan = List.scan;
    prelude.scanl = List.scanl;
    prelude.scan1 = List.scan1;
    prelude.scanl1 = List.scanl1;
    prelude.scanr = List.scanr;
    prelude.scanr1 = List.scanr1;
    prelude.slice = List.slice;
    prelude.take = List.take;
    prelude.drop = List.drop;
    prelude.splitAt = List.splitAt;
    prelude.takeWhile = List.takeWhile;
    prelude.dropWhile = List.dropWhile;
    prelude.span = List.span;
    prelude.breakList = List.breakList;
    prelude.zip = List.zip;
    prelude.zipWith = List.zipWith;
    prelude.zipAll = List.zipAll;
    prelude.zipAllWith = List.zipAllWith;
    prelude.at = List.at;
    prelude.elemIndex = List.elemIndex;
    prelude.elemIndices = List.elemIndices;
    prelude.findIndex = List.findIndex;
    prelude.findIndices = List.findIndices;
    prelude.apply = Func.apply;
    prelude.curry = Func.curry;
    prelude.flip = Func.flip;
    prelude.fix = Func.fix;
    prelude.over = Func.over;
    prelude.split = Str.split;
    prelude.join = Str.join;
    prelude.lines = Str.lines;
    prelude.unlines = Str.unlines;
    prelude.words = Str.words;
    prelude.unwords = Str.unwords;
    prelude.chars = Str.chars;
    prelude.unchars = Str.unchars;
    prelude.repeat = Str.repeat;
    prelude.capitalize = Str.capitalize;
    prelude.camelize = Str.camelize;
    prelude.dasherize = Str.dasherize;
    prelude.values = Obj.values;
    prelude.keys = Obj.keys;
    prelude.pairsToObj = Obj.pairsToObj;
    prelude.objToPairs = Obj.objToPairs;
    prelude.listsToObj = Obj.listsToObj;
    prelude.objToLists = Obj.objToLists;
    prelude.max = Num.max;
    prelude.min = Num.min;
    prelude.negate = Num.negate;
    prelude.abs = Num.abs;
    prelude.signum = Num.signum;
    prelude.quot = Num.quot;
    prelude.rem = Num.rem;
    prelude.div = Num.div;
    prelude.mod = Num.mod;
    prelude.recip = Num.recip;
    prelude.pi = Num.pi;
    prelude.tau = Num.tau;
    prelude.exp = Num.exp;
    prelude.sqrt = Num.sqrt;
    prelude.ln = Num.ln;
    prelude.pow = Num.pow;
    prelude.sin = Num.sin;
    prelude.tan = Num.tan;
    prelude.cos = Num.cos;
    prelude.acos = Num.acos;
    prelude.asin = Num.asin;
    prelude.atan = Num.atan;
    prelude.atan2 = Num.atan2;
    prelude.truncate = Num.truncate;
    prelude.round = Num.round;
    prelude.ceiling = Num.ceiling;
    prelude.floor = Num.floor;
    prelude.isItNaN = Num.isItNaN;
    prelude.even = Num.even;
    prelude.odd = Num.odd;
    prelude.gcd = Num.gcd;
    prelude.lcm = Num.lcm;
    prelude.VERSION = '1.1.2';
    module.exports = prelude;
    function curry$(f, bound){
      var context,
      _curry = function(args) {
        return f.length > 1 ? function(){
          var params = args ? args.concat() : [];
          context = bound ? context || this : this;
          return params.push.apply(params, arguments) <
              f.length && arguments.length ?
            _curry.call(context, params) : f.apply(context, params);
        } : f;
      };
      return _curry();
    }
    },{"./Func.js":14,"./List.js":15,"./Num.js":16,"./Obj.js":17,"./Str.js":18}],20:[function(require,module,exports){
    // shim for using process in browser
    var process = module.exports = {};
    
    // cached from whatever global is present so that test runners that stub it
    // don't break things.  But we need to wrap it in a try catch in case it is
    // wrapped in strict mode code which doesn't define any globals.  It's inside a
    // function because try/catches deoptimize in certain engines.
    
    var cachedSetTimeout;
    var cachedClearTimeout;
    
    function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
    }
    function defaultClearTimeout () {
        throw new Error('clearTimeout has not been defined');
    }
    (function () {
        try {
            if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
            } else {
                cachedSetTimeout = defaultSetTimout;
            }
        } catch (e) {
            cachedSetTimeout = defaultSetTimout;
        }
        try {
            if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
            } else {
                cachedClearTimeout = defaultClearTimeout;
            }
        } catch (e) {
            cachedClearTimeout = defaultClearTimeout;
        }
    } ())
    function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
            //normal enviroments in sane situations
            return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
            cachedSetTimeout = setTimeout;
            return setTimeout(fun, 0);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedSetTimeout(fun, 0);
        } catch(e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
                return cachedSetTimeout.call(null, fun, 0);
            } catch(e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
                return cachedSetTimeout.call(this, fun, 0);
            }
        }
    
    
    }
    function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
            //normal enviroments in sane situations
            return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
            cachedClearTimeout = clearTimeout;
            return clearTimeout(marker);
        }
        try {
            // when when somebody has screwed with setTimeout but no I.E. maddness
            return cachedClearTimeout(marker);
        } catch (e){
            try {
                // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
                return cachedClearTimeout.call(null, marker);
            } catch (e){
                // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
                // Some versions of I.E. have different rules for clearTimeout vs setTimeout
                return cachedClearTimeout.call(this, marker);
            }
        }
    
    
    
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    
    function cleanUpNextTick() {
        if (!draining || !currentQueue) {
            return;
        }
        draining = false;
        if (currentQueue.length) {
            queue = currentQueue.concat(queue);
        } else {
            queueIndex = -1;
        }
        if (queue.length) {
            drainQueue();
        }
    }
    
    function drainQueue() {
        if (draining) {
            return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
    
        var len = queue.length;
        while(len) {
            currentQueue = queue;
            queue = [];
            while (++queueIndex < len) {
                if (currentQueue) {
                    currentQueue[queueIndex].run();
                }
            }
            queueIndex = -1;
            len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
    }
    
    process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
            for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
            }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
            runTimeout(drainQueue);
        }
    };
    
    // v8 likes predictible objects
    function Item(fun, array) {
        this.fun = fun;
        this.array = array;
    }
    Item.prototype.run = function () {
        this.fun.apply(null, this.array);
    };
    process.title = 'browser';
    process.browser = true;
    process.env = {};
    process.argv = [];
    process.version = ''; // empty string to avoid regexp issues
    process.versions = {};
    
    function noop() {}
    
    process.on = noop;
    process.addListener = noop;
    process.once = noop;
    process.off = noop;
    process.removeListener = noop;
    process.removeAllListeners = noop;
    process.emit = noop;
    process.prependListener = noop;
    process.prependOnceListener = noop;
    
    process.listeners = function (name) { return [] }
    
    process.binding = function (name) {
        throw new Error('process.binding is not supported');
    };
    
    process.cwd = function () { return '/' };
    process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
    };
    process.umask = function() { return 0; };
    
    },{}],21:[function(require,module,exports){
    /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    
    var util = require('./util');
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    
    /**
     * A data structure which is a combination of an array and a set. Adding a new
     * member is O(1), testing for membership is O(1), and finding the index of an
     * element is O(1). Removing elements from the set is not supported. Only
     * strings are supported for membership.
     */
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? new Map() : Object.create(null);
    }
    
    /**
     * Static method for creating ArraySet instances from an existing array.
     */
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    
    /**
     * Return how many unique items are in this ArraySet. If duplicates have been
     * added, than those do not count towards the size.
     *
     * @returns Number
     */
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    
    /**
     * Add the given string to this set.
     *
     * @param String aStr
     */
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    
    /**
     * Is the given string a member of this set?
     *
     * @param String aStr
     */
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    
    /**
     * What is the index of the given string in the array?
     *
     * @param String aStr
     */
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
            return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
    
      throw new Error('"' + aStr + '" is not in the set.');
    };
    
    /**
     * What is the element at the given index?
     *
     * @param Number aIdx
     */
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error('No element indexed by ' + aIdx);
    };
    
    /**
     * Returns the array representation of this set (which has the proper indices
     * indicated by indexOf). Note that this is a copy of the internal array used
     * for storing the members so that no one can mess with internal state.
     */
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    
    exports.ArraySet = ArraySet;
    
    },{"./util":30}],22:[function(require,module,exports){
    /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     *
     * Based on the Base 64 VLQ implementation in Closure Compiler:
     * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
     *
     * Copyright 2011 The Closure Compiler Authors. All rights reserved.
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are
     * met:
     *
     *  * Redistributions of source code must retain the above copyright
     *    notice, this list of conditions and the following disclaimer.
     *  * Redistributions in binary form must reproduce the above
     *    copyright notice, this list of conditions and the following
     *    disclaimer in the documentation and/or other materials provided
     *    with the distribution.
     *  * Neither the name of Google Inc. nor the names of its
     *    contributors may be used to endorse or promote products derived
     *    from this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
     * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
     * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
     * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
     * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
     * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
     * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
     * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
     * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    
    var base64 = require('./base64');
    
    // A single base 64 digit can contain 6 bits of data. For the base 64 variable
    // length quantities we use in the source map spec, the first bit is the sign,
    // the next four bits are the actual value, and the 6th bit is the
    // continuation bit. The continuation bit tells us whether there are more
    // digits in this value following this digit.
    //
    //   Continuation
    //   |    Sign
    //   |    |
    //   V    V
    //   101011
    
    var VLQ_BASE_SHIFT = 5;
    
    // binary: 100000
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    
    // binary: 011111
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    
    // binary: 100000
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    
    /**
     * Converts from a two-complement value to a value where the sign bit is
     * placed in the least significant bit.  For example, as decimals:
     *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
     *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
     */
    function toVLQSigned(aValue) {
      return aValue < 0
        ? ((-aValue) << 1) + 1
        : (aValue << 1) + 0;
    }
    
    /**
     * Converts to a two-complement value from a value where the sign bit is
     * placed in the least significant bit.  For example, as decimals:
     *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
     *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
     */
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative
        ? -shifted
        : shifted;
    }
    
    /**
     * Returns the base 64 VLQ encoded value.
     */
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
    
      var vlq = toVLQSigned(aValue);
    
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          // There are still more digits in this value, so we must make sure the
          // continuation bit is marked.
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
    
      return encoded;
    };
    
    /**
     * Decodes the next base 64 VLQ value from the given string and returns the
     * value and the rest of the string via the out parameter.
     */
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
    
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
    
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
    
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
    
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
    
    },{"./base64":23}],23:[function(require,module,exports){
    /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    
    var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
    
    /**
     * Encode an integer in the range of 0 to 63 to a single base 64 digit.
     */
    exports.encode = function (number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    
    /**
     * Decode a single base 64 character code digit to an integer. Returns -1 on
     * failure.
     */
    exports.decode = function (charCode) {
      var bigA = 65;     // 'A'
      var bigZ = 90;     // 'Z'
    
      var littleA = 97;  // 'a'
      var littleZ = 122; // 'z'
    
      var zero = 48;     // '0'
      var nine = 57;     // '9'
    
      var plus = 43;     // '+'
      var slash = 47;    // '/'
    
      var littleOffset = 26;
      var numberOffset = 52;
    
      // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
      if (bigA <= charCode && charCode <= bigZ) {
        return (charCode - bigA);
      }
    
      // 26 - 51: abcdefghijklmnopqrstuvwxyz
      if (littleA <= charCode && charCode <= littleZ) {
        return (charCode - littleA + littleOffset);
      }
    
      // 52 - 61: 0123456789
      if (zero <= charCode && charCode <= nine) {
        return (charCode - zero + numberOffset);
      }
    
      // 62: +
      if (charCode == plus) {
        return 62;
      }
    
      // 63: /
      if (charCode == slash) {
        return 63;
      }
    
      // Invalid base64 digit.
      return -1;
    };
    
    },{}],24:[function(require,module,exports){
    /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    
    /**
     * Recursive implementation of binary search.
     *
     * @param aLow Indices here and lower do not contain the needle.
     * @param aHigh Indices here and higher do not contain the needle.
     * @param aNeedle The element being searched for.
     * @param aHaystack The non-empty array being searched.
     * @param aCompare Function which takes two elements and returns -1, 0, or 1.
     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
     *     closest element that is smaller than or greater than the one we are
     *     searching for, respectively, if the exact element cannot be found.
     */
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      // This function terminates when one of the following is true:
      //
      //   1. We find the exact element we are looking for.
      //
      //   2. We did not find the exact element, but we can return the index of
      //      the next-closest element.
      //
      //   3. We did not find the exact element, and there is no next-closest
      //      element than the one we are searching for, so we return -1.
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        // Found the element we are looking for.
        return mid;
      }
      else if (cmp > 0) {
        // Our needle is greater than aHaystack[mid].
        if (aHigh - mid > 1) {
          // The element is in the upper half.
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
    
        // The exact needle element was not found in this haystack. Determine if
        // we are in termination case (3) or (2) and return the appropriate thing.
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      }
      else {
        // Our needle is less than aHaystack[mid].
        if (mid - aLow > 1) {
          // The element is in the lower half.
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
    
        // we are in termination case (3) or (2) and return the appropriate thing.
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    
    /**
     * This is an implementation of binary search which will always try and return
     * the index of the closest element if there is no exact hit. This is because
     * mappings between original and generated line/col pairs are single points,
     * and there is an implicit region between each of them, so a miss just means
     * that you aren't on the very start of a region.
     *
     * @param aNeedle The element you are looking for.
     * @param aHaystack The array that is being searched.
     * @param aCompare A function which takes the needle and an element in the
     *     array and returns -1, 0, or 1 depending on whether the needle is less
     *     than, equal to, or greater than the element, respectively.
     * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
     *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
     *     closest element that is smaller than or greater than the one we are
     *     searching for, respectively, if the exact element cannot be found.
     *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
     */
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
    
      var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack,
                                  aCompare, aBias || exports.GREATEST_LOWER_BOUND);
      if (index < 0) {
        return -1;
      }
    
      // We have found either the exact element, or the next-closest element than
      // the one we are searching for. However, there may be more than one such
      // element. Make sure we always return the smallest of these.
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
    
      return index;
    };
    
    },{}],25:[function(require,module,exports){
    /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2014 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    
    var util = require('./util');
    
    /**
     * Determine whether mappingB is after mappingA with respect to generated
     * position.
     */
    function generatedPositionAfter(mappingA, mappingB) {
      // Optimized for most common case
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA ||
             util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    
    /**
     * A data structure to provide a sorted view of accumulated mappings in a
     * performance conscious manner. It trades a neglibable overhead in general
     * case for a large speedup in case of mappings being added in order.
     */
    function MappingList() {
      this._array = [];
      this._sorted = true;
      // Serves as infimum
      this._last = {generatedLine: -1, generatedColumn: 0};
    }
    
    /**
     * Iterate through internal items. This method takes the same arguments that
     * `Array.prototype.forEach` takes.
     *
     * NOTE: The order of the mappings is NOT guaranteed.
     */
    MappingList.prototype.unsortedForEach =
      function MappingList_forEach(aCallback, aThisArg) {
        this._array.forEach(aCallback, aThisArg);
      };
    
    /**
     * Add the given source mapping.
     *
     * @param Object aMapping
     */
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    
    /**
     * Returns the flat, sorted array of mappings. The mappings are sorted by
     * generated position.
     *
     * WARNING: This method returns internal data without copying, for
     * performance. The return value must NOT be mutated, and should be treated as
     * an immutable borrow. If you want to take ownership, you must make your own
     * copy.
     */
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    
    exports.MappingList = MappingList;
    
    },{"./util":30}],26:[function(require,module,exports){
    /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    
    // It turns out that some (most?) JavaScript engines don't self-host
    // `Array.prototype.sort`. This makes sense because C++ will likely remain
    // faster than JS when doing raw CPU-intensive sorting. However, when using a
    // custom comparator function, calling back and forth between the VM's C++ and
    // JIT'd JS is rather slow *and* loses JIT type information, resulting in
    // worse generated code for the comparator function than would be optimal. In
    // fact, when sorting with a comparator, these costs outweigh the benefits of
    // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
    // a ~3500ms mean speed-up in `bench/bench.html`.
    
    /**
     * Swap the elements indexed by `x` and `y` in the array `ary`.
     *
     * @param {Array} ary
     *        The array.
     * @param {Number} x
     *        The index of the first item.
     * @param {Number} y
     *        The index of the second item.
     */
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    
    /**
     * Returns a random integer within the range `low .. high` inclusive.
     *
     * @param {Number} low
     *        The lower bound on the range.
     * @param {Number} high
     *        The upper bound on the range.
     */
    function randomIntInRange(low, high) {
      return Math.round(low + (Math.random() * (high - low)));
    }
    
    /**
     * The Quick Sort algorithm.
     *
     * @param {Array} ary
     *        An array to sort.
     * @param {function} comparator
     *        Function to use to compare two items.
     * @param {Number} p
     *        Start index of the array
     * @param {Number} r
     *        End index of the array
     */
    function doQuickSort(ary, comparator, p, r) {
      // If our lower bound is less than our upper bound, we (1) partition the
      // array into two pieces and (2) recurse on each half. If it is not, this is
      // the empty array and our base case.
    
      if (p < r) {
        // (1) Partitioning.
        //
        // The partitioning chooses a pivot between `p` and `r` and moves all
        // elements that are less than or equal to the pivot to the before it, and
        // all the elements that are greater than it after it. The effect is that
        // once partition is done, the pivot is in the exact place it will be when
        // the array is put in sorted order, and it will not need to be moved
        // again. This runs in O(n) time.
    
        // Always choose a random pivot so that an input array which is reverse
        // sorted does not cause O(n^2) running time.
        var pivotIndex = randomIntInRange(p, r);
        var i = p - 1;
    
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
    
        // Immediately after `j` is incremented in this loop, the following hold
        // true:
        //
        //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
        //
        //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
        for (var j = p; j < r; j++) {
          if (comparator(ary[j], pivot) <= 0) {
            i += 1;
            swap(ary, i, j);
          }
        }
    
        swap(ary, i + 1, j);
        var q = i + 1;
    
        // (2) Recurse on each half.
    
        doQuickSort(ary, comparator, p, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    
    /**
     * Sort the given array in-place with the given comparator function.
     *
     * @param {Array} ary
     *        An array to sort.
     * @param {function} comparator
     *        Function to use to compare two items.
     */
    exports.quickSort = function (ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
    
    },{}],27:[function(require,module,exports){
    /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    
    var util = require('./util');
    var binarySearch = require('./binary-search');
    var ArraySet = require('./array-set').ArraySet;
    var base64VLQ = require('./base64-vlq');
    var quickSort = require('./quick-sort').quickSort;
    
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
    
      return sourceMap.sections != null
        ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)
        : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    }
    
    /**
     * The version of the source mapping spec that we are consuming.
     */
    SourceMapConsumer.prototype._version = 3;
    
    // `__generatedMappings` and `__originalMappings` are arrays that hold the
    // parsed mapping coordinates from the source map's "mappings" attribute. They
    // are lazily instantiated, accessed via the `_generatedMappings` and
    // `_originalMappings` getters respectively, and we only parse the mappings
    // and create these arrays once queried for a source location. We jump through
    // these hoops because there can be many thousands of mappings, and parsing
    // them is expensive, so we only want to do it if we must.
    //
    // Each object in the arrays is of the form:
    //
    //     {
    //       generatedLine: The line number in the generated code,
    //       generatedColumn: The column number in the generated code,
    //       source: The path to the original source file that generated this
    //               chunk of code,
    //       originalLine: The line number in the original source that
    //                     corresponds to this chunk of generated code,
    //       originalColumn: The column number in the original source that
    //                       corresponds to this chunk of generated code,
    //       name: The name of the original symbol which generated this chunk of
    //             code.
    //     }
    //
    // All properties except for `generatedLine` and `generatedColumn` can be
    // `null`.
    //
    // `_generatedMappings` is ordered by the generated positions.
    //
    // `_originalMappings` is ordered by the original positions.
    
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
      configurable: true,
      enumerable: true,
      get: function () {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
    
        return this.__generatedMappings;
      }
    });
    
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
      configurable: true,
      enumerable: true,
      get: function () {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
    
        return this.__originalMappings;
      }
    });
    
    SourceMapConsumer.prototype._charIsMappingSeparator =
      function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
        var c = aStr.charAt(index);
        return c === ";" || c === ",";
      };
    
    /**
     * Parse the mappings in a string in to a data structure which we can easily
     * query (the ordered arrays in the `this.__generatedMappings` and
     * `this.__originalMappings` properties).
     */
    SourceMapConsumer.prototype._parseMappings =
      function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        throw new Error("Subclasses must implement _parseMappings");
      };
    
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    
    /**
     * Iterate over each mapping between an original source/line/column and a
     * generated line/column in this source map.
     *
     * @param Function aCallback
     *        The function that is called with each mapping.
     * @param Object aContext
     *        Optional. If specified, this object will be the value of `this` every
     *        time that `aCallback` is called.
     * @param aOrder
     *        Either `SourceMapConsumer.GENERATED_ORDER` or
     *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
     *        iterate over the mappings sorted by the generated file's line/column
     *        order or the original's source/line/column order, respectively. Defaults to
     *        `SourceMapConsumer.GENERATED_ORDER`.
     */
    SourceMapConsumer.prototype.eachMapping =
      function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
        var context = aContext || null;
        var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    
        var mappings;
        switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
        }
    
        var sourceRoot = this.sourceRoot;
        mappings.map(function (mapping) {
          var source = mapping.source === null ? null : this._sources.at(mapping.source);
          source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
          return {
            source: source,
            generatedLine: mapping.generatedLine,
            generatedColumn: mapping.generatedColumn,
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name: mapping.name === null ? null : this._names.at(mapping.name)
          };
        }, this).forEach(aCallback, context);
      };
    
    /**
     * Returns all generated line and column information for the original source,
     * line, and column provided. If no column is provided, returns all mappings
     * corresponding to a either the line we are searching for or the next
     * closest line that has any mappings. Otherwise, returns all mappings
     * corresponding to the given line and either the column we are searching for
     * or the next closest column that has any offsets.
     *
     * The only argument is an object with the following properties:
     *
     *   - source: The filename of the original source.
     *   - line: The line number in the original source.  The line number is 1-based.
     *   - column: Optional. the column number in the original source.
     *    The column number is 0-based.
     *
     * and an array of objects is returned, each with the following properties:
     *
     *   - line: The line number in the generated source, or null.  The
     *    line number is 1-based.
     *   - column: The column number in the generated source, or null.
     *    The column number is 0-based.
     */
    SourceMapConsumer.prototype.allGeneratedPositionsFor =
      function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
        var line = util.getArg(aArgs, 'line');
    
        // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
        // returns the index of the closest mapping less than the needle. By
        // setting needle.originalColumn to 0, we thus find the last mapping for
        // the given line, provided such a mapping exists.
        var needle = {
          source: util.getArg(aArgs, 'source'),
          originalLine: line,
          originalColumn: util.getArg(aArgs, 'column', 0)
        };
    
        needle.source = this._findSourceIndex(needle.source);
        if (needle.source < 0) {
          return [];
        }
    
        var mappings = [];
    
        var index = this._findMapping(needle,
                                      this._originalMappings,
                                      "originalLine",
                                      "originalColumn",
                                      util.compareByOriginalPositions,
                                      binarySearch.LEAST_UPPER_BOUND);
        if (index >= 0) {
          var mapping = this._originalMappings[index];
    
          if (aArgs.column === undefined) {
            var originalLine = mapping.originalLine;
    
            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we found. Since
            // mappings are sorted, this is guaranteed to find all mappings for
            // the line we found.
            while (mapping && mapping.originalLine === originalLine) {
              mappings.push({
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
              });
    
              mapping = this._originalMappings[++index];
            }
          } else {
            var originalColumn = mapping.originalColumn;
    
            // Iterate until either we run out of mappings, or we run into
            // a mapping for a different line than the one we were searching for.
            // Since mappings are sorted, this is guaranteed to find all mappings for
            // the line we are searching for.
            while (mapping &&
                   mapping.originalLine === line &&
                   mapping.originalColumn == originalColumn) {
              mappings.push({
                line: util.getArg(mapping, 'generatedLine', null),
                column: util.getArg(mapping, 'generatedColumn', null),
                lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
              });
    
              mapping = this._originalMappings[++index];
            }
          }
        }
    
        return mappings;
      };
    
    exports.SourceMapConsumer = SourceMapConsumer;
    
    /**
     * A BasicSourceMapConsumer instance represents a parsed source map which we can
     * query for information about the original file positions by giving it a file
     * position in the generated source.
     *
     * The first parameter is the raw source map (either as a JSON string, or
     * already parsed to an object). According to the spec, source maps have the
     * following attributes:
     *
     *   - version: Which version of the source map spec this map is following.
     *   - sources: An array of URLs to the original source files.
     *   - names: An array of identifiers which can be referrenced by individual mappings.
     *   - sourceRoot: Optional. The URL root from which all sources are relative.
     *   - sourcesContent: Optional. An array of contents of the original source files.
     *   - mappings: A string of base64 VLQs which contain the actual mappings.
     *   - file: Optional. The generated file this source map is associated with.
     *
     * Here is an example source map, taken from the source map spec[0]:
     *
     *     {
     *       version : 3,
     *       file: "out.js",
     *       sourceRoot : "",
     *       sources: ["foo.js", "bar.js"],
     *       names: ["src", "maps", "are", "fun"],
     *       mappings: "AA,AB;;ABCDE;"
     *     }
     *
     * The second parameter, if given, is a string whose value is the URL
     * at which the source map was found.  This URL is used to compute the
     * sources array.
     *
     * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
     */
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
    
      var version = util.getArg(sourceMap, 'version');
      var sources = util.getArg(sourceMap, 'sources');
      // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
      // requires the array) to play nice here.
      var names = util.getArg(sourceMap, 'names', []);
      var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
      var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
      var mappings = util.getArg(sourceMap, 'mappings');
      var file = util.getArg(sourceMap, 'file', null);
    
      // Once again, Sass deviates from the spec and supplies the version as a
      // string rather than a number, so we use loose equality checking here.
      if (version != this._version) {
        throw new Error('Unsupported version: ' + version);
      }
    
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
    
      sources = sources
        .map(String)
        // Some source maps produce relative source paths like "./foo.js" instead of
        // "foo.js".  Normalize these first so that future comparisons will succeed.
        // See bugzil.la/1090768.
        .map(util.normalize)
        // Always ensure that absolute sources are internally stored relative to
        // the source root, if the source root is absolute. Not doing this would
        // be particularly problematic when the source root is a prefix of the
        // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
        .map(function (source) {
          return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source)
            ? util.relative(sourceRoot, source)
            : source;
        });
    
      // Pass `true` below to allow duplicate names and sources. While source maps
      // are intended to be compressed and deduplicated, the TypeScript compiler
      // sometimes generates source maps with duplicates in them. See Github issue
      // #72 and bugzil.la/889492.
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
    
      this._absoluteSources = this._sources.toArray().map(function (s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
    
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file;
    }
    
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    
    /**
     * Utility function to find the index of a source.  Returns -1 if not
     * found.
     */
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
    
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
    
      // Maybe aSource is an absolute URL as returned by |sources|.  In
      // this case we can't simply undo the transform.
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
    
      return -1;
    };
    
    /**
     * Create a BasicSourceMapConsumer from a SourceMapGenerator.
     *
     * @param SourceMapGenerator aSourceMap
     *        The source map that will be consumed.
     * @param String aSourceMapURL
     *        The URL at which the source map can be found (optional)
     * @returns BasicSourceMapConsumer
     */
    BasicSourceMapConsumer.fromSourceMap =
      function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
        var smc = Object.create(BasicSourceMapConsumer.prototype);
    
        var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
        var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
        smc.sourceRoot = aSourceMap._sourceRoot;
        smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(),
                                                                smc.sourceRoot);
        smc.file = aSourceMap._file;
        smc._sourceMapURL = aSourceMapURL;
        smc._absoluteSources = smc._sources.toArray().map(function (s) {
          return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
        });
    
        // Because we are modifying the entries (by converting string sources and
        // names to indices into the sources and names ArraySets), we have to make
        // a copy of the entry or else bad things happen. Shared mutable state
        // strikes again! See github issue #191.
    
        var generatedMappings = aSourceMap._mappings.toArray().slice();
        var destGeneratedMappings = smc.__generatedMappings = [];
        var destOriginalMappings = smc.__originalMappings = [];
    
        for (var i = 0, length = generatedMappings.length; i < length; i++) {
          var srcMapping = generatedMappings[i];
          var destMapping = new Mapping;
          destMapping.generatedLine = srcMapping.generatedLine;
          destMapping.generatedColumn = srcMapping.generatedColumn;
    
          if (srcMapping.source) {
            destMapping.source = sources.indexOf(srcMapping.source);
            destMapping.originalLine = srcMapping.originalLine;
            destMapping.originalColumn = srcMapping.originalColumn;
    
            if (srcMapping.name) {
              destMapping.name = names.indexOf(srcMapping.name);
            }
    
            destOriginalMappings.push(destMapping);
          }
    
          destGeneratedMappings.push(destMapping);
        }
    
        quickSort(smc.__originalMappings, util.compareByOriginalPositions);
    
        return smc;
      };
    
    /**
     * The version of the source mapping spec that we are consuming.
     */
    BasicSourceMapConsumer.prototype._version = 3;
    
    /**
     * The list of original sources.
     */
    Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
      get: function () {
        return this._absoluteSources.slice();
      }
    });
    
    /**
     * Provide the JIT with a nice shape / hidden class.
     */
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    
    /**
     * Parse the mappings in a string in to a data structure which we can easily
     * query (the ordered arrays in the `this.__generatedMappings` and
     * `this.__originalMappings` properties).
     */
    BasicSourceMapConsumer.prototype._parseMappings =
      function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        var generatedLine = 1;
        var previousGeneratedColumn = 0;
        var previousOriginalLine = 0;
        var previousOriginalColumn = 0;
        var previousSource = 0;
        var previousName = 0;
        var length = aStr.length;
        var index = 0;
        var cachedSegments = {};
        var temp = {};
        var originalMappings = [];
        var generatedMappings = [];
        var mapping, str, segment, end, value;
    
        while (index < length) {
          if (aStr.charAt(index) === ';') {
            generatedLine++;
            index++;
            previousGeneratedColumn = 0;
          }
          else if (aStr.charAt(index) === ',') {
            index++;
          }
          else {
            mapping = new Mapping();
            mapping.generatedLine = generatedLine;
    
            // Because each offset is encoded relative to the previous one,
            // many segments often have the same encoding. We can exploit this
            // fact by caching the parsed variable length fields of each segment,
            // allowing us to avoid a second parse if we encounter the same
            // segment again.
            for (end = index; end < length; end++) {
              if (this._charIsMappingSeparator(aStr, end)) {
                break;
              }
            }
            str = aStr.slice(index, end);
    
            segment = cachedSegments[str];
            if (segment) {
              index += str.length;
            } else {
              segment = [];
              while (index < end) {
                base64VLQ.decode(aStr, index, temp);
                value = temp.value;
                index = temp.rest;
                segment.push(value);
              }
    
              if (segment.length === 2) {
                throw new Error('Found a source, but no line and column');
              }
    
              if (segment.length === 3) {
                throw new Error('Found a source and line, but no column');
              }
    
              cachedSegments[str] = segment;
            }
    
            // Generated column.
            mapping.generatedColumn = previousGeneratedColumn + segment[0];
            previousGeneratedColumn = mapping.generatedColumn;
    
            if (segment.length > 1) {
              // Original source.
              mapping.source = previousSource + segment[1];
              previousSource += segment[1];
    
              // Original line.
              mapping.originalLine = previousOriginalLine + segment[2];
              previousOriginalLine = mapping.originalLine;
              // Lines are stored 0-based
              mapping.originalLine += 1;
    
              // Original column.
              mapping.originalColumn = previousOriginalColumn + segment[3];
              previousOriginalColumn = mapping.originalColumn;
    
              if (segment.length > 4) {
                // Original name.
                mapping.name = previousName + segment[4];
                previousName += segment[4];
              }
            }
    
            generatedMappings.push(mapping);
            if (typeof mapping.originalLine === 'number') {
              originalMappings.push(mapping);
            }
          }
        }
    
        quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
        this.__generatedMappings = generatedMappings;
    
        quickSort(originalMappings, util.compareByOriginalPositions);
        this.__originalMappings = originalMappings;
      };
    
    /**
     * Find the mapping that best matches the hypothetical "needle" mapping that
     * we are searching for in the given "haystack" of mappings.
     */
    BasicSourceMapConsumer.prototype._findMapping =
      function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName,
                                             aColumnName, aComparator, aBias) {
        // To return the position we are searching for, we must first find the
        // mapping for the given position and then return the opposite position it
        // points to. Because the mappings are sorted, we can use binary search to
        // find the best mapping.
    
        if (aNeedle[aLineName] <= 0) {
          throw new TypeError('Line must be greater than or equal to 1, got '
                              + aNeedle[aLineName]);
        }
        if (aNeedle[aColumnName] < 0) {
          throw new TypeError('Column must be greater than or equal to 0, got '
                              + aNeedle[aColumnName]);
        }
    
        return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
      };
    
    /**
     * Compute the last column for each generated mapping. The last column is
     * inclusive.
     */
    BasicSourceMapConsumer.prototype.computeColumnSpans =
      function SourceMapConsumer_computeColumnSpans() {
        for (var index = 0; index < this._generatedMappings.length; ++index) {
          var mapping = this._generatedMappings[index];
    
          // Mappings do not contain a field for the last generated columnt. We
          // can come up with an optimistic estimate, however, by assuming that
          // mappings are contiguous (i.e. given two consecutive mappings, the
          // first mapping ends where the second one starts).
          if (index + 1 < this._generatedMappings.length) {
            var nextMapping = this._generatedMappings[index + 1];
    
            if (mapping.generatedLine === nextMapping.generatedLine) {
              mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
              continue;
            }
          }
    
          // The last mapping for each line spans the entire line.
          mapping.lastGeneratedColumn = Infinity;
        }
      };
    
    /**
     * Returns the original source, line, and column information for the generated
     * source's line and column positions provided. The only argument is an object
     * with the following properties:
     *
     *   - line: The line number in the generated source.  The line number
     *     is 1-based.
     *   - column: The column number in the generated source.  The column
     *     number is 0-based.
     *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
     *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
     *     closest element that is smaller than or greater than the one we are
     *     searching for, respectively, if the exact element cannot be found.
     *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
     *
     * and an object is returned with the following properties:
     *
     *   - source: The original source file, or null.
     *   - line: The line number in the original source, or null.  The
     *     line number is 1-based.
     *   - column: The column number in the original source, or null.  The
     *     column number is 0-based.
     *   - name: The original identifier, or null.
     */
    BasicSourceMapConsumer.prototype.originalPositionFor =
      function SourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, 'line'),
          generatedColumn: util.getArg(aArgs, 'column')
        };
    
        var index = this._findMapping(
          needle,
          this._generatedMappings,
          "generatedLine",
          "generatedColumn",
          util.compareByGeneratedPositionsDeflated,
          util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
        );
    
        if (index >= 0) {
          var mapping = this._generatedMappings[index];
    
          if (mapping.generatedLine === needle.generatedLine) {
            var source = util.getArg(mapping, 'source', null);
            if (source !== null) {
              source = this._sources.at(source);
              source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
            }
            var name = util.getArg(mapping, 'name', null);
            if (name !== null) {
              name = this._names.at(name);
            }
            return {
              source: source,
              line: util.getArg(mapping, 'originalLine', null),
              column: util.getArg(mapping, 'originalColumn', null),
              name: name
            };
          }
        }
    
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      };
    
    /**
     * Return true if we have the source content for every source in the source
     * map, false otherwise.
     */
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources =
      function BasicSourceMapConsumer_hasContentsOfAllSources() {
        if (!this.sourcesContent) {
          return false;
        }
        return this.sourcesContent.length >= this._sources.size() &&
          !this.sourcesContent.some(function (sc) { return sc == null; });
      };
    
    /**
     * Returns the original source content. The only argument is the url of the
     * original source file. Returns null if no original source content is
     * available.
     */
    BasicSourceMapConsumer.prototype.sourceContentFor =
      function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        if (!this.sourcesContent) {
          return null;
        }
    
        var index = this._findSourceIndex(aSource);
        if (index >= 0) {
          return this.sourcesContent[index];
        }
    
        var relativeSource = aSource;
        if (this.sourceRoot != null) {
          relativeSource = util.relative(this.sourceRoot, relativeSource);
        }
    
        var url;
        if (this.sourceRoot != null
            && (url = util.urlParse(this.sourceRoot))) {
          // XXX: file:// URIs and absolute paths lead to unexpected behavior for
          // many users. We can help them out when they expect file:// URIs to
          // behave like it would if they were running a local HTTP server. See
          // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
          var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
          if (url.scheme == "file"
              && this._sources.has(fileUriAbsPath)) {
            return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)]
          }
    
          if ((!url.path || url.path == "/")
              && this._sources.has("/" + relativeSource)) {
            return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
          }
        }
    
        // This function is used recursively from
        // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
        // don't want to throw if we can't find the source - we just want to
        // return null, so we provide a flag to exit gracefully.
        if (nullOnMissing) {
          return null;
        }
        else {
          throw new Error('"' + relativeSource + '" is not in the SourceMap.');
        }
      };
    
    /**
     * Returns the generated line and column information for the original source,
     * line, and column positions provided. The only argument is an object with
     * the following properties:
     *
     *   - source: The filename of the original source.
     *   - line: The line number in the original source.  The line number
     *     is 1-based.
     *   - column: The column number in the original source.  The column
     *     number is 0-based.
     *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
     *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
     *     closest element that is smaller than or greater than the one we are
     *     searching for, respectively, if the exact element cannot be found.
     *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
     *
     * and an object is returned with the following properties:
     *
     *   - line: The line number in the generated source, or null.  The
     *     line number is 1-based.
     *   - column: The column number in the generated source, or null.
     *     The column number is 0-based.
     */
    BasicSourceMapConsumer.prototype.generatedPositionFor =
      function SourceMapConsumer_generatedPositionFor(aArgs) {
        var source = util.getArg(aArgs, 'source');
        source = this._findSourceIndex(source);
        if (source < 0) {
          return {
            line: null,
            column: null,
            lastColumn: null
          };
        }
    
        var needle = {
          source: source,
          originalLine: util.getArg(aArgs, 'line'),
          originalColumn: util.getArg(aArgs, 'column')
        };
    
        var index = this._findMapping(
          needle,
          this._originalMappings,
          "originalLine",
          "originalColumn",
          util.compareByOriginalPositions,
          util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND)
        );
    
        if (index >= 0) {
          var mapping = this._originalMappings[index];
    
          if (mapping.source === needle.source) {
            return {
              line: util.getArg(mapping, 'generatedLine', null),
              column: util.getArg(mapping, 'generatedColumn', null),
              lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
            };
          }
        }
    
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      };
    
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    
    /**
     * An IndexedSourceMapConsumer instance represents a parsed source map which
     * we can query for information. It differs from BasicSourceMapConsumer in
     * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
     * input.
     *
     * The first parameter is a raw source map (either as a JSON string, or already
     * parsed to an object). According to the spec for indexed source maps, they
     * have the following attributes:
     *
     *   - version: Which version of the source map spec this map is following.
     *   - file: Optional. The generated file this source map is associated with.
     *   - sections: A list of section definitions.
     *
     * Each value under the "sections" field has two fields:
     *   - offset: The offset into the original specified at which this section
     *       begins to apply, defined as an object with a "line" and "column"
     *       field.
     *   - map: A source map definition. This source map could also be indexed,
     *       but doesn't have to be.
     *
     * Instead of the "map" field, it's also possible to have a "url" field
     * specifying a URL to retrieve a source map from, but that's currently
     * unsupported.
     *
     * Here's an example source map, taken from the source map spec[0], but
     * modified to omit a section which uses the "url" field.
     *
     *  {
     *    version : 3,
     *    file: "app.js",
     *    sections: [{
     *      offset: {line:100, column:10},
     *      map: {
     *        version : 3,
     *        file: "section.js",
     *        sources: ["foo.js", "bar.js"],
     *        names: ["src", "maps", "are", "fun"],
     *        mappings: "AAAA,E;;ABCDE;"
     *      }
     *    }],
     *  }
     *
     * The second parameter, if given, is a string whose value is the URL
     * at which the source map was found.  This URL is used to compute the
     * sources array.
     *
     * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
     */
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === 'string') {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
    
      var version = util.getArg(sourceMap, 'version');
      var sections = util.getArg(sourceMap, 'sections');
    
      if (version != this._version) {
        throw new Error('Unsupported version: ' + version);
      }
    
      this._sources = new ArraySet();
      this._names = new ArraySet();
    
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function (s) {
        if (s.url) {
          // The url field will require support for asynchronicity.
          // See https://github.com/mozilla/source-map/issues/16
          throw new Error('Support for url field in sections not implemented.');
        }
        var offset = util.getArg(s, 'offset');
        var offsetLine = util.getArg(offset, 'line');
        var offsetColumn = util.getArg(offset, 'column');
    
        if (offsetLine < lastOffset.line ||
            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)) {
          throw new Error('Section offsets must be ordered and non-overlapping.');
        }
        lastOffset = offset;
    
        return {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
        }
      });
    }
    
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    
    /**
     * The version of the source mapping spec that we are consuming.
     */
    IndexedSourceMapConsumer.prototype._version = 3;
    
    /**
     * The list of original sources.
     */
    Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
      get: function () {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
            sources.push(this._sections[i].consumer.sources[j]);
          }
        }
        return sources;
      }
    });
    
    /**
     * Returns the original source, line, and column information for the generated
     * source's line and column positions provided. The only argument is an object
     * with the following properties:
     *
     *   - line: The line number in the generated source.  The line number
     *     is 1-based.
     *   - column: The column number in the generated source.  The column
     *     number is 0-based.
     *
     * and an object is returned with the following properties:
     *
     *   - source: The original source file, or null.
     *   - line: The line number in the original source, or null.  The
     *     line number is 1-based.
     *   - column: The column number in the original source, or null.  The
     *     column number is 0-based.
     *   - name: The original identifier, or null.
     */
    IndexedSourceMapConsumer.prototype.originalPositionFor =
      function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
        var needle = {
          generatedLine: util.getArg(aArgs, 'line'),
          generatedColumn: util.getArg(aArgs, 'column')
        };
    
        // Find the section containing the generated position we're trying to map
        // to an original position.
        var sectionIndex = binarySearch.search(needle, this._sections,
          function(needle, section) {
            var cmp = needle.generatedLine - section.generatedOffset.generatedLine;
            if (cmp) {
              return cmp;
            }
    
            return (needle.generatedColumn -
                    section.generatedOffset.generatedColumn);
          });
        var section = this._sections[sectionIndex];
    
        if (!section) {
          return {
            source: null,
            line: null,
            column: null,
            name: null
          };
        }
    
        return section.consumer.originalPositionFor({
          line: needle.generatedLine -
            (section.generatedOffset.generatedLine - 1),
          column: needle.generatedColumn -
            (section.generatedOffset.generatedLine === needle.generatedLine
             ? section.generatedOffset.generatedColumn - 1
             : 0),
          bias: aArgs.bias
        });
      };
    
    /**
     * Return true if we have the source content for every source in the source
     * map, false otherwise.
     */
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources =
      function IndexedSourceMapConsumer_hasContentsOfAllSources() {
        return this._sections.every(function (s) {
          return s.consumer.hasContentsOfAllSources();
        });
      };
    
    /**
     * Returns the original source content. The only argument is the url of the
     * original source file. Returns null if no original source content is
     * available.
     */
    IndexedSourceMapConsumer.prototype.sourceContentFor =
      function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
    
          var content = section.consumer.sourceContentFor(aSource, true);
          if (content) {
            return content;
          }
        }
        if (nullOnMissing) {
          return null;
        }
        else {
          throw new Error('"' + aSource + '" is not in the SourceMap.');
        }
      };
    
    /**
     * Returns the generated line and column information for the original source,
     * line, and column positions provided. The only argument is an object with
     * the following properties:
     *
     *   - source: The filename of the original source.
     *   - line: The line number in the original source.  The line number
     *     is 1-based.
     *   - column: The column number in the original source.  The column
     *     number is 0-based.
     *
     * and an object is returned with the following properties:
     *
     *   - line: The line number in the generated source, or null.  The
     *     line number is 1-based. 
     *   - column: The column number in the generated source, or null.
     *     The column number is 0-based.
     */
    IndexedSourceMapConsumer.prototype.generatedPositionFor =
      function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
    
          // Only consider this section if the requested source is in the list of
          // sources of the consumer.
          if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
            continue;
          }
          var generatedPosition = section.consumer.generatedPositionFor(aArgs);
          if (generatedPosition) {
            var ret = {
              line: generatedPosition.line +
                (section.generatedOffset.generatedLine - 1),
              column: generatedPosition.column +
                (section.generatedOffset.generatedLine === generatedPosition.line
                 ? section.generatedOffset.generatedColumn - 1
                 : 0)
            };
            return ret;
          }
        }
    
        return {
          line: null,
          column: null
        };
      };
    
    /**
     * Parse the mappings in a string in to a data structure which we can easily
     * query (the ordered arrays in the `this.__generatedMappings` and
     * `this.__originalMappings` properties).
     */
    IndexedSourceMapConsumer.prototype._parseMappings =
      function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
        this.__generatedMappings = [];
        this.__originalMappings = [];
        for (var i = 0; i < this._sections.length; i++) {
          var section = this._sections[i];
          var sectionMappings = section.consumer._generatedMappings;
          for (var j = 0; j < sectionMappings.length; j++) {
            var mapping = sectionMappings[j];
    
            var source = section.consumer._sources.at(mapping.source);
            source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
            this._sources.add(source);
            source = this._sources.indexOf(source);
    
            var name = null;
            if (mapping.name) {
              name = section.consumer._names.at(mapping.name);
              this._names.add(name);
              name = this._names.indexOf(name);
            }
    
            // The mappings coming from the consumer for the section have
            // generated positions relative to the start of the section, so we
            // need to offset them to be relative to the start of the concatenated
            // generated file.
            var adjustedMapping = {
              source: source,
              generatedLine: mapping.generatedLine +
                (section.generatedOffset.generatedLine - 1),
              generatedColumn: mapping.generatedColumn +
                (section.generatedOffset.generatedLine === mapping.generatedLine
                ? section.generatedOffset.generatedColumn - 1
                : 0),
              originalLine: mapping.originalLine,
              originalColumn: mapping.originalColumn,
              name: name
            };
    
            this.__generatedMappings.push(adjustedMapping);
            if (typeof adjustedMapping.originalLine === 'number') {
              this.__originalMappings.push(adjustedMapping);
            }
          }
        }
    
        quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
        quickSort(this.__originalMappings, util.compareByOriginalPositions);
      };
    
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
    
    },{"./array-set":21,"./base64-vlq":22,"./binary-search":24,"./quick-sort":26,"./util":30}],28:[function(require,module,exports){
    /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    
    var base64VLQ = require('./base64-vlq');
    var util = require('./util');
    var ArraySet = require('./array-set').ArraySet;
    var MappingList = require('./mapping-list').MappingList;
    
    /**
     * An instance of the SourceMapGenerator represents a source map which is
     * being built incrementally. You may pass an object with the following
     * properties:
     *
     *   - file: The filename of the generated source.
     *   - sourceRoot: A root for all relative URLs in this source map.
     */
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, 'file', null);
      this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
      this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    
    SourceMapGenerator.prototype._version = 3;
    
    /**
     * Creates a new SourceMapGenerator based on a SourceMapConsumer
     *
     * @param aSourceMapConsumer The SourceMap.
     */
    SourceMapGenerator.fromSourceMap =
      function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
        var sourceRoot = aSourceMapConsumer.sourceRoot;
        var generator = new SourceMapGenerator({
          file: aSourceMapConsumer.file,
          sourceRoot: sourceRoot
        });
        aSourceMapConsumer.eachMapping(function (mapping) {
          var newMapping = {
            generated: {
              line: mapping.generatedLine,
              column: mapping.generatedColumn
            }
          };
    
          if (mapping.source != null) {
            newMapping.source = mapping.source;
            if (sourceRoot != null) {
              newMapping.source = util.relative(sourceRoot, newMapping.source);
            }
    
            newMapping.original = {
              line: mapping.originalLine,
              column: mapping.originalColumn
            };
    
            if (mapping.name != null) {
              newMapping.name = mapping.name;
            }
          }
    
          generator.addMapping(newMapping);
        });
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var sourceRelative = sourceFile;
          if (sourceRoot !== null) {
            sourceRelative = util.relative(sourceRoot, sourceFile);
          }
    
          if (!generator._sources.has(sourceRelative)) {
            generator._sources.add(sourceRelative);
          }
    
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            generator.setSourceContent(sourceFile, content);
          }
        });
        return generator;
      };
    
    /**
     * Add a single mapping from original source line and column to the generated
     * source's line and column for this source map being created. The mapping
     * object should have the following properties:
     *
     *   - generated: An object with the generated line and column positions.
     *   - original: An object with the original line and column positions.
     *   - source: The original source file (relative to the sourceRoot).
     *   - name: An optional original token name for this mapping.
     */
    SourceMapGenerator.prototype.addMapping =
      function SourceMapGenerator_addMapping(aArgs) {
        var generated = util.getArg(aArgs, 'generated');
        var original = util.getArg(aArgs, 'original', null);
        var source = util.getArg(aArgs, 'source', null);
        var name = util.getArg(aArgs, 'name', null);
    
        if (!this._skipValidation) {
          this._validateMapping(generated, original, source, name);
        }
    
        if (source != null) {
          source = String(source);
          if (!this._sources.has(source)) {
            this._sources.add(source);
          }
        }
    
        if (name != null) {
          name = String(name);
          if (!this._names.has(name)) {
            this._names.add(name);
          }
        }
    
        this._mappings.add({
          generatedLine: generated.line,
          generatedColumn: generated.column,
          originalLine: original != null && original.line,
          originalColumn: original != null && original.column,
          source: source,
          name: name
        });
      };
    
    /**
     * Set the source content for a source file.
     */
    SourceMapGenerator.prototype.setSourceContent =
      function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
        var source = aSourceFile;
        if (this._sourceRoot != null) {
          source = util.relative(this._sourceRoot, source);
        }
    
        if (aSourceContent != null) {
          // Add the source content to the _sourcesContents map.
          // Create a new _sourcesContents map if the property is null.
          if (!this._sourcesContents) {
            this._sourcesContents = Object.create(null);
          }
          this._sourcesContents[util.toSetString(source)] = aSourceContent;
        } else if (this._sourcesContents) {
          // Remove the source file from the _sourcesContents map.
          // If the _sourcesContents map is empty, set the property to null.
          delete this._sourcesContents[util.toSetString(source)];
          if (Object.keys(this._sourcesContents).length === 0) {
            this._sourcesContents = null;
          }
        }
      };
    
    /**
     * Applies the mappings of a sub-source-map for a specific source file to the
     * source map being generated. Each mapping to the supplied source file is
     * rewritten using the supplied source map. Note: The resolution for the
     * resulting mappings is the minimium of this map and the supplied map.
     *
     * @param aSourceMapConsumer The source map to be applied.
     * @param aSourceFile Optional. The filename of the source file.
     *        If omitted, SourceMapConsumer's file property will be used.
     * @param aSourceMapPath Optional. The dirname of the path to the source map
     *        to be applied. If relative, it is relative to the SourceMapConsumer.
     *        This parameter is needed when the two source maps aren't in the same
     *        directory, and the source map to be applied contains relative source
     *        paths. If so, those relative source paths need to be rewritten
     *        relative to the SourceMapGenerator.
     */
    SourceMapGenerator.prototype.applySourceMap =
      function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
        var sourceFile = aSourceFile;
        // If aSourceFile is omitted, we will use the file property of the SourceMap
        if (aSourceFile == null) {
          if (aSourceMapConsumer.file == null) {
            throw new Error(
              'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
              'or the source map\'s "file" property. Both were omitted.'
            );
          }
          sourceFile = aSourceMapConsumer.file;
        }
        var sourceRoot = this._sourceRoot;
        // Make "sourceFile" relative if an absolute Url is passed.
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        // Applying the SourceMap can add and remove items from the sources and
        // the names array.
        var newSources = new ArraySet();
        var newNames = new ArraySet();
    
        // Find mappings for the "sourceFile"
        this._mappings.unsortedForEach(function (mapping) {
          if (mapping.source === sourceFile && mapping.originalLine != null) {
            // Check if it can be mapped by the source map, then update the mapping.
            var original = aSourceMapConsumer.originalPositionFor({
              line: mapping.originalLine,
              column: mapping.originalColumn
            });
            if (original.source != null) {
              // Copy mapping
              mapping.source = original.source;
              if (aSourceMapPath != null) {
                mapping.source = util.join(aSourceMapPath, mapping.source)
              }
              if (sourceRoot != null) {
                mapping.source = util.relative(sourceRoot, mapping.source);
              }
              mapping.originalLine = original.line;
              mapping.originalColumn = original.column;
              if (original.name != null) {
                mapping.name = original.name;
              }
            }
          }
    
          var source = mapping.source;
          if (source != null && !newSources.has(source)) {
            newSources.add(source);
          }
    
          var name = mapping.name;
          if (name != null && !newNames.has(name)) {
            newNames.add(name);
          }
    
        }, this);
        this._sources = newSources;
        this._names = newNames;
    
        // Copy sourcesContents of applied map.
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aSourceMapPath != null) {
              sourceFile = util.join(aSourceMapPath, sourceFile);
            }
            if (sourceRoot != null) {
              sourceFile = util.relative(sourceRoot, sourceFile);
            }
            this.setSourceContent(sourceFile, content);
          }
        }, this);
      };
    
    /**
     * A mapping can have one of the three levels of data:
     *
     *   1. Just the generated position.
     *   2. The Generated position, original position, and original source.
     *   3. Generated and original position, original source, as well as a name
     *      token.
     *
     * To maintain consistency, we validate that any new mapping being added falls
     * in to one of these categories.
     */
    SourceMapGenerator.prototype._validateMapping =
      function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                                  aName) {
        // When aOriginal is truthy but has empty values for .line and .column,
        // it is most likely a programmer error. In this case we throw a very
        // specific error message to try to guide them the right way.
        // For example: https://github.com/Polymer/polymer-bundler/pull/519
        if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
            throw new Error(
                'original.line and original.column are not numbers -- you probably meant to omit ' +
                'the original mapping entirely and only map the generated position. If so, pass ' +
                'null for the original mapping instead of an object with empty or null values.'
            );
        }
    
        if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
            && aGenerated.line > 0 && aGenerated.column >= 0
            && !aOriginal && !aSource && !aName) {
          // Case 1.
          return;
        }
        else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
                 && aOriginal && 'line' in aOriginal && 'column' in aOriginal
                 && aGenerated.line > 0 && aGenerated.column >= 0
                 && aOriginal.line > 0 && aOriginal.column >= 0
                 && aSource) {
          // Cases 2 and 3.
          return;
        }
        else {
          throw new Error('Invalid mapping: ' + JSON.stringify({
            generated: aGenerated,
            source: aSource,
            original: aOriginal,
            name: aName
          }));
        }
      };
    
    /**
     * Serialize the accumulated mappings in to the stream of base 64 VLQs
     * specified by the source map format.
     */
    SourceMapGenerator.prototype._serializeMappings =
      function SourceMapGenerator_serializeMappings() {
        var previousGeneratedColumn = 0;
        var previousGeneratedLine = 1;
        var previousOriginalColumn = 0;
        var previousOriginalLine = 0;
        var previousName = 0;
        var previousSource = 0;
        var result = '';
        var next;
        var mapping;
        var nameIdx;
        var sourceIdx;
    
        var mappings = this._mappings.toArray();
        for (var i = 0, len = mappings.length; i < len; i++) {
          mapping = mappings[i];
          next = ''
    
          if (mapping.generatedLine !== previousGeneratedLine) {
            previousGeneratedColumn = 0;
            while (mapping.generatedLine !== previousGeneratedLine) {
              next += ';';
              previousGeneratedLine++;
            }
          }
          else {
            if (i > 0) {
              if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
                continue;
              }
              next += ',';
            }
          }
    
          next += base64VLQ.encode(mapping.generatedColumn
                                     - previousGeneratedColumn);
          previousGeneratedColumn = mapping.generatedColumn;
    
          if (mapping.source != null) {
            sourceIdx = this._sources.indexOf(mapping.source);
            next += base64VLQ.encode(sourceIdx - previousSource);
            previousSource = sourceIdx;
    
            // lines are stored 0-based in SourceMap spec version 3
            next += base64VLQ.encode(mapping.originalLine - 1
                                       - previousOriginalLine);
            previousOriginalLine = mapping.originalLine - 1;
    
            next += base64VLQ.encode(mapping.originalColumn
                                       - previousOriginalColumn);
            previousOriginalColumn = mapping.originalColumn;
    
            if (mapping.name != null) {
              nameIdx = this._names.indexOf(mapping.name);
              next += base64VLQ.encode(nameIdx - previousName);
              previousName = nameIdx;
            }
          }
    
          result += next;
        }
    
        return result;
      };
    
    SourceMapGenerator.prototype._generateSourcesContent =
      function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
        return aSources.map(function (source) {
          if (!this._sourcesContents) {
            return null;
          }
          if (aSourceRoot != null) {
            source = util.relative(aSourceRoot, source);
          }
          var key = util.toSetString(source);
          return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
            ? this._sourcesContents[key]
            : null;
        }, this);
      };
    
    /**
     * Externalize the source map.
     */
    SourceMapGenerator.prototype.toJSON =
      function SourceMapGenerator_toJSON() {
        var map = {
          version: this._version,
          sources: this._sources.toArray(),
          names: this._names.toArray(),
          mappings: this._serializeMappings()
        };
        if (this._file != null) {
          map.file = this._file;
        }
        if (this._sourceRoot != null) {
          map.sourceRoot = this._sourceRoot;
        }
        if (this._sourcesContents) {
          map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
        }
    
        return map;
      };
    
    /**
     * Render the source map being generated to a string.
     */
    SourceMapGenerator.prototype.toString =
      function SourceMapGenerator_toString() {
        return JSON.stringify(this.toJSON());
      };
    
    exports.SourceMapGenerator = SourceMapGenerator;
    
    },{"./array-set":21,"./base64-vlq":22,"./mapping-list":25,"./util":30}],29:[function(require,module,exports){
    /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    
    var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;
    var util = require('./util');
    
    // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
    // operating systems these days (capturing the result).
    var REGEX_NEWLINE = /(\r?\n)/;
    
    // Newline character code for charCodeAt() comparisons
    var NEWLINE_CODE = 10;
    
    // Private symbol for identifying `SourceNode`s when multiple versions of
    // the source-map library are loaded. This MUST NOT CHANGE across
    // versions!
    var isSourceNode = "$$$isSourceNode$$$";
    
    /**
     * SourceNodes provide a way to abstract over interpolating/concatenating
     * snippets of generated JavaScript source code while maintaining the line and
     * column information associated with the original source code.
     *
     * @param aLine The original line number.
     * @param aColumn The original column number.
     * @param aSource The original source's filename.
     * @param aChunks Optional. An array of strings which are snippets of
     *        generated JS, or other SourceNodes.
     * @param aName The original identifier.
     */
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null) this.add(aChunks);
    }
    
    /**
     * Creates a SourceNode from generated code and a SourceMapConsumer.
     *
     * @param aGeneratedCode The generated code
     * @param aSourceMapConsumer The SourceMap for the generated code
     * @param aRelativePath Optional. The path that relative sources in the
     *        SourceMapConsumer should be relative to.
     */
    SourceNode.fromStringWithSourceMap =
      function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
        // The SourceNode we want to fill with the generated code
        // and the SourceMap
        var node = new SourceNode();
    
        // All even indices of this array are one line of the generated code,
        // while all odd indices are the newlines between two adjacent lines
        // (since `REGEX_NEWLINE` captures its match).
        // Processed fragments are accessed by calling `shiftNextLine`.
        var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
        var remainingLinesIndex = 0;
        var shiftNextLine = function() {
          var lineContents = getNextLine();
          // The last line of a file might not have a newline.
          var newLine = getNextLine() || "";
          return lineContents + newLine;
    
          function getNextLine() {
            return remainingLinesIndex < remainingLines.length ?
                remainingLines[remainingLinesIndex++] : undefined;
          }
        };
    
        // We need to remember the position of "remainingLines"
        var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    
        // The generate SourceNodes we need a code range.
        // To extract it current and last mapping is used.
        // Here we store the last mapping.
        var lastMapping = null;
    
        aSourceMapConsumer.eachMapping(function (mapping) {
          if (lastMapping !== null) {
            // We add the code from "lastMapping" to "mapping":
            // First check if there is a new line in between.
            if (lastGeneratedLine < mapping.generatedLine) {
              // Associate first line with "lastMapping"
              addMappingWithCode(lastMapping, shiftNextLine());
              lastGeneratedLine++;
              lastGeneratedColumn = 0;
              // The remaining code is added without mapping
            } else {
              // There is no new line in between.
              // Associate the code between "lastGeneratedColumn" and
              // "mapping.generatedColumn" with "lastMapping"
              var nextLine = remainingLines[remainingLinesIndex] || '';
              var code = nextLine.substr(0, mapping.generatedColumn -
                                            lastGeneratedColumn);
              remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -
                                                  lastGeneratedColumn);
              lastGeneratedColumn = mapping.generatedColumn;
              addMappingWithCode(lastMapping, code);
              // No more remaining code, continue
              lastMapping = mapping;
              return;
            }
          }
          // We add the generated code until the first mapping
          // to the SourceNode without any mapping.
          // Each line is added as separate string.
          while (lastGeneratedLine < mapping.generatedLine) {
            node.add(shiftNextLine());
            lastGeneratedLine++;
          }
          if (lastGeneratedColumn < mapping.generatedColumn) {
            var nextLine = remainingLines[remainingLinesIndex] || '';
            node.add(nextLine.substr(0, mapping.generatedColumn));
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
          }
          lastMapping = mapping;
        }, this);
        // We have processed all mappings.
        if (remainingLinesIndex < remainingLines.length) {
          if (lastMapping) {
            // Associate the remaining code in the current line with "lastMapping"
            addMappingWithCode(lastMapping, shiftNextLine());
          }
          // and add the remaining lines without any mapping
          node.add(remainingLines.splice(remainingLinesIndex).join(""));
        }
    
        // Copy sourcesContent into SourceNode
        aSourceMapConsumer.sources.forEach(function (sourceFile) {
          var content = aSourceMapConsumer.sourceContentFor(sourceFile);
          if (content != null) {
            if (aRelativePath != null) {
              sourceFile = util.join(aRelativePath, sourceFile);
            }
            node.setSourceContent(sourceFile, content);
          }
        });
    
        return node;
    
        function addMappingWithCode(mapping, code) {
          if (mapping === null || mapping.source === undefined) {
            node.add(code);
          } else {
            var source = aRelativePath
              ? util.join(aRelativePath, mapping.source)
              : mapping.source;
            node.add(new SourceNode(mapping.originalLine,
                                    mapping.originalColumn,
                                    source,
                                    code,
                                    mapping.name));
          }
        }
      };
    
    /**
     * Add a chunk of generated JS to this source node.
     *
     * @param aChunk A string snippet of generated JS code, another instance of
     *        SourceNode, or an array where each member is one of those things.
     */
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function (chunk) {
          this.add(chunk);
        }, this);
      }
      else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      }
      else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    
    /**
     * Add a chunk of generated JS to the beginning of this source node.
     *
     * @param aChunk A string snippet of generated JS code, another instance of
     *        SourceNode, or an array where each member is one of those things.
     */
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length-1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      }
      else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      }
      else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    
    /**
     * Walk over the tree of JS snippets in this node and its children. The
     * walking function is called once for each snippet of JS and is passed that
     * snippet and the its original associated source's line/column location.
     *
     * @param aFn The traversal function.
     */
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        }
        else {
          if (chunk !== '') {
            aFn(chunk, { source: this.source,
                         line: this.line,
                         column: this.column,
                         name: this.name });
          }
        }
      }
    };
    
    /**
     * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
     * each of `this.children`.
     *
     * @param aSep The separator.
     */
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len-1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    
    /**
     * Call String.prototype.replace on the very right-most source snippet. Useful
     * for trimming whitespace from the end of a source node, etc.
     *
     * @param aPattern The pattern to replace.
     * @param aReplacement The thing to replace the pattern with.
     */
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      }
      else if (typeof lastChild === 'string') {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      }
      else {
        this.children.push(''.replace(aPattern, aReplacement));
      }
      return this;
    };
    
    /**
     * Set the source content for a source file. This will be added to the SourceMapGenerator
     * in the sourcesContent field.
     *
     * @param aSourceFile The filename of the source file
     * @param aSourceContent The content of the source file
     */
    SourceNode.prototype.setSourceContent =
      function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
        this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
      };
    
    /**
     * Walk over the tree of SourceNodes. The walking function is called for each
     * source file content and is passed the filename and source content.
     *
     * @param aFn The traversal function.
     */
    SourceNode.prototype.walkSourceContents =
      function SourceNode_walkSourceContents(aFn) {
        for (var i = 0, len = this.children.length; i < len; i++) {
          if (this.children[i][isSourceNode]) {
            this.children[i].walkSourceContents(aFn);
          }
        }
    
        var sources = Object.keys(this.sourceContents);
        for (var i = 0, len = sources.length; i < len; i++) {
          aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
        }
      };
    
    /**
     * Return the string representation of this source node. Walks over the tree
     * and concatenates all the various snippets together to one string.
     */
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function (chunk) {
        str += chunk;
      });
      return str;
    };
    
    /**
     * Returns the string representation of this source node along with a source
     * map.
     */
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function (chunk, original) {
        generated.code += chunk;
        if (original.source !== null
            && original.line !== null
            && original.column !== null) {
          if(lastOriginalSource !== original.source
             || lastOriginalLine !== original.line
             || lastOriginalColumn !== original.column
             || lastOriginalName !== original.name) {
            map.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            // Mappings end at eol
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function (sourceFile, sourceContent) {
        map.setSourceContent(sourceFile, sourceContent);
      });
    
      return { code: generated.code, map: map };
    };
    
    exports.SourceNode = SourceNode;
    
    },{"./source-map-generator":28,"./util":30}],30:[function(require,module,exports){
    /* -*- Mode: js; js-indent-level: 2; -*- */
    /*
     * Copyright 2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    
    /**
     * This is a helper function for getting values from parameter/options
     * objects.
     *
     * @param args The object we are extracting values from
     * @param name The name of the property we are getting.
     * @param defaultValue An optional value to return if the property is missing
     * from the object. If this is not specified and the property is missing, an
     * error will be thrown.
     */
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    
    function urlGenerate(aParsedUrl) {
      var url = '';
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ':';
      }
      url += '//';
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + '@';
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports.urlGenerate = urlGenerate;
    
    /**
     * Normalizes a path, or the path portion of a URL:
     *
     * - Replaces consecutive slashes with one slash.
     * - Removes unnecessary '.' parts.
     * - Removes unnecessary '<dir>/..' parts.
     *
     * Based on code in the Node.js 'path' core module.
     *
     * @param aPath The path or url to normalize.
     */
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports.isAbsolute(path);
    
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === '.') {
          parts.splice(i, 1);
        } else if (part === '..') {
          up++;
        } else if (up > 0) {
          if (part === '') {
            // The first part is blank if the path is absolute. Trying to go
            // above the root is a no-op. Therefore we can remove all '..' parts
            // directly after the root.
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join('/');
    
      if (path === '') {
        path = isAbsolute ? '/' : '.';
      }
    
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports.normalize = normalize;
    
    /**
     * Joins two paths/URLs.
     *
     * @param aRoot The root path or URL.
     * @param aPath The path or URL to be joined with the root.
     *
     * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
     *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
     *   first.
     * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
     *   is updated with the result and aRoot is returned. Otherwise the result
     *   is returned.
     *   - If aPath is absolute, the result is aPath.
     *   - Otherwise the two paths are joined with a slash.
     * - Joining for example 'http://' and 'www.example.com' is also supported.
     */
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || '/';
      }
    
      // `join(foo, '//www.example.org')`
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
    
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
    
      // `join('http://', 'www.example.com')`
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
    
      var joined = aPath.charAt(0) === '/'
        ? aPath
        : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);
    
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    
    exports.isAbsolute = function (aPath) {
      return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
    };
    
    /**
     * Make a path relative to a URL or another path.
     *
     * @param aRoot The root path or URL.
     * @param aPath The path or URL to be made relative to aRoot.
     */
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
    
      aRoot = aRoot.replace(/\/$/, '');
    
      // It is possible for the path to be above the root. In this case, simply
      // checking whether the root is a prefix of the path won't work. Instead, we
      // need to remove components from the root one by one, until either we find
      // a prefix that fits, or we run out of components to remove.
      var level = 0;
      while (aPath.indexOf(aRoot + '/') !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
    
        // If the only part of the root that is left is the scheme (i.e. http://,
        // file:///, etc.), one or more slashes (/), or simply nothing at all, we
        // have exhausted all components, so the path is not relative to the root.
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
    
        ++level;
      }
    
      // Make sure we add a "../" for each component we removed from the root.
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    
    var supportsNullProto = (function () {
      var obj = Object.create(null);
      return !('__proto__' in obj);
    }());
    
    function identity (s) {
      return s;
    }
    
    /**
     * Because behavior goes wacky when you set `__proto__` on objects, we
     * have to prefix all the strings in our set with an arbitrary character.
     *
     * See https://github.com/mozilla/source-map/pull/31 and
     * https://github.com/mozilla/source-map/issues/30
     *
     * @param String aStr
     */
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return '$' + aStr;
      }
    
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
    
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    
    function isProtoString(s) {
      if (!s) {
        return false;
      }
    
      var length = s.length;
    
      if (length < 9 /* "__proto__".length */) {
        return false;
      }
    
      if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
          s.charCodeAt(length - 2) !== 95  /* '_' */ ||
          s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
          s.charCodeAt(length - 4) !== 116 /* 't' */ ||
          s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
          s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
          s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
          s.charCodeAt(length - 8) !== 95  /* '_' */ ||
          s.charCodeAt(length - 9) !== 95  /* '_' */) {
        return false;
      }
    
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36 /* '$' */) {
          return false;
        }
      }
    
      return true;
    }
    
    /**
     * Comparator between two mappings where the original positions are compared.
     *
     * Optionally pass in `true` as `onlyCompareGenerated` to consider two
     * mappings with the same original source/line/column, but different generated
     * line and column the same. Useful when searching for a mapping with a
     * stubbed out mapping.
     */
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
    
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
    
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
    
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
    
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
    
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    
    /**
     * Comparator between two mappings with deflated source and name indices where
     * the generated positions are compared.
     *
     * Optionally pass in `true` as `onlyCompareGenerated` to consider two
     * mappings with the same generated line and column, but different
     * source/name/original line and column the same. Useful when searching for a
     * mapping with a stubbed out mapping.
     */
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
    
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
    
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
    
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
    
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
    
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
    
      if (aStr1 === null) {
        return 1; // aStr2 !== null
      }
    
      if (aStr2 === null) {
        return -1; // aStr1 !== null
      }
    
      if (aStr1 > aStr2) {
        return 1;
      }
    
      return -1;
    }
    
    /**
     * Comparator between two mappings with inflated source and name strings where
     * the generated positions are compared.
     */
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
    
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
    
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
    
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
    
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
    
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    
    /**
     * Strip any JSON XSSI avoidance prefix from the string (as documented
     * in the source maps specification), and then parse the string as
     * JSON.
     */
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    
    /**
     * Compute the URL of a source given the the source root, the source's
     * URL, and the source map's URL.
     */
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || '';
    
      if (sourceRoot) {
        // This follows what Chrome does.
        if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
          sourceRoot += '/';
        }
        // The spec says:
        //   Line 4: An optional source root, useful for relocating source
        //   files on a server or removing repeated values in the
        //   sources entry.  This value is prepended to the individual
        //   entries in the source field.
        sourceURL = sourceRoot + sourceURL;
      }
    
      // Historically, SourceMapConsumer did not take the sourceMapURL as
      // a parameter.  This mode is still somewhat supported, which is why
      // this code block is conditional.  However, it's preferable to pass
      // the source map URL to SourceMapConsumer, so that this function
      // can implement the source URL resolution algorithm as outlined in
      // the spec.  This block is basically the equivalent of:
      //    new URL(sourceURL, sourceMapURL).toString()
      // ... except it avoids using URL, which wasn't available in the
      // older releases of node still supported by this library.
      //
      // The spec says:
      //   If the sources are not absolute URLs after prepending of the
      //   sourceRoot, the sources are resolved relative to the
      //   SourceMap (like resolving script src in a html document).
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          // Strip the last path component, but keep the "/".
          var index = parsed.path.lastIndexOf('/');
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
    
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
    
    },{}],31:[function(require,module,exports){
    /*
     * Copyright 2009-2011 Mozilla Foundation and contributors
     * Licensed under the New BSD license. See LICENSE.txt or:
     * http://opensource.org/licenses/BSD-3-Clause
     */
    exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
    exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
    exports.SourceNode = require('./lib/source-node').SourceNode;
    
    },{"./lib/source-map-consumer":27,"./lib/source-map-generator":28,"./lib/source-node":29}],"blackpard":[function(require,module,exports){
    // Generated by blackpard 1.5.0
    var blackpard;
    blackpard = require('./index');
    blackpard.stab = function(code, callback, filename){
      var e;
      try {
        blackpard.run(code, {
          filename: filename,
          map: 'embedded'
        });
      } catch (e$) {
        e = e$;
      }
      if (typeof callback == 'function') {
        callback(e);
      }
    };
    blackpard.load = function(url, callback){
      var xhr;
      xhr = new XMLHttpRequest;
      xhr.open('GET', url, true);
      if ('overrideMimeType' in xhr) {
        xhr.overrideMimeType('text/plain');
      }
      xhr.onreadystatechange = function(){
        var ref$;
        if (xhr.readyState === 4) {
          if ((ref$ = xhr.status) === 200 || ref$ === 0) {
            blackpard.stab(xhr.responseText, callback, url);
          } else {
            if (typeof callback == 'function') {
              callback(Error(url + ": " + xhr.status + " " + xhr.statusText));
            }
          }
        }
      };
      xhr.send(null);
      return xhr;
    };
    blackpard.go = function(){
      var type, sink, i$, ref$, len$, script, that;
      type = /^(?:text\/|application\/)?ls$/i;
      sink = function(error){
        error && setTimeout(function(){
          throw error;
        });
      };
      for (i$ = 0, len$ = (ref$ = document.getElementsByTagName('script')).length; i$ < len$; ++i$) {
        script = ref$[i$];
        if (type.test(script.type)) {
          if (that = script.src) {
            blackpard.load(that, sink);
          } else {
            blackpard.stab(script.innerHTML, sink, script.id);
          }
        }
      }
    };
    module.exports = blackpard;
    },{"./index":2}]},{},[]);

    (function (global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
      typeof define === 'function' && define.amd ? define(['exports'], factory) :
      (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.blackpard = {}));
  }(this, (function (exports) { 'use strict';
  
      /**
       * Relu Activation, aka Rectified Linear Unit Activation
       * @description https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
       */
      function activate$3(weight) {
          return Math.max(0, weight);
      }
      /**
       * Relu derivative
       */
      function measure$3(weight, delta) {
          if (weight <= 0) {
              return 0;
          }
          return delta;
      }
  
      var relu$2 = /*#__PURE__*/Object.freeze({
          __proto__: null,
          activate: activate$3,
          measure: measure$3
      });
  
      /**
       * sigmoid activation
       */
      function activate$2(value) {
          return 1 / (1 + Math.exp(-value));
      }
      /**
       * sigmoid derivative
       */
      function measure$2(weight, error) {
          return weight * (1 - weight) * error;
      }
  
      var sigmoid$2 = /*#__PURE__*/Object.freeze({
          __proto__: null,
          activate: activate$2,
          measure: measure$2
      });
  
      /**
       * Hyperbolic tan
       */
      function activate$1(weight) {
          return Math.tanh(weight);
      }
      /**
       * @description grad for z = tanh(x) is (1 - z^2)
       */
      function measure$1(weight, error) {
          return (1 - weight * weight) * error;
      }
  
      var tanh$2 = /*#__PURE__*/Object.freeze({
          __proto__: null,
          activate: activate$1,
          measure: measure$1
      });
  
      /**
       * Leaky Relu Activation, aka Leaky Rectified Linear Unit Activation
       * @description https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
       */
      function activate(weight) {
          return weight > 0 ? weight : 0.01 * weight;
      }
      /**
       * Leaky Relu derivative
       */
      function measure(weight, error) {
          return weight > 0 ? error : 0.01 * error;
      }
  
      var leakyRelu$1 = /*#__PURE__*/Object.freeze({
          __proto__: null,
          activate: activate,
          measure: measure
      });
  
      var index$1 = /*#__PURE__*/Object.freeze({
          __proto__: null,
          relu: relu$2,
          sigmoid: sigmoid$2,
          tanh: tanh$2,
          leakyRelu: leakyRelu$1
      });
  
      class CrossValidate {
          constructor(initClassifier) {
              this.json = {
                  avgs: {
                      error: 0,
                      iterations: 0,
                      testTime: 0,
                      trainTime: 0,
                  },
                  stats: {
                      total: 0,
                      testSize: 0,
                      trainSize: 0,
                  },
                  sets: [],
              };
              this.initClassifier = initClassifier;
          }
          testPartition(trainOpts, trainSet, testSet) {
              const classifier = this.initClassifier();
              const beginTrain = Date.now();
              const trainingStats = classifier.train(trainSet, trainOpts);
              const beginTest = Date.now();
              const testStats = classifier.test(testSet);
              const endTest = Date.now();
              return {
                  ...testStats,
                  trainTime: beginTest - beginTrain,
                  testTime: endTest - beginTest,
                  iterations: trainingStats.iterations,
                  error: trainingStats.error,
                  total: testStats.total,
                  network: classifier.toJSON(),
              };
          }
          /**
           * Randomize array element order in-place.
           * Using Durstenfeld shuffle algorithm.
           * source: http://stackoverflow.com/a/12646864/1324039
           */
          shuffleArray(array) {
              for (let i = array.length - 1; i > 0; i--) {
                  const j = Math.floor(Math.random() * (i + 1));
                  const temp = array[i];
                  array[i] = array[j];
                  array[j] = temp;
              }
              return array;
          }
          train(data, trainOpts = {}, k = 4) {
              if (data.length < k) {
                  throw new Error(`Training set size is too small for ${data.length} k folds of ${k}`);
              }
              this.shuffleArray(data);
              const size = data.length / k;
              const avgs = {
                  trainTime: 0,
                  testTime: 0,
                  iterations: 0,
                  error: 0,
              };
              const stats = {
                  total: 0,
                  testSize: 0,
                  trainSize: 0,
              };
              const binaryStats = {
                  total: 0,
                  testSize: 0,
                  trainSize: 0,
                  truePos: 0,
                  trueNeg: 0,
                  falsePos: 0,
                  falseNeg: 0,
                  precision: 0,
                  recall: 0,
                  accuracy: 0,
              };
              const results = [];
              let isBinary = null;
              for (let i = 0; i < k; i++) {
                  const dclone = data.slice(0);
                  const testSet = dclone.splice(i * size, size);
                  const trainSet = dclone;
                  const result = this.testPartition(trainOpts, trainSet, testSet);
                  if (isBinary === null) {
                      isBinary =
                          result.hasOwnProperty('falseNeg') &&
                              result.hasOwnProperty('falsePos') &&
                              result.hasOwnProperty('trueNeg') &&
                              result.hasOwnProperty('truePos');
                      if (isBinary) {
                          Object.assign(stats, binaryStats);
                      }
                  }
                  avgs.iterations += result.iterations;
                  avgs.testTime += result.testTime;
                  avgs.trainTime += result.trainTime;
                  avgs.error += result.error;
                  stats.total += result.total;
                  if (CrossValidate.isBinaryStats(stats) &&
                      CrossValidate.isBinaryPartitionResults(result)) {
                      stats.accuracy += result.accuracy;
                      stats.falseNeg += result.falseNeg;
                      stats.falsePos += result.falsePos;
                      stats.precision += result.precision;
                      stats.recall += result.recall;
                      stats.trueNeg += result.trueNeg;
                      stats.truePos += result.truePos;
                  }
                  results.push(result);
              }
              avgs.error /= k;
              avgs.iterations /= k;
              avgs.testTime /= k;
              avgs.trainTime /= k;
              if (CrossValidate.isBinaryStats(stats)) {
                  stats.precision = stats.truePos / (stats.truePos + stats.falsePos);
                  stats.recall = stats.truePos / (stats.truePos + stats.falseNeg);
                  stats.accuracy = (stats.trueNeg + stats.truePos) / stats.total;
              }
              stats.testSize = size;
              stats.trainSize = data.length - size;
              this.json = {
                  avgs: avgs,
                  stats: stats,
                  sets: results,
              };
              return this.json;
          }
          toNeuralNetwork() {
              return this.fromJSON(this.json);
          }
          toJSON() {
              return this.json;
          }
          fromJSON(crossValidateJson) {
              const winningJSON = crossValidateJson.sets.reduce((prev, cur) => (prev.error < cur.error ? prev : cur));
              return this.initClassifier().fromJSON(winningJSON.network);
          }
      }
      CrossValidate.isBinaryStats = (stats) => {
          return (stats.accuracy !== undefined);
      };
      CrossValidate.isBinaryResults = (stats) => stats.stats.accuracy !== undefined;
      CrossValidate.isBinaryPartitionResults = (stats) => stats.accuracy !==
          undefined;
  
      var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
  
      function createCommonjsModule(fn, basedir, module) {
        return module = {
          path: basedir,
          exports: {},
          require: function (path, base) {
            return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
          }
        }, fn(module, module.exports), module.exports;
      }
  
      function commonjsRequire () {
        throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
      }
  
      var gpuBrowser = createCommonjsModule(function (module, exports) {
      /**
       * gpu.js
       * http://gpu.rocks/
       *
       * GPU Accelerated JavaScript
       *
       * @version 2.16.0
       * @date Wed Nov 16 2022 15:48:37 GMT-0500 (Eastern Standard Time)
       *
       * @license MIT
       * The MIT License
       *
       * Copyright (c) 2022 gpu.js Team
       */(function(f){{module.exports=f();}})(function(){return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof commonjsRequire&&commonjsRequire;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t);}return n[i].exports}for(var u="function"==typeof commonjsRequire&&commonjsRequire,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
      (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
        (global = global || self, factory(global.acorn = {}));
      }(this, function (exports) {
  
        var reservedWords = {
          3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
          5: "class enum extends super const export import",
          6: "enum",
          strict: "implements interface let package private protected public static yield",
          strictBind: "eval arguments"
        };
  
  
        var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
  
        var keywords = {
          5: ecma5AndLessKeywords,
          "5module": ecma5AndLessKeywords + " export import",
          6: ecma5AndLessKeywords + " const class extends export import super"
        };
  
        var keywordRelationalOperator = /^in(stanceof)?$/;
  
  
        var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
        var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";
  
        var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
        var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
  
        nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
  
  
        var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];
  
        var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];
  
        function isInAstralSet(code, set) {
          var pos = 0x10000;
          for (var i = 0; i < set.length; i += 2) {
            pos += set[i];
            if (pos > code) { return false }
            pos += set[i + 1];
            if (pos >= code) { return true }
          }
        }
  
  
        function isIdentifierStart(code, astral) {
          if (code < 65) { return code === 36 }
          if (code < 91) { return true }
          if (code < 97) { return code === 95 }
          if (code < 123) { return true }
          if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
          if (astral === false) { return false }
          return isInAstralSet(code, astralIdentifierStartCodes)
        }
  
  
        function isIdentifierChar(code, astral) {
          if (code < 48) { return code === 36 }
          if (code < 58) { return true }
          if (code < 65) { return false }
          if (code < 91) { return true }
          if (code < 97) { return code === 95 }
          if (code < 123) { return true }
          if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
          if (astral === false) { return false }
          return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
        }
  
  
  
  
  
        var TokenType = function TokenType(label, conf) {
          if ( conf === void 0 ) conf = {};
  
          this.label = label;
          this.keyword = conf.keyword;
          this.beforeExpr = !!conf.beforeExpr;
          this.startsExpr = !!conf.startsExpr;
          this.isLoop = !!conf.isLoop;
          this.isAssign = !!conf.isAssign;
          this.prefix = !!conf.prefix;
          this.postfix = !!conf.postfix;
          this.binop = conf.binop || null;
          this.updateContext = null;
        };
  
        function binop(name, prec) {
          return new TokenType(name, {beforeExpr: true, binop: prec})
        }
        var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};
  
  
        var keywords$1 = {};
  
        function kw(name, options) {
          if ( options === void 0 ) options = {};
  
          options.keyword = name;
          return keywords$1[name] = new TokenType(name, options)
        }
  
        var types = {
          num: new TokenType("num", startsExpr),
          regexp: new TokenType("regexp", startsExpr),
          string: new TokenType("string", startsExpr),
          name: new TokenType("name", startsExpr),
          eof: new TokenType("eof"),
  
          bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
          bracketR: new TokenType("]"),
          braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
          braceR: new TokenType("}"),
          parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
          parenR: new TokenType(")"),
          comma: new TokenType(",", beforeExpr),
          semi: new TokenType(";", beforeExpr),
          colon: new TokenType(":", beforeExpr),
          dot: new TokenType("."),
          question: new TokenType("?", beforeExpr),
          arrow: new TokenType("=>", beforeExpr),
          template: new TokenType("template"),
          invalidTemplate: new TokenType("invalidTemplate"),
          ellipsis: new TokenType("...", beforeExpr),
          backQuote: new TokenType("`", startsExpr),
          dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),
  
  
          eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
          assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
          incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
          prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
          logicalOR: binop("||", 1),
          logicalAND: binop("&&", 2),
          bitwiseOR: binop("|", 3),
          bitwiseXOR: binop("^", 4),
          bitwiseAND: binop("&", 5),
          equality: binop("==/!=/===/!==", 6),
          relational: binop("</>/<=/>=", 7),
          bitShift: binop("<</>>/>>>", 8),
          plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
          modulo: binop("%", 10),
          star: binop("*", 10),
          slash: binop("/", 10),
          starstar: new TokenType("**", {beforeExpr: true}),
  
          _break: kw("break"),
          _case: kw("case", beforeExpr),
          _catch: kw("catch"),
          _continue: kw("continue"),
          _debugger: kw("debugger"),
          _default: kw("default", beforeExpr),
          _do: kw("do", {isLoop: true, beforeExpr: true}),
          _else: kw("else", beforeExpr),
          _finally: kw("finally"),
          _for: kw("for", {isLoop: true}),
          _function: kw("function", startsExpr),
          _if: kw("if"),
          _return: kw("return", beforeExpr),
          _switch: kw("switch"),
          _throw: kw("throw", beforeExpr),
          _try: kw("try"),
          _var: kw("var"),
          _const: kw("const"),
          _while: kw("while", {isLoop: true}),
          _with: kw("with"),
          _new: kw("new", {beforeExpr: true, startsExpr: true}),
          _this: kw("this", startsExpr),
          _super: kw("super", startsExpr),
          _class: kw("class", startsExpr),
          _extends: kw("extends", beforeExpr),
          _export: kw("export"),
          _import: kw("import", startsExpr),
          _null: kw("null", startsExpr),
          _true: kw("true", startsExpr),
          _false: kw("false", startsExpr),
          _in: kw("in", {beforeExpr: true, binop: 7}),
          _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
          _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
          _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
          _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
        };
  
  
        var lineBreak = /\r\n?|\n|\u2028|\u2029/;
        var lineBreakG = new RegExp(lineBreak.source, "g");
  
        function isNewLine(code, ecma2019String) {
          return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
        }
  
        var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
  
        var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
  
        var ref = Object.prototype;
        var hasOwnProperty = ref.hasOwnProperty;
        var toString = ref.toString;
  
  
        function has(obj, propName) {
          return hasOwnProperty.call(obj, propName)
        }
  
        var isArray = Array.isArray || (function (obj) { return (
          toString.call(obj) === "[object Array]"
        ); });
  
        function wordsRegexp(words) {
          return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
        }
  
  
        var Position = function Position(line, col) {
          this.line = line;
          this.column = col;
        };
  
        Position.prototype.offset = function offset (n) {
          return new Position(this.line, this.column + n)
        };
  
        var SourceLocation = function SourceLocation(p, start, end) {
          this.start = start;
          this.end = end;
          if (p.sourceFile !== null) { this.source = p.sourceFile; }
        };
  
  
        function getLineInfo(input, offset) {
          for (var line = 1, cur = 0;;) {
            lineBreakG.lastIndex = cur;
            var match = lineBreakG.exec(input);
            if (match && match.index < offset) {
              ++line;
              cur = match.index + match[0].length;
            } else {
              return new Position(line, offset - cur)
            }
          }
        }
  
  
        var defaultOptions = {
          ecmaVersion: 10,
          sourceType: "script",
          onInsertedSemicolon: null,
          onTrailingComma: null,
          allowReserved: null,
          allowReturnOutsideFunction: false,
          allowImportExportEverywhere: false,
          allowAwaitOutsideFunction: false,
          allowHashBang: false,
          locations: false,
          onToken: null,
          onComment: null,
          ranges: false,
          program: null,
          sourceFile: null,
          directSourceFile: null,
          preserveParens: false
        };
  
  
        function getOptions(opts) {
          var options = {};
  
          for (var opt in defaultOptions)
            { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }
  
          if (options.ecmaVersion >= 2015)
            { options.ecmaVersion -= 2009; }
  
          if (options.allowReserved == null)
            { options.allowReserved = options.ecmaVersion < 5; }
  
          if (isArray(options.onToken)) {
            var tokens = options.onToken;
            options.onToken = function (token) { return tokens.push(token); };
          }
          if (isArray(options.onComment))
            { options.onComment = pushComment(options, options.onComment); }
  
          return options
        }
  
        function pushComment(options, array) {
          return function(block, text, start, end, startLoc, endLoc) {
            var comment = {
              type: block ? "Block" : "Line",
              value: text,
              start: start,
              end: end
            };
            if (options.locations)
              { comment.loc = new SourceLocation(this, startLoc, endLoc); }
            if (options.ranges)
              { comment.range = [start, end]; }
            array.push(comment);
          }
        }
  
        var
            SCOPE_TOP = 1,
            SCOPE_FUNCTION = 2,
            SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
            SCOPE_ASYNC = 4,
            SCOPE_GENERATOR = 8,
            SCOPE_ARROW = 16,
            SCOPE_SIMPLE_CATCH = 32,
            SCOPE_SUPER = 64,
            SCOPE_DIRECT_SUPER = 128;
  
        function functionFlags(async, generator) {
          return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
        }
  
        var
            BIND_NONE = 0, 
            BIND_VAR = 1, 
            BIND_LEXICAL = 2, 
            BIND_FUNCTION = 3, 
            BIND_SIMPLE_CATCH = 4, 
            BIND_OUTSIDE = 5; 
  
        var Parser = function Parser(options, input, startPos) {
          this.options = options = getOptions(options);
          this.sourceFile = options.sourceFile;
          this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
          var reserved = "";
          if (options.allowReserved !== true) {
            for (var v = options.ecmaVersion;; v--)
              { if (reserved = reservedWords[v]) { break } }
            if (options.sourceType === "module") { reserved += " await"; }
          }
          this.reservedWords = wordsRegexp(reserved);
          var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
          this.reservedWordsStrict = wordsRegexp(reservedStrict);
          this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
          this.input = String(input);
  
          this.containsEsc = false;
  
  
          if (startPos) {
            this.pos = startPos;
            this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
            this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
          } else {
            this.pos = this.lineStart = 0;
            this.curLine = 1;
          }
  
          this.type = types.eof;
          this.value = null;
          this.start = this.end = this.pos;
          this.startLoc = this.endLoc = this.curPosition();
  
          this.lastTokEndLoc = this.lastTokStartLoc = null;
          this.lastTokStart = this.lastTokEnd = this.pos;
  
          this.context = this.initialContext();
          this.exprAllowed = true;
  
          this.inModule = options.sourceType === "module";
          this.strict = this.inModule || this.strictDirective(this.pos);
  
          this.potentialArrowAt = -1;
  
          this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
          this.labels = [];
          this.undefinedExports = {};
  
          if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
            { this.skipLineComment(2); }
  
          this.scopeStack = [];
          this.enterScope(SCOPE_TOP);
  
          this.regexpState = null;
        };
  
        var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };
  
        Parser.prototype.parse = function parse () {
          var node = this.options.program || this.startNode();
          this.nextToken();
          return this.parseTopLevel(node)
        };
  
        prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
        prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
        prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
        prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
        prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
        prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };
  
        Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };
  
        Parser.extend = function extend () {
            var plugins = [], len = arguments.length;
            while ( len-- ) plugins[ len ] = arguments[ len ];
  
          var cls = this;
          for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
          return cls
        };
  
        Parser.parse = function parse (input, options) {
          return new this(options, input).parse()
        };
  
        Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
          var parser = new this(options, input, pos);
          parser.nextToken();
          return parser.parseExpression()
        };
  
        Parser.tokenizer = function tokenizer (input, options) {
          return new this(options, input)
        };
  
        Object.defineProperties( Parser.prototype, prototypeAccessors );
  
        var pp = Parser.prototype;
  
  
        var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
        pp.strictDirective = function(start) {
          for (;;) {
            skipWhiteSpace.lastIndex = start;
            start += skipWhiteSpace.exec(this.input)[0].length;
            var match = literal.exec(this.input.slice(start));
            if (!match) { return false }
            if ((match[1] || match[2]) === "use strict") { return true }
            start += match[0].length;
  
            skipWhiteSpace.lastIndex = start;
            start += skipWhiteSpace.exec(this.input)[0].length;
            if (this.input[start] === ";")
              { start++; }
          }
        };
  
  
        pp.eat = function(type) {
          if (this.type === type) {
            this.next();
            return true
          } else {
            return false
          }
        };
  
  
        pp.isContextual = function(name) {
          return this.type === types.name && this.value === name && !this.containsEsc
        };
  
  
        pp.eatContextual = function(name) {
          if (!this.isContextual(name)) { return false }
          this.next();
          return true
        };
  
  
        pp.expectContextual = function(name) {
          if (!this.eatContextual(name)) { this.unexpected(); }
        };
  
  
        pp.canInsertSemicolon = function() {
          return this.type === types.eof ||
            this.type === types.braceR ||
            lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
        };
  
        pp.insertSemicolon = function() {
          if (this.canInsertSemicolon()) {
            if (this.options.onInsertedSemicolon)
              { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
            return true
          }
        };
  
  
        pp.semicolon = function() {
          if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
        };
  
        pp.afterTrailingComma = function(tokType, notNext) {
          if (this.type === tokType) {
            if (this.options.onTrailingComma)
              { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
            if (!notNext)
              { this.next(); }
            return true
          }
        };
  
  
        pp.expect = function(type) {
          this.eat(type) || this.unexpected();
        };
  
  
        pp.unexpected = function(pos) {
          this.raise(pos != null ? pos : this.start, "Unexpected token");
        };
  
        function DestructuringErrors() {
          this.shorthandAssign =
          this.trailingComma =
          this.parenthesizedAssign =
          this.parenthesizedBind =
          this.doubleProto =
            -1;
        }
  
        pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
          if (!refDestructuringErrors) { return }
          if (refDestructuringErrors.trailingComma > -1)
            { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
          var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
          if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
        };
  
        pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
          if (!refDestructuringErrors) { return false }
          var shorthandAssign = refDestructuringErrors.shorthandAssign;
          var doubleProto = refDestructuringErrors.doubleProto;
          if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
          if (shorthandAssign >= 0)
            { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
          if (doubleProto >= 0)
            { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
        };
  
        pp.checkYieldAwaitInDefaultParams = function() {
          if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
            { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
          if (this.awaitPos)
            { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
        };
  
        pp.isSimpleAssignTarget = function(expr) {
          if (expr.type === "ParenthesizedExpression")
            { return this.isSimpleAssignTarget(expr.expression) }
          return expr.type === "Identifier" || expr.type === "MemberExpression"
        };
  
        var pp$1 = Parser.prototype;
  
  
  
        pp$1.parseTopLevel = function(node) {
          var exports = {};
          if (!node.body) { node.body = []; }
          while (this.type !== types.eof) {
            var stmt = this.parseStatement(null, true, exports);
            node.body.push(stmt);
          }
          if (this.inModule)
            { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
              {
                var name = list[i];
  
                this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
              } }
          this.adaptDirectivePrologue(node.body);
          this.next();
          node.sourceType = this.options.sourceType;
          return this.finishNode(node, "Program")
        };
  
        var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};
  
        pp$1.isLet = function(context) {
          if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
          skipWhiteSpace.lastIndex = this.pos;
          var skip = skipWhiteSpace.exec(this.input);
          var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
          if (nextCh === 91) { return true } 
          if (context) { return false }
  
          if (nextCh === 123) { return true } 
          if (isIdentifierStart(nextCh, true)) {
            var pos = next + 1;
            while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
            var ident = this.input.slice(next, pos);
            if (!keywordRelationalOperator.test(ident)) { return true }
          }
          return false
        };
  
        pp$1.isAsyncFunction = function() {
          if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
            { return false }
  
          skipWhiteSpace.lastIndex = this.pos;
          var skip = skipWhiteSpace.exec(this.input);
          var next = this.pos + skip[0].length;
          return !lineBreak.test(this.input.slice(this.pos, next)) &&
            this.input.slice(next, next + 8) === "function" &&
            (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
        };
  
  
        pp$1.parseStatement = function(context, topLevel, exports) {
          var starttype = this.type, node = this.startNode(), kind;
  
          if (this.isLet(context)) {
            starttype = types._var;
            kind = "let";
          }
  
  
          switch (starttype) {
          case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
          case types._debugger: return this.parseDebuggerStatement(node)
          case types._do: return this.parseDoStatement(node)
          case types._for: return this.parseForStatement(node)
          case types._function:
            if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
            return this.parseFunctionStatement(node, false, !context)
          case types._class:
            if (context) { this.unexpected(); }
            return this.parseClass(node, true)
          case types._if: return this.parseIfStatement(node)
          case types._return: return this.parseReturnStatement(node)
          case types._switch: return this.parseSwitchStatement(node)
          case types._throw: return this.parseThrowStatement(node)
          case types._try: return this.parseTryStatement(node)
          case types._const: case types._var:
            kind = kind || this.value;
            if (context && kind !== "var") { this.unexpected(); }
            return this.parseVarStatement(node, kind)
          case types._while: return this.parseWhileStatement(node)
          case types._with: return this.parseWithStatement(node)
          case types.braceL: return this.parseBlock(true, node)
          case types.semi: return this.parseEmptyStatement(node)
          case types._export:
          case types._import:
            if (this.options.ecmaVersion > 10 && starttype === types._import) {
              skipWhiteSpace.lastIndex = this.pos;
              var skip = skipWhiteSpace.exec(this.input);
              var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
              if (nextCh === 40) 
                { return this.parseExpressionStatement(node, this.parseExpression()) }
            }
  
            if (!this.options.allowImportExportEverywhere) {
              if (!topLevel)
                { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
              if (!this.inModule)
                { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
            }
            return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)
  
          default:
            if (this.isAsyncFunction()) {
              if (context) { this.unexpected(); }
              this.next();
              return this.parseFunctionStatement(node, true, !context)
            }
  
            var maybeName = this.value, expr = this.parseExpression();
            if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
              { return this.parseLabeledStatement(node, maybeName, expr, context) }
            else { return this.parseExpressionStatement(node, expr) }
          }
        };
  
        pp$1.parseBreakContinueStatement = function(node, keyword) {
          var isBreak = keyword === "break";
          this.next();
          if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
          else if (this.type !== types.name) { this.unexpected(); }
          else {
            node.label = this.parseIdent();
            this.semicolon();
          }
  
          var i = 0;
          for (; i < this.labels.length; ++i) {
            var lab = this.labels[i];
            if (node.label == null || lab.name === node.label.name) {
              if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
              if (node.label && isBreak) { break }
            }
          }
          if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
          return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
        };
  
        pp$1.parseDebuggerStatement = function(node) {
          this.next();
          this.semicolon();
          return this.finishNode(node, "DebuggerStatement")
        };
  
        pp$1.parseDoStatement = function(node) {
          this.next();
          this.labels.push(loopLabel);
          node.body = this.parseStatement("do");
          this.labels.pop();
          this.expect(types._while);
          node.test = this.parseParenExpression();
          if (this.options.ecmaVersion >= 6)
            { this.eat(types.semi); }
          else
            { this.semicolon(); }
          return this.finishNode(node, "DoWhileStatement")
        };
  
  
        pp$1.parseForStatement = function(node) {
          this.next();
          var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
          this.labels.push(loopLabel);
          this.enterScope(0);
          this.expect(types.parenL);
          if (this.type === types.semi) {
            if (awaitAt > -1) { this.unexpected(awaitAt); }
            return this.parseFor(node, null)
          }
          var isLet = this.isLet();
          if (this.type === types._var || this.type === types._const || isLet) {
            var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
            this.next();
            this.parseVar(init$1, true, kind);
            this.finishNode(init$1, "VariableDeclaration");
            if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
              if (this.options.ecmaVersion >= 9) {
                if (this.type === types._in) {
                  if (awaitAt > -1) { this.unexpected(awaitAt); }
                } else { node.await = awaitAt > -1; }
              }
              return this.parseForIn(node, init$1)
            }
            if (awaitAt > -1) { this.unexpected(awaitAt); }
            return this.parseFor(node, init$1)
          }
          var refDestructuringErrors = new DestructuringErrors;
          var init = this.parseExpression(true, refDestructuringErrors);
          if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
            if (this.options.ecmaVersion >= 9) {
              if (this.type === types._in) {
                if (awaitAt > -1) { this.unexpected(awaitAt); }
              } else { node.await = awaitAt > -1; }
            }
            this.toAssignable(init, false, refDestructuringErrors);
            this.checkLVal(init);
            return this.parseForIn(node, init)
          } else {
            this.checkExpressionErrors(refDestructuringErrors, true);
          }
          if (awaitAt > -1) { this.unexpected(awaitAt); }
          return this.parseFor(node, init)
        };
  
        pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
          this.next();
          return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
        };
  
        pp$1.parseIfStatement = function(node) {
          this.next();
          node.test = this.parseParenExpression();
          node.consequent = this.parseStatement("if");
          node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
          return this.finishNode(node, "IfStatement")
        };
  
        pp$1.parseReturnStatement = function(node) {
          if (!this.inFunction && !this.options.allowReturnOutsideFunction)
            { this.raise(this.start, "'return' outside of function"); }
          this.next();
  
  
          if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
          else { node.argument = this.parseExpression(); this.semicolon(); }
          return this.finishNode(node, "ReturnStatement")
        };
  
        pp$1.parseSwitchStatement = function(node) {
          this.next();
          node.discriminant = this.parseParenExpression();
          node.cases = [];
          this.expect(types.braceL);
          this.labels.push(switchLabel);
          this.enterScope(0);
  
  
          var cur;
          for (var sawDefault = false; this.type !== types.braceR;) {
            if (this.type === types._case || this.type === types._default) {
              var isCase = this.type === types._case;
              if (cur) { this.finishNode(cur, "SwitchCase"); }
              node.cases.push(cur = this.startNode());
              cur.consequent = [];
              this.next();
              if (isCase) {
                cur.test = this.parseExpression();
              } else {
                if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
                sawDefault = true;
                cur.test = null;
              }
              this.expect(types.colon);
            } else {
              if (!cur) { this.unexpected(); }
              cur.consequent.push(this.parseStatement(null));
            }
          }
          this.exitScope();
          if (cur) { this.finishNode(cur, "SwitchCase"); }
          this.next(); 
          this.labels.pop();
          return this.finishNode(node, "SwitchStatement")
        };
  
        pp$1.parseThrowStatement = function(node) {
          this.next();
          if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
            { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
          node.argument = this.parseExpression();
          this.semicolon();
          return this.finishNode(node, "ThrowStatement")
        };
  
  
        var empty = [];
  
        pp$1.parseTryStatement = function(node) {
          this.next();
          node.block = this.parseBlock();
          node.handler = null;
          if (this.type === types._catch) {
            var clause = this.startNode();
            this.next();
            if (this.eat(types.parenL)) {
              clause.param = this.parseBindingAtom();
              var simple = clause.param.type === "Identifier";
              this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
              this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
              this.expect(types.parenR);
            } else {
              if (this.options.ecmaVersion < 10) { this.unexpected(); }
              clause.param = null;
              this.enterScope(0);
            }
            clause.body = this.parseBlock(false);
            this.exitScope();
            node.handler = this.finishNode(clause, "CatchClause");
          }
          node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
          if (!node.handler && !node.finalizer)
            { this.raise(node.start, "Missing catch or finally clause"); }
          return this.finishNode(node, "TryStatement")
        };
  
        pp$1.parseVarStatement = function(node, kind) {
          this.next();
          this.parseVar(node, false, kind);
          this.semicolon();
          return this.finishNode(node, "VariableDeclaration")
        };
  
        pp$1.parseWhileStatement = function(node) {
          this.next();
          node.test = this.parseParenExpression();
          this.labels.push(loopLabel);
          node.body = this.parseStatement("while");
          this.labels.pop();
          return this.finishNode(node, "WhileStatement")
        };
  
        pp$1.parseWithStatement = function(node) {
          if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
          this.next();
          node.object = this.parseParenExpression();
          node.body = this.parseStatement("with");
          return this.finishNode(node, "WithStatement")
        };
  
        pp$1.parseEmptyStatement = function(node) {
          this.next();
          return this.finishNode(node, "EmptyStatement")
        };
  
        pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
          for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
            {
            var label = list[i$1];
  
            if (label.name === maybeName)
              { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
          } }
          var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
          for (var i = this.labels.length - 1; i >= 0; i--) {
            var label$1 = this.labels[i];
            if (label$1.statementStart === node.start) {
              label$1.statementStart = this.start;
              label$1.kind = kind;
            } else { break }
          }
          this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
          node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
          this.labels.pop();
          node.label = expr;
          return this.finishNode(node, "LabeledStatement")
        };
  
        pp$1.parseExpressionStatement = function(node, expr) {
          node.expression = expr;
          this.semicolon();
          return this.finishNode(node, "ExpressionStatement")
        };
  
  
        pp$1.parseBlock = function(createNewLexicalScope, node) {
          if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
          if ( node === void 0 ) node = this.startNode();
  
          node.body = [];
          this.expect(types.braceL);
          if (createNewLexicalScope) { this.enterScope(0); }
          while (!this.eat(types.braceR)) {
            var stmt = this.parseStatement(null);
            node.body.push(stmt);
          }
          if (createNewLexicalScope) { this.exitScope(); }
          return this.finishNode(node, "BlockStatement")
        };
  
  
        pp$1.parseFor = function(node, init) {
          node.init = init;
          this.expect(types.semi);
          node.test = this.type === types.semi ? null : this.parseExpression();
          this.expect(types.semi);
          node.update = this.type === types.parenR ? null : this.parseExpression();
          this.expect(types.parenR);
          node.body = this.parseStatement("for");
          this.exitScope();
          this.labels.pop();
          return this.finishNode(node, "ForStatement")
        };
  
  
        pp$1.parseForIn = function(node, init) {
          var isForIn = this.type === types._in;
          this.next();
  
          if (
            init.type === "VariableDeclaration" &&
            init.declarations[0].init != null &&
            (
              !isForIn ||
              this.options.ecmaVersion < 8 ||
              this.strict ||
              init.kind !== "var" ||
              init.declarations[0].id.type !== "Identifier"
            )
          ) {
            this.raise(
              init.start,
              ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
            );
          } else if (init.type === "AssignmentPattern") {
            this.raise(init.start, "Invalid left-hand side in for-loop");
          }
          node.left = init;
          node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
          this.expect(types.parenR);
          node.body = this.parseStatement("for");
          this.exitScope();
          this.labels.pop();
          return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
        };
  
  
        pp$1.parseVar = function(node, isFor, kind) {
          node.declarations = [];
          node.kind = kind;
          for (;;) {
            var decl = this.startNode();
            this.parseVarId(decl, kind);
            if (this.eat(types.eq)) {
              decl.init = this.parseMaybeAssign(isFor);
            } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
              this.unexpected();
            } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
              this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
            } else {
              decl.init = null;
            }
            node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
            if (!this.eat(types.comma)) { break }
          }
          return node
        };
  
        pp$1.parseVarId = function(decl, kind) {
          decl.id = this.parseBindingAtom();
          this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
        };
  
        var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
  
  
        pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
          this.initFunction(node);
          if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
            if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
              { this.unexpected(); }
            node.generator = this.eat(types.star);
          }
          if (this.options.ecmaVersion >= 8)
            { node.async = !!isAsync; }
  
          if (statement & FUNC_STATEMENT) {
            node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
            if (node.id && !(statement & FUNC_HANGING_STATEMENT))
              { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
          }
  
          var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          this.enterScope(functionFlags(node.async, node.generator));
  
          if (!(statement & FUNC_STATEMENT))
            { node.id = this.type === types.name ? this.parseIdent() : null; }
  
          this.parseFunctionParams(node);
          this.parseFunctionBody(node, allowExpressionBody, false);
  
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
        };
  
        pp$1.parseFunctionParams = function(node) {
          this.expect(types.parenL);
          node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
          this.checkYieldAwaitInDefaultParams();
        };
  
  
        pp$1.parseClass = function(node, isStatement) {
          this.next();
  
          var oldStrict = this.strict;
          this.strict = true;
  
          this.parseClassId(node, isStatement);
          this.parseClassSuper(node);
          var classBody = this.startNode();
          var hadConstructor = false;
          classBody.body = [];
          this.expect(types.braceL);
          while (!this.eat(types.braceR)) {
            var element = this.parseClassElement(node.superClass !== null);
            if (element) {
              classBody.body.push(element);
              if (element.type === "MethodDefinition" && element.kind === "constructor") {
                if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
                hadConstructor = true;
              }
            }
          }
          node.body = this.finishNode(classBody, "ClassBody");
          this.strict = oldStrict;
          return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
        };
  
        pp$1.parseClassElement = function(constructorAllowsSuper) {
          var this$1 = this;
  
          if (this.eat(types.semi)) { return null }
  
          var method = this.startNode();
          var tryContextual = function (k, noLineBreak) {
            if ( noLineBreak === void 0 ) noLineBreak = false;
  
            var start = this$1.start, startLoc = this$1.startLoc;
            if (!this$1.eatContextual(k)) { return false }
            if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
            if (method.key) { this$1.unexpected(); }
            method.computed = false;
            method.key = this$1.startNodeAt(start, startLoc);
            method.key.name = k;
            this$1.finishNode(method.key, "Identifier");
            return false
          };
  
          method.kind = "method";
          method.static = tryContextual("static");
          var isGenerator = this.eat(types.star);
          var isAsync = false;
          if (!isGenerator) {
            if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
              isAsync = true;
              isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
            } else if (tryContextual("get")) {
              method.kind = "get";
            } else if (tryContextual("set")) {
              method.kind = "set";
            }
          }
          if (!method.key) { this.parsePropertyName(method); }
          var key = method.key;
          var allowsDirectSuper = false;
          if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
              key.type === "Literal" && key.value === "constructor")) {
            if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
            if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
            if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
            method.kind = "constructor";
            allowsDirectSuper = constructorAllowsSuper;
          } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
            this.raise(key.start, "Classes may not have a static property named prototype");
          }
          this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
          if (method.kind === "get" && method.value.params.length !== 0)
            { this.raiseRecoverable(method.value.start, "getter should have no params"); }
          if (method.kind === "set" && method.value.params.length !== 1)
            { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
          if (method.kind === "set" && method.value.params[0].type === "RestElement")
            { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
          return method
        };
  
        pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
          method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
          return this.finishNode(method, "MethodDefinition")
        };
  
        pp$1.parseClassId = function(node, isStatement) {
          if (this.type === types.name) {
            node.id = this.parseIdent();
            if (isStatement)
              { this.checkLVal(node.id, BIND_LEXICAL, false); }
          } else {
            if (isStatement === true)
              { this.unexpected(); }
            node.id = null;
          }
        };
  
        pp$1.parseClassSuper = function(node) {
          node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
        };
  
  
        pp$1.parseExport = function(node, exports) {
          this.next();
          if (this.eat(types.star)) {
            this.expectContextual("from");
            if (this.type !== types.string) { this.unexpected(); }
            node.source = this.parseExprAtom();
            this.semicolon();
            return this.finishNode(node, "ExportAllDeclaration")
          }
          if (this.eat(types._default)) { 
            this.checkExport(exports, "default", this.lastTokStart);
            var isAsync;
            if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
              var fNode = this.startNode();
              this.next();
              if (isAsync) { this.next(); }
              node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
            } else if (this.type === types._class) {
              var cNode = this.startNode();
              node.declaration = this.parseClass(cNode, "nullableID");
            } else {
              node.declaration = this.parseMaybeAssign();
              this.semicolon();
            }
            return this.finishNode(node, "ExportDefaultDeclaration")
          }
          if (this.shouldParseExportStatement()) {
            node.declaration = this.parseStatement(null);
            if (node.declaration.type === "VariableDeclaration")
              { this.checkVariableExport(exports, node.declaration.declarations); }
            else
              { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
            node.specifiers = [];
            node.source = null;
          } else { 
            node.declaration = null;
            node.specifiers = this.parseExportSpecifiers(exports);
            if (this.eatContextual("from")) {
              if (this.type !== types.string) { this.unexpected(); }
              node.source = this.parseExprAtom();
            } else {
              for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
                var spec = list[i];
  
                this.checkUnreserved(spec.local);
                this.checkLocalExport(spec.local);
              }
  
              node.source = null;
            }
            this.semicolon();
          }
          return this.finishNode(node, "ExportNamedDeclaration")
        };
  
        pp$1.checkExport = function(exports, name, pos) {
          if (!exports) { return }
          if (has(exports, name))
            { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
          exports[name] = true;
        };
  
        pp$1.checkPatternExport = function(exports, pat) {
          var type = pat.type;
          if (type === "Identifier")
            { this.checkExport(exports, pat.name, pat.start); }
          else if (type === "ObjectPattern")
            { for (var i = 0, list = pat.properties; i < list.length; i += 1)
              {
                var prop = list[i];
  
                this.checkPatternExport(exports, prop);
              } }
          else if (type === "ArrayPattern")
            { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
              var elt = list$1[i$1];
  
                if (elt) { this.checkPatternExport(exports, elt); }
            } }
          else if (type === "Property")
            { this.checkPatternExport(exports, pat.value); }
          else if (type === "AssignmentPattern")
            { this.checkPatternExport(exports, pat.left); }
          else if (type === "RestElement")
            { this.checkPatternExport(exports, pat.argument); }
          else if (type === "ParenthesizedExpression")
            { this.checkPatternExport(exports, pat.expression); }
        };
  
        pp$1.checkVariableExport = function(exports, decls) {
          if (!exports) { return }
          for (var i = 0, list = decls; i < list.length; i += 1)
            {
            var decl = list[i];
  
            this.checkPatternExport(exports, decl.id);
          }
        };
  
        pp$1.shouldParseExportStatement = function() {
          return this.type.keyword === "var" ||
            this.type.keyword === "const" ||
            this.type.keyword === "class" ||
            this.type.keyword === "function" ||
            this.isLet() ||
            this.isAsyncFunction()
        };
  
  
        pp$1.parseExportSpecifiers = function(exports) {
          var nodes = [], first = true;
          this.expect(types.braceL);
          while (!this.eat(types.braceR)) {
            if (!first) {
              this.expect(types.comma);
              if (this.afterTrailingComma(types.braceR)) { break }
            } else { first = false; }
  
            var node = this.startNode();
            node.local = this.parseIdent(true);
            node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
            this.checkExport(exports, node.exported.name, node.exported.start);
            nodes.push(this.finishNode(node, "ExportSpecifier"));
          }
          return nodes
        };
  
  
        pp$1.parseImport = function(node) {
          this.next();
          if (this.type === types.string) {
            node.specifiers = empty;
            node.source = this.parseExprAtom();
          } else {
            node.specifiers = this.parseImportSpecifiers();
            this.expectContextual("from");
            node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
          }
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration")
        };
  
  
        pp$1.parseImportSpecifiers = function() {
          var nodes = [], first = true;
          if (this.type === types.name) {
            var node = this.startNode();
            node.local = this.parseIdent();
            this.checkLVal(node.local, BIND_LEXICAL);
            nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
            if (!this.eat(types.comma)) { return nodes }
          }
          if (this.type === types.star) {
            var node$1 = this.startNode();
            this.next();
            this.expectContextual("as");
            node$1.local = this.parseIdent();
            this.checkLVal(node$1.local, BIND_LEXICAL);
            nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
            return nodes
          }
          this.expect(types.braceL);
          while (!this.eat(types.braceR)) {
            if (!first) {
              this.expect(types.comma);
              if (this.afterTrailingComma(types.braceR)) { break }
            } else { first = false; }
  
            var node$2 = this.startNode();
            node$2.imported = this.parseIdent(true);
            if (this.eatContextual("as")) {
              node$2.local = this.parseIdent();
            } else {
              this.checkUnreserved(node$2.imported);
              node$2.local = node$2.imported;
            }
            this.checkLVal(node$2.local, BIND_LEXICAL);
            nodes.push(this.finishNode(node$2, "ImportSpecifier"));
          }
          return nodes
        };
  
        pp$1.adaptDirectivePrologue = function(statements) {
          for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
            statements[i].directive = statements[i].expression.raw.slice(1, -1);
          }
        };
        pp$1.isDirectiveCandidate = function(statement) {
          return (
            statement.type === "ExpressionStatement" &&
            statement.expression.type === "Literal" &&
            typeof statement.expression.value === "string" &&
            (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
          )
        };
  
        var pp$2 = Parser.prototype;
  
  
        pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
          if (this.options.ecmaVersion >= 6 && node) {
            switch (node.type) {
            case "Identifier":
              if (this.inAsync && node.name === "await")
                { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
              break
  
            case "ObjectPattern":
            case "ArrayPattern":
            case "RestElement":
              break
  
            case "ObjectExpression":
              node.type = "ObjectPattern";
              if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
              for (var i = 0, list = node.properties; i < list.length; i += 1) {
                var prop = list[i];
  
              this.toAssignable(prop, isBinding);
                if (
                  prop.type === "RestElement" &&
                  (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
                ) {
                  this.raise(prop.argument.start, "Unexpected token");
                }
              }
              break
  
            case "Property":
              if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
              this.toAssignable(node.value, isBinding);
              break
  
            case "ArrayExpression":
              node.type = "ArrayPattern";
              if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
              this.toAssignableList(node.elements, isBinding);
              break
  
            case "SpreadElement":
              node.type = "RestElement";
              this.toAssignable(node.argument, isBinding);
              if (node.argument.type === "AssignmentPattern")
                { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
              break
  
            case "AssignmentExpression":
              if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
              node.type = "AssignmentPattern";
              delete node.operator;
              this.toAssignable(node.left, isBinding);
  
            case "AssignmentPattern":
              break
  
            case "ParenthesizedExpression":
              this.toAssignable(node.expression, isBinding, refDestructuringErrors);
              break
  
            case "MemberExpression":
              if (!isBinding) { break }
  
            default:
              this.raise(node.start, "Assigning to rvalue");
            }
          } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
          return node
        };
  
  
        pp$2.toAssignableList = function(exprList, isBinding) {
          var end = exprList.length;
          for (var i = 0; i < end; i++) {
            var elt = exprList[i];
            if (elt) { this.toAssignable(elt, isBinding); }
          }
          if (end) {
            var last = exprList[end - 1];
            if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
              { this.unexpected(last.argument.start); }
          }
          return exprList
        };
  
  
        pp$2.parseSpread = function(refDestructuringErrors) {
          var node = this.startNode();
          this.next();
          node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          return this.finishNode(node, "SpreadElement")
        };
  
        pp$2.parseRestBinding = function() {
          var node = this.startNode();
          this.next();
  
          if (this.options.ecmaVersion === 6 && this.type !== types.name)
            { this.unexpected(); }
  
          node.argument = this.parseBindingAtom();
  
          return this.finishNode(node, "RestElement")
        };
  
  
        pp$2.parseBindingAtom = function() {
          if (this.options.ecmaVersion >= 6) {
            switch (this.type) {
            case types.bracketL:
              var node = this.startNode();
              this.next();
              node.elements = this.parseBindingList(types.bracketR, true, true);
              return this.finishNode(node, "ArrayPattern")
  
            case types.braceL:
              return this.parseObj(true)
            }
          }
          return this.parseIdent()
        };
  
        pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
          var elts = [], first = true;
          while (!this.eat(close)) {
            if (first) { first = false; }
            else { this.expect(types.comma); }
            if (allowEmpty && this.type === types.comma) {
              elts.push(null);
            } else if (allowTrailingComma && this.afterTrailingComma(close)) {
              break
            } else if (this.type === types.ellipsis) {
              var rest = this.parseRestBinding();
              this.parseBindingListItem(rest);
              elts.push(rest);
              if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
              this.expect(close);
              break
            } else {
              var elem = this.parseMaybeDefault(this.start, this.startLoc);
              this.parseBindingListItem(elem);
              elts.push(elem);
            }
          }
          return elts
        };
  
        pp$2.parseBindingListItem = function(param) {
          return param
        };
  
  
        pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
          left = left || this.parseBindingAtom();
          if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
          var node = this.startNodeAt(startPos, startLoc);
          node.left = left;
          node.right = this.parseMaybeAssign();
          return this.finishNode(node, "AssignmentPattern")
        };
  
  
        pp$2.checkLVal = function(expr, bindingType, checkClashes) {
          if ( bindingType === void 0 ) bindingType = BIND_NONE;
  
          switch (expr.type) {
          case "Identifier":
            if (bindingType === BIND_LEXICAL && expr.name === "let")
              { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
            if (this.strict && this.reservedWordsStrictBind.test(expr.name))
              { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
            if (checkClashes) {
              if (has(checkClashes, expr.name))
                { this.raiseRecoverable(expr.start, "Argument name clash"); }
              checkClashes[expr.name] = true;
            }
            if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
            break
  
          case "MemberExpression":
            if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
            break
  
          case "ObjectPattern":
            for (var i = 0, list = expr.properties; i < list.length; i += 1)
              {
            var prop = list[i];
  
            this.checkLVal(prop, bindingType, checkClashes);
          }
            break
  
          case "Property":
            this.checkLVal(expr.value, bindingType, checkClashes);
            break
  
          case "ArrayPattern":
            for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
              var elem = list$1[i$1];
  
            if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
            }
            break
  
          case "AssignmentPattern":
            this.checkLVal(expr.left, bindingType, checkClashes);
            break
  
          case "RestElement":
            this.checkLVal(expr.argument, bindingType, checkClashes);
            break
  
          case "ParenthesizedExpression":
            this.checkLVal(expr.expression, bindingType, checkClashes);
            break
  
          default:
            this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
          }
        };
  
  
        var pp$3 = Parser.prototype;
  
  
        pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
          if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
            { return }
          if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
            { return }
          var key = prop.key;
          var name;
          switch (key.type) {
          case "Identifier": name = key.name; break
          case "Literal": name = String(key.value); break
          default: return
          }
          var kind = prop.kind;
          if (this.options.ecmaVersion >= 6) {
            if (name === "__proto__" && kind === "init") {
              if (propHash.proto) {
                if (refDestructuringErrors) {
                  if (refDestructuringErrors.doubleProto < 0)
                    { refDestructuringErrors.doubleProto = key.start; }
                } else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
              }
              propHash.proto = true;
            }
            return
          }
          name = "$" + name;
          var other = propHash[name];
          if (other) {
            var redefinition;
            if (kind === "init") {
              redefinition = this.strict && other.init || other.get || other.set;
            } else {
              redefinition = other.init || other[kind];
            }
            if (redefinition)
              { this.raiseRecoverable(key.start, "Redefinition of property"); }
          } else {
            other = propHash[name] = {
              init: false,
              get: false,
              set: false
            };
          }
          other[kind] = true;
        };
  
  
  
  
        pp$3.parseExpression = function(noIn, refDestructuringErrors) {
          var startPos = this.start, startLoc = this.startLoc;
          var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
          if (this.type === types.comma) {
            var node = this.startNodeAt(startPos, startLoc);
            node.expressions = [expr];
            while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
            return this.finishNode(node, "SequenceExpression")
          }
          return expr
        };
  
  
        pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
          if (this.isContextual("yield")) {
            if (this.inGenerator) { return this.parseYield(noIn) }
            else { this.exprAllowed = false; }
          }
  
          var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
          if (refDestructuringErrors) {
            oldParenAssign = refDestructuringErrors.parenthesizedAssign;
            oldTrailingComma = refDestructuringErrors.trailingComma;
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
          } else {
            refDestructuringErrors = new DestructuringErrors;
            ownDestructuringErrors = true;
          }
  
          var startPos = this.start, startLoc = this.startLoc;
          if (this.type === types.parenL || this.type === types.name)
            { this.potentialArrowAt = this.start; }
          var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
          if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
          if (this.type.isAssign) {
            var node = this.startNodeAt(startPos, startLoc);
            node.operator = this.value;
            node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
            if (!ownDestructuringErrors) {
              refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
            }
            if (refDestructuringErrors.shorthandAssign >= node.left.start)
              { refDestructuringErrors.shorthandAssign = -1; } 
            this.checkLVal(left);
            this.next();
            node.right = this.parseMaybeAssign(noIn);
            return this.finishNode(node, "AssignmentExpression")
          } else {
            if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
          }
          if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
          if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
          return left
        };
  
  
        pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
          var startPos = this.start, startLoc = this.startLoc;
          var expr = this.parseExprOps(noIn, refDestructuringErrors);
          if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
          if (this.eat(types.question)) {
            var node = this.startNodeAt(startPos, startLoc);
            node.test = expr;
            node.consequent = this.parseMaybeAssign();
            this.expect(types.colon);
            node.alternate = this.parseMaybeAssign(noIn);
            return this.finishNode(node, "ConditionalExpression")
          }
          return expr
        };
  
  
        pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
          var startPos = this.start, startLoc = this.startLoc;
          var expr = this.parseMaybeUnary(refDestructuringErrors, false);
          if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
          return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
        };
  
  
        pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
          var prec = this.type.binop;
          if (prec != null && (!noIn || this.type !== types._in)) {
            if (prec > minPrec) {
              var logical = this.type === types.logicalOR || this.type === types.logicalAND;
              var op = this.value;
              this.next();
              var startPos = this.start, startLoc = this.startLoc;
              var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
              var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
              return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
            }
          }
          return left
        };
  
        pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
          var node = this.startNodeAt(startPos, startLoc);
          node.left = left;
          node.operator = op;
          node.right = right;
          return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
        };
  
  
        pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
          var startPos = this.start, startLoc = this.startLoc, expr;
          if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
            expr = this.parseAwait();
            sawUnary = true;
          } else if (this.type.prefix) {
            var node = this.startNode(), update = this.type === types.incDec;
            node.operator = this.value;
            node.prefix = true;
            this.next();
            node.argument = this.parseMaybeUnary(null, true);
            this.checkExpressionErrors(refDestructuringErrors, true);
            if (update) { this.checkLVal(node.argument); }
            else if (this.strict && node.operator === "delete" &&
                     node.argument.type === "Identifier")
              { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
            else { sawUnary = true; }
            expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
          } else {
            expr = this.parseExprSubscripts(refDestructuringErrors);
            if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
            while (this.type.postfix && !this.canInsertSemicolon()) {
              var node$1 = this.startNodeAt(startPos, startLoc);
              node$1.operator = this.value;
              node$1.prefix = false;
              node$1.argument = expr;
              this.checkLVal(expr);
              this.next();
              expr = this.finishNode(node$1, "UpdateExpression");
            }
          }
  
          if (!sawUnary && this.eat(types.starstar))
            { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
          else
            { return expr }
        };
  
  
        pp$3.parseExprSubscripts = function(refDestructuringErrors) {
          var startPos = this.start, startLoc = this.startLoc;
          var expr = this.parseExprAtom(refDestructuringErrors);
          if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
            { return expr }
          var result = this.parseSubscripts(expr, startPos, startLoc);
          if (refDestructuringErrors && result.type === "MemberExpression") {
            if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
            if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
          }
          return result
        };
  
        pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
          var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
              this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
          while (true) {
            var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
            if (element === base || element.type === "ArrowFunctionExpression") { return element }
            base = element;
          }
        };
  
        pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
          var computed = this.eat(types.bracketL);
          if (computed || this.eat(types.dot)) {
            var node = this.startNodeAt(startPos, startLoc);
            node.object = base;
            node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
            node.computed = !!computed;
            if (computed) { this.expect(types.bracketR); }
            base = this.finishNode(node, "MemberExpression");
          } else if (!noCalls && this.eat(types.parenL)) {
            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
            this.yieldPos = 0;
            this.awaitPos = 0;
            this.awaitIdentPos = 0;
            var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
            if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
              this.checkPatternErrors(refDestructuringErrors, false);
              this.checkYieldAwaitInDefaultParams();
              if (this.awaitIdentPos > 0)
                { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
              this.yieldPos = oldYieldPos;
              this.awaitPos = oldAwaitPos;
              this.awaitIdentPos = oldAwaitIdentPos;
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
            }
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;
            this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.callee = base;
            node$1.arguments = exprList;
            base = this.finishNode(node$1, "CallExpression");
          } else if (this.type === types.backQuote) {
            var node$2 = this.startNodeAt(startPos, startLoc);
            node$2.tag = base;
            node$2.quasi = this.parseTemplate({isTagged: true});
            base = this.finishNode(node$2, "TaggedTemplateExpression");
          }
          return base
        };
  
  
        pp$3.parseExprAtom = function(refDestructuringErrors) {
          if (this.type === types.slash) { this.readRegexp(); }
  
          var node, canBeArrow = this.potentialArrowAt === this.start;
          switch (this.type) {
          case types._super:
            if (!this.allowSuper)
              { this.raise(this.start, "'super' keyword outside a method"); }
            node = this.startNode();
            this.next();
            if (this.type === types.parenL && !this.allowDirectSuper)
              { this.raise(node.start, "super() call outside constructor of a subclass"); }
            if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
              { this.unexpected(); }
            return this.finishNode(node, "Super")
  
          case types._this:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression")
  
          case types.name:
            var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
            var id = this.parseIdent(false);
            if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
              { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
            if (canBeArrow && !this.canInsertSemicolon()) {
              if (this.eat(types.arrow))
                { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
              if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
                id = this.parseIdent(false);
                if (this.canInsertSemicolon() || !this.eat(types.arrow))
                  { this.unexpected(); }
                return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
              }
            }
            return id
  
          case types.regexp:
            var value = this.value;
            node = this.parseLiteral(value.value);
            node.regex = {pattern: value.pattern, flags: value.flags};
            return node
  
          case types.num: case types.string:
            return this.parseLiteral(this.value)
  
          case types._null: case types._true: case types._false:
            node = this.startNode();
            node.value = this.type === types._null ? null : this.type === types._true;
            node.raw = this.type.keyword;
            this.next();
            return this.finishNode(node, "Literal")
  
          case types.parenL:
            var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
            if (refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
                { refDestructuringErrors.parenthesizedAssign = start; }
              if (refDestructuringErrors.parenthesizedBind < 0)
                { refDestructuringErrors.parenthesizedBind = start; }
            }
            return expr
  
          case types.bracketL:
            node = this.startNode();
            this.next();
            node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
            return this.finishNode(node, "ArrayExpression")
  
          case types.braceL:
            return this.parseObj(false, refDestructuringErrors)
  
          case types._function:
            node = this.startNode();
            this.next();
            return this.parseFunction(node, 0)
  
          case types._class:
            return this.parseClass(this.startNode(), false)
  
          case types._new:
            return this.parseNew()
  
          case types.backQuote:
            return this.parseTemplate()
  
          case types._import:
            if (this.options.ecmaVersion >= 11) {
              return this.parseExprImport()
            } else {
              return this.unexpected()
            }
  
          default:
            this.unexpected();
          }
        };
  
        pp$3.parseExprImport = function() {
          var node = this.startNode();
          this.next(); 
          switch (this.type) {
          case types.parenL:
            return this.parseDynamicImport(node)
          default:
            this.unexpected();
          }
        };
  
        pp$3.parseDynamicImport = function(node) {
          this.next(); 
  
          node.source = this.parseMaybeAssign();
  
          if (!this.eat(types.parenR)) {
            var errorPos = this.start;
            if (this.eat(types.comma) && this.eat(types.parenR)) {
              this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
            } else {
              this.unexpected(errorPos);
            }
          }
  
          return this.finishNode(node, "ImportExpression")
        };
  
        pp$3.parseLiteral = function(value) {
          var node = this.startNode();
          node.value = value;
          node.raw = this.input.slice(this.start, this.end);
          if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
          this.next();
          return this.finishNode(node, "Literal")
        };
  
        pp$3.parseParenExpression = function() {
          this.expect(types.parenL);
          var val = this.parseExpression();
          this.expect(types.parenR);
          return val
        };
  
        pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
          var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
          if (this.options.ecmaVersion >= 6) {
            this.next();
  
            var innerStartPos = this.start, innerStartLoc = this.startLoc;
            var exprList = [], first = true, lastIsComma = false;
            var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
            this.yieldPos = 0;
            this.awaitPos = 0;
            while (this.type !== types.parenR) {
              first ? first = false : this.expect(types.comma);
              if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
                lastIsComma = true;
                break
              } else if (this.type === types.ellipsis) {
                spreadStart = this.start;
                exprList.push(this.parseParenItem(this.parseRestBinding()));
                if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
                break
              } else {
                exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
              }
            }
            var innerEndPos = this.start, innerEndLoc = this.startLoc;
            this.expect(types.parenR);
  
            if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
              this.checkPatternErrors(refDestructuringErrors, false);
              this.checkYieldAwaitInDefaultParams();
              this.yieldPos = oldYieldPos;
              this.awaitPos = oldAwaitPos;
              return this.parseParenArrowList(startPos, startLoc, exprList)
            }
  
            if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
            if (spreadStart) { this.unexpected(spreadStart); }
            this.checkExpressionErrors(refDestructuringErrors, true);
            this.yieldPos = oldYieldPos || this.yieldPos;
            this.awaitPos = oldAwaitPos || this.awaitPos;
  
            if (exprList.length > 1) {
              val = this.startNodeAt(innerStartPos, innerStartLoc);
              val.expressions = exprList;
              this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
            } else {
              val = exprList[0];
            }
          } else {
            val = this.parseParenExpression();
          }
  
          if (this.options.preserveParens) {
            var par = this.startNodeAt(startPos, startLoc);
            par.expression = val;
            return this.finishNode(par, "ParenthesizedExpression")
          } else {
            return val
          }
        };
  
        pp$3.parseParenItem = function(item) {
          return item
        };
  
        pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
        };
  
  
        var empty$1 = [];
  
        pp$3.parseNew = function() {
          if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
          var node = this.startNode();
          var meta = this.parseIdent(true);
          if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
            node.meta = meta;
            var containsEsc = this.containsEsc;
            node.property = this.parseIdent(true);
            if (node.property.name !== "target" || containsEsc)
              { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
            if (!this.inNonArrowFunction())
              { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
            return this.finishNode(node, "MetaProperty")
          }
          var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
          node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
          if (isImport && node.callee.type === "ImportExpression") {
            this.raise(startPos, "Cannot use new with import()");
          }
          if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
          else { node.arguments = empty$1; }
          return this.finishNode(node, "NewExpression")
        };
  
  
        pp$3.parseTemplateElement = function(ref) {
          var isTagged = ref.isTagged;
  
          var elem = this.startNode();
          if (this.type === types.invalidTemplate) {
            if (!isTagged) {
              this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
            }
            elem.value = {
              raw: this.value,
              cooked: null
            };
          } else {
            elem.value = {
              raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
              cooked: this.value
            };
          }
          this.next();
          elem.tail = this.type === types.backQuote;
          return this.finishNode(elem, "TemplateElement")
        };
  
        pp$3.parseTemplate = function(ref) {
          if ( ref === void 0 ) ref = {};
          var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;
  
          var node = this.startNode();
          this.next();
          node.expressions = [];
          var curElt = this.parseTemplateElement({isTagged: isTagged});
          node.quasis = [curElt];
          while (!curElt.tail) {
            if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
            this.expect(types.dollarBraceL);
            node.expressions.push(this.parseExpression());
            this.expect(types.braceR);
            node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
          }
          this.next();
          return this.finishNode(node, "TemplateLiteral")
        };
  
        pp$3.isAsyncProp = function(prop) {
          return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
            (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
            !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
        };
  
  
        pp$3.parseObj = function(isPattern, refDestructuringErrors) {
          var node = this.startNode(), first = true, propHash = {};
          node.properties = [];
          this.next();
          while (!this.eat(types.braceR)) {
            if (!first) {
              this.expect(types.comma);
              if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
            } else { first = false; }
  
            var prop = this.parseProperty(isPattern, refDestructuringErrors);
            if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
            node.properties.push(prop);
          }
          return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
        };
  
        pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
          var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
          if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
            if (isPattern) {
              prop.argument = this.parseIdent(false);
              if (this.type === types.comma) {
                this.raise(this.start, "Comma is not permitted after the rest element");
              }
              return this.finishNode(prop, "RestElement")
            }
            if (this.type === types.parenL && refDestructuringErrors) {
              if (refDestructuringErrors.parenthesizedAssign < 0) {
                refDestructuringErrors.parenthesizedAssign = this.start;
              }
              if (refDestructuringErrors.parenthesizedBind < 0) {
                refDestructuringErrors.parenthesizedBind = this.start;
              }
            }
            prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
            if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
              refDestructuringErrors.trailingComma = this.start;
            }
            return this.finishNode(prop, "SpreadElement")
          }
          if (this.options.ecmaVersion >= 6) {
            prop.method = false;
            prop.shorthand = false;
            if (isPattern || refDestructuringErrors) {
              startPos = this.start;
              startLoc = this.startLoc;
            }
            if (!isPattern)
              { isGenerator = this.eat(types.star); }
          }
          var containsEsc = this.containsEsc;
          this.parsePropertyName(prop);
          if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
            isAsync = true;
            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
            this.parsePropertyName(prop, refDestructuringErrors);
          } else {
            isAsync = false;
          }
          this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
          return this.finishNode(prop, "Property")
        };
  
        pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
          if ((isGenerator || isAsync) && this.type === types.colon)
            { this.unexpected(); }
  
          if (this.eat(types.colon)) {
            prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
            prop.kind = "init";
          } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
            if (isPattern) { this.unexpected(); }
            prop.kind = "init";
            prop.method = true;
            prop.value = this.parseMethod(isGenerator, isAsync);
          } else if (!isPattern && !containsEsc &&
                     this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
                     (prop.key.name === "get" || prop.key.name === "set") &&
                     (this.type !== types.comma && this.type !== types.braceR)) {
            if (isGenerator || isAsync) { this.unexpected(); }
            prop.kind = prop.key.name;
            this.parsePropertyName(prop);
            prop.value = this.parseMethod(false);
            var paramCount = prop.kind === "get" ? 0 : 1;
            if (prop.value.params.length !== paramCount) {
              var start = prop.value.start;
              if (prop.kind === "get")
                { this.raiseRecoverable(start, "getter should have no params"); }
              else
                { this.raiseRecoverable(start, "setter should have exactly one param"); }
            } else {
              if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
                { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
            }
          } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
            if (isGenerator || isAsync) { this.unexpected(); }
            this.checkUnreserved(prop.key);
            if (prop.key.name === "await" && !this.awaitIdentPos)
              { this.awaitIdentPos = startPos; }
            prop.kind = "init";
            if (isPattern) {
              prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
            } else if (this.type === types.eq && refDestructuringErrors) {
              if (refDestructuringErrors.shorthandAssign < 0)
                { refDestructuringErrors.shorthandAssign = this.start; }
              prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
            } else {
              prop.value = prop.key;
            }
            prop.shorthand = true;
          } else { this.unexpected(); }
        };
  
        pp$3.parsePropertyName = function(prop) {
          if (this.options.ecmaVersion >= 6) {
            if (this.eat(types.bracketL)) {
              prop.computed = true;
              prop.key = this.parseMaybeAssign();
              this.expect(types.bracketR);
              return prop.key
            } else {
              prop.computed = false;
            }
          }
          return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
        };
  
  
        pp$3.initFunction = function(node) {
          node.id = null;
          if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
          if (this.options.ecmaVersion >= 8) { node.async = false; }
        };
  
  
        pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
          var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  
          this.initFunction(node);
          if (this.options.ecmaVersion >= 6)
            { node.generator = isGenerator; }
          if (this.options.ecmaVersion >= 8)
            { node.async = !!isAsync; }
  
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  
          this.expect(types.parenL);
          node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
          this.checkYieldAwaitInDefaultParams();
          this.parseFunctionBody(node, false, true);
  
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.finishNode(node, "FunctionExpression")
        };
  
  
        pp$3.parseArrowExpression = function(node, params, isAsync) {
          var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  
          this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
          this.initFunction(node);
          if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }
  
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
  
          node.params = this.toAssignableList(params, true);
          this.parseFunctionBody(node, true, false);
  
          this.yieldPos = oldYieldPos;
          this.awaitPos = oldAwaitPos;
          this.awaitIdentPos = oldAwaitIdentPos;
          return this.finishNode(node, "ArrowFunctionExpression")
        };
  
  
        pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
          var isExpression = isArrowFunction && this.type !== types.braceL;
          var oldStrict = this.strict, useStrict = false;
  
          if (isExpression) {
            node.body = this.parseMaybeAssign();
            node.expression = true;
            this.checkParams(node, false);
          } else {
            var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
            if (!oldStrict || nonSimple) {
              useStrict = this.strictDirective(this.end);
              if (useStrict && nonSimple)
                { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
            }
            var oldLabels = this.labels;
            this.labels = [];
            if (useStrict) { this.strict = true; }
  
            this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
            node.body = this.parseBlock(false);
            node.expression = false;
            this.adaptDirectivePrologue(node.body.body);
            this.labels = oldLabels;
          }
          this.exitScope();
  
          if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
          this.strict = oldStrict;
        };
  
        pp$3.isSimpleParamList = function(params) {
          for (var i = 0, list = params; i < list.length; i += 1)
            {
            var param = list[i];
  
            if (param.type !== "Identifier") { return false
          } }
          return true
        };
  
  
        pp$3.checkParams = function(node, allowDuplicates) {
          var nameHash = {};
          for (var i = 0, list = node.params; i < list.length; i += 1)
            {
            var param = list[i];
  
            this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
          }
        };
  
  
        pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
          var elts = [], first = true;
          while (!this.eat(close)) {
            if (!first) {
              this.expect(types.comma);
              if (allowTrailingComma && this.afterTrailingComma(close)) { break }
            } else { first = false; }
  
            var elt = (void 0);
            if (allowEmpty && this.type === types.comma)
              { elt = null; }
            else if (this.type === types.ellipsis) {
              elt = this.parseSpread(refDestructuringErrors);
              if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
                { refDestructuringErrors.trailingComma = this.start; }
            } else {
              elt = this.parseMaybeAssign(false, refDestructuringErrors);
            }
            elts.push(elt);
          }
          return elts
        };
  
        pp$3.checkUnreserved = function(ref) {
          var start = ref.start;
          var end = ref.end;
          var name = ref.name;
  
          if (this.inGenerator && name === "yield")
            { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
          if (this.inAsync && name === "await")
            { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
          if (this.keywords.test(name))
            { this.raise(start, ("Unexpected keyword '" + name + "'")); }
          if (this.options.ecmaVersion < 6 &&
            this.input.slice(start, end).indexOf("\\") !== -1) { return }
          var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
          if (re.test(name)) {
            if (!this.inAsync && name === "await")
              { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
            this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
          }
        };
  
  
        pp$3.parseIdent = function(liberal, isBinding) {
          var node = this.startNode();
          if (this.type === types.name) {
            node.name = this.value;
          } else if (this.type.keyword) {
            node.name = this.type.keyword;
  
            if ((node.name === "class" || node.name === "function") &&
                (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
              this.context.pop();
            }
          } else {
            this.unexpected();
          }
          this.next(!!liberal);
          this.finishNode(node, "Identifier");
          if (!liberal) {
            this.checkUnreserved(node);
            if (node.name === "await" && !this.awaitIdentPos)
              { this.awaitIdentPos = node.start; }
          }
          return node
        };
  
  
        pp$3.parseYield = function(noIn) {
          if (!this.yieldPos) { this.yieldPos = this.start; }
  
          var node = this.startNode();
          this.next();
          if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
            node.delegate = false;
            node.argument = null;
          } else {
            node.delegate = this.eat(types.star);
            node.argument = this.parseMaybeAssign(noIn);
          }
          return this.finishNode(node, "YieldExpression")
        };
  
        pp$3.parseAwait = function() {
          if (!this.awaitPos) { this.awaitPos = this.start; }
  
          var node = this.startNode();
          this.next();
          node.argument = this.parseMaybeUnary(null, false);
          return this.finishNode(node, "AwaitExpression")
        };
  
        var pp$4 = Parser.prototype;
  
  
        pp$4.raise = function(pos, message) {
          var loc = getLineInfo(this.input, pos);
          message += " (" + loc.line + ":" + loc.column + ")";
          var err = new SyntaxError(message);
          err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
          throw err
        };
  
        pp$4.raiseRecoverable = pp$4.raise;
  
        pp$4.curPosition = function() {
          if (this.options.locations) {
            return new Position(this.curLine, this.pos - this.lineStart)
          }
        };
  
        var pp$5 = Parser.prototype;
  
        var Scope = function Scope(flags) {
          this.flags = flags;
          this.var = [];
          this.lexical = [];
          this.functions = [];
        };
  
  
        pp$5.enterScope = function(flags) {
          this.scopeStack.push(new Scope(flags));
        };
  
        pp$5.exitScope = function() {
          this.scopeStack.pop();
        };
  
        pp$5.treatFunctionsAsVarInScope = function(scope) {
          return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
        };
  
        pp$5.declareName = function(name, bindingType, pos) {
          var redeclared = false;
          if (bindingType === BIND_LEXICAL) {
            var scope = this.currentScope();
            redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
            scope.lexical.push(name);
            if (this.inModule && (scope.flags & SCOPE_TOP))
              { delete this.undefinedExports[name]; }
          } else if (bindingType === BIND_SIMPLE_CATCH) {
            var scope$1 = this.currentScope();
            scope$1.lexical.push(name);
          } else if (bindingType === BIND_FUNCTION) {
            var scope$2 = this.currentScope();
            if (this.treatFunctionsAsVar)
              { redeclared = scope$2.lexical.indexOf(name) > -1; }
            else
              { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
            scope$2.functions.push(name);
          } else {
            for (var i = this.scopeStack.length - 1; i >= 0; --i) {
              var scope$3 = this.scopeStack[i];
              if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
                  !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
                redeclared = true;
                break
              }
              scope$3.var.push(name);
              if (this.inModule && (scope$3.flags & SCOPE_TOP))
                { delete this.undefinedExports[name]; }
              if (scope$3.flags & SCOPE_VAR) { break }
            }
          }
          if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
        };
  
        pp$5.checkLocalExport = function(id) {
          if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
              this.scopeStack[0].var.indexOf(id.name) === -1) {
            this.undefinedExports[id.name] = id;
          }
        };
  
        pp$5.currentScope = function() {
          return this.scopeStack[this.scopeStack.length - 1]
        };
  
        pp$5.currentVarScope = function() {
          for (var i = this.scopeStack.length - 1;; i--) {
            var scope = this.scopeStack[i];
            if (scope.flags & SCOPE_VAR) { return scope }
          }
        };
  
        pp$5.currentThisScope = function() {
          for (var i = this.scopeStack.length - 1;; i--) {
            var scope = this.scopeStack[i];
            if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
          }
        };
  
        var Node = function Node(parser, pos, loc) {
          this.type = "";
          this.start = pos;
          this.end = 0;
          if (parser.options.locations)
            { this.loc = new SourceLocation(parser, loc); }
          if (parser.options.directSourceFile)
            { this.sourceFile = parser.options.directSourceFile; }
          if (parser.options.ranges)
            { this.range = [pos, 0]; }
        };
  
  
        var pp$6 = Parser.prototype;
  
        pp$6.startNode = function() {
          return new Node(this, this.start, this.startLoc)
        };
  
        pp$6.startNodeAt = function(pos, loc) {
          return new Node(this, pos, loc)
        };
  
  
        function finishNodeAt(node, type, pos, loc) {
          node.type = type;
          node.end = pos;
          if (this.options.locations)
            { node.loc.end = loc; }
          if (this.options.ranges)
            { node.range[1] = pos; }
          return node
        }
  
        pp$6.finishNode = function(node, type) {
          return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
        };
  
  
        pp$6.finishNodeAt = function(node, type, pos, loc) {
          return finishNodeAt.call(this, node, type, pos, loc)
        };
  
  
        var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
          this.token = token;
          this.isExpr = !!isExpr;
          this.preserveSpace = !!preserveSpace;
          this.override = override;
          this.generator = !!generator;
        };
  
        var types$1 = {
          b_stat: new TokContext("{", false),
          b_expr: new TokContext("{", true),
          b_tmpl: new TokContext("${", false),
          p_stat: new TokContext("(", false),
          p_expr: new TokContext("(", true),
          q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
          f_stat: new TokContext("function", false),
          f_expr: new TokContext("function", true),
          f_expr_gen: new TokContext("function", true, false, null, true),
          f_gen: new TokContext("function", false, false, null, true)
        };
  
        var pp$7 = Parser.prototype;
  
        pp$7.initialContext = function() {
          return [types$1.b_stat]
        };
  
        pp$7.braceIsBlock = function(prevType) {
          var parent = this.curContext();
          if (parent === types$1.f_expr || parent === types$1.f_stat)
            { return true }
          if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
            { return !parent.isExpr }
  
          if (prevType === types._return || prevType === types.name && this.exprAllowed)
            { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
          if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
            { return true }
          if (prevType === types.braceL)
            { return parent === types$1.b_stat }
          if (prevType === types._var || prevType === types._const || prevType === types.name)
            { return false }
          return !this.exprAllowed
        };
  
        pp$7.inGeneratorContext = function() {
          for (var i = this.context.length - 1; i >= 1; i--) {
            var context = this.context[i];
            if (context.token === "function")
              { return context.generator }
          }
          return false
        };
  
        pp$7.updateContext = function(prevType) {
          var update, type = this.type;
          if (type.keyword && prevType === types.dot)
            { this.exprAllowed = false; }
          else if (update = type.updateContext)
            { update.call(this, prevType); }
          else
            { this.exprAllowed = type.beforeExpr; }
        };
  
  
        types.parenR.updateContext = types.braceR.updateContext = function() {
          if (this.context.length === 1) {
            this.exprAllowed = true;
            return
          }
          var out = this.context.pop();
          if (out === types$1.b_stat && this.curContext().token === "function") {
            out = this.context.pop();
          }
          this.exprAllowed = !out.isExpr;
        };
  
        types.braceL.updateContext = function(prevType) {
          this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
          this.exprAllowed = true;
        };
  
        types.dollarBraceL.updateContext = function() {
          this.context.push(types$1.b_tmpl);
          this.exprAllowed = true;
        };
  
        types.parenL.updateContext = function(prevType) {
          var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
          this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
          this.exprAllowed = true;
        };
  
        types.incDec.updateContext = function() {
        };
  
        types._function.updateContext = types._class.updateContext = function(prevType) {
          if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
              !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
              !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
            { this.context.push(types$1.f_expr); }
          else
            { this.context.push(types$1.f_stat); }
          this.exprAllowed = false;
        };
  
        types.backQuote.updateContext = function() {
          if (this.curContext() === types$1.q_tmpl)
            { this.context.pop(); }
          else
            { this.context.push(types$1.q_tmpl); }
          this.exprAllowed = false;
        };
  
        types.star.updateContext = function(prevType) {
          if (prevType === types._function) {
            var index = this.context.length - 1;
            if (this.context[index] === types$1.f_expr)
              { this.context[index] = types$1.f_expr_gen; }
            else
              { this.context[index] = types$1.f_gen; }
          }
          this.exprAllowed = true;
        };
  
        types.name.updateContext = function(prevType) {
          var allowed = false;
          if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
            if (this.value === "of" && !this.exprAllowed ||
                this.value === "yield" && this.inGeneratorContext())
              { allowed = true; }
          }
          this.exprAllowed = allowed;
        };
  
  
        var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
        var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
        var ecma11BinaryProperties = ecma10BinaryProperties;
        var unicodeBinaryProperties = {
          9: ecma9BinaryProperties,
          10: ecma10BinaryProperties,
          11: ecma11BinaryProperties
        };
  
        var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
  
        var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
        var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
        var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
        var unicodeScriptValues = {
          9: ecma9ScriptValues,
          10: ecma10ScriptValues,
          11: ecma11ScriptValues
        };
  
        var data = {};
        function buildUnicodeData(ecmaVersion) {
          var d = data[ecmaVersion] = {
            binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
            nonBinary: {
              General_Category: wordsRegexp(unicodeGeneralCategoryValues),
              Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
            }
          };
          d.nonBinary.Script_Extensions = d.nonBinary.Script;
  
          d.nonBinary.gc = d.nonBinary.General_Category;
          d.nonBinary.sc = d.nonBinary.Script;
          d.nonBinary.scx = d.nonBinary.Script_Extensions;
        }
        buildUnicodeData(9);
        buildUnicodeData(10);
        buildUnicodeData(11);
  
        var pp$8 = Parser.prototype;
  
        var RegExpValidationState = function RegExpValidationState(parser) {
          this.parser = parser;
          this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
          this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
          this.source = "";
          this.flags = "";
          this.start = 0;
          this.switchU = false;
          this.switchN = false;
          this.pos = 0;
          this.lastIntValue = 0;
          this.lastStringValue = "";
          this.lastAssertionIsQuantifiable = false;
          this.numCapturingParens = 0;
          this.maxBackReference = 0;
          this.groupNames = [];
          this.backReferenceNames = [];
        };
  
        RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
          var unicode = flags.indexOf("u") !== -1;
          this.start = start | 0;
          this.source = pattern + "";
          this.flags = flags;
          this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
          this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
        };
  
        RegExpValidationState.prototype.raise = function raise (message) {
          this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
        };
  
        RegExpValidationState.prototype.at = function at (i) {
          var s = this.source;
          var l = s.length;
          if (i >= l) {
            return -1
          }
          var c = s.charCodeAt(i);
          if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
            return c
          }
          var next = s.charCodeAt(i + 1);
          return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
        };
  
        RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
          var s = this.source;
          var l = s.length;
          if (i >= l) {
            return l
          }
          var c = s.charCodeAt(i), next;
          if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
              (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
            return i + 1
          }
          return i + 2
        };
  
        RegExpValidationState.prototype.current = function current () {
          return this.at(this.pos)
        };
  
        RegExpValidationState.prototype.lookahead = function lookahead () {
          return this.at(this.nextIndex(this.pos))
        };
  
        RegExpValidationState.prototype.advance = function advance () {
          this.pos = this.nextIndex(this.pos);
        };
  
        RegExpValidationState.prototype.eat = function eat (ch) {
          if (this.current() === ch) {
            this.advance();
            return true
          }
          return false
        };
  
        function codePointToString(ch) {
          if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
          ch -= 0x10000;
          return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
        }
  
        pp$8.validateRegExpFlags = function(state) {
          var validFlags = state.validFlags;
          var flags = state.flags;
  
          for (var i = 0; i < flags.length; i++) {
            var flag = flags.charAt(i);
            if (validFlags.indexOf(flag) === -1) {
              this.raise(state.start, "Invalid regular expression flag");
            }
            if (flags.indexOf(flag, i + 1) > -1) {
              this.raise(state.start, "Duplicate regular expression flag");
            }
          }
        };
  
        pp$8.validateRegExpPattern = function(state) {
          this.regexp_pattern(state);
  
          if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
            state.switchN = true;
            this.regexp_pattern(state);
          }
        };
  
        pp$8.regexp_pattern = function(state) {
          state.pos = 0;
          state.lastIntValue = 0;
          state.lastStringValue = "";
          state.lastAssertionIsQuantifiable = false;
          state.numCapturingParens = 0;
          state.maxBackReference = 0;
          state.groupNames.length = 0;
          state.backReferenceNames.length = 0;
  
          this.regexp_disjunction(state);
  
          if (state.pos !== state.source.length) {
            if (state.eat(0x29 )) {
              state.raise("Unmatched ')'");
            }
            if (state.eat(0x5D ) || state.eat(0x7D )) {
              state.raise("Lone quantifier brackets");
            }
          }
          if (state.maxBackReference > state.numCapturingParens) {
            state.raise("Invalid escape");
          }
          for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
            var name = list[i];
  
            if (state.groupNames.indexOf(name) === -1) {
              state.raise("Invalid named capture referenced");
            }
          }
        };
  
        pp$8.regexp_disjunction = function(state) {
          this.regexp_alternative(state);
          while (state.eat(0x7C )) {
            this.regexp_alternative(state);
          }
  
          if (this.regexp_eatQuantifier(state, true)) {
            state.raise("Nothing to repeat");
          }
          if (state.eat(0x7B )) {
            state.raise("Lone quantifier brackets");
          }
        };
  
        pp$8.regexp_alternative = function(state) {
          while (state.pos < state.source.length && this.regexp_eatTerm(state))
            { }
        };
  
        pp$8.regexp_eatTerm = function(state) {
          if (this.regexp_eatAssertion(state)) {
            if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
              if (state.switchU) {
                state.raise("Invalid quantifier");
              }
            }
            return true
          }
  
          if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
            this.regexp_eatQuantifier(state);
            return true
          }
  
          return false
        };
  
        pp$8.regexp_eatAssertion = function(state) {
          var start = state.pos;
          state.lastAssertionIsQuantifiable = false;
  
          if (state.eat(0x5E ) || state.eat(0x24 )) {
            return true
          }
  
          if (state.eat(0x5C )) {
            if (state.eat(0x42 ) || state.eat(0x62 )) {
              return true
            }
            state.pos = start;
          }
  
          if (state.eat(0x28 ) && state.eat(0x3F )) {
            var lookbehind = false;
            if (this.options.ecmaVersion >= 9) {
              lookbehind = state.eat(0x3C );
            }
            if (state.eat(0x3D ) || state.eat(0x21 )) {
              this.regexp_disjunction(state);
              if (!state.eat(0x29 )) {
                state.raise("Unterminated group");
              }
              state.lastAssertionIsQuantifiable = !lookbehind;
              return true
            }
          }
  
          state.pos = start;
          return false
        };
  
        pp$8.regexp_eatQuantifier = function(state, noError) {
          if ( noError === void 0 ) noError = false;
  
          if (this.regexp_eatQuantifierPrefix(state, noError)) {
            state.eat(0x3F );
            return true
          }
          return false
        };
  
        pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
          return (
            state.eat(0x2A ) ||
            state.eat(0x2B ) ||
            state.eat(0x3F ) ||
            this.regexp_eatBracedQuantifier(state, noError)
          )
        };
        pp$8.regexp_eatBracedQuantifier = function(state, noError) {
          var start = state.pos;
          if (state.eat(0x7B )) {
            var min = 0, max = -1;
            if (this.regexp_eatDecimalDigits(state)) {
              min = state.lastIntValue;
              if (state.eat(0x2C ) && this.regexp_eatDecimalDigits(state)) {
                max = state.lastIntValue;
              }
              if (state.eat(0x7D )) {
                if (max !== -1 && max < min && !noError) {
                  state.raise("numbers out of order in {} quantifier");
                }
                return true
              }
            }
            if (state.switchU && !noError) {
              state.raise("Incomplete quantifier");
            }
            state.pos = start;
          }
          return false
        };
  
        pp$8.regexp_eatAtom = function(state) {
          return (
            this.regexp_eatPatternCharacters(state) ||
            state.eat(0x2E ) ||
            this.regexp_eatReverseSolidusAtomEscape(state) ||
            this.regexp_eatCharacterClass(state) ||
            this.regexp_eatUncapturingGroup(state) ||
            this.regexp_eatCapturingGroup(state)
          )
        };
        pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
          var start = state.pos;
          if (state.eat(0x5C )) {
            if (this.regexp_eatAtomEscape(state)) {
              return true
            }
            state.pos = start;
          }
          return false
        };
        pp$8.regexp_eatUncapturingGroup = function(state) {
          var start = state.pos;
          if (state.eat(0x28 )) {
            if (state.eat(0x3F ) && state.eat(0x3A )) {
              this.regexp_disjunction(state);
              if (state.eat(0x29 )) {
                return true
              }
              state.raise("Unterminated group");
            }
            state.pos = start;
          }
          return false
        };
        pp$8.regexp_eatCapturingGroup = function(state) {
          if (state.eat(0x28 )) {
            if (this.options.ecmaVersion >= 9) {
              this.regexp_groupSpecifier(state);
            } else if (state.current() === 0x3F ) {
              state.raise("Invalid group");
            }
            this.regexp_disjunction(state);
            if (state.eat(0x29 )) {
              state.numCapturingParens += 1;
              return true
            }
            state.raise("Unterminated group");
          }
          return false
        };
  
        pp$8.regexp_eatExtendedAtom = function(state) {
          return (
            state.eat(0x2E ) ||
            this.regexp_eatReverseSolidusAtomEscape(state) ||
            this.regexp_eatCharacterClass(state) ||
            this.regexp_eatUncapturingGroup(state) ||
            this.regexp_eatCapturingGroup(state) ||
            this.regexp_eatInvalidBracedQuantifier(state) ||
            this.regexp_eatExtendedPatternCharacter(state)
          )
        };
  
        pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
          if (this.regexp_eatBracedQuantifier(state, true)) {
            state.raise("Nothing to repeat");
          }
          return false
        };
  
        pp$8.regexp_eatSyntaxCharacter = function(state) {
          var ch = state.current();
          if (isSyntaxCharacter(ch)) {
            state.lastIntValue = ch;
            state.advance();
            return true
          }
          return false
        };
        function isSyntaxCharacter(ch) {
          return (
            ch === 0x24  ||
            ch >= 0x28  && ch <= 0x2B  ||
            ch === 0x2E  ||
            ch === 0x3F  ||
            ch >= 0x5B  && ch <= 0x5E  ||
            ch >= 0x7B  && ch <= 0x7D 
          )
        }
  
        pp$8.regexp_eatPatternCharacters = function(state) {
          var start = state.pos;
          var ch = 0;
          while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
            state.advance();
          }
          return state.pos !== start
        };
  
        pp$8.regexp_eatExtendedPatternCharacter = function(state) {
          var ch = state.current();
          if (
            ch !== -1 &&
            ch !== 0x24  &&
            !(ch >= 0x28  && ch <= 0x2B ) &&
            ch !== 0x2E  &&
            ch !== 0x3F  &&
            ch !== 0x5B  &&
            ch !== 0x5E  &&
            ch !== 0x7C 
          ) {
            state.advance();
            return true
          }
          return false
        };
  
        pp$8.regexp_groupSpecifier = function(state) {
          if (state.eat(0x3F )) {
            if (this.regexp_eatGroupName(state)) {
              if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
                state.raise("Duplicate capture group name");
              }
              state.groupNames.push(state.lastStringValue);
              return
            }
            state.raise("Invalid group");
          }
        };
  
        pp$8.regexp_eatGroupName = function(state) {
          state.lastStringValue = "";
          if (state.eat(0x3C )) {
            if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E )) {
              return true
            }
            state.raise("Invalid capture group name");
          }
          return false
        };
  
        pp$8.regexp_eatRegExpIdentifierName = function(state) {
          state.lastStringValue = "";
          if (this.regexp_eatRegExpIdentifierStart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
            while (this.regexp_eatRegExpIdentifierPart(state)) {
              state.lastStringValue += codePointToString(state.lastIntValue);
            }
            return true
          }
          return false
        };
  
        pp$8.regexp_eatRegExpIdentifierStart = function(state) {
          var start = state.pos;
          var ch = state.current();
          state.advance();
  
          if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
            ch = state.lastIntValue;
          }
          if (isRegExpIdentifierStart(ch)) {
            state.lastIntValue = ch;
            return true
          }
  
          state.pos = start;
          return false
        };
        function isRegExpIdentifierStart(ch) {
          return isIdentifierStart(ch, true) || ch === 0x24  || ch === 0x5F 
        }
  
        pp$8.regexp_eatRegExpIdentifierPart = function(state) {
          var start = state.pos;
          var ch = state.current();
          state.advance();
  
          if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
            ch = state.lastIntValue;
          }
          if (isRegExpIdentifierPart(ch)) {
            state.lastIntValue = ch;
            return true
          }
  
          state.pos = start;
          return false
        };
        function isRegExpIdentifierPart(ch) {
          return isIdentifierChar(ch, true) || ch === 0x24  || ch === 0x5F  || ch === 0x200C  || ch === 0x200D 
        }
  
        pp$8.regexp_eatAtomEscape = function(state) {
          if (
            this.regexp_eatBackReference(state) ||
            this.regexp_eatCharacterClassEscape(state) ||
            this.regexp_eatCharacterEscape(state) ||
            (state.switchN && this.regexp_eatKGroupName(state))
          ) {
            return true
          }
          if (state.switchU) {
            if (state.current() === 0x63 ) {
              state.raise("Invalid unicode escape");
            }
            state.raise("Invalid escape");
          }
          return false
        };
        pp$8.regexp_eatBackReference = function(state) {
          var start = state.pos;
          if (this.regexp_eatDecimalEscape(state)) {
            var n = state.lastIntValue;
            if (state.switchU) {
              if (n > state.maxBackReference) {
                state.maxBackReference = n;
              }
              return true
            }
            if (n <= state.numCapturingParens) {
              return true
            }
            state.pos = start;
          }
          return false
        };
        pp$8.regexp_eatKGroupName = function(state) {
          if (state.eat(0x6B )) {
            if (this.regexp_eatGroupName(state)) {
              state.backReferenceNames.push(state.lastStringValue);
              return true
            }
            state.raise("Invalid named reference");
          }
          return false
        };
  
        pp$8.regexp_eatCharacterEscape = function(state) {
          return (
            this.regexp_eatControlEscape(state) ||
            this.regexp_eatCControlLetter(state) ||
            this.regexp_eatZero(state) ||
            this.regexp_eatHexEscapeSequence(state) ||
            this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
            (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
            this.regexp_eatIdentityEscape(state)
          )
        };
        pp$8.regexp_eatCControlLetter = function(state) {
          var start = state.pos;
          if (state.eat(0x63 )) {
            if (this.regexp_eatControlLetter(state)) {
              return true
            }
            state.pos = start;
          }
          return false
        };
        pp$8.regexp_eatZero = function(state) {
          if (state.current() === 0x30  && !isDecimalDigit(state.lookahead())) {
            state.lastIntValue = 0;
            state.advance();
            return true
          }
          return false
        };
  
        pp$8.regexp_eatControlEscape = function(state) {
          var ch = state.current();
          if (ch === 0x74 ) {
            state.lastIntValue = 0x09; 
            state.advance();
            return true
          }
          if (ch === 0x6E ) {
            state.lastIntValue = 0x0A; 
            state.advance();
            return true
          }
          if (ch === 0x76 ) {
            state.lastIntValue = 0x0B; 
            state.advance();
            return true
          }
          if (ch === 0x66 ) {
            state.lastIntValue = 0x0C; 
            state.advance();
            return true
          }
          if (ch === 0x72 ) {
            state.lastIntValue = 0x0D; 
            state.advance();
            return true
          }
          return false
        };
  
        pp$8.regexp_eatControlLetter = function(state) {
          var ch = state.current();
          if (isControlLetter(ch)) {
            state.lastIntValue = ch % 0x20;
            state.advance();
            return true
          }
          return false
        };
        function isControlLetter(ch) {
          return (
            (ch >= 0x41  && ch <= 0x5A ) ||
            (ch >= 0x61  && ch <= 0x7A )
          )
        }
  
        pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
          var start = state.pos;
  
          if (state.eat(0x75 )) {
            if (this.regexp_eatFixedHexDigits(state, 4)) {
              var lead = state.lastIntValue;
              if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
                var leadSurrogateEnd = state.pos;
                if (state.eat(0x5C ) && state.eat(0x75 ) && this.regexp_eatFixedHexDigits(state, 4)) {
                  var trail = state.lastIntValue;
                  if (trail >= 0xDC00 && trail <= 0xDFFF) {
                    state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
                    return true
                  }
                }
                state.pos = leadSurrogateEnd;
                state.lastIntValue = lead;
              }
              return true
            }
            if (
              state.switchU &&
              state.eat(0x7B ) &&
              this.regexp_eatHexDigits(state) &&
              state.eat(0x7D ) &&
              isValidUnicode(state.lastIntValue)
            ) {
              return true
            }
            if (state.switchU) {
              state.raise("Invalid unicode escape");
            }
            state.pos = start;
          }
  
          return false
        };
        function isValidUnicode(ch) {
          return ch >= 0 && ch <= 0x10FFFF
        }
  
        pp$8.regexp_eatIdentityEscape = function(state) {
          if (state.switchU) {
            if (this.regexp_eatSyntaxCharacter(state)) {
              return true
            }
            if (state.eat(0x2F )) {
              state.lastIntValue = 0x2F; 
              return true
            }
            return false
          }
  
          var ch = state.current();
          if (ch !== 0x63  && (!state.switchN || ch !== 0x6B )) {
            state.lastIntValue = ch;
            state.advance();
            return true
          }
  
          return false
        };
  
        pp$8.regexp_eatDecimalEscape = function(state) {
          state.lastIntValue = 0;
          var ch = state.current();
          if (ch >= 0x31  && ch <= 0x39 ) {
            do {
              state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );
              state.advance();
            } while ((ch = state.current()) >= 0x30  && ch <= 0x39 )
            return true
          }
          return false
        };
  
        pp$8.regexp_eatCharacterClassEscape = function(state) {
          var ch = state.current();
  
          if (isCharacterClassEscape(ch)) {
            state.lastIntValue = -1;
            state.advance();
            return true
          }
  
          if (
            state.switchU &&
            this.options.ecmaVersion >= 9 &&
            (ch === 0x50  || ch === 0x70 )
          ) {
            state.lastIntValue = -1;
            state.advance();
            if (
              state.eat(0x7B ) &&
              this.regexp_eatUnicodePropertyValueExpression(state) &&
              state.eat(0x7D )
            ) {
              return true
            }
            state.raise("Invalid property name");
          }
  
          return false
        };
        function isCharacterClassEscape(ch) {
          return (
            ch === 0x64  ||
            ch === 0x44  ||
            ch === 0x73  ||
            ch === 0x53  ||
            ch === 0x77  ||
            ch === 0x57 
          )
        }
  
        pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
          var start = state.pos;
  
          if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D )) {
            var name = state.lastStringValue;
            if (this.regexp_eatUnicodePropertyValue(state)) {
              var value = state.lastStringValue;
              this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
              return true
            }
          }
          state.pos = start;
  
          if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
            var nameOrValue = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
            return true
          }
          return false
        };
        pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
          if (!has(state.unicodeProperties.nonBinary, name))
            { state.raise("Invalid property name"); }
          if (!state.unicodeProperties.nonBinary[name].test(value))
            { state.raise("Invalid property value"); }
        };
        pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
          if (!state.unicodeProperties.binary.test(nameOrValue))
            { state.raise("Invalid property name"); }
        };
  
        pp$8.regexp_eatUnicodePropertyName = function(state) {
          var ch = 0;
          state.lastStringValue = "";
          while (isUnicodePropertyNameCharacter(ch = state.current())) {
            state.lastStringValue += codePointToString(ch);
            state.advance();
          }
          return state.lastStringValue !== ""
        };
        function isUnicodePropertyNameCharacter(ch) {
          return isControlLetter(ch) || ch === 0x5F 
        }
  
        pp$8.regexp_eatUnicodePropertyValue = function(state) {
          var ch = 0;
          state.lastStringValue = "";
          while (isUnicodePropertyValueCharacter(ch = state.current())) {
            state.lastStringValue += codePointToString(ch);
            state.advance();
          }
          return state.lastStringValue !== ""
        };
        function isUnicodePropertyValueCharacter(ch) {
          return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
        }
  
        pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
          return this.regexp_eatUnicodePropertyValue(state)
        };
  
        pp$8.regexp_eatCharacterClass = function(state) {
          if (state.eat(0x5B )) {
            state.eat(0x5E );
            this.regexp_classRanges(state);
            if (state.eat(0x5D )) {
              return true
            }
            state.raise("Unterminated character class");
          }
          return false
        };
  
        pp$8.regexp_classRanges = function(state) {
          while (this.regexp_eatClassAtom(state)) {
            var left = state.lastIntValue;
            if (state.eat(0x2D ) && this.regexp_eatClassAtom(state)) {
              var right = state.lastIntValue;
              if (state.switchU && (left === -1 || right === -1)) {
                state.raise("Invalid character class");
              }
              if (left !== -1 && right !== -1 && left > right) {
                state.raise("Range out of order in character class");
              }
            }
          }
        };
  
        pp$8.regexp_eatClassAtom = function(state) {
          var start = state.pos;
  
          if (state.eat(0x5C )) {
            if (this.regexp_eatClassEscape(state)) {
              return true
            }
            if (state.switchU) {
              var ch$1 = state.current();
              if (ch$1 === 0x63  || isOctalDigit(ch$1)) {
                state.raise("Invalid class escape");
              }
              state.raise("Invalid escape");
            }
            state.pos = start;
          }
  
          var ch = state.current();
          if (ch !== 0x5D ) {
            state.lastIntValue = ch;
            state.advance();
            return true
          }
  
          return false
        };
  
        pp$8.regexp_eatClassEscape = function(state) {
          var start = state.pos;
  
          if (state.eat(0x62 )) {
            state.lastIntValue = 0x08; 
            return true
          }
  
          if (state.switchU && state.eat(0x2D )) {
            state.lastIntValue = 0x2D; 
            return true
          }
  
          if (!state.switchU && state.eat(0x63 )) {
            if (this.regexp_eatClassControlLetter(state)) {
              return true
            }
            state.pos = start;
          }
  
          return (
            this.regexp_eatCharacterClassEscape(state) ||
            this.regexp_eatCharacterEscape(state)
          )
        };
  
        pp$8.regexp_eatClassControlLetter = function(state) {
          var ch = state.current();
          if (isDecimalDigit(ch) || ch === 0x5F ) {
            state.lastIntValue = ch % 0x20;
            state.advance();
            return true
          }
          return false
        };
  
        pp$8.regexp_eatHexEscapeSequence = function(state) {
          var start = state.pos;
          if (state.eat(0x78 )) {
            if (this.regexp_eatFixedHexDigits(state, 2)) {
              return true
            }
            if (state.switchU) {
              state.raise("Invalid escape");
            }
            state.pos = start;
          }
          return false
        };
  
        pp$8.regexp_eatDecimalDigits = function(state) {
          var start = state.pos;
          var ch = 0;
          state.lastIntValue = 0;
          while (isDecimalDigit(ch = state.current())) {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );
            state.advance();
          }
          return state.pos !== start
        };
        function isDecimalDigit(ch) {
          return ch >= 0x30  && ch <= 0x39 
        }
  
        pp$8.regexp_eatHexDigits = function(state) {
          var start = state.pos;
          var ch = 0;
          state.lastIntValue = 0;
          while (isHexDigit(ch = state.current())) {
            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
            state.advance();
          }
          return state.pos !== start
        };
        function isHexDigit(ch) {
          return (
            (ch >= 0x30  && ch <= 0x39 ) ||
            (ch >= 0x41  && ch <= 0x46 ) ||
            (ch >= 0x61  && ch <= 0x66 )
          )
        }
        function hexToInt(ch) {
          if (ch >= 0x41  && ch <= 0x46 ) {
            return 10 + (ch - 0x41 )
          }
          if (ch >= 0x61  && ch <= 0x66 ) {
            return 10 + (ch - 0x61 )
          }
          return ch - 0x30 
        }
  
        pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
          if (this.regexp_eatOctalDigit(state)) {
            var n1 = state.lastIntValue;
            if (this.regexp_eatOctalDigit(state)) {
              var n2 = state.lastIntValue;
              if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
                state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
              } else {
                state.lastIntValue = n1 * 8 + n2;
              }
            } else {
              state.lastIntValue = n1;
            }
            return true
          }
          return false
        };
  
        pp$8.regexp_eatOctalDigit = function(state) {
          var ch = state.current();
          if (isOctalDigit(ch)) {
            state.lastIntValue = ch - 0x30; 
            state.advance();
            return true
          }
          state.lastIntValue = 0;
          return false
        };
        function isOctalDigit(ch) {
          return ch >= 0x30  && ch <= 0x37 
        }
  
        pp$8.regexp_eatFixedHexDigits = function(state, length) {
          var start = state.pos;
          state.lastIntValue = 0;
          for (var i = 0; i < length; ++i) {
            var ch = state.current();
            if (!isHexDigit(ch)) {
              state.pos = start;
              return false
            }
            state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
            state.advance();
          }
          return true
        };
  
  
        var Token = function Token(p) {
          this.type = p.type;
          this.value = p.value;
          this.start = p.start;
          this.end = p.end;
          if (p.options.locations)
            { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
          if (p.options.ranges)
            { this.range = [p.start, p.end]; }
        };
  
  
        var pp$9 = Parser.prototype;
  
  
        pp$9.next = function(ignoreEscapeSequenceInKeyword) {
          if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
            { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
          if (this.options.onToken)
            { this.options.onToken(new Token(this)); }
  
          this.lastTokEnd = this.end;
          this.lastTokStart = this.start;
          this.lastTokEndLoc = this.endLoc;
          this.lastTokStartLoc = this.startLoc;
          this.nextToken();
        };
  
        pp$9.getToken = function() {
          this.next();
          return new Token(this)
        };
  
        if (typeof Symbol !== "undefined")
          { pp$9[Symbol.iterator] = function() {
            var this$1 = this;
  
            return {
              next: function () {
                var token = this$1.getToken();
                return {
                  done: token.type === types.eof,
                  value: token
                }
              }
            }
          }; }
  
  
        pp$9.curContext = function() {
          return this.context[this.context.length - 1]
        };
  
  
        pp$9.nextToken = function() {
          var curContext = this.curContext();
          if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }
  
          this.start = this.pos;
          if (this.options.locations) { this.startLoc = this.curPosition(); }
          if (this.pos >= this.input.length) { return this.finishToken(types.eof) }
  
          if (curContext.override) { return curContext.override(this) }
          else { this.readToken(this.fullCharCodeAtPos()); }
        };
  
        pp$9.readToken = function(code) {
          if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 )
            { return this.readWord() }
  
          return this.getTokenFromCode(code)
        };
  
        pp$9.fullCharCodeAtPos = function() {
          var code = this.input.charCodeAt(this.pos);
          if (code <= 0xd7ff || code >= 0xe000) { return code }
          var next = this.input.charCodeAt(this.pos + 1);
          return (code << 10) + next - 0x35fdc00
        };
  
        pp$9.skipBlockComment = function() {
          var startLoc = this.options.onComment && this.curPosition();
          var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
          if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
          this.pos = end + 2;
          if (this.options.locations) {
            lineBreakG.lastIndex = start;
            var match;
            while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
              ++this.curLine;
              this.lineStart = match.index + match[0].length;
            }
          }
          if (this.options.onComment)
            { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                                   startLoc, this.curPosition()); }
        };
  
        pp$9.skipLineComment = function(startSkip) {
          var start = this.pos;
          var startLoc = this.options.onComment && this.curPosition();
          var ch = this.input.charCodeAt(this.pos += startSkip);
          while (this.pos < this.input.length && !isNewLine(ch)) {
            ch = this.input.charCodeAt(++this.pos);
          }
          if (this.options.onComment)
            { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                                   startLoc, this.curPosition()); }
        };
  
  
        pp$9.skipSpace = function() {
          loop: while (this.pos < this.input.length) {
            var ch = this.input.charCodeAt(this.pos);
            switch (ch) {
            case 32: case 160: 
              ++this.pos;
              break
            case 13:
              if (this.input.charCodeAt(this.pos + 1) === 10) {
                ++this.pos;
              }
            case 10: case 8232: case 8233:
              ++this.pos;
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              break
            case 47: 
              switch (this.input.charCodeAt(this.pos + 1)) {
              case 42: 
                this.skipBlockComment();
                break
              case 47:
                this.skipLineComment(2);
                break
              default:
                break loop
              }
              break
            default:
              if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
                ++this.pos;
              } else {
                break loop
              }
            }
          }
        };
  
  
        pp$9.finishToken = function(type, val) {
          this.end = this.pos;
          if (this.options.locations) { this.endLoc = this.curPosition(); }
          var prevType = this.type;
          this.type = type;
          this.value = val;
  
          this.updateContext(prevType);
        };
  
  
        pp$9.readToken_dot = function() {
          var next = this.input.charCodeAt(this.pos + 1);
          if (next >= 48 && next <= 57) { return this.readNumber(true) }
          var next2 = this.input.charCodeAt(this.pos + 2);
          if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { 
            this.pos += 3;
            return this.finishToken(types.ellipsis)
          } else {
            ++this.pos;
            return this.finishToken(types.dot)
          }
        };
  
        pp$9.readToken_slash = function() { 
          var next = this.input.charCodeAt(this.pos + 1);
          if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
          if (next === 61) { return this.finishOp(types.assign, 2) }
          return this.finishOp(types.slash, 1)
        };
  
        pp$9.readToken_mult_modulo_exp = function(code) { 
          var next = this.input.charCodeAt(this.pos + 1);
          var size = 1;
          var tokentype = code === 42 ? types.star : types.modulo;
  
          if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
            ++size;
            tokentype = types.starstar;
            next = this.input.charCodeAt(this.pos + 2);
          }
  
          if (next === 61) { return this.finishOp(types.assign, size + 1) }
          return this.finishOp(tokentype, size)
        };
  
        pp$9.readToken_pipe_amp = function(code) { 
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
          if (next === 61) { return this.finishOp(types.assign, 2) }
          return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
        };
  
        pp$9.readToken_caret = function() { 
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 61) { return this.finishOp(types.assign, 2) }
          return this.finishOp(types.bitwiseXOR, 1)
        };
  
        pp$9.readToken_plus_min = function(code) { 
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === code) {
            if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
                (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
              this.skipLineComment(3);
              this.skipSpace();
              return this.nextToken()
            }
            return this.finishOp(types.incDec, 2)
          }
          if (next === 61) { return this.finishOp(types.assign, 2) }
          return this.finishOp(types.plusMin, 1)
        };
  
        pp$9.readToken_lt_gt = function(code) { 
          var next = this.input.charCodeAt(this.pos + 1);
          var size = 1;
          if (next === code) {
            size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
            if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
            return this.finishOp(types.bitShift, size)
          }
          if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
              this.input.charCodeAt(this.pos + 3) === 45) {
            this.skipLineComment(4);
            this.skipSpace();
            return this.nextToken()
          }
          if (next === 61) { size = 2; }
          return this.finishOp(types.relational, size)
        };
  
        pp$9.readToken_eq_excl = function(code) { 
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
          if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { 
            this.pos += 2;
            return this.finishToken(types.arrow)
          }
          return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
        };
  
        pp$9.getTokenFromCode = function(code) {
          switch (code) {
          case 46: 
            return this.readToken_dot()
  
          case 40: ++this.pos; return this.finishToken(types.parenL)
          case 41: ++this.pos; return this.finishToken(types.parenR)
          case 59: ++this.pos; return this.finishToken(types.semi)
          case 44: ++this.pos; return this.finishToken(types.comma)
          case 91: ++this.pos; return this.finishToken(types.bracketL)
          case 93: ++this.pos; return this.finishToken(types.bracketR)
          case 123: ++this.pos; return this.finishToken(types.braceL)
          case 125: ++this.pos; return this.finishToken(types.braceR)
          case 58: ++this.pos; return this.finishToken(types.colon)
          case 63: ++this.pos; return this.finishToken(types.question)
  
          case 96: 
            if (this.options.ecmaVersion < 6) { break }
            ++this.pos;
            return this.finishToken(types.backQuote)
  
          case 48: 
            var next = this.input.charCodeAt(this.pos + 1);
            if (next === 120 || next === 88) { return this.readRadixNumber(16) } 
            if (this.options.ecmaVersion >= 6) {
              if (next === 111 || next === 79) { return this.readRadixNumber(8) } 
              if (next === 98 || next === 66) { return this.readRadixNumber(2) } 
            }
  
          case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: 
            return this.readNumber(false)
  
          case 34: case 39: 
            return this.readString(code)
  
  
          case 47: 
            return this.readToken_slash()
  
          case 37: case 42: 
            return this.readToken_mult_modulo_exp(code)
  
          case 124: case 38: 
            return this.readToken_pipe_amp(code)
  
          case 94: 
            return this.readToken_caret()
  
          case 43: case 45: 
            return this.readToken_plus_min(code)
  
          case 60: case 62: 
            return this.readToken_lt_gt(code)
  
          case 61: case 33: 
            return this.readToken_eq_excl(code)
  
          case 126: 
            return this.finishOp(types.prefix, 1)
          }
  
          this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
        };
  
        pp$9.finishOp = function(type, size) {
          var str = this.input.slice(this.pos, this.pos + size);
          this.pos += size;
          return this.finishToken(type, str)
        };
  
        pp$9.readRegexp = function() {
          var escaped, inClass, start = this.pos;
          for (;;) {
            if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
            var ch = this.input.charAt(this.pos);
            if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
            if (!escaped) {
              if (ch === "[") { inClass = true; }
              else if (ch === "]" && inClass) { inClass = false; }
              else if (ch === "/" && !inClass) { break }
              escaped = ch === "\\";
            } else { escaped = false; }
            ++this.pos;
          }
          var pattern = this.input.slice(start, this.pos);
          ++this.pos;
          var flagsStart = this.pos;
          var flags = this.readWord1();
          if (this.containsEsc) { this.unexpected(flagsStart); }
  
          var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
          state.reset(start, pattern, flags);
          this.validateRegExpFlags(state);
          this.validateRegExpPattern(state);
  
          var value = null;
          try {
            value = new RegExp(pattern, flags);
          } catch (e) {
          }
  
          return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
        };
  
  
        pp$9.readInt = function(radix, len) {
          var start = this.pos, total = 0;
          for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
            var code = this.input.charCodeAt(this.pos), val = (void 0);
            if (code >= 97) { val = code - 97 + 10; } 
            else if (code >= 65) { val = code - 65 + 10; } 
            else if (code >= 48 && code <= 57) { val = code - 48; } 
            else { val = Infinity; }
            if (val >= radix) { break }
            ++this.pos;
            total = total * radix + val;
          }
          if (this.pos === start || len != null && this.pos - start !== len) { return null }
  
          return total
        };
  
        pp$9.readRadixNumber = function(radix) {
          var start = this.pos;
          this.pos += 2; 
          var val = this.readInt(radix);
          if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
          if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
            val = typeof BigInt !== "undefined" ? BigInt(this.input.slice(start, this.pos)) : null;
            ++this.pos;
          } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
          return this.finishToken(types.num, val)
        };
  
  
        pp$9.readNumber = function(startsWithDot) {
          var start = this.pos;
          if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
          var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
          if (octal && this.strict) { this.raise(start, "Invalid number"); }
          var next = this.input.charCodeAt(this.pos);
          if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
            var str$1 = this.input.slice(start, this.pos);
            var val$1 = typeof BigInt !== "undefined" ? BigInt(str$1) : null;
            ++this.pos;
            if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
            return this.finishToken(types.num, val$1)
          }
          if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
          if (next === 46 && !octal) { 
            ++this.pos;
            this.readInt(10);
            next = this.input.charCodeAt(this.pos);
          }
          if ((next === 69 || next === 101) && !octal) { 
            next = this.input.charCodeAt(++this.pos);
            if (next === 43 || next === 45) { ++this.pos; } 
            if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
          }
          if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
  
          var str = this.input.slice(start, this.pos);
          var val = octal ? parseInt(str, 8) : parseFloat(str);
          return this.finishToken(types.num, val)
        };
  
  
        pp$9.readCodePoint = function() {
          var ch = this.input.charCodeAt(this.pos), code;
  
          if (ch === 123) { 
            if (this.options.ecmaVersion < 6) { this.unexpected(); }
            var codePos = ++this.pos;
            code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
            ++this.pos;
            if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
          } else {
            code = this.readHexChar(4);
          }
          return code
        };
  
        function codePointToString$1(code) {
          if (code <= 0xFFFF) { return String.fromCharCode(code) }
          code -= 0x10000;
          return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
        }
  
        pp$9.readString = function(quote) {
          var out = "", chunkStart = ++this.pos;
          for (;;) {
            if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
            var ch = this.input.charCodeAt(this.pos);
            if (ch === quote) { break }
            if (ch === 92) { 
              out += this.input.slice(chunkStart, this.pos);
              out += this.readEscapedChar(false);
              chunkStart = this.pos;
            } else {
              if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
              ++this.pos;
            }
          }
          out += this.input.slice(chunkStart, this.pos++);
          return this.finishToken(types.string, out)
        };
  
  
        var INVALID_TEMPLATE_ESCAPE_ERROR = {};
  
        pp$9.tryReadTemplateToken = function() {
          this.inTemplateElement = true;
          try {
            this.readTmplToken();
          } catch (err) {
            if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
              this.readInvalidTemplateToken();
            } else {
              throw err
            }
          }
  
          this.inTemplateElement = false;
        };
  
        pp$9.invalidStringToken = function(position, message) {
          if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
            throw INVALID_TEMPLATE_ESCAPE_ERROR
          } else {
            this.raise(position, message);
          }
        };
  
        pp$9.readTmplToken = function() {
          var out = "", chunkStart = this.pos;
          for (;;) {
            if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
            var ch = this.input.charCodeAt(this.pos);
            if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { 
              if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
                if (ch === 36) {
                  this.pos += 2;
                  return this.finishToken(types.dollarBraceL)
                } else {
                  ++this.pos;
                  return this.finishToken(types.backQuote)
                }
              }
              out += this.input.slice(chunkStart, this.pos);
              return this.finishToken(types.template, out)
            }
            if (ch === 92) { 
              out += this.input.slice(chunkStart, this.pos);
              out += this.readEscapedChar(true);
              chunkStart = this.pos;
            } else if (isNewLine(ch)) {
              out += this.input.slice(chunkStart, this.pos);
              ++this.pos;
              switch (ch) {
              case 13:
                if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
              case 10:
                out += "\n";
                break
              default:
                out += String.fromCharCode(ch);
                break
              }
              if (this.options.locations) {
                ++this.curLine;
                this.lineStart = this.pos;
              }
              chunkStart = this.pos;
            } else {
              ++this.pos;
            }
          }
        };
  
        pp$9.readInvalidTemplateToken = function() {
          for (; this.pos < this.input.length; this.pos++) {
            switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break
  
            case "$":
              if (this.input[this.pos + 1] !== "{") {
                break
              }
  
            case "`":
              return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))
  
            }
          }
          this.raise(this.start, "Unterminated template");
        };
  
  
        pp$9.readEscapedChar = function(inTemplate) {
          var ch = this.input.charCodeAt(++this.pos);
          ++this.pos;
          switch (ch) {
          case 110: return "\n" 
          case 114: return "\r" 
          case 120: return String.fromCharCode(this.readHexChar(2)) 
          case 117: return codePointToString$1(this.readCodePoint()) 
          case 116: return "\t" 
          case 98: return "\b" 
          case 118: return "\u000b" 
          case 102: return "\f" 
          case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } 
          case 10: 
            if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
            return ""
          case 56:
          case 57:
            if (inTemplate) {
              var codePos = this.pos - 1;
  
              this.invalidStringToken(
                codePos,
                "Invalid escape sequence in template string"
              );
  
              return null
            }
          default:
            if (ch >= 48 && ch <= 55) {
              var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
              var octal = parseInt(octalStr, 8);
              if (octal > 255) {
                octalStr = octalStr.slice(0, -1);
                octal = parseInt(octalStr, 8);
              }
              this.pos += octalStr.length - 1;
              ch = this.input.charCodeAt(this.pos);
              if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
                this.invalidStringToken(
                  this.pos - 1 - octalStr.length,
                  inTemplate
                    ? "Octal literal in template string"
                    : "Octal literal in strict mode"
                );
              }
              return String.fromCharCode(octal)
            }
            if (isNewLine(ch)) {
              return ""
            }
            return String.fromCharCode(ch)
          }
        };
  
  
        pp$9.readHexChar = function(len) {
          var codePos = this.pos;
          var n = this.readInt(16, len);
          if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
          return n
        };
  
  
        pp$9.readWord1 = function() {
          this.containsEsc = false;
          var word = "", first = true, chunkStart = this.pos;
          var astral = this.options.ecmaVersion >= 6;
          while (this.pos < this.input.length) {
            var ch = this.fullCharCodeAtPos();
            if (isIdentifierChar(ch, astral)) {
              this.pos += ch <= 0xffff ? 1 : 2;
            } else if (ch === 92) { 
              this.containsEsc = true;
              word += this.input.slice(chunkStart, this.pos);
              var escStart = this.pos;
              if (this.input.charCodeAt(++this.pos) !== 117) 
                { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
              ++this.pos;
              var esc = this.readCodePoint();
              if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
                { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
              word += codePointToString$1(esc);
              chunkStart = this.pos;
            } else {
              break
            }
            first = false;
          }
          return word + this.input.slice(chunkStart, this.pos)
        };
  
  
        pp$9.readWord = function() {
          var word = this.readWord1();
          var type = types.name;
          if (this.keywords.test(word)) {
            type = keywords$1[word];
          }
          return this.finishToken(type, word)
        };
  
  
        var version = "7.1.0";
  
        Parser.acorn = {
          Parser: Parser,
          version: version,
          defaultOptions: defaultOptions,
          Position: Position,
          SourceLocation: SourceLocation,
          getLineInfo: getLineInfo,
          Node: Node,
          TokenType: TokenType,
          tokTypes: types,
          keywordTypes: keywords$1,
          TokContext: TokContext,
          tokContexts: types$1,
          isIdentifierChar: isIdentifierChar,
          isIdentifierStart: isIdentifierStart,
          Token: Token,
          isNewLine: isNewLine,
          lineBreak: lineBreak,
          lineBreakG: lineBreakG,
          nonASCIIwhitespace: nonASCIIwhitespace
        };
  
  
        function parse(input, options) {
          return Parser.parse(input, options)
        }
  
  
        function parseExpressionAt(input, pos, options) {
          return Parser.parseExpressionAt(input, pos, options)
        }
  
  
        function tokenizer(input, options) {
          return Parser.tokenizer(input, options)
        }
  
        exports.Node = Node;
        exports.Parser = Parser;
        exports.Position = Position;
        exports.SourceLocation = SourceLocation;
        exports.TokContext = TokContext;
        exports.Token = Token;
        exports.TokenType = TokenType;
        exports.defaultOptions = defaultOptions;
        exports.getLineInfo = getLineInfo;
        exports.isIdentifierChar = isIdentifierChar;
        exports.isIdentifierStart = isIdentifierStart;
        exports.isNewLine = isNewLine;
        exports.keywordTypes = keywords$1;
        exports.lineBreak = lineBreak;
        exports.lineBreakG = lineBreakG;
        exports.nonASCIIwhitespace = nonASCIIwhitespace;
        exports.parse = parse;
        exports.parseExpressionAt = parseExpressionAt;
        exports.tokContexts = types$1;
        exports.tokTypes = types;
        exports.tokenizer = tokenizer;
        exports.version = version;
  
        Object.defineProperty(exports, '__esModule', { value: true });
  
      }));
  
      },{}],2:[function(require,module,exports){
  
      },{}],3:[function(require,module,exports){
      function glWiretap(gl, options = {}) {
        const {
          contextName = 'gl',
          throwGetError,
          useTrackablePrimitives,
          readPixelsFile,
          recording = [],
          variables = {},
          onReadPixels,
          onUnrecognizedArgumentLookup,
        } = options;
        const proxy = new Proxy(gl, { get: listen });
        const contextVariables = [];
        const entityNames = {};
        let imageCount = 0;
        let indent = '';
        let readPixelsVariableName;
        return proxy;
        function listen(obj, property) {
          switch (property) {
            case 'addComment': return addComment;
            case 'checkThrowError': return checkThrowError;
            case 'getReadPixelsVariableName': return readPixelsVariableName;
            case 'insertVariable': return insertVariable;
            case 'reset': return reset;
            case 'setIndent': return setIndent;
            case 'toString': return toString;
            case 'getContextVariableName': return getContextVariableName;
          }
          if (typeof gl[property] === 'function') {
            return function() { 
              switch (property) {
                case 'getError':
                  if (throwGetError) {
                    recording.push(`${indent}if (${contextName}.getError() !== ${contextName}.NONE) throw new Error('error');`);
                  } else {
                    recording.push(`${indent}${contextName}.getError();`); 
                  }
                  return gl.getError();
                case 'getExtension': {
                  const variableName = `${contextName}Variables${contextVariables.length}`;
                  recording.push(`${indent}const ${variableName} = ${contextName}.getExtension('${arguments[0]}');`);
                  const extension = gl.getExtension(arguments[0]);
                  if (extension && typeof extension === 'object') {
                    const tappedExtension = glExtensionWiretap(extension, {
                      getEntity,
                      useTrackablePrimitives,
                      recording,
                      contextName: variableName,
                      contextVariables,
                      variables,
                      indent,
                      onUnrecognizedArgumentLookup,
                    });
                    contextVariables.push(tappedExtension);
                    return tappedExtension;
                  } else {
                    contextVariables.push(null);
                  }
                  return extension;
                }
                case 'readPixels':
                  const i = contextVariables.indexOf(arguments[6]);
                  let targetVariableName;
                  if (i === -1) {
                    const variableName = getVariableName(arguments[6]);
                    if (variableName) {
                      targetVariableName = variableName;
                      recording.push(`${indent}${variableName}`);
                    } else {
                      targetVariableName = `${contextName}Variable${contextVariables.length}`;
                      contextVariables.push(arguments[6]);
                      recording.push(`${indent}const ${targetVariableName} = new ${arguments[6].constructor.name}(${arguments[6].length});`);
                    }
                  } else {
                    targetVariableName = `${contextName}Variable${i}`;
                  }
                  readPixelsVariableName = targetVariableName;
                  const argumentAsStrings = [
                    arguments[0],
                    arguments[1],
                    arguments[2],
                    arguments[3],
                    getEntity(arguments[4]),
                    getEntity(arguments[5]),
                    targetVariableName
                  ];
                  recording.push(`${indent}${contextName}.readPixels(${argumentAsStrings.join(', ')});`);
                  if (readPixelsFile) {
                    writePPM(arguments[2], arguments[3]);
                  }
                  if (onReadPixels) {
                    onReadPixels(targetVariableName, argumentAsStrings);
                  }
                  return gl.readPixels.apply(gl, arguments);
                case 'drawBuffers':
                  recording.push(`${indent}${contextName}.drawBuffers([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup } )}]);`);
                  return gl.drawBuffers(arguments[0]);
              }
              let result = gl[property].apply(gl, arguments);
              switch (typeof result) {
                case 'undefined':
                  recording.push(`${indent}${methodCallToString(property, arguments)};`);
                  return;
                case 'number':
                case 'boolean':
                  if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {
                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
                    contextVariables.push(result = trackablePrimitive(result));
                    break;
                  }
                default:
                  if (result === null) {
                    recording.push(`${methodCallToString(property, arguments)};`);
                  } else {
                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
                  }
  
                  contextVariables.push(result);
              }
              return result;
            }
          }
          entityNames[gl[property]] = property;
          return gl[property];
        }
        function toString() {
          return recording.join('\n');
        }
        function reset() {
          while (recording.length > 0) {
            recording.pop();
          }
        }
        function insertVariable(name, value) {
          variables[name] = value;
        }
        function getEntity(value) {
          const name = entityNames[value];
          if (name) {
            return contextName + '.' + name;
          }
          return value;
        }
        function setIndent(spaces) {
          indent = ' '.repeat(spaces);
        }
        function addVariable(value, source) {
          const variableName = `${contextName}Variable${contextVariables.length}`;
          recording.push(`${indent}const ${variableName} = ${source};`);
          contextVariables.push(value);
          return variableName;
        }
        function writePPM(width, height) {
          const sourceVariable = `${contextName}Variable${contextVariables.length}`;
          const imageVariable = `imageDatum${imageCount}`;
          recording.push(`${indent}let ${imageVariable} = ["P3\\n# ${readPixelsFile}.ppm\\n", ${width}, ' ', ${height}, "\\n255\\n"].join("");`);
          recording.push(`${indent}for (let i = 0; i < ${imageVariable}.length; i += 4) {`);
          recording.push(`${indent}  ${imageVariable} += ${sourceVariable}[i] + ' ' + ${sourceVariable}[i + 1] + ' ' + ${sourceVariable}[i + 2] + ' ';`);
          recording.push(`${indent}}`);
          recording.push(`${indent}if (typeof require !== "undefined") {`);
          recording.push(`${indent}  require('fs').writeFileSync('./${readPixelsFile}.ppm', ${imageVariable});`);
          recording.push(`${indent}}`);
          imageCount++;
        }
        function addComment(value) {
          recording.push(`${indent}// ${value}`);
        }
        function checkThrowError() {
          recording.push(`${indent}(() => {
  ${indent}const error = ${contextName}.getError();
  ${indent}if (error !== ${contextName}.NONE) {
  ${indent}  const names = Object.getOwnPropertyNames(gl);
  ${indent}  for (let i = 0; i < names.length; i++) {
  ${indent}    const name = names[i];
  ${indent}    if (${contextName}[name] === error) {
  ${indent}      throw new Error('${contextName} threw ' + name);
  ${indent}    }
  ${indent}  }
  ${indent}}
  ${indent}})();`);
        }
        function methodCallToString(method, args) {
          return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;
        }
  
        function getVariableName(value) {
          if (variables) {
            for (const name in variables) {
              if (variables[name] === value) {
                return name;
              }
            }
          }
          return null;
        }
  
        function getContextVariableName(value) {
          const i = contextVariables.indexOf(value);
          if (i !== -1) {
            return `${contextName}Variable${i}`;
          }
          return null;
        }
      }
  
      function glExtensionWiretap(extension, options) {
        const proxy = new Proxy(extension, { get: listen });
        const extensionEntityNames = {};
        const {
          contextName,
          contextVariables,
          getEntity,
          useTrackablePrimitives,
          recording,
          variables,
          indent,
          onUnrecognizedArgumentLookup,
        } = options;
        return proxy;
        function listen(obj, property) {
          if (typeof obj[property] === 'function') {
            return function() {
              switch (property) {
                case 'drawBuffersWEBGL':
                  recording.push(`${indent}${contextName}.drawBuffersWEBGL([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })}]);`);
                  return extension.drawBuffersWEBGL(arguments[0]);
              }
              let result = extension[property].apply(extension, arguments);
              switch (typeof result) {
                case 'undefined':
                  recording.push(`${indent}${methodCallToString(property, arguments)};`);
                  return;
                case 'number':
                case 'boolean':
                  if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {
                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
                    contextVariables.push(result = trackablePrimitive(result));
                  } else {
                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
                    contextVariables.push(result);
                  }
                  break;
                default:
                  if (result === null) {
                    recording.push(`${methodCallToString(property, arguments)};`);
                  } else {
                    recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
                  }
                  contextVariables.push(result);
              }
              return result;
            };
          }
          extensionEntityNames[extension[property]] = property;
          return extension[property];
        }
  
        function getExtensionEntity(value) {
          if (extensionEntityNames.hasOwnProperty(value)) {
            return `${contextName}.${extensionEntityNames[value]}`;
          }
          return getEntity(value);
        }
  
        function methodCallToString(method, args) {
          return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;
        }
  
        function addVariable(value, source) {
          const variableName = `${contextName}Variable${contextVariables.length}`;
          contextVariables.push(value);
          recording.push(`${indent}const ${variableName} = ${source};`);
          return variableName;
        }
      }
  
      function argumentsToString(args, options) {
        const { variables, onUnrecognizedArgumentLookup } = options;
        return (Array.from(args).map((arg) => {
          const variableName = getVariableName(arg);
          if (variableName) {
            return variableName;
          }
          return argumentToString(arg, options);
        }).join(', '));
  
        function getVariableName(value) {
          if (variables) {
            for (const name in variables) {
              if (!variables.hasOwnProperty(name)) continue;
              if (variables[name] === value) {
                return name;
              }
            }
          }
          if (onUnrecognizedArgumentLookup) {
            return onUnrecognizedArgumentLookup(value);
          }
          return null;
        }
      }
  
      function argumentToString(arg, options) {
        const { contextName, contextVariables, getEntity, addVariable, onUnrecognizedArgumentLookup } = options;
        if (typeof arg === 'undefined') {
          return 'undefined';
        }
        if (arg === null) {
          return 'null';
        }
        const i = contextVariables.indexOf(arg);
        if (i > -1) {
          return `${contextName}Variable${i}`;
        }
        switch (arg.constructor.name) {
          case 'String':
            const hasLines = /\n/.test(arg);
            const hasSingleQuotes = /'/.test(arg);
            const hasDoubleQuotes = /"/.test(arg);
            if (hasLines) {
              return '`' + arg + '`';
            } else if (hasSingleQuotes && !hasDoubleQuotes) {
              return '"' + arg + '"';
            } else if (!hasSingleQuotes && hasDoubleQuotes) {
              return "'" + arg + "'";
            } else {
              return '\'' + arg + '\'';
            }
          case 'Number': return getEntity(arg);
          case 'Boolean': return getEntity(arg);
          case 'Array':
            return addVariable(arg, `new ${arg.constructor.name}([${Array.from(arg).join(',')}])`);
          case 'Float32Array':
          case 'Uint8Array':
          case 'Uint16Array':
          case 'Int32Array':
            return addVariable(arg, `new ${arg.constructor.name}(${JSON.stringify(Array.from(arg))})`);
          default:
            if (onUnrecognizedArgumentLookup) {
              const instantiationString = onUnrecognizedArgumentLookup(arg);
              if (instantiationString) {
                return instantiationString;
              }
            }
            throw new Error(`unrecognized argument type ${arg.constructor.name}`);
        }
      }
  
      function trackablePrimitive(value) {
        return new value.constructor(value);
      }
  
      if (typeof module !== 'undefined') {
        module.exports = { glWiretap, glExtensionWiretap };
      }
  
      if (typeof window !== 'undefined') {
        glWiretap.glExtensionWiretap = glExtensionWiretap;
        window.glWiretap = glWiretap;
      }
  
      },{}],4:[function(require,module,exports){
      function setupArguments(args) {
        const newArguments = new Array(args.length);
        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          if (arg.toArray) {
            newArguments[i] = arg.toArray();
          } else {
            newArguments[i] = arg;
          }
        }
        return newArguments;
      }
  
      function mock1D() {
        const args = setupArguments(arguments);
        const row = new Float32Array(this.output.x);
        for (let x = 0; x < this.output.x; x++) {
          this.thread.x = x;
          this.thread.y = 0;
          this.thread.z = 0;
          row[x] = this._fn.apply(this, args);
        }
        return row;
      }
  
      function mock2D() {
        const args = setupArguments(arguments);
        const matrix = new Array(this.output.y);
        for (let y = 0; y < this.output.y; y++) {
          const row = new Float32Array(this.output.x);
          for (let x = 0; x < this.output.x; x++) {
            this.thread.x = x;
            this.thread.y = y;
            this.thread.z = 0;
            row[x] = this._fn.apply(this, args);
          }
          matrix[y] = row;
        }
        return matrix;
      }
  
      function mock2DGraphical() {
        const args = setupArguments(arguments);
        for (let y = 0; y < this.output.y; y++) {
          for (let x = 0; x < this.output.x; x++) {
            this.thread.x = x;
            this.thread.y = y;
            this.thread.z = 0;
            this._fn.apply(this, args);
          }
        }
      }
  
      function mock3D() {
        const args = setupArguments(arguments);
        const cube = new Array(this.output.z);
        for (let z = 0; z < this.output.z; z++) {
          const matrix = new Array(this.output.y);
          for (let y = 0; y < this.output.y; y++) {
            const row = new Float32Array(this.output.x);
            for (let x = 0; x < this.output.x; x++) {
              this.thread.x = x;
              this.thread.y = y;
              this.thread.z = z;
              row[x] = this._fn.apply(this, args);
            }
            matrix[y] = row;
          }
          cube[z] = matrix;
        }
        return cube;
      }
  
      function apiDecorate(kernel) {
        kernel.setOutput = (output) => {
          kernel.output = setupOutput(output);
          if (kernel.graphical) {
            setupGraphical(kernel);
          }
        };
        kernel.toJSON = () => {
          throw new Error('Not usable with gpuMock');
        };
        kernel.setConstants = (flag) => {
          kernel.constants = flag;
          return kernel;
        };
        kernel.setGraphical = (flag) => {
          kernel.graphical = flag;
          return kernel;
        };
        kernel.setCanvas = (flag) => {
          kernel.canvas = flag;
          return kernel;
        };
        kernel.setContext = (flag) => {
          kernel.context = flag;
          return kernel;
        };
        kernel.destroy = () => {};
        kernel.validateSettings = () => {};
        if (kernel.graphical && kernel.output) {
          setupGraphical(kernel);
        }
        kernel.exec = function() {
          return new Promise((resolve, reject) => {
            try {
              resolve(kernel.apply(kernel, arguments));
            } catch(e) {
              reject(e);
            }
          });
        };
        kernel.getPixels = (flip) => {
          const {x, y} = kernel.output;
          return flip ? flipPixels(kernel._imageData.data, x, y) : kernel._imageData.data.slice(0);
        };
        kernel.color = function(r, g, b, a) {
          if (typeof a === 'undefined') {
            a = 1;
          }
  
          r = Math.floor(r * 255);
          g = Math.floor(g * 255);
          b = Math.floor(b * 255);
          a = Math.floor(a * 255);
  
          const width = kernel.output.x;
          const height = kernel.output.y;
  
          const x = kernel.thread.x;
          const y = height - kernel.thread.y - 1;
  
          const index = x + y * width;
  
          kernel._colorData[index * 4 + 0] = r;
          kernel._colorData[index * 4 + 1] = g;
          kernel._colorData[index * 4 + 2] = b;
          kernel._colorData[index * 4 + 3] = a;
        };
  
        const mockMethod = () => kernel;
        const methods = [
          'setWarnVarUsage',
          'setArgumentTypes',
          'setTactic',
          'setOptimizeFloatMemory',
          'setDebug',
          'setLoopMaxIterations',
          'setConstantTypes',
          'setFunctions',
          'setNativeFunctions',
          'setInjectedNative',
          'setPipeline',
          'setPrecision',
          'setOutputToTexture',
          'setImmutable',
          'setStrictIntegers',
          'setDynamicOutput',
          'setHardcodeConstants',
          'setDynamicArguments',
          'setUseLegacyEncoder',
          'setWarnVarUsage',
          'addSubKernel',
        ];
        for (let i = 0; i < methods.length; i++) {
          kernel[methods[i]] = mockMethod;
        }
        return kernel;
      }
  
      function setupGraphical(kernel) {
        const {x, y} = kernel.output;
        if (kernel.context && kernel.context.createImageData) {
          const data = new Uint8ClampedArray(x * y * 4);
          kernel._imageData = kernel.context.createImageData(x, y);
          kernel._colorData = data;
        } else {
          const data = new Uint8ClampedArray(x * y * 4);
          kernel._imageData = { data };
          kernel._colorData = data;
        }
      }
  
      function setupOutput(output) {
        let result = null;
        if (output.length) {
          if (output.length === 3) {
            const [x,y,z] = output;
            result = { x, y, z };
          } else if (output.length === 2) {
            const [x,y] = output;
            result = { x, y };
          } else {
            const [x] = output;
            result = { x };
          }
        } else {
          result = output;
        }
        return result;
      }
  
      function gpuMock(fn, settings = {}) {
        const output = settings.output ? setupOutput(settings.output) : null;
        function kernel() {
          if (kernel.output.z) {
            return mock3D.apply(kernel, arguments);
          } else if (kernel.output.y) {
            if (kernel.graphical) {
              return mock2DGraphical.apply(kernel, arguments);
            }
            return mock2D.apply(kernel, arguments);
          } else {
            return mock1D.apply(kernel, arguments);
          }
        }
        kernel._fn = fn;
        kernel.constants = settings.constants || null;
        kernel.context = settings.context || null;
        kernel.canvas = settings.canvas || null;
        kernel.graphical = settings.graphical || false;
        kernel._imageData = null;
        kernel._colorData = null;
        kernel.output = output;
        kernel.thread = {
          x: 0,
          y: 0,
          z: 0
        };
        return apiDecorate(kernel);
      }
  
      function flipPixels(pixels, width, height) {
        const halfHeight = height / 2 | 0; 
        const bytesPerRow = width * 4;
        const temp = new Uint8ClampedArray(width * 4);
        const result = pixels.slice(0);
        for (let y = 0; y < halfHeight; ++y) {
          const topOffset = y * bytesPerRow;
          const bottomOffset = (height - y - 1) * bytesPerRow;
  
          temp.set(result.subarray(topOffset, topOffset + bytesPerRow));
  
          result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
  
          result.set(temp, bottomOffset);
        }
        return result;
      }
  
      module.exports = {
        gpuMock
      };
  
      },{}],5:[function(require,module,exports){
      const { utils } = require('./utils');
  
      function alias(name, source) {
        const fnString = source.toString();
        return new Function(`return function ${ name } (${ utils.getArgumentNamesFromString(fnString).join(', ') }) {
    ${ utils.getFunctionBodyFromString(fnString) }
  }`)();
      }
  
      module.exports = {
        alias
      };
      },{"./utils":114}],6:[function(require,module,exports){
      const { FunctionNode } = require('../function-node');
  
      class CPUFunctionNode extends FunctionNode {
        astFunction(ast, retArr) {
  
          if (!this.isRootKernel) {
            retArr.push('function');
            retArr.push(' ');
            retArr.push(this.name);
            retArr.push('(');
  
            for (let i = 0; i < this.argumentNames.length; ++i) {
              const argumentName = this.argumentNames[i];
  
              if (i > 0) {
                retArr.push(', ');
              }
              retArr.push('user_');
              retArr.push(argumentName);
            }
  
            retArr.push(') {\n');
          }
  
          for (let i = 0; i < ast.body.body.length; ++i) {
            this.astGeneric(ast.body.body[i], retArr);
            retArr.push('\n');
          }
  
          if (!this.isRootKernel) {
            retArr.push('}\n');
          }
          return retArr;
        }
  
        astReturnStatement(ast, retArr) {
          const type = this.returnType || this.getType(ast.argument);
  
          if (!this.returnType) {
            this.returnType = type;
          }
  
          if (this.isRootKernel) {
            retArr.push(this.leadingReturnStatement);
            this.astGeneric(ast.argument, retArr);
            retArr.push(';\n');
            retArr.push(this.followingReturnStatement);
            retArr.push('continue;\n');
          } else if (this.isSubKernel) {
            retArr.push(`subKernelResult_${ this.name } = `);
            this.astGeneric(ast.argument, retArr);
            retArr.push(';');
            retArr.push(`return subKernelResult_${ this.name };`);
          } else {
            retArr.push('return ');
            this.astGeneric(ast.argument, retArr);
            retArr.push(';');
          }
          return retArr;
        }
  
        astLiteral(ast, retArr) {
  
          if (isNaN(ast.value)) {
            throw this.astErrorOutput(
              'Non-numeric literal not supported : ' + ast.value,
              ast
            );
          }
  
          retArr.push(ast.value);
  
          return retArr;
        }
  
        astBinaryExpression(ast, retArr) {
          retArr.push('(');
          this.astGeneric(ast.left, retArr);
          retArr.push(ast.operator);
          this.astGeneric(ast.right, retArr);
          retArr.push(')');
          return retArr;
        }
  
        astIdentifierExpression(idtNode, retArr) {
          if (idtNode.type !== 'Identifier') {
            throw this.astErrorOutput(
              'IdentifierExpression - not an Identifier',
              idtNode
            );
          }
  
          switch (idtNode.name) {
            case 'Infinity':
              retArr.push('Infinity');
              break;
            default:
              if (this.constants && this.constants.hasOwnProperty(idtNode.name)) {
                retArr.push('constants_' + idtNode.name);
              } else {
                retArr.push('user_' + idtNode.name);
              }
          }
  
          return retArr;
        }
  
        astForStatement(forNode, retArr) {
          if (forNode.type !== 'ForStatement') {
            throw this.astErrorOutput('Invalid for statement', forNode);
          }
  
          const initArr = [];
          const testArr = [];
          const updateArr = [];
          const bodyArr = [];
          let isSafe = null;
  
          if (forNode.init) {
            this.pushState('in-for-loop-init');
            this.astGeneric(forNode.init, initArr);
            for (let i = 0; i < initArr.length; i++) {
              if (initArr[i].includes && initArr[i].includes(',')) {
                isSafe = false;
              }
            }
            this.popState('in-for-loop-init');
          } else {
            isSafe = false;
          }
  
          if (forNode.test) {
            this.astGeneric(forNode.test, testArr);
          } else {
            isSafe = false;
          }
  
          if (forNode.update) {
            this.astGeneric(forNode.update, updateArr);
          } else {
            isSafe = false;
          }
  
          if (forNode.body) {
            this.pushState('loop-body');
            this.astGeneric(forNode.body, bodyArr);
            this.popState('loop-body');
          }
  
          if (isSafe === null) {
            isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
          }
  
          if (isSafe) {
            retArr.push(`for (${initArr.join('')};${testArr.join('')};${updateArr.join('')}){\n`);
            retArr.push(bodyArr.join(''));
            retArr.push('}\n');
          } else {
            const iVariableName = this.getInternalVariableName('safeI');
            if (initArr.length > 0) {
              retArr.push(initArr.join(''), ';\n');
            }
            retArr.push(`for (let ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
            if (testArr.length > 0) {
              retArr.push(`if (!${testArr.join('')}) break;\n`);
            }
            retArr.push(bodyArr.join(''));
            retArr.push(`\n${updateArr.join('')};`);
            retArr.push('}\n');
          }
          return retArr;
        }
  
        astWhileStatement(whileNode, retArr) {
          if (whileNode.type !== 'WhileStatement') {
            throw this.astErrorOutput(
              'Invalid while statement',
              whileNode
            );
          }
  
          retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
          retArr.push('if (');
          this.astGeneric(whileNode.test, retArr);
          retArr.push(') {\n');
          this.astGeneric(whileNode.body, retArr);
          retArr.push('} else {\n');
          retArr.push('break;\n');
          retArr.push('}\n');
          retArr.push('}\n');
  
          return retArr;
        }
  
        astDoWhileStatement(doWhileNode, retArr) {
          if (doWhileNode.type !== 'DoWhileStatement') {
            throw this.astErrorOutput(
              'Invalid while statement',
              doWhileNode
            );
          }
  
          retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
          this.astGeneric(doWhileNode.body, retArr);
          retArr.push('if (!');
          this.astGeneric(doWhileNode.test, retArr);
          retArr.push(') {\n');
          retArr.push('break;\n');
          retArr.push('}\n');
          retArr.push('}\n');
  
          return retArr;
  
        }
  
        astAssignmentExpression(assNode, retArr) {
          const declaration = this.getDeclaration(assNode.left);
          if (declaration && !declaration.assignable) {
            throw this.astErrorOutput(`Variable ${assNode.left.name} is not assignable here`, assNode);
          }
          this.astGeneric(assNode.left, retArr);
          retArr.push(assNode.operator);
          this.astGeneric(assNode.right, retArr);
          return retArr;
        }
  
        astBlockStatement(bNode, retArr) {
          if (this.isState('loop-body')) {
            this.pushState('block-body'); 
            for (let i = 0; i < bNode.body.length; i++) {
              this.astGeneric(bNode.body[i], retArr);
            }
            this.popState('block-body');
          } else {
            retArr.push('{\n');
            for (let i = 0; i < bNode.body.length; i++) {
              this.astGeneric(bNode.body[i], retArr);
            }
            retArr.push('}\n');
          }
          return retArr;
        }
  
        astVariableDeclaration(varDecNode, retArr) {
          retArr.push(`${varDecNode.kind} `);
          const { declarations } = varDecNode;
          for (let i = 0; i < declarations.length; i++) {
            if (i > 0) {
              retArr.push(',');
            }
            const declaration = declarations[i];
            const info = this.getDeclaration(declaration.id);
            if (!info.valueType) {
              info.valueType = this.getType(declaration.init);
            }
            this.astGeneric(declaration, retArr);
          }
          if (!this.isState('in-for-loop-init')) {
            retArr.push(';');
          }
          return retArr;
        }
  
        astIfStatement(ifNode, retArr) {
          retArr.push('if (');
          this.astGeneric(ifNode.test, retArr);
          retArr.push(')');
          if (ifNode.consequent.type === 'BlockStatement') {
            this.astGeneric(ifNode.consequent, retArr);
          } else {
            retArr.push(' {\n');
            this.astGeneric(ifNode.consequent, retArr);
            retArr.push('\n}\n');
          }
  
          if (ifNode.alternate) {
            retArr.push('else ');
            if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {
              this.astGeneric(ifNode.alternate, retArr);
            } else {
              retArr.push(' {\n');
              this.astGeneric(ifNode.alternate, retArr);
              retArr.push('\n}\n');
            }
          }
          return retArr;
  
        }
  
        astSwitchStatement(ast, retArr) {
          const { discriminant, cases } = ast;
          retArr.push('switch (');
          this.astGeneric(discriminant, retArr);
          retArr.push(') {\n');
          for (let i = 0; i < cases.length; i++) {
            if (cases[i].test === null) {
              retArr.push('default:\n');
              this.astGeneric(cases[i].consequent, retArr);
              if (cases[i].consequent && cases[i].consequent.length > 0) {
                retArr.push('break;\n');
              }
              continue;
            }
            retArr.push('case ');
            this.astGeneric(cases[i].test, retArr);
            retArr.push(':\n');
            if (cases[i].consequent && cases[i].consequent.length > 0) {
              this.astGeneric(cases[i].consequent, retArr);
              retArr.push('break;\n');
            }
          }
          retArr.push('\n}');
        }
  
        astThisExpression(tNode, retArr) {
          retArr.push('_this');
          return retArr;
        }
  
        astMemberExpression(mNode, retArr) {
          const {
            signature,
            type,
            property,
            xProperty,
            yProperty,
            zProperty,
            name,
            origin
          } = this.getMemberExpressionDetails(mNode);
          switch (signature) {
            case 'this.thread.value':
              retArr.push(`_this.thread.${ name }`);
              return retArr;
            case 'this.output.value':
              switch (name) {
                case 'x':
                  retArr.push('outputX');
                  break;
                case 'y':
                  retArr.push('outputY');
                  break;
                case 'z':
                  retArr.push('outputZ');
                  break;
                default:
                  throw this.astErrorOutput('Unexpected expression', mNode);
              }
              return retArr;
            case 'value':
              throw this.astErrorOutput('Unexpected expression', mNode);
            case 'value[]':
            case 'value[][]':
            case 'value[][][]':
            case 'value.value':
              if (origin === 'Math') {
                retArr.push(Math[name]);
                return retArr;
              }
              switch (property) {
                case 'r':
                  retArr.push(`user_${ name }[0]`);
                  return retArr;
                case 'g':
                  retArr.push(`user_${ name }[1]`);
                  return retArr;
                case 'b':
                  retArr.push(`user_${ name }[2]`);
                  return retArr;
                case 'a':
                  retArr.push(`user_${ name }[3]`);
                  return retArr;
              }
              break;
            case 'this.constants.value':
            case 'this.constants.value[]':
            case 'this.constants.value[][]':
            case 'this.constants.value[][][]':
              break;
            case 'fn()[]':
              this.astGeneric(mNode.object, retArr);
              retArr.push('[');
              this.astGeneric(mNode.property, retArr);
              retArr.push(']');
              return retArr;
            case 'fn()[][]':
              this.astGeneric(mNode.object.object, retArr);
              retArr.push('[');
              this.astGeneric(mNode.object.property, retArr);
              retArr.push(']');
              retArr.push('[');
              this.astGeneric(mNode.property, retArr);
              retArr.push(']');
              return retArr;
            default:
              throw this.astErrorOutput('Unexpected expression', mNode);
          }
  
          if (!mNode.computed) {
            switch (type) {
              case 'Number':
              case 'Integer':
              case 'Float':
              case 'Boolean':
                retArr.push(`${origin}_${name}`);
                return retArr;
            }
          }
  
          const markupName = `${origin}_${name}`;
  
          switch (type) {
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
            case 'Matrix(2)':
            case 'Matrix(3)':
            case 'Matrix(4)':
            case 'HTMLImageArray':
            case 'ArrayTexture(1)':
            case 'ArrayTexture(2)':
            case 'ArrayTexture(3)':
            case 'ArrayTexture(4)':
            case 'HTMLImage':
            default:
              let size;
              let isInput;
              if (origin === 'constants') {
                const constant = this.constants[name];
                isInput = this.constantTypes[name] === 'Input';
                size = isInput ? constant.size : null;
              } else {
                isInput = this.isInput(name);
                size = isInput ? this.argumentSizes[this.argumentNames.indexOf(name)] : null;
              }
              retArr.push(`${ markupName }`);
              if (zProperty && yProperty) {
                if (isInput) {
                  retArr.push('[(');
                  this.astGeneric(zProperty, retArr);
                  retArr.push(`*${ this.dynamicArguments ? '(outputY * outputX)' : size[1] * size[0] })+(`);
                  this.astGeneric(yProperty, retArr);
                  retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);
                  this.astGeneric(xProperty, retArr);
                  retArr.push(']');
                } else {
                  retArr.push('[');
                  this.astGeneric(zProperty, retArr);
                  retArr.push(']');
                  retArr.push('[');
                  this.astGeneric(yProperty, retArr);
                  retArr.push(']');
                  retArr.push('[');
                  this.astGeneric(xProperty, retArr);
                  retArr.push(']');
                }
              } else if (yProperty) {
                if (isInput) {
                  retArr.push('[(');
                  this.astGeneric(yProperty, retArr);
                  retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);
                  this.astGeneric(xProperty, retArr);
                  retArr.push(']');
                } else {
                  retArr.push('[');
                  this.astGeneric(yProperty, retArr);
                  retArr.push(']');
                  retArr.push('[');
                  this.astGeneric(xProperty, retArr);
                  retArr.push(']');
                }
              } else if (typeof xProperty !== 'undefined') {
                retArr.push('[');
                this.astGeneric(xProperty, retArr);
                retArr.push(']');
              }
          }
          return retArr;
        }
  
        astCallExpression(ast, retArr) {
          if (ast.type !== 'CallExpression') {
            throw this.astErrorOutput('Unknown CallExpression', ast);
          }
          let functionName = this.astMemberExpressionUnroll(ast.callee);
  
          if (this.calledFunctions.indexOf(functionName) < 0) {
            this.calledFunctions.push(functionName);
          }
  
          this.isAstMathFunction(ast);
  
          if (this.onFunctionCall) {
            this.onFunctionCall(this.name, functionName, ast.arguments);
          }
  
          retArr.push(functionName);
  
          retArr.push('(');
          const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];
          for (let i = 0; i < ast.arguments.length; ++i) {
            const argument = ast.arguments[i];
  
            let argumentType = this.getType(argument);
            if (!targetTypes[i]) {
              this.triggerImplyArgumentType(functionName, i, argumentType, this);
            }
  
            if (i > 0) {
              retArr.push(', ');
            }
            this.astGeneric(argument, retArr);
          }
          retArr.push(')');
  
          return retArr;
        }
  
        astArrayExpression(arrNode, retArr) {
          const returnType = this.getType(arrNode);
          const arrLen = arrNode.elements.length;
          const elements = [];
          for (let i = 0; i < arrLen; ++i) {
            const element = [];
            this.astGeneric(arrNode.elements[i], element);
            elements.push(element.join(''));
          }
          switch (returnType) {
            case 'Matrix(2)':
            case 'Matrix(3)':
            case 'Matrix(4)':
              retArr.push(`[${elements.join(', ')}]`);
              break;
            default:
              retArr.push(`new Float32Array([${elements.join(', ')}])`);
          }
          return retArr;
        }
  
        astDebuggerStatement(arrNode, retArr) {
          retArr.push('debugger;');
          return retArr;
        }
      }
  
      module.exports = {
        CPUFunctionNode
      };
      },{"../function-node":10}],7:[function(require,module,exports){
      const { utils } = require('../../utils');
  
      function constantsToString(constants, types) {
        const results = [];
        for (const name in types) {
          if (!types.hasOwnProperty(name)) continue;
          const type = types[name];
          const constant = constants[name];
          switch (type) {
            case 'Number':
            case 'Integer':
            case 'Float':
            case 'Boolean':
              results.push(`${name}:${constant}`);
              break;
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
            case 'Matrix(2)':
            case 'Matrix(3)':
            case 'Matrix(4)':
              results.push(`${name}:new ${constant.constructor.name}(${JSON.stringify(Array.from(constant))})`);
              break;
          }
        }
        return `{ ${ results.join() } }`;
      }
  
      function cpuKernelString(cpuKernel, name) {
        const header = [];
        const thisProperties = [];
        const beforeReturn = [];
  
        const useFunctionKeyword = !/^function/.test(cpuKernel.color.toString());
  
        header.push(
          '  const { context, canvas, constants: incomingConstants } = settings;',
          `  const output = new Int32Array(${JSON.stringify(Array.from(cpuKernel.output))});`,
          `  const _constantTypes = ${JSON.stringify(cpuKernel.constantTypes)};`,
          `  const _constants = ${constantsToString(cpuKernel.constants, cpuKernel.constantTypes)};`
        );
  
        thisProperties.push(
          '    constants: _constants,',
          '    context,',
          '    output,',
          '    thread: {x: 0, y: 0, z: 0},'
        );
  
        if (cpuKernel.graphical) {
          header.push(`  const _imageData = context.createImageData(${cpuKernel.output[0]}, ${cpuKernel.output[1]});`);
          header.push(`  const _colorData = new Uint8ClampedArray(${cpuKernel.output[0]} * ${cpuKernel.output[1]} * 4);`);
  
          const colorFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.color.toString(), {
            thisLookup: (propertyName) => {
              switch (propertyName) {
                case '_colorData':
                  return '_colorData';
                case '_imageData':
                  return '_imageData';
                case 'output':
                  return 'output';
                case 'thread':
                  return 'this.thread';
              }
              return JSON.stringify(cpuKernel[propertyName]);
            },
            findDependency: (object, name) => {
              return null;
            }
          });
  
          const getPixelsFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.getPixels.toString(), {
            thisLookup: (propertyName) => {
              switch (propertyName) {
                case '_colorData':
                  return '_colorData';
                case '_imageData':
                  return '_imageData';
                case 'output':
                  return 'output';
                case 'thread':
                  return 'this.thread';
              }
              return JSON.stringify(cpuKernel[propertyName]);
            },
            findDependency: () => {
              return null;
            }
          });
  
          thisProperties.push(
            '    _imageData,',
            '    _colorData,',
            `    color: ${colorFn},`
          );
  
          beforeReturn.push(
            `  kernel.getPixels = ${getPixelsFn};`
          );
        }
  
        const constantTypes = [];
        const constantKeys = Object.keys(cpuKernel.constantTypes);
        for (let i = 0; i < constantKeys.length; i++) {
          constantTypes.push(cpuKernel.constantTypes[constantKeys]);
        }
        if (cpuKernel.argumentTypes.indexOf('HTMLImageArray') !== -1 || constantTypes.indexOf('HTMLImageArray') !== -1) {
          const flattenedImageTo3DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._imageTo3DArray.toString(), {
            doNotDefine: ['canvas'],
            findDependency: (object, name) => {
              if (object === 'this') {
                return (useFunctionKeyword ? 'function ' : '') + cpuKernel[name].toString();
              }
              return null;
            },
            thisLookup: (propertyName) => {
              switch (propertyName) {
                case 'canvas':
                  return;
                case 'context':
                  return 'context';
              }
            }
          });
          beforeReturn.push(flattenedImageTo3DArray);
          thisProperties.push(`    _mediaTo2DArray,`);
          thisProperties.push(`    _imageTo3DArray,`);
        } else if (cpuKernel.argumentTypes.indexOf('HTMLImage') !== -1 || constantTypes.indexOf('HTMLImage') !== -1) {
          const flattenedImageTo2DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._mediaTo2DArray.toString(), {
            findDependency: (object, name) => {
              return null;
            },
            thisLookup: (propertyName) => {
              switch (propertyName) {
                case 'canvas':
                  return 'settings.canvas';
                case 'context':
                  return 'settings.context';
              }
              throw new Error('unhandled thisLookup');
            }
          });
          beforeReturn.push(flattenedImageTo2DArray);
          thisProperties.push(`    _mediaTo2DArray,`);
        }
  
        return `function(settings) {
  ${ header.join('\n') }
    for (const p in _constantTypes) {
      if (!_constantTypes.hasOwnProperty(p)) continue;
      const type = _constantTypes[p];
      switch (type) {
        case 'Number':
        case 'Integer':
        case 'Float':
        case 'Boolean':
        case 'Array(2)':
        case 'Array(3)':
        case 'Array(4)':
        case 'Matrix(2)':
        case 'Matrix(3)':
        case 'Matrix(4)':
          if (incomingConstants.hasOwnProperty(p)) {
            console.warn('constant ' + p + ' of type ' + type + ' cannot be resigned');
          }
          continue;
      }
      if (!incomingConstants.hasOwnProperty(p)) {
        throw new Error('constant ' + p + ' not found');
      }
      _constants[p] = incomingConstants[p];
    }
    const kernel = (function() {
  ${cpuKernel._kernelString}
    })
      .apply({ ${thisProperties.join('\n')} });
    ${ beforeReturn.join('\n') }
    return kernel;
  }`;
      }
  
      module.exports = {
        cpuKernelString
      };
      },{"../../utils":114}],8:[function(require,module,exports){
      const { Kernel } = require('../kernel');
      const { FunctionBuilder } = require('../function-builder');
      const { CPUFunctionNode } = require('./function-node');
      const { utils } = require('../../utils');
      const { cpuKernelString } = require('./kernel-string');
  
      class CPUKernel extends Kernel {
        static getFeatures() {
          return this.features;
        }
        static get features() {
          return Object.freeze({
            kernelMap: true,
            isIntegerDivisionAccurate: true
          });
        }
        static get isSupported() {
          return true;
        }
        static isContextMatch(context) {
          return false;
        }
        static get mode() {
          return 'cpu';
        }
  
        static nativeFunctionArguments() {
          return null;
        }
  
        static nativeFunctionReturnType() {
          throw new Error(`Looking up native function return type not supported on ${this.name}`);
        }
  
        static combineKernels(combinedKernel) {
          return combinedKernel;
        }
  
        static getSignature(kernel, argumentTypes) {
          return 'cpu' + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');
        }
  
        constructor(source, settings) {
          super(source, settings);
          this.mergeSettings(source.settings || settings);
  
          this._imageData = null;
          this._colorData = null;
          this._kernelString = null;
          this._prependedString = [];
          this.thread = {
            x: 0,
            y: 0,
            z: 0
          };
          this.translatedSources = null;
        }
  
        initCanvas() {
          if (typeof document !== 'undefined') {
            return document.createElement('canvas');
          } else if (typeof OffscreenCanvas !== 'undefined') {
            return new OffscreenCanvas(0, 0);
          }
        }
  
        initContext() {
          if (!this.canvas) return null;
          return this.canvas.getContext('2d');
        }
  
        initPlugins(settings) {
          return [];
        }
  
        validateSettings(args) {
          if (!this.output || this.output.length === 0) {
            if (args.length !== 1) {
              throw new Error('Auto output only supported for kernels with only one input');
            }
  
            const argType = utils.getVariableType(args[0], this.strictIntegers);
            if (argType === 'Array') {
              this.output = utils.getDimensions(argType);
            } else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {
              this.output = args[0].output;
            } else {
              throw new Error('Auto output not supported for input type: ' + argType);
            }
          }
  
          if (this.graphical) {
            if (this.output.length !== 2) {
              throw new Error('Output must have 2 dimensions on graphical mode');
            }
          }
  
          this.checkOutput();
        }
  
        translateSource() {
          this.leadingReturnStatement = this.output.length > 1 ? 'resultX[x] = ' : 'result[x] = ';
          if (this.subKernels) {
            const followingReturnStatement = [];
            for (let i = 0; i < this.subKernels.length; i++) {
              const {
                name
              } = this.subKernels[i];
              followingReturnStatement.push(this.output.length > 1 ? `resultX_${ name }[x] = subKernelResult_${ name };\n` : `result_${ name }[x] = subKernelResult_${ name };\n`);
            }
            this.followingReturnStatement = followingReturnStatement.join('');
          }
          const functionBuilder = FunctionBuilder.fromKernel(this, CPUFunctionNode);
          this.translatedSources = functionBuilder.getPrototypes('kernel');
          if (!this.graphical && !this.returnType) {
            this.returnType = functionBuilder.getKernelResultType();
          }
        }
  
        build() {
          if (this.built) return;
          this.setupConstants();
          this.setupArguments(arguments);
          this.validateSettings(arguments);
          this.translateSource();
  
          if (this.graphical) {
            const {
              canvas,
              output
            } = this;
            if (!canvas) {
              throw new Error('no canvas available for using graphical output');
            }
            const width = output[0];
            const height = output[1] || 1;
            canvas.width = width;
            canvas.height = height;
            this._imageData = this.context.createImageData(width, height);
            this._colorData = new Uint8ClampedArray(width * height * 4);
          }
  
          const kernelString = this.getKernelString();
          this.kernelString = kernelString;
  
          if (this.debug) {
            console.log('Function output:');
            console.log(kernelString);
          }
  
          try {
            this.run = new Function([], kernelString).bind(this)();
          } catch (e) {
            console.error('An error occurred compiling the javascript: ', e);
          }
          this.buildSignature(arguments);
          this.built = true;
        }
  
        color(r, g, b, a) {
          if (typeof a === 'undefined') {
            a = 1;
          }
  
          r = Math.floor(r * 255);
          g = Math.floor(g * 255);
          b = Math.floor(b * 255);
          a = Math.floor(a * 255);
  
          const width = this.output[0];
          const height = this.output[1];
  
          const x = this.thread.x;
          const y = height - this.thread.y - 1;
  
          const index = x + y * width;
  
          this._colorData[index * 4 + 0] = r;
          this._colorData[index * 4 + 1] = g;
          this._colorData[index * 4 + 2] = b;
          this._colorData[index * 4 + 3] = a;
        }
  
        getKernelString() {
          if (this._kernelString !== null) return this._kernelString;
  
          let kernelThreadString = null;
          let {
            translatedSources
          } = this;
          if (translatedSources.length > 1) {
            translatedSources = translatedSources.filter(fn => {
              if (/^function/.test(fn)) return fn;
              kernelThreadString = fn;
              return false;
            });
          } else {
            kernelThreadString = translatedSources.shift();
          }
          return this._kernelString = `  const LOOP_MAX = ${ this._getLoopMaxString() };
    ${ this.injectedNative || '' }
    const _this = this;
    ${ this._resultKernelHeader() }
    ${ this._processConstants() }
    return (${ this.argumentNames.map(argumentName => 'user_' + argumentName).join(', ') }) => {
      ${ this._prependedString.join('') }
      ${ this._earlyThrows() }
      ${ this._processArguments() }
      ${ this.graphical ? this._graphicalKernelBody(kernelThreadString) : this._resultKernelBody(kernelThreadString) }
      ${ translatedSources.length > 0 ? translatedSources.join('\n') : '' }
    };`;
        }
  
        toString() {
          return cpuKernelString(this);
        }
  
        _getLoopMaxString() {
          return (
            this.loopMaxIterations ?
            ` ${ parseInt(this.loopMaxIterations) };` :
            ' 1000;'
          );
        }
  
        _processConstants() {
          if (!this.constants) return '';
  
          const result = [];
          for (let p in this.constants) {
            const type = this.constantTypes[p];
            switch (type) {
              case 'HTMLCanvas':
              case 'OffscreenCanvas':
              case 'HTMLImage':
              case 'ImageBitmap':
              case 'ImageData':
              case 'HTMLVideo':
                result.push(`    const constants_${p} = this._mediaTo2DArray(this.constants.${p});\n`);
                break;
              case 'HTMLImageArray':
                result.push(`    const constants_${p} = this._imageTo3DArray(this.constants.${p});\n`);
                break;
              case 'Input':
                result.push(`    const constants_${p} = this.constants.${p}.value;\n`);
                break;
              default:
                result.push(`    const constants_${p} = this.constants.${p};\n`);
            }
          }
          return result.join('');
        }
  
        _earlyThrows() {
          if (this.graphical) return '';
          if (this.immutable) return '';
          if (!this.pipeline) return '';
          const arrayArguments = [];
          for (let i = 0; i < this.argumentTypes.length; i++) {
            if (this.argumentTypes[i] === 'Array') {
              arrayArguments.push(this.argumentNames[i]);
            }
          }
          if (arrayArguments.length === 0) return '';
          const checks = [];
          for (let i = 0; i < arrayArguments.length; i++) {
            const argumentName = arrayArguments[i];
            const checkSubKernels = this._mapSubKernels(subKernel => `user_${argumentName} === result_${subKernel.name}`).join(' || ');
            checks.push(`user_${argumentName} === result${checkSubKernels ? ` || ${checkSubKernels}` : ''}`);
          }
          return `if (${checks.join(' || ')}) throw new Error('Source and destination arrays are the same.  Use immutable = true');`;
        }
  
        _processArguments() {
          const result = [];
          for (let i = 0; i < this.argumentTypes.length; i++) {
            const variableName = `user_${this.argumentNames[i]}`;
            switch (this.argumentTypes[i]) {
              case 'HTMLCanvas':
              case 'OffscreenCanvas':
              case 'HTMLImage':
              case 'ImageBitmap':
              case 'ImageData':
              case 'HTMLVideo':
                result.push(`    ${variableName} = this._mediaTo2DArray(${variableName});\n`);
                break;
              case 'HTMLImageArray':
                result.push(`    ${variableName} = this._imageTo3DArray(${variableName});\n`);
                break;
              case 'Input':
                result.push(`    ${variableName} = ${variableName}.value;\n`);
                break;
              case 'ArrayTexture(1)':
              case 'ArrayTexture(2)':
              case 'ArrayTexture(3)':
              case 'ArrayTexture(4)':
              case 'NumberTexture':
              case 'MemoryOptimizedNumberTexture':
                result.push(`
      if (${variableName}.toArray) {
        if (!_this.textureCache) {
          _this.textureCache = [];
          _this.arrayCache = [];
        }
        const textureIndex = _this.textureCache.indexOf(${variableName});
        if (textureIndex !== -1) {
          ${variableName} = _this.arrayCache[textureIndex];
        } else {
          _this.textureCache.push(${variableName});
          ${variableName} = ${variableName}.toArray();
          _this.arrayCache.push(${variableName});
        }
      }`);
                break;
            }
          }
          return result.join('');
        }
  
        _mediaTo2DArray(media) {
          const canvas = this.canvas;
          const width = media.width > 0 ? media.width : media.videoWidth;
          const height = media.height > 0 ? media.height : media.videoHeight;
          if (canvas.width < width) {
            canvas.width = width;
          }
          if (canvas.height < height) {
            canvas.height = height;
          }
          const ctx = this.context;
          let pixelsData;
          if (media.constructor === ImageData) {
            pixelsData = media.data;
          } else {
            ctx.drawImage(media, 0, 0, width, height);
            pixelsData = ctx.getImageData(0, 0, width, height).data;
          }
          const imageArray = new Array(height);
          let index = 0;
          for (let y = height - 1; y >= 0; y--) {
            const row = imageArray[y] = new Array(width);
            for (let x = 0; x < width; x++) {
              const pixel = new Float32Array(4);
              pixel[0] = pixelsData[index++] / 255; 
              pixel[1] = pixelsData[index++] / 255; 
              pixel[2] = pixelsData[index++] / 255; 
              pixel[3] = pixelsData[index++] / 255; 
              row[x] = pixel;
            }
          }
          return imageArray;
        }
  
        getPixels(flip) {
          const [width, height] = this.output;
          return flip ? utils.flipPixels(this._imageData.data, width, height) : this._imageData.data.slice(0);
        }
  
        _imageTo3DArray(images) {
          const imagesArray = new Array(images.length);
          for (let i = 0; i < images.length; i++) {
            imagesArray[i] = this._mediaTo2DArray(images[i]);
          }
          return imagesArray;
        }
  
        _resultKernelHeader() {
          if (this.graphical) return '';
          if (this.immutable) return '';
          if (!this.pipeline) return '';
          switch (this.output.length) {
            case 1:
              return this._mutableKernel1DResults();
            case 2:
              return this._mutableKernel2DResults();
            case 3:
              return this._mutableKernel3DResults();
          }
        }
  
        _resultKernelBody(kernelString) {
          switch (this.output.length) {
            case 1:
              return (!this.immutable && this.pipeline ? this._resultMutableKernel1DLoop(kernelString) : this._resultImmutableKernel1DLoop(kernelString)) + this._kernelOutput();
            case 2:
              return (!this.immutable && this.pipeline ? this._resultMutableKernel2DLoop(kernelString) : this._resultImmutableKernel2DLoop(kernelString)) + this._kernelOutput();
            case 3:
              return (!this.immutable && this.pipeline ? this._resultMutableKernel3DLoop(kernelString) : this._resultImmutableKernel3DLoop(kernelString)) + this._kernelOutput();
            default:
              throw new Error('unsupported size kernel');
          }
        }
  
        _graphicalKernelBody(kernelThreadString) {
          switch (this.output.length) {
            case 2:
              return this._graphicalKernel2DLoop(kernelThreadString) + this._graphicalOutput();
            default:
              throw new Error('unsupported size kernel');
          }
        }
  
        _graphicalOutput() {
          return `
      this._imageData.data.set(this._colorData);
      this.context.putImageData(this._imageData, 0, 0);
      return;`
        }
  
        _getKernelResultTypeConstructorString() {
          switch (this.returnType) {
            case 'LiteralInteger':
            case 'Number':
            case 'Integer':
            case 'Float':
              return 'Float32Array';
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              return 'Array';
            default:
              if (this.graphical) {
                return 'Float32Array';
              }
              throw new Error(`unhandled returnType ${ this.returnType }`);
          }
        }
  
        _resultImmutableKernel1DLoop(kernelString) {
          const constructorString = this._getKernelResultTypeConstructorString();
          return `  const outputX = _this.output[0];
      const result = new ${constructorString}(outputX);
      ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\n`).join('    ') }
      ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        this.thread.y = 0;
        this.thread.z = 0;
        ${ kernelString }
      }`;
        }
  
        _mutableKernel1DResults() {
          const constructorString = this._getKernelResultTypeConstructorString();
          return `  const outputX = _this.output[0];
      const result = new ${constructorString}(outputX);
      ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\n`).join('    ') }
      ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }`;
        }
  
        _resultMutableKernel1DLoop(kernelString) {
          return `  const outputX = _this.output[0];
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        this.thread.y = 0;
        this.thread.z = 0;
        ${ kernelString }
      }`;
        }
  
        _resultImmutableKernel2DLoop(kernelString) {
          const constructorString = this._getKernelResultTypeConstructorString();
          return `  const outputX = _this.output[0];
      const outputY = _this.output[1];
      const result = new Array(outputY);
      ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\n`).join('    ') }
      ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
      for (let y = 0; y < outputY; y++) {
        this.thread.z = 0;
        this.thread.y = y;
        const resultX = result[y] = new ${constructorString}(outputX);
        ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${ kernelString }
        }
      }`;
        }
  
        _mutableKernel2DResults() {
          const constructorString = this._getKernelResultTypeConstructorString();
          return `  const outputX = _this.output[0];
      const outputY = _this.output[1];
      const result = new Array(outputY);
      ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\n`).join('    ') }
      ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
      for (let y = 0; y < outputY; y++) {
        const resultX = result[y] = new ${constructorString}(outputX);
        ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
      }`;
        }
  
        _resultMutableKernel2DLoop(kernelString) {
          const constructorString = this._getKernelResultTypeConstructorString();
          return `  const outputX = _this.output[0];
      const outputY = _this.output[1];
      for (let y = 0; y < outputY; y++) {
        this.thread.z = 0;
        this.thread.y = y;
        const resultX = result[y];
        ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${ kernelString }
        }
      }`;
        }
  
        _graphicalKernel2DLoop(kernelString) {
          return `  const outputX = _this.output[0];
      const outputY = _this.output[1];
      for (let y = 0; y < outputY; y++) {
        this.thread.z = 0;
        this.thread.y = y;
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${ kernelString }
        }
      }`;
        }
  
        _resultImmutableKernel3DLoop(kernelString) {
          const constructorString = this._getKernelResultTypeConstructorString();
          return `  const outputX = _this.output[0];
      const outputY = _this.output[1];
      const outputZ = _this.output[2];
      const result = new Array(outputZ);
      ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\n`).join('    ') }
      ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
      for (let z = 0; z < outputZ; z++) {
        this.thread.z = z;
        const resultY = result[z] = new Array(outputY);
        ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\n`).join('      ') }
        for (let y = 0; y < outputY; y++) {
          this.thread.y = y;
          const resultX = resultY[y] = new ${constructorString}(outputX);
          ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('        ') }
          for (let x = 0; x < outputX; x++) {
            this.thread.x = x;
            ${ kernelString }
          }
        }
      }`;
        }
  
        _mutableKernel3DResults() {
          const constructorString = this._getKernelResultTypeConstructorString();
          return `  const outputX = _this.output[0];
      const outputY = _this.output[1];
      const outputZ = _this.output[2];
      const result = new Array(outputZ);
      ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\n`).join('    ') }
      ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
      for (let z = 0; z < outputZ; z++) {
        const resultY = result[z] = new Array(outputY);
        ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\n`).join('      ') }
        for (let y = 0; y < outputY; y++) {
          const resultX = resultY[y] = new ${constructorString}(outputX);
          ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('        ') }
        }
      }`;
        }
  
        _resultMutableKernel3DLoop(kernelString) {
          return `  const outputX = _this.output[0];
      const outputY = _this.output[1];
      const outputZ = _this.output[2];
      for (let z = 0; z < outputZ; z++) {
        this.thread.z = z;
        const resultY = result[z];
        for (let y = 0; y < outputY; y++) {
          this.thread.y = y;
          const resultX = resultY[y];
          for (let x = 0; x < outputX; x++) {
            this.thread.x = x;
            ${ kernelString }
          }
        }
      }`;
        }
  
        _kernelOutput() {
          if (!this.subKernels) {
            return '\n    return result;';
          }
          return `\n    return {
        result: result,
        ${ this.subKernels.map(subKernel => `${ subKernel.property }: result_${ subKernel.name }`).join(',\n      ') }
      };`;
        }
  
        _mapSubKernels(fn) {
          return this.subKernels === null ? [''] :
            this.subKernels.map(fn);
        }
  
        destroy(removeCanvasReference) {
          if (removeCanvasReference) {
            delete this.canvas;
          }
        }
  
        static destroyContext(context) {}
  
        toJSON() {
          const json = super.toJSON();
          json.functionNodes = FunctionBuilder.fromKernel(this, CPUFunctionNode).toJSON();
          return json;
        }
  
        setOutput(output) {
          super.setOutput(output);
          const [width, height] = this.output;
          if (this.graphical) {
            this._imageData = this.context.createImageData(width, height);
            this._colorData = new Uint8ClampedArray(width * height * 4);
          }
        }
  
        prependString(value) {
          if (this._kernelString) throw new Error('Kernel already built');
          this._prependedString.push(value);
        }
  
        hasPrependString(value) {
          return this._prependedString.indexOf(value) > -1;
        }
      }
  
      module.exports = {
        CPUKernel
      };
      },{"../../utils":114,"../function-builder":9,"../kernel":36,"./function-node":6,"./kernel-string":7}],9:[function(require,module,exports){
      class FunctionBuilder {
        static fromKernel(kernel, FunctionNode, extraNodeOptions) {
          const {
            kernelArguments,
            kernelConstants,
            argumentNames,
            argumentSizes,
            argumentBitRatios,
            constants,
            constantBitRatios,
            debug,
            loopMaxIterations,
            nativeFunctions,
            output,
            optimizeFloatMemory,
            precision,
            plugins,
            source,
            subKernels,
            functions,
            leadingReturnStatement,
            followingReturnStatement,
            dynamicArguments,
            dynamicOutput,
          } = kernel;
  
          const argumentTypes = new Array(kernelArguments.length);
          const constantTypes = {};
  
          for (let i = 0; i < kernelArguments.length; i++) {
            argumentTypes[i] = kernelArguments[i].type;
          }
  
          for (let i = 0; i < kernelConstants.length; i++) {
            const kernelConstant = kernelConstants[i];
            constantTypes[kernelConstant.name] = kernelConstant.type;
          }
  
          const needsArgumentType = (functionName, index) => {
            return functionBuilder.needsArgumentType(functionName, index);
          };
  
          const assignArgumentType = (functionName, index, type) => {
            functionBuilder.assignArgumentType(functionName, index, type);
          };
  
          const lookupReturnType = (functionName, ast, requestingNode) => {
            return functionBuilder.lookupReturnType(functionName, ast, requestingNode);
          };
  
          const lookupFunctionArgumentTypes = (functionName) => {
            return functionBuilder.lookupFunctionArgumentTypes(functionName);
          };
  
          const lookupFunctionArgumentName = (functionName, argumentIndex) => {
            return functionBuilder.lookupFunctionArgumentName(functionName, argumentIndex);
          };
  
          const lookupFunctionArgumentBitRatio = (functionName, argumentName) => {
            return functionBuilder.lookupFunctionArgumentBitRatio(functionName, argumentName);
          };
  
          const triggerImplyArgumentType = (functionName, i, argumentType, requestingNode) => {
            functionBuilder.assignArgumentType(functionName, i, argumentType, requestingNode);
          };
  
          const triggerImplyArgumentBitRatio = (functionName, argumentName, calleeFunctionName, argumentIndex) => {
            functionBuilder.assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex);
          };
  
          const onFunctionCall = (functionName, calleeFunctionName, args) => {
            functionBuilder.trackFunctionCall(functionName, calleeFunctionName, args);
          };
  
          const onNestedFunction = (ast, source) => {
            const argumentNames = [];
            for (let i = 0; i < ast.params.length; i++) {
              argumentNames.push(ast.params[i].name);
            }
            const nestedFunction = new FunctionNode(source, Object.assign({}, nodeOptions, {
              returnType: null,
              ast,
              name: ast.id.name,
              argumentNames,
              lookupReturnType,
              lookupFunctionArgumentTypes,
              lookupFunctionArgumentName,
              lookupFunctionArgumentBitRatio,
              needsArgumentType,
              assignArgumentType,
              triggerImplyArgumentType,
              triggerImplyArgumentBitRatio,
              onFunctionCall,
            }));
            nestedFunction.traceFunctionAST(ast);
            functionBuilder.addFunctionNode(nestedFunction);
          };
  
          const nodeOptions = Object.assign({
            isRootKernel: false,
            onNestedFunction,
            lookupReturnType,
            lookupFunctionArgumentTypes,
            lookupFunctionArgumentName,
            lookupFunctionArgumentBitRatio,
            needsArgumentType,
            assignArgumentType,
            triggerImplyArgumentType,
            triggerImplyArgumentBitRatio,
            onFunctionCall,
            optimizeFloatMemory,
            precision,
            constants,
            constantTypes,
            constantBitRatios,
            debug,
            loopMaxIterations,
            output,
            plugins,
            dynamicArguments,
            dynamicOutput,
          }, extraNodeOptions || {});
  
          const rootNodeOptions = Object.assign({}, nodeOptions, {
            isRootKernel: true,
            name: 'kernel',
            argumentNames,
            argumentTypes,
            argumentSizes,
            argumentBitRatios,
            leadingReturnStatement,
            followingReturnStatement,
          });
  
          if (typeof source === 'object' && source.functionNodes) {
            return new FunctionBuilder().fromJSON(source.functionNodes, FunctionNode);
          }
  
          const rootNode = new FunctionNode(source, rootNodeOptions);
  
          let functionNodes = null;
          if (functions) {
            functionNodes = functions.map((fn) => new FunctionNode(fn.source, {
              returnType: fn.returnType,
              argumentTypes: fn.argumentTypes,
              output,
              plugins,
              constants,
              constantTypes,
              constantBitRatios,
              optimizeFloatMemory,
              precision,
              lookupReturnType,
              lookupFunctionArgumentTypes,
              lookupFunctionArgumentName,
              lookupFunctionArgumentBitRatio,
              needsArgumentType,
              assignArgumentType,
              triggerImplyArgumentType,
              triggerImplyArgumentBitRatio,
              onFunctionCall,
              onNestedFunction,
            }));
          }
  
          let subKernelNodes = null;
          if (subKernels) {
            subKernelNodes = subKernels.map((subKernel) => {
              const { name, source } = subKernel;
              return new FunctionNode(source, Object.assign({}, nodeOptions, {
                name,
                isSubKernel: true,
                isRootKernel: false,
              }));
            });
          }
  
          const functionBuilder = new FunctionBuilder({
            kernel,
            rootNode,
            functionNodes,
            nativeFunctions,
            subKernelNodes
          });
  
          return functionBuilder;
        }
  
        constructor(settings) {
          settings = settings || {};
          this.kernel = settings.kernel;
          this.rootNode = settings.rootNode;
          this.functionNodes = settings.functionNodes || [];
          this.subKernelNodes = settings.subKernelNodes || [];
          this.nativeFunctions = settings.nativeFunctions || [];
          this.functionMap = {};
          this.nativeFunctionNames = [];
          this.lookupChain = [];
          this.functionNodeDependencies = {};
          this.functionCalls = {};
  
          if (this.rootNode) {
            this.functionMap['kernel'] = this.rootNode;
          }
  
          if (this.functionNodes) {
            for (let i = 0; i < this.functionNodes.length; i++) {
              this.functionMap[this.functionNodes[i].name] = this.functionNodes[i];
            }
          }
  
          if (this.subKernelNodes) {
            for (let i = 0; i < this.subKernelNodes.length; i++) {
              this.functionMap[this.subKernelNodes[i].name] = this.subKernelNodes[i];
            }
          }
  
          if (this.nativeFunctions) {
            for (let i = 0; i < this.nativeFunctions.length; i++) {
              const nativeFunction = this.nativeFunctions[i];
              this.nativeFunctionNames.push(nativeFunction.name);
            }
          }
        }
  
        addFunctionNode(functionNode) {
          if (!functionNode.name) throw new Error('functionNode.name needs set');
          this.functionMap[functionNode.name] = functionNode;
          if (functionNode.isRootKernel) {
            this.rootNode = functionNode;
          }
        }
  
        traceFunctionCalls(functionName, retList) {
          functionName = functionName || 'kernel';
          retList = retList || [];
  
          if (this.nativeFunctionNames.indexOf(functionName) > -1) {
            const nativeFunctionIndex = retList.indexOf(functionName);
            if (nativeFunctionIndex === -1) {
              retList.push(functionName);
            } else {
              const dependantNativeFunctionName = retList.splice(nativeFunctionIndex, 1)[0];
              retList.push(dependantNativeFunctionName);
            }
            return retList;
          }
  
          const functionNode = this.functionMap[functionName];
          if (functionNode) {
            const functionIndex = retList.indexOf(functionName);
            if (functionIndex === -1) {
              retList.push(functionName);
              functionNode.toString(); 
              for (let i = 0; i < functionNode.calledFunctions.length; ++i) {
                this.traceFunctionCalls(functionNode.calledFunctions[i], retList);
              }
            } else {
              const dependantFunctionName = retList.splice(functionIndex, 1)[0];
              retList.push(dependantFunctionName);
            }
          }
  
          return retList;
        }
  
        getPrototypeString(functionName) {
          return this.getPrototypes(functionName).join('\n');
        }
  
        getPrototypes(functionName) {
          if (this.rootNode) {
            this.rootNode.toString();
          }
          if (functionName) {
            return this.getPrototypesFromFunctionNames(this.traceFunctionCalls(functionName, []).reverse());
          }
          return this.getPrototypesFromFunctionNames(Object.keys(this.functionMap));
        }
  
        getStringFromFunctionNames(functionList) {
          const ret = [];
          for (let i = 0; i < functionList.length; ++i) {
            const node = this.functionMap[functionList[i]];
            if (node) {
              ret.push(this.functionMap[functionList[i]].toString());
            }
          }
          return ret.join('\n');
        }
  
        getPrototypesFromFunctionNames(functionList) {
          const ret = [];
          for (let i = 0; i < functionList.length; ++i) {
            const functionName = functionList[i];
            const functionIndex = this.nativeFunctionNames.indexOf(functionName);
            if (functionIndex > -1) {
              ret.push(this.nativeFunctions[functionIndex].source);
              continue;
            }
            const node = this.functionMap[functionName];
            if (node) {
              ret.push(node.toString());
            }
          }
          return ret;
        }
  
        toJSON() {
          return this.traceFunctionCalls(this.rootNode.name).reverse().map(name => {
            const nativeIndex = this.nativeFunctions.indexOf(name);
            if (nativeIndex > -1) {
              return {
                name,
                source: this.nativeFunctions[nativeIndex].source
              };
            } else if (this.functionMap[name]) {
              return this.functionMap[name].toJSON();
            } else {
              throw new Error(`function ${ name } not found`);
            }
          });
        }
  
        fromJSON(jsonFunctionNodes, FunctionNode) {
          this.functionMap = {};
          for (let i = 0; i < jsonFunctionNodes.length; i++) {
            const jsonFunctionNode = jsonFunctionNodes[i];
            this.functionMap[jsonFunctionNode.settings.name] = new FunctionNode(jsonFunctionNode.ast, jsonFunctionNode.settings);
          }
          return this;
        }
  
        getString(functionName) {
          if (functionName) {
            return this.getStringFromFunctionNames(this.traceFunctionCalls(functionName).reverse());
          }
          return this.getStringFromFunctionNames(Object.keys(this.functionMap));
        }
  
        lookupReturnType(functionName, ast, requestingNode) {
          if (ast.type !== 'CallExpression') {
            throw new Error(`expected ast type of "CallExpression", but is ${ ast.type }`);
          }
          if (this._isNativeFunction(functionName)) {
            return this._lookupNativeFunctionReturnType(functionName);
          } else if (this._isFunction(functionName)) {
            const node = this._getFunction(functionName);
            if (node.returnType) {
              return node.returnType;
            } else {
              for (let i = 0; i < this.lookupChain.length; i++) {
                if (this.lookupChain[i].ast === ast) {
                  if (node.argumentTypes.length === 0 && ast.arguments.length > 0) {
                    const args = ast.arguments;
                    for (let j = 0; j < args.length; j++) {
                      this.lookupChain.push({
                        name: requestingNode.name,
                        ast: args[i],
                        requestingNode
                      });
                      node.argumentTypes[j] = requestingNode.getType(args[j]);
                      this.lookupChain.pop();
                    }
                    return node.returnType = node.getType(node.getJsAST());
                  }
  
                  throw new Error('circlical logic detected!');
                }
              }
              this.lookupChain.push({
                name: requestingNode.name,
                ast,
                requestingNode
              });
              const type = node.getType(node.getJsAST());
              this.lookupChain.pop();
              return node.returnType = type;
            }
          }
  
          return null;
        }
  
        _getFunction(functionName) {
          if (!this._isFunction(functionName)) ;
          return this.functionMap[functionName];
        }
  
        _isFunction(functionName) {
          return Boolean(this.functionMap[functionName]);
        }
  
        _getNativeFunction(functionName) {
          for (let i = 0; i < this.nativeFunctions.length; i++) {
            if (this.nativeFunctions[i].name === functionName) return this.nativeFunctions[i];
          }
          return null;
        }
  
        _isNativeFunction(functionName) {
          return Boolean(this._getNativeFunction(functionName));
        }
  
        _lookupNativeFunctionReturnType(functionName) {
          let nativeFunction = this._getNativeFunction(functionName);
          if (nativeFunction) {
            return nativeFunction.returnType;
          }
          throw new Error(`Native function ${ functionName } not found`);
        }
  
        lookupFunctionArgumentTypes(functionName) {
          if (this._isNativeFunction(functionName)) {
            return this._getNativeFunction(functionName).argumentTypes;
          } else if (this._isFunction(functionName)) {
            return this._getFunction(functionName).argumentTypes;
          }
          return null;
        }
  
        lookupFunctionArgumentName(functionName, argumentIndex) {
          return this._getFunction(functionName).argumentNames[argumentIndex];
        }
  
        lookupFunctionArgumentBitRatio(functionName, argumentName) {
          if (!this._isFunction(functionName)) {
            throw new Error('function not found');
          }
          if (this.rootNode.name === functionName) {
            const i = this.rootNode.argumentNames.indexOf(argumentName);
            if (i !== -1) {
              return this.rootNode.argumentBitRatios[i];
            }
          }
          const node = this._getFunction(functionName);
          const i = node.argumentNames.indexOf(argumentName);
          if (i === -1) {
            throw new Error('argument not found');
          }
          const bitRatio = node.argumentBitRatios[i];
          if (typeof bitRatio !== 'number') {
            throw new Error('argument bit ratio not found');
          }
          return bitRatio;
        }
  
        needsArgumentType(functionName, i) {
          if (!this._isFunction(functionName)) return false;
          const fnNode = this._getFunction(functionName);
          return !fnNode.argumentTypes[i];
        }
  
        assignArgumentType(functionName, i, argumentType, requestingNode) {
          if (!this._isFunction(functionName)) return;
          const fnNode = this._getFunction(functionName);
          if (!fnNode.argumentTypes[i]) {
            fnNode.argumentTypes[i] = argumentType;
          }
        }
  
        assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex) {
          const node = this._getFunction(functionName);
          if (this._isNativeFunction(calleeFunctionName)) return null;
          const calleeNode = this._getFunction(calleeFunctionName);
          const i = node.argumentNames.indexOf(argumentName);
          if (i === -1) {
            throw new Error(`Argument ${argumentName} not found in arguments from function ${functionName}`);
          }
          const bitRatio = node.argumentBitRatios[i];
          if (typeof bitRatio !== 'number') {
            throw new Error(`Bit ratio for argument ${argumentName} not found in function ${functionName}`);
          }
          if (!calleeNode.argumentBitRatios) {
            calleeNode.argumentBitRatios = new Array(calleeNode.argumentNames.length);
          }
          const calleeBitRatio = calleeNode.argumentBitRatios[i];
          if (typeof calleeBitRatio === 'number') {
            if (calleeBitRatio !== bitRatio) {
              throw new Error(`Incompatible bit ratio found at function ${functionName} at argument ${argumentName}`);
            }
            return calleeBitRatio;
          }
          calleeNode.argumentBitRatios[i] = bitRatio;
          return bitRatio;
        }
  
        trackFunctionCall(functionName, calleeFunctionName, args) {
          if (!this.functionNodeDependencies[functionName]) {
            this.functionNodeDependencies[functionName] = new Set();
            this.functionCalls[functionName] = [];
          }
          this.functionNodeDependencies[functionName].add(calleeFunctionName);
          this.functionCalls[functionName].push(args);
        }
  
        getKernelResultType() {
          return this.rootNode.returnType || this.rootNode.getType(this.rootNode.ast);
        }
  
        getSubKernelResultType(index) {
          const subKernelNode = this.subKernelNodes[index];
          let called = false;
          for (let functionCallIndex = 0; functionCallIndex < this.rootNode.functionCalls.length; functionCallIndex++) {
            const functionCall = this.rootNode.functionCalls[functionCallIndex];
            if (functionCall.ast.callee.name === subKernelNode.name) {
              called = true;
            }
          }
          if (!called) {
            throw new Error(`SubKernel ${ subKernelNode.name } never called by kernel`);
          }
          return subKernelNode.returnType || subKernelNode.getType(subKernelNode.getJsAST());
        }
  
        getReturnTypes() {
          const result = {
            [this.rootNode.name]: this.rootNode.getType(this.rootNode.ast),
          };
          const list = this.traceFunctionCalls(this.rootNode.name);
          for (let i = 0; i < list.length; i++) {
            const functionName = list[i];
            const functionNode = this.functionMap[functionName];
            result[functionName] = functionNode.getType(functionNode.ast);
          }
          return result;
        }
      }
  
      module.exports = {
        FunctionBuilder
      };
      },{}],10:[function(require,module,exports){
      const acorn = require('acorn');
      const { utils } = require('../utils');
      const { FunctionTracer } = require('./function-tracer');
  
      class FunctionNode {
        constructor(source, settings) {
          if (!source && !settings.ast) {
            throw new Error('source parameter is missing');
          }
          settings = settings || {};
          this.source = source;
          this.ast = null;
          this.name = typeof source === 'string' ? settings.isRootKernel ?
            'kernel' :
            (settings.name || utils.getFunctionNameFromString(source)) : null;
          this.calledFunctions = [];
          this.constants = {};
          this.constantTypes = {};
          this.constantBitRatios = {};
          this.isRootKernel = false;
          this.isSubKernel = false;
          this.debug = null;
          this.functions = null;
          this.identifiers = null;
          this.contexts = null;
          this.functionCalls = null;
          this.states = [];
          this.needsArgumentType = null;
          this.assignArgumentType = null;
          this.lookupReturnType = null;
          this.lookupFunctionArgumentTypes = null;
          this.lookupFunctionArgumentBitRatio = null;
          this.triggerImplyArgumentType = null;
          this.triggerImplyArgumentBitRatio = null;
          this.onNestedFunction = null;
          this.onFunctionCall = null;
          this.optimizeFloatMemory = null;
          this.precision = null;
          this.loopMaxIterations = null;
          this.argumentNames = (typeof this.source === 'string' ? utils.getArgumentNamesFromString(this.source) : null);
          this.argumentTypes = [];
          this.argumentSizes = [];
          this.argumentBitRatios = null;
          this.returnType = null;
          this.output = [];
          this.plugins = null;
          this.leadingReturnStatement = null;
          this.followingReturnStatement = null;
          this.dynamicOutput = null;
          this.dynamicArguments = null;
          this.strictTypingChecking = false;
          this.fixIntegerDivisionAccuracy = null;
  
          if (settings) {
            for (const p in settings) {
              if (!settings.hasOwnProperty(p)) continue;
              if (!this.hasOwnProperty(p)) continue;
              this[p] = settings[p];
            }
          }
  
          this.literalTypes = {};
  
          this.validate();
          this._string = null;
          this._internalVariableNames = {};
        }
  
        validate() {
          if (typeof this.source !== 'string' && !this.ast) {
            throw new Error('this.source not a string');
          }
  
          if (!this.ast && !utils.isFunctionString(this.source)) {
            throw new Error('this.source not a function string');
          }
  
          if (!this.name) {
            throw new Error('this.name could not be set');
          }
  
          if (this.argumentTypes.length > 0 && this.argumentTypes.length !== this.argumentNames.length) {
            throw new Error(`argumentTypes count of ${ this.argumentTypes.length } exceeds ${ this.argumentNames.length }`);
          }
  
          if (this.output.length < 1) {
            throw new Error('this.output is not big enough');
          }
        }
  
        isIdentifierConstant(name) {
          if (!this.constants) return false;
          return this.constants.hasOwnProperty(name);
        }
  
        isInput(argumentName) {
          return this.argumentTypes[this.argumentNames.indexOf(argumentName)] === 'Input';
        }
  
        pushState(state) {
          this.states.push(state);
        }
  
        popState(state) {
          if (this.state !== state) {
            throw new Error(`Cannot popState ${ state } when in ${ this.state }`);
          }
          this.states.pop();
        }
  
        isState(state) {
          return this.state === state;
        }
  
        get state() {
          return this.states[this.states.length - 1];
        }
  
        astMemberExpressionUnroll(ast) {
          if (ast.type === 'Identifier') {
            return ast.name;
          } else if (ast.type === 'ThisExpression') {
            return 'this';
          }
  
          if (ast.type === 'MemberExpression') {
            if (ast.object && ast.property) {
              if (ast.object.hasOwnProperty('name') && ast.object.name !== 'Math') {
                return this.astMemberExpressionUnroll(ast.property);
              }
  
              return (
                this.astMemberExpressionUnroll(ast.object) +
                '.' +
                this.astMemberExpressionUnroll(ast.property)
              );
            }
          }
  
          if (ast.hasOwnProperty('expressions')) {
            const firstExpression = ast.expressions[0];
            if (firstExpression.type === 'Literal' && firstExpression.value === 0 && ast.expressions.length === 2) {
              return this.astMemberExpressionUnroll(ast.expressions[1]);
            }
          }
  
          throw this.astErrorOutput('Unknown astMemberExpressionUnroll', ast);
        }
  
        getJsAST(inParser) {
          if (this.ast) {
            return this.ast;
          }
          if (typeof this.source === 'object') {
            this.traceFunctionAST(this.source);
            return this.ast = this.source;
          }
  
          inParser = inParser || acorn;
          if (inParser === null) {
            throw new Error('Missing JS to AST parser');
          }
  
          const ast = Object.freeze(inParser.parse(`const parser_${ this.name } = ${ this.source };`, {
            locations: true
          }));
          const functionAST = ast.body[0].declarations[0].init;
          this.traceFunctionAST(functionAST);
  
          if (!ast) {
            throw new Error('Failed to parse JS code');
          }
  
          return this.ast = functionAST;
        }
  
        traceFunctionAST(ast) {
          const { contexts, declarations, functions, identifiers, functionCalls } = new FunctionTracer(ast);
          this.contexts = contexts;
          this.identifiers = identifiers;
          this.functionCalls = functionCalls;
          this.functions = functions;
          for (let i = 0; i < declarations.length; i++) {
            const declaration = declarations[i];
            const { ast, inForLoopInit, inForLoopTest } = declaration;
            const { init } = ast;
            const dependencies = this.getDependencies(init);
            let valueType = null;
  
            if (inForLoopInit && inForLoopTest) {
              valueType = 'Integer';
            } else {
              if (init) {
                const realType = this.getType(init);
                switch (realType) {
                  case 'Integer':
                  case 'Float':
                  case 'Number':
                    if (init.type === 'MemberExpression') {
                      valueType = realType;
                    } else {
                      valueType = 'Number';
                    }
                    break;
                  case 'LiteralInteger':
                    valueType = 'Number';
                    break;
                  default:
                    valueType = realType;
                }
              }
            }
            declaration.valueType = valueType;
            declaration.dependencies = dependencies;
            declaration.isSafe = this.isSafeDependencies(dependencies);
          }
  
          for (let i = 0; i < functions.length; i++) {
            this.onNestedFunction(functions[i], this.source);
          }
        }
  
        getDeclaration(ast) {
          for (let i = 0; i < this.identifiers.length; i++) {
            const identifier = this.identifiers[i];
            if (ast === identifier.ast) {
              return identifier.declaration;
            }
          }
          return null;
        }
  
        getVariableType(ast) {
          if (ast.type !== 'Identifier') {
            throw new Error(`ast of ${ast.type} not "Identifier"`);
          }
          let type = null;
          const argumentIndex = this.argumentNames.indexOf(ast.name);
          if (argumentIndex === -1) {
            const declaration = this.getDeclaration(ast);
            if (declaration) {
              return declaration.valueType;
            }
          } else {
            const argumentType = this.argumentTypes[argumentIndex];
            if (argumentType) {
              type = argumentType;
            }
          }
          if (!type && this.strictTypingChecking) {
            throw new Error(`Declaration of ${name} not found`);
          }
          return type;
        }
  
        getLookupType(type) {
          if (!typeLookupMap.hasOwnProperty(type)) {
            throw new Error(`unknown typeLookupMap ${ type }`);
          }
          return typeLookupMap[type];
        }
  
        getConstantType(constantName) {
          if (this.constantTypes[constantName]) {
            const type = this.constantTypes[constantName];
            if (type === 'Float') {
              return 'Number';
            } else {
              return type;
            }
          }
          throw new Error(`Type for constant "${ constantName }" not declared`);
        }
  
        toString() {
          if (this._string) return this._string;
          return this._string = this.astGeneric(this.getJsAST(), []).join('').trim();
        }
  
        toJSON() {
          const settings = {
            source: this.source,
            name: this.name,
            constants: this.constants,
            constantTypes: this.constantTypes,
            isRootKernel: this.isRootKernel,
            isSubKernel: this.isSubKernel,
            debug: this.debug,
            output: this.output,
            loopMaxIterations: this.loopMaxIterations,
            argumentNames: this.argumentNames,
            argumentTypes: this.argumentTypes,
            argumentSizes: this.argumentSizes,
            returnType: this.returnType,
            leadingReturnStatement: this.leadingReturnStatement,
            followingReturnStatement: this.followingReturnStatement,
          };
  
          return {
            ast: this.ast,
            settings
          };
        }
  
        getType(ast) {
          if (Array.isArray(ast)) {
            return this.getType(ast[ast.length - 1]);
          }
          switch (ast.type) {
            case 'BlockStatement':
              return this.getType(ast.body);
            case 'ArrayExpression':
              const childType = this.getType(ast.elements[0]);
              switch (childType) {
                case 'Array(2)':
                case 'Array(3)':
                case 'Array(4)':
                  return `Matrix(${ast.elements.length})`;
              }
              return `Array(${ ast.elements.length })`;
            case 'Literal':
              const literalKey = this.astKey(ast);
              if (this.literalTypes[literalKey]) {
                return this.literalTypes[literalKey];
              }
              if (Number.isInteger(ast.value)) {
                return 'LiteralInteger';
              } else if (ast.value === true || ast.value === false) {
                return 'Boolean';
              } else {
                return 'Number';
              }
              case 'AssignmentExpression':
                return this.getType(ast.left);
              case 'CallExpression':
                if (this.isAstMathFunction(ast)) {
                  return 'Number';
                }
                if (!ast.callee || !ast.callee.name) {
                  if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[ast.callee.expressions.length - 1].property.name) {
                    const functionName = ast.callee.expressions[ast.callee.expressions.length - 1].property.name;
                    this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
                    return this.lookupReturnType(functionName, ast, this);
                  }
                  if (this.getVariableSignature(ast.callee, true) === 'this.color') {
                    return null;
                  }
                  if (ast.callee.type === 'MemberExpression' && ast.callee.object && ast.callee.property && ast.callee.property.name && ast.arguments) {
                    const functionName = ast.callee.property.name;
                    this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
                    return this.lookupReturnType(functionName, ast, this);
                  }
                  throw this.astErrorOutput('Unknown call expression', ast);
                }
                if (ast.callee && ast.callee.name) {
                  const functionName = ast.callee.name;
                  this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
                  return this.lookupReturnType(functionName, ast, this);
                }
                throw this.astErrorOutput(`Unhandled getType Type "${ ast.type }"`, ast);
              case 'LogicalExpression':
                return 'Boolean';
              case 'BinaryExpression':
                switch (ast.operator) {
                  case '%':
                  case '/':
                    if (this.fixIntegerDivisionAccuracy) {
                      return 'Number';
                    } else {
                      break;
                    }
                    case '>':
                    case '<':
                      return 'Boolean';
                    case '&':
                    case '|':
                    case '^':
                    case '<<':
                    case '>>':
                    case '>>>':
                      return 'Integer';
                }
                const type = this.getType(ast.left);
                if (this.isState('skip-literal-correction')) return type;
                if (type === 'LiteralInteger') {
                  const rightType = this.getType(ast.right);
                  if (rightType === 'LiteralInteger') {
                    if (ast.left.value % 1 === 0) {
                      return 'Integer';
                    } else {
                      return 'Float';
                    }
                  }
                  return rightType;
                }
                return typeLookupMap[type] || type;
              case 'UpdateExpression':
                return this.getType(ast.argument);
              case 'UnaryExpression':
                if (ast.operator === '~') {
                  return 'Integer';
                }
                return this.getType(ast.argument);
              case 'VariableDeclaration': {
                const declarations = ast.declarations;
                let lastType;
                for (let i = 0; i < declarations.length; i++) {
                  const declaration = declarations[i];
                  lastType = this.getType(declaration);
                }
                if (!lastType) {
                  throw this.astErrorOutput(`Unable to find type for declaration`, ast);
                }
                return lastType;
              }
              case 'VariableDeclarator':
                const declaration = this.getDeclaration(ast.id);
                if (!declaration) {
                  throw this.astErrorOutput(`Unable to find declarator`, ast);
                }
  
                if (!declaration.valueType) {
                  throw this.astErrorOutput(`Unable to find declarator valueType`, ast);
                }
  
                return declaration.valueType;
              case 'Identifier':
                if (ast.name === 'Infinity') {
                  return 'Number';
                }
                if (this.isAstVariable(ast)) {
                  const signature = this.getVariableSignature(ast);
                  if (signature === 'value') {
                    return this.getCheckVariableType(ast);
                  }
                }
                const origin = this.findIdentifierOrigin(ast);
                if (origin && origin.init) {
                  return this.getType(origin.init);
                }
                return null;
              case 'ReturnStatement':
                return this.getType(ast.argument);
              case 'MemberExpression':
                if (this.isAstMathFunction(ast)) {
                  switch (ast.property.name) {
                    case 'ceil':
                      return 'Integer';
                    case 'floor':
                      return 'Integer';
                    case 'round':
                      return 'Integer';
                  }
                  return 'Number';
                }
                if (this.isAstVariable(ast)) {
                  const variableSignature = this.getVariableSignature(ast);
                  switch (variableSignature) {
                    case 'value[]':
                      return this.getLookupType(this.getCheckVariableType(ast.object));
                    case 'value[][]':
                      return this.getLookupType(this.getCheckVariableType(ast.object.object));
                    case 'value[][][]':
                      return this.getLookupType(this.getCheckVariableType(ast.object.object.object));
                    case 'value[][][][]':
                      return this.getLookupType(this.getCheckVariableType(ast.object.object.object.object));
                    case 'value.thread.value':
                    case 'this.thread.value':
                      return 'Integer';
                    case 'this.output.value':
                      return this.dynamicOutput ? 'Integer' : 'LiteralInteger';
                    case 'this.constants.value':
                      return this.getConstantType(ast.property.name);
                    case 'this.constants.value[]':
                      return this.getLookupType(this.getConstantType(ast.object.property.name));
                    case 'this.constants.value[][]':
                      return this.getLookupType(this.getConstantType(ast.object.object.property.name));
                    case 'this.constants.value[][][]':
                      return this.getLookupType(this.getConstantType(ast.object.object.object.property.name));
                    case 'this.constants.value[][][][]':
                      return this.getLookupType(this.getConstantType(ast.object.object.object.object.property.name));
                    case 'fn()[]':
                    case 'fn()[][]':
                    case 'fn()[][][]':
                      return this.getLookupType(this.getType(ast.object));
                    case 'value.value':
                      if (this.isAstMathVariable(ast)) {
                        return 'Number';
                      }
                      switch (ast.property.name) {
                        case 'r':
                        case 'g':
                        case 'b':
                        case 'a':
                          return this.getLookupType(this.getCheckVariableType(ast.object));
                      }
                      case '[][]':
                        return 'Number';
                  }
                  throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
                }
                throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
              case 'ConditionalExpression':
                return this.getType(ast.consequent);
              case 'FunctionDeclaration':
              case 'FunctionExpression':
                const lastReturn = this.findLastReturn(ast.body);
                if (lastReturn) {
                  return this.getType(lastReturn);
                }
                return null;
              case 'IfStatement':
                return this.getType(ast.consequent);
              case 'SequenceExpression':
                return this.getType(ast.expressions[ast.expressions.length - 1]);
              default:
                throw this.astErrorOutput(`Unhandled getType Type "${ ast.type }"`, ast);
          }
        }
  
        getCheckVariableType(ast) {
          const type = this.getVariableType(ast);
          if (!type) {
            throw this.astErrorOutput(`${ast.type} is not defined`, ast);
          }
          return type;
        }
  
        inferArgumentTypesIfNeeded(functionName, args) {
          for (let i = 0; i < args.length; i++) {
            if (!this.needsArgumentType(functionName, i)) continue;
            const type = this.getType(args[i]);
            if (!type) {
              throw this.astErrorOutput(`Unable to infer argument ${i}`, args[i]);
            }
            this.assignArgumentType(functionName, i, type);
          }
        }
  
        isAstMathVariable(ast) {
          const mathProperties = [
            'E',
            'PI',
            'SQRT2',
            'SQRT1_2',
            'LN2',
            'LN10',
            'LOG2E',
            'LOG10E',
          ];
          return ast.type === 'MemberExpression' &&
            ast.object && ast.object.type === 'Identifier' &&
            ast.object.name === 'Math' &&
            ast.property &&
            ast.property.type === 'Identifier' &&
            mathProperties.indexOf(ast.property.name) > -1;
        }
  
        isAstMathFunction(ast) {
          const mathFunctions = [
            'abs',
            'acos',
            'acosh',
            'asin',
            'asinh',
            'atan',
            'atan2',
            'atanh',
            'cbrt',
            'ceil',
            'clz32',
            'cos',
            'cosh',
            'expm1',
            'exp',
            'floor',
            'fround',
            'imul',
            'log',
            'log2',
            'log10',
            'log1p',
            'max',
            'min',
            'pow',
            'random',
            'round',
            'sign',
            'sin',
            'sinh',
            'sqrt',
            'tan',
            'tanh',
            'trunc',
          ];
          return ast.type === 'CallExpression' &&
            ast.callee &&
            ast.callee.type === 'MemberExpression' &&
            ast.callee.object &&
            ast.callee.object.type === 'Identifier' &&
            ast.callee.object.name === 'Math' &&
            ast.callee.property &&
            ast.callee.property.type === 'Identifier' &&
            mathFunctions.indexOf(ast.callee.property.name) > -1;
        }
  
        isAstVariable(ast) {
          return ast.type === 'Identifier' || ast.type === 'MemberExpression';
        }
  
        isSafe(ast) {
          return this.isSafeDependencies(this.getDependencies(ast));
        }
  
        isSafeDependencies(dependencies) {
          return dependencies && dependencies.every ? dependencies.every(dependency => dependency.isSafe) : true;
        }
  
        getDependencies(ast, dependencies, isNotSafe) {
          if (!dependencies) {
            dependencies = [];
          }
          if (!ast) return null;
          if (Array.isArray(ast)) {
            for (let i = 0; i < ast.length; i++) {
              this.getDependencies(ast[i], dependencies, isNotSafe);
            }
            return dependencies;
          }
          switch (ast.type) {
            case 'AssignmentExpression':
              this.getDependencies(ast.left, dependencies, isNotSafe);
              this.getDependencies(ast.right, dependencies, isNotSafe);
              return dependencies;
            case 'ConditionalExpression':
              this.getDependencies(ast.test, dependencies, isNotSafe);
              this.getDependencies(ast.alternate, dependencies, isNotSafe);
              this.getDependencies(ast.consequent, dependencies, isNotSafe);
              return dependencies;
            case 'Literal':
              dependencies.push({
                origin: 'literal',
                value: ast.value,
                isSafe: isNotSafe === true ? false : ast.value > -Infinity && ast.value < Infinity && !isNaN(ast.value)
              });
              break;
            case 'VariableDeclarator':
              return this.getDependencies(ast.init, dependencies, isNotSafe);
            case 'Identifier':
              const declaration = this.getDeclaration(ast);
              if (declaration) {
                dependencies.push({
                  name: ast.name,
                  origin: 'declaration',
                  isSafe: isNotSafe ? false : this.isSafeDependencies(declaration.dependencies),
                });
              } else if (this.argumentNames.indexOf(ast.name) > -1) {
                dependencies.push({
                  name: ast.name,
                  origin: 'argument',
                  isSafe: false,
                });
              } else if (this.strictTypingChecking) {
                throw new Error(`Cannot find identifier origin "${ast.name}"`);
              }
              break;
            case 'FunctionDeclaration':
              return this.getDependencies(ast.body.body[ast.body.body.length - 1], dependencies, isNotSafe);
            case 'ReturnStatement':
              return this.getDependencies(ast.argument, dependencies);
            case 'BinaryExpression':
            case 'LogicalExpression':
              isNotSafe = (ast.operator === '/' || ast.operator === '*');
              this.getDependencies(ast.left, dependencies, isNotSafe);
              this.getDependencies(ast.right, dependencies, isNotSafe);
              return dependencies;
            case 'UnaryExpression':
            case 'UpdateExpression':
              return this.getDependencies(ast.argument, dependencies, isNotSafe);
            case 'VariableDeclaration':
              return this.getDependencies(ast.declarations, dependencies, isNotSafe);
            case 'ArrayExpression':
              dependencies.push({
                origin: 'declaration',
                isSafe: true,
              });
              return dependencies;
            case 'CallExpression':
              dependencies.push({
                origin: 'function',
                isSafe: true,
              });
              return dependencies;
            case 'MemberExpression':
              const details = this.getMemberExpressionDetails(ast);
              switch (details.signature) {
                case 'value[]':
                  this.getDependencies(ast.object, dependencies, isNotSafe);
                  break;
                case 'value[][]':
                  this.getDependencies(ast.object.object, dependencies, isNotSafe);
                  break;
                case 'value[][][]':
                  this.getDependencies(ast.object.object.object, dependencies, isNotSafe);
                  break;
                case 'this.output.value':
                  if (this.dynamicOutput) {
                    dependencies.push({
                      name: details.name,
                      origin: 'output',
                      isSafe: false,
                    });
                  }
                  break;
              }
              if (details) {
                if (details.property) {
                  this.getDependencies(details.property, dependencies, isNotSafe);
                }
                if (details.xProperty) {
                  this.getDependencies(details.xProperty, dependencies, isNotSafe);
                }
                if (details.yProperty) {
                  this.getDependencies(details.yProperty, dependencies, isNotSafe);
                }
                if (details.zProperty) {
                  this.getDependencies(details.zProperty, dependencies, isNotSafe);
                }
                return dependencies;
              }
              case 'SequenceExpression':
                return this.getDependencies(ast.expressions, dependencies, isNotSafe);
              default:
                throw this.astErrorOutput(`Unhandled type ${ ast.type } in getDependencies`, ast);
          }
          return dependencies;
        }
  
        getVariableSignature(ast, returnRawValue) {
          if (!this.isAstVariable(ast)) {
            throw new Error(`ast of type "${ ast.type }" is not a variable signature`);
          }
          if (ast.type === 'Identifier') {
            return 'value';
          }
          const signature = [];
          while (true) {
            if (!ast) break;
            if (ast.computed) {
              signature.push('[]');
            } else if (ast.type === 'ThisExpression') {
              signature.unshift('this');
            } else if (ast.property && ast.property.name) {
              if (
                ast.property.name === 'x' ||
                ast.property.name === 'y' ||
                ast.property.name === 'z'
              ) {
                signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');
              } else if (
                ast.property.name === 'constants' ||
                ast.property.name === 'thread' ||
                ast.property.name === 'output'
              ) {
                signature.unshift('.' + ast.property.name);
              } else {
                signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');
              }
            } else if (ast.name) {
              signature.unshift(returnRawValue ? ast.name : 'value');
            } else if (ast.callee && ast.callee.name) {
              signature.unshift(returnRawValue ? ast.callee.name + '()' : 'fn()');
            } else if (ast.elements) {
              signature.unshift('[]');
            } else {
              signature.unshift('unknown');
            }
            ast = ast.object;
          }
  
          const signatureString = signature.join('');
          if (returnRawValue) {
            return signatureString;
          }
  
          const allowedExpressions = [
            'value',
            'value[]',
            'value[][]',
            'value[][][]',
            'value[][][][]',
            'value.value',
            'value.thread.value',
            'this.thread.value',
            'this.output.value',
            'this.constants.value',
            'this.constants.value[]',
            'this.constants.value[][]',
            'this.constants.value[][][]',
            'this.constants.value[][][][]',
            'fn()[]',
            'fn()[][]',
            'fn()[][][]',
            '[][]',
          ];
          if (allowedExpressions.indexOf(signatureString) > -1) {
            return signatureString;
          }
          return null;
        }
  
        build() {
          return this.toString().length > 0;
        }
  
        astGeneric(ast, retArr) {
          if (ast === null) {
            throw this.astErrorOutput('NULL ast', ast);
          } else {
            if (Array.isArray(ast)) {
              for (let i = 0; i < ast.length; i++) {
                this.astGeneric(ast[i], retArr);
              }
              return retArr;
            }
  
            switch (ast.type) {
              case 'FunctionDeclaration':
                return this.astFunctionDeclaration(ast, retArr);
              case 'FunctionExpression':
                return this.astFunctionExpression(ast, retArr);
              case 'ReturnStatement':
                return this.astReturnStatement(ast, retArr);
              case 'Literal':
                return this.astLiteral(ast, retArr);
              case 'BinaryExpression':
                return this.astBinaryExpression(ast, retArr);
              case 'Identifier':
                return this.astIdentifierExpression(ast, retArr);
              case 'AssignmentExpression':
                return this.astAssignmentExpression(ast, retArr);
              case 'ExpressionStatement':
                return this.astExpressionStatement(ast, retArr);
              case 'EmptyStatement':
                return this.astEmptyStatement(ast, retArr);
              case 'BlockStatement':
                return this.astBlockStatement(ast, retArr);
              case 'IfStatement':
                return this.astIfStatement(ast, retArr);
              case 'SwitchStatement':
                return this.astSwitchStatement(ast, retArr);
              case 'BreakStatement':
                return this.astBreakStatement(ast, retArr);
              case 'ContinueStatement':
                return this.astContinueStatement(ast, retArr);
              case 'ForStatement':
                return this.astForStatement(ast, retArr);
              case 'WhileStatement':
                return this.astWhileStatement(ast, retArr);
              case 'DoWhileStatement':
                return this.astDoWhileStatement(ast, retArr);
              case 'VariableDeclaration':
                return this.astVariableDeclaration(ast, retArr);
              case 'VariableDeclarator':
                return this.astVariableDeclarator(ast, retArr);
              case 'ThisExpression':
                return this.astThisExpression(ast, retArr);
              case 'SequenceExpression':
                return this.astSequenceExpression(ast, retArr);
              case 'UnaryExpression':
                return this.astUnaryExpression(ast, retArr);
              case 'UpdateExpression':
                return this.astUpdateExpression(ast, retArr);
              case 'LogicalExpression':
                return this.astLogicalExpression(ast, retArr);
              case 'MemberExpression':
                return this.astMemberExpression(ast, retArr);
              case 'CallExpression':
                return this.astCallExpression(ast, retArr);
              case 'ArrayExpression':
                return this.astArrayExpression(ast, retArr);
              case 'DebuggerStatement':
                return this.astDebuggerStatement(ast, retArr);
              case 'ConditionalExpression':
                return this.astConditionalExpression(ast, retArr);
            }
  
            throw this.astErrorOutput('Unknown ast type : ' + ast.type, ast);
          }
        }
        astErrorOutput(error, ast) {
          if (typeof this.source !== 'string') {
            return new Error(error);
          }
  
          const debugString = utils.getAstString(this.source, ast);
          const leadingSource = this.source.substr(ast.start);
          const splitLines = leadingSource.split(/\n/);
          const lineBefore = splitLines.length > 0 ? splitLines[splitLines.length - 1] : 0;
          return new Error(`${error} on line ${ splitLines.length }, position ${ lineBefore.length }:\n ${ debugString }`);
        }
  
        astDebuggerStatement(arrNode, retArr) {
          return retArr;
        }
  
        astConditionalExpression(ast, retArr) {
          if (ast.type !== 'ConditionalExpression') {
            throw this.astErrorOutput('Not a conditional expression', ast);
          }
          retArr.push('(');
          this.astGeneric(ast.test, retArr);
          retArr.push('?');
          this.astGeneric(ast.consequent, retArr);
          retArr.push(':');
          this.astGeneric(ast.alternate, retArr);
          retArr.push(')');
          return retArr;
        }
  
        astFunction(ast, retArr) {
          throw new Error(`"astFunction" not defined on ${ this.constructor.name }`);
        }
  
        astFunctionDeclaration(ast, retArr) {
          if (this.isChildFunction(ast)) {
            return retArr;
          }
          return this.astFunction(ast, retArr);
        }
        astFunctionExpression(ast, retArr) {
          if (this.isChildFunction(ast)) {
            return retArr;
          }
          return this.astFunction(ast, retArr);
        }
        isChildFunction(ast) {
          for (let i = 0; i < this.functions.length; i++) {
            if (this.functions[i] === ast) {
              return true;
            }
          }
          return false;
        }
        astReturnStatement(ast, retArr) {
          return retArr;
        }
        astLiteral(ast, retArr) {
          this.literalTypes[this.astKey(ast)] = 'Number';
          return retArr;
        }
        astBinaryExpression(ast, retArr) {
          return retArr;
        }
        astIdentifierExpression(ast, retArr) {
          return retArr;
        }
        astAssignmentExpression(ast, retArr) {
          return retArr;
        }
        astExpressionStatement(esNode, retArr) {
          this.astGeneric(esNode.expression, retArr);
          retArr.push(';');
          return retArr;
        }
        astEmptyStatement(eNode, retArr) {
          return retArr;
        }
        astBlockStatement(ast, retArr) {
          return retArr;
        }
        astIfStatement(ast, retArr) {
          return retArr;
        }
        astSwitchStatement(ast, retArr) {
          return retArr;
        }
        astBreakStatement(brNode, retArr) {
          retArr.push('break;');
          return retArr;
        }
        astContinueStatement(crNode, retArr) {
          retArr.push('continue;\n');
          return retArr;
        }
        astForStatement(ast, retArr) {
          return retArr;
        }
        astWhileStatement(ast, retArr) {
          return retArr;
        }
        astDoWhileStatement(ast, retArr) {
          return retArr;
        }
        astVariableDeclarator(iVarDecNode, retArr) {
          this.astGeneric(iVarDecNode.id, retArr);
          if (iVarDecNode.init !== null) {
            retArr.push('=');
            this.astGeneric(iVarDecNode.init, retArr);
          }
          return retArr;
        }
        astThisExpression(ast, retArr) {
          return retArr;
        }
        astSequenceExpression(sNode, retArr) {
          const { expressions } = sNode;
          const sequenceResult = [];
          for (let i = 0; i < expressions.length; i++) {
            const expression = expressions[i];
            const expressionResult = [];
            this.astGeneric(expression, expressionResult);
            sequenceResult.push(expressionResult.join(''));
          }
          if (sequenceResult.length > 1) {
            retArr.push('(', sequenceResult.join(','), ')');
          } else {
            retArr.push(sequenceResult[0]);
          }
          return retArr;
        }
        astUnaryExpression(uNode, retArr) {
          const unaryResult = this.checkAndUpconvertBitwiseUnary(uNode, retArr);
          if (unaryResult) {
            return retArr;
          }
  
          if (uNode.prefix) {
            retArr.push(uNode.operator);
            this.astGeneric(uNode.argument, retArr);
          } else {
            this.astGeneric(uNode.argument, retArr);
            retArr.push(uNode.operator);
          }
  
          return retArr;
        }
  
        checkAndUpconvertBitwiseUnary(uNode, retArr) {}
  
        astUpdateExpression(uNode, retArr) {
          if (uNode.prefix) {
            retArr.push(uNode.operator);
            this.astGeneric(uNode.argument, retArr);
          } else {
            this.astGeneric(uNode.argument, retArr);
            retArr.push(uNode.operator);
          }
  
          return retArr;
        }
        astLogicalExpression(logNode, retArr) {
          retArr.push('(');
          this.astGeneric(logNode.left, retArr);
          retArr.push(logNode.operator);
          this.astGeneric(logNode.right, retArr);
          retArr.push(')');
          return retArr;
        }
        astMemberExpression(ast, retArr) {
          return retArr;
        }
        astCallExpression(ast, retArr) {
          return retArr;
        }
        astArrayExpression(ast, retArr) {
          return retArr;
        }
  
        getMemberExpressionDetails(ast) {
          if (ast.type !== 'MemberExpression') {
            throw this.astErrorOutput(`Expression ${ ast.type } not a MemberExpression`, ast);
          }
          let name = null;
          let type = null;
          const variableSignature = this.getVariableSignature(ast);
          switch (variableSignature) {
            case 'value':
              return null;
            case 'value.thread.value':
            case 'this.thread.value':
            case 'this.output.value':
              return {
                signature: variableSignature,
                  type: 'Integer',
                  name: ast.property.name
              };
            case 'value[]':
              if (typeof ast.object.name !== 'string') {
                throw this.astErrorOutput('Unexpected expression', ast);
              }
              name = ast.object.name;
              return {
                name,
                origin: 'user',
                  signature: variableSignature,
                  type: this.getVariableType(ast.object),
                  xProperty: ast.property
              };
            case 'value[][]':
              if (typeof ast.object.object.name !== 'string') {
                throw this.astErrorOutput('Unexpected expression', ast);
              }
              name = ast.object.object.name;
              return {
                name,
                origin: 'user',
                  signature: variableSignature,
                  type: this.getVariableType(ast.object.object),
                  yProperty: ast.object.property,
                  xProperty: ast.property,
              };
            case 'value[][][]':
              if (typeof ast.object.object.object.name !== 'string') {
                throw this.astErrorOutput('Unexpected expression', ast);
              }
              name = ast.object.object.object.name;
              return {
                name,
                origin: 'user',
                  signature: variableSignature,
                  type: this.getVariableType(ast.object.object.object),
                  zProperty: ast.object.object.property,
                  yProperty: ast.object.property,
                  xProperty: ast.property,
              };
            case 'value[][][][]':
              if (typeof ast.object.object.object.object.name !== 'string') {
                throw this.astErrorOutput('Unexpected expression', ast);
              }
              name = ast.object.object.object.object.name;
              return {
                name,
                origin: 'user',
                  signature: variableSignature,
                  type: this.getVariableType(ast.object.object.object.object),
                  zProperty: ast.object.object.property,
                  yProperty: ast.object.property,
                  xProperty: ast.property,
              };
            case 'value.value':
              if (typeof ast.property.name !== 'string') {
                throw this.astErrorOutput('Unexpected expression', ast);
              }
              if (this.isAstMathVariable(ast)) {
                name = ast.property.name;
                return {
                  name,
                  origin: 'Math',
                  type: 'Number',
                  signature: variableSignature,
                };
              }
              switch (ast.property.name) {
                case 'r':
                case 'g':
                case 'b':
                case 'a':
                  name = ast.object.name;
                  return {
                    name,
                    property: ast.property.name,
                      origin: 'user',
                      signature: variableSignature,
                      type: 'Number'
                  };
                default:
                  throw this.astErrorOutput('Unexpected expression', ast);
              }
              case 'this.constants.value':
                if (typeof ast.property.name !== 'string') {
                  throw this.astErrorOutput('Unexpected expression', ast);
                }
                name = ast.property.name;
                type = this.getConstantType(name);
                if (!type) {
                  throw this.astErrorOutput('Constant has no type', ast);
                }
                return {
                  name,
                  type,
                  origin: 'constants',
                    signature: variableSignature,
                };
              case 'this.constants.value[]':
                if (typeof ast.object.property.name !== 'string') {
                  throw this.astErrorOutput('Unexpected expression', ast);
                }
                name = ast.object.property.name;
                type = this.getConstantType(name);
                if (!type) {
                  throw this.astErrorOutput('Constant has no type', ast);
                }
                return {
                  name,
                  type,
                  origin: 'constants',
                    signature: variableSignature,
                    xProperty: ast.property,
                };
              case 'this.constants.value[][]': {
                if (typeof ast.object.object.property.name !== 'string') {
                  throw this.astErrorOutput('Unexpected expression', ast);
                }
                name = ast.object.object.property.name;
                type = this.getConstantType(name);
                if (!type) {
                  throw this.astErrorOutput('Constant has no type', ast);
                }
                return {
                  name,
                  type,
                  origin: 'constants',
                  signature: variableSignature,
                  yProperty: ast.object.property,
                  xProperty: ast.property,
                };
              }
              case 'this.constants.value[][][]': {
                if (typeof ast.object.object.object.property.name !== 'string') {
                  throw this.astErrorOutput('Unexpected expression', ast);
                }
                name = ast.object.object.object.property.name;
                type = this.getConstantType(name);
                if (!type) {
                  throw this.astErrorOutput('Constant has no type', ast);
                }
                return {
                  name,
                  type,
                  origin: 'constants',
                  signature: variableSignature,
                  zProperty: ast.object.object.property,
                  yProperty: ast.object.property,
                  xProperty: ast.property,
                };
              }
              case 'fn()[]':
              case 'fn()[][]':
              case '[][]':
                return {
                  signature: variableSignature,
                    property: ast.property,
                };
              default:
                throw this.astErrorOutput('Unexpected expression', ast);
          }
        }
  
        findIdentifierOrigin(astToFind) {
          const stack = [this.ast];
  
          while (stack.length > 0) {
            const atNode = stack[0];
            if (atNode.type === 'VariableDeclarator' && atNode.id && atNode.id.name && atNode.id.name === astToFind.name) {
              return atNode;
            }
            stack.shift();
            if (atNode.argument) {
              stack.push(atNode.argument);
            } else if (atNode.body) {
              stack.push(atNode.body);
            } else if (atNode.declarations) {
              stack.push(atNode.declarations);
            } else if (Array.isArray(atNode)) {
              for (let i = 0; i < atNode.length; i++) {
                stack.push(atNode[i]);
              }
            }
          }
          return null;
        }
  
        findLastReturn(ast) {
          const stack = [ast || this.ast];
  
          while (stack.length > 0) {
            const atNode = stack.pop();
            if (atNode.type === 'ReturnStatement') {
              return atNode;
            }
            if (atNode.type === 'FunctionDeclaration') {
              continue;
            }
            if (atNode.argument) {
              stack.push(atNode.argument);
            } else if (atNode.body) {
              stack.push(atNode.body);
            } else if (atNode.declarations) {
              stack.push(atNode.declarations);
            } else if (Array.isArray(atNode)) {
              for (let i = 0; i < atNode.length; i++) {
                stack.push(atNode[i]);
              }
            } else if (atNode.consequent) {
              stack.push(atNode.consequent);
            } else if (atNode.cases) {
              stack.push(atNode.cases);
            }
          }
          return null;
        }
  
        getInternalVariableName(name) {
          if (!this._internalVariableNames.hasOwnProperty(name)) {
            this._internalVariableNames[name] = 0;
          }
          this._internalVariableNames[name]++;
          if (this._internalVariableNames[name] === 1) {
            return name;
          }
          return name + this._internalVariableNames[name];
        }
  
        astKey(ast, separator = ',') {
          if (!ast.start || !ast.end) throw new Error('AST start and end needed');
          return `${ast.start}${separator}${ast.end}`;
        }
      }
  
      const typeLookupMap = {
        'Number': 'Number',
        'Float': 'Float',
        'Integer': 'Integer',
        'Array': 'Number',
        'Array(2)': 'Number',
        'Array(3)': 'Number',
        'Array(4)': 'Number',
        'Matrix(2)': 'Number',
        'Matrix(3)': 'Number',
        'Matrix(4)': 'Number',
        'Array2D': 'Number',
        'Array3D': 'Number',
        'Input': 'Number',
        'HTMLCanvas': 'Array(4)',
        'OffscreenCanvas': 'Array(4)',
        'HTMLImage': 'Array(4)',
        'ImageBitmap': 'Array(4)',
        'ImageData': 'Array(4)',
        'HTMLVideo': 'Array(4)',
        'HTMLImageArray': 'Array(4)',
        'NumberTexture': 'Number',
        'MemoryOptimizedNumberTexture': 'Number',
        'Array1D(2)': 'Array(2)',
        'Array1D(3)': 'Array(3)',
        'Array1D(4)': 'Array(4)',
        'Array2D(2)': 'Array(2)',
        'Array2D(3)': 'Array(3)',
        'Array2D(4)': 'Array(4)',
        'Array3D(2)': 'Array(2)',
        'Array3D(3)': 'Array(3)',
        'Array3D(4)': 'Array(4)',
        'ArrayTexture(1)': 'Number',
        'ArrayTexture(2)': 'Array(2)',
        'ArrayTexture(3)': 'Array(3)',
        'ArrayTexture(4)': 'Array(4)',
      };
  
      module.exports = {
        FunctionNode
      };
      },{"../utils":114,"./function-tracer":11,"acorn":1}],11:[function(require,module,exports){
      const { utils } = require('../utils');
  
      function last(array) {
        return array.length > 0 ? array[array.length - 1] : null;
      }
  
      const states = {
        trackIdentifiers: 'trackIdentifiers',
        memberExpression: 'memberExpression',
        inForLoopInit: 'inForLoopInit'
      };
  
      class FunctionTracer {
        constructor(ast) {
          this.runningContexts = [];
          this.functionContexts = [];
          this.contexts = [];
          this.functionCalls = [];
          this.declarations = [];
          this.identifiers = [];
          this.functions = [];
          this.returnStatements = [];
          this.trackedIdentifiers = null;
          this.states = [];
          this.newFunctionContext();
          this.scan(ast);
        }
  
        isState(state) {
          return this.states[this.states.length - 1] === state;
        }
  
        hasState(state) {
          return this.states.indexOf(state) > -1;
        }
  
        pushState(state) {
          this.states.push(state);
        }
  
        popState(state) {
          if (this.isState(state)) {
            this.states.pop();
          } else {
            throw new Error(`Cannot pop the non-active state "${state}"`);
          }
        }
  
        get currentFunctionContext() {
          return last(this.functionContexts);
        }
  
        get currentContext() {
          return last(this.runningContexts);
        }
  
        newFunctionContext() {
          const newContext = { '@contextType': 'function' };
          this.contexts.push(newContext);
          this.functionContexts.push(newContext);
        }
  
        newContext(run) {
          const newContext = Object.assign({ '@contextType': 'const/let' }, this.currentContext);
          this.contexts.push(newContext);
          this.runningContexts.push(newContext);
          run();
          const { currentFunctionContext } = this;
          for (const p in currentFunctionContext) {
            if (!currentFunctionContext.hasOwnProperty(p) || newContext.hasOwnProperty(p)) continue;
            newContext[p] = currentFunctionContext[p];
          }
          this.runningContexts.pop();
          return newContext;
        }
  
        useFunctionContext(run) {
          const functionContext = last(this.functionContexts);
          this.runningContexts.push(functionContext);
          run();
          this.runningContexts.pop();
        }
  
        getIdentifiers(run) {
          const trackedIdentifiers = this.trackedIdentifiers = [];
          this.pushState(states.trackIdentifiers);
          run();
          this.trackedIdentifiers = null;
          this.popState(states.trackIdentifiers);
          return trackedIdentifiers;
        }
  
        getDeclaration(name) {
          const { currentContext, currentFunctionContext, runningContexts } = this;
          const declaration = currentContext[name] || currentFunctionContext[name] || null;
  
          if (
            !declaration &&
            currentContext === currentFunctionContext &&
            runningContexts.length > 0
          ) {
            const previousRunningContext = runningContexts[runningContexts.length - 2];
            if (previousRunningContext[name]) {
              return previousRunningContext[name];
            }
          }
  
          return declaration;
        }
  
        scan(ast) {
          if (!ast) return;
          if (Array.isArray(ast)) {
            for (let i = 0; i < ast.length; i++) {
              this.scan(ast[i]);
            }
            return;
          }
          switch (ast.type) {
            case 'Program':
              this.useFunctionContext(() => {
                this.scan(ast.body);
              });
              break;
            case 'BlockStatement':
              this.newContext(() => {
                this.scan(ast.body);
              });
              break;
            case 'AssignmentExpression':
            case 'LogicalExpression':
              this.scan(ast.left);
              this.scan(ast.right);
              break;
            case 'BinaryExpression':
              this.scan(ast.left);
              this.scan(ast.right);
              break;
            case 'UpdateExpression':
              if (ast.operator === '++') {
                const declaration = this.getDeclaration(ast.argument.name);
                if (declaration) {
                  declaration.suggestedType = 'Integer';
                }
              }
              this.scan(ast.argument);
              break;
            case 'UnaryExpression':
              this.scan(ast.argument);
              break;
            case 'VariableDeclaration':
              if (ast.kind === 'var') {
                this.useFunctionContext(() => {
                  ast.declarations = utils.normalizeDeclarations(ast);
                  this.scan(ast.declarations);
                });
              } else {
                ast.declarations = utils.normalizeDeclarations(ast);
                this.scan(ast.declarations);
              }
              break;
            case 'VariableDeclarator': {
              const { currentContext } = this;
              const inForLoopInit = this.hasState(states.inForLoopInit);
              const declaration = {
                ast: ast,
                context: currentContext,
                name: ast.id.name,
                origin: 'declaration',
                inForLoopInit,
                inForLoopTest: null,
                assignable: currentContext === this.currentFunctionContext || (!inForLoopInit && !currentContext.hasOwnProperty(ast.id.name)),
                suggestedType: null,
                valueType: null,
                dependencies: null,
                isSafe: null,
              };
              if (!currentContext[ast.id.name]) {
                currentContext[ast.id.name] = declaration;
              }
              this.declarations.push(declaration);
              this.scan(ast.id);
              this.scan(ast.init);
              break;
            }
            case 'FunctionExpression':
            case 'FunctionDeclaration':
              if (this.runningContexts.length === 0) {
                this.scan(ast.body);
              } else {
                this.functions.push(ast);
              }
              break;
            case 'IfStatement':
              this.scan(ast.test);
              this.scan(ast.consequent);
              if (ast.alternate) this.scan(ast.alternate);
              break;
            case 'ForStatement': {
              let testIdentifiers;
              const context = this.newContext(() => {
                this.pushState(states.inForLoopInit);
                this.scan(ast.init);
                this.popState(states.inForLoopInit);
  
                testIdentifiers = this.getIdentifiers(() => {
                  this.scan(ast.test);
                });
  
                this.scan(ast.update);
                this.newContext(() => {
                  this.scan(ast.body);
                });
              });
  
              if (testIdentifiers) {
                for (const p in context) {
                  if (p === '@contextType') continue;
                  if (testIdentifiers.indexOf(p) > -1) {
                    context[p].inForLoopTest = true;
                  }
                }
              }
              break;
            }
            case 'DoWhileStatement':
            case 'WhileStatement':
              this.newContext(() => {
                this.scan(ast.body);
                this.scan(ast.test);
              });
              break;
            case 'Identifier': {
              if (this.isState(states.trackIdentifiers)) {
                this.trackedIdentifiers.push(ast.name);
              }
              this.identifiers.push({
                context: this.currentContext,
                declaration: this.getDeclaration(ast.name),
                ast,
              });
              break;
            }
            case 'ReturnStatement':
              this.returnStatements.push(ast);
              this.scan(ast.argument);
              break;
            case 'MemberExpression':
              this.pushState(states.memberExpression);
              this.scan(ast.object);
              this.scan(ast.property);
              this.popState(states.memberExpression);
              break;
            case 'ExpressionStatement':
              this.scan(ast.expression);
              break;
            case 'SequenceExpression':
              this.scan(ast.expressions);
              break;
            case 'CallExpression':
              this.functionCalls.push({
                context: this.currentContext,
                ast,
              });
              this.scan(ast.arguments);
              break;
            case 'ArrayExpression':
              this.scan(ast.elements);
              break;
            case 'ConditionalExpression':
              this.scan(ast.test);
              this.scan(ast.alternate);
              this.scan(ast.consequent);
              break;
            case 'SwitchStatement':
              this.scan(ast.discriminant);
              this.scan(ast.cases);
              break;
            case 'SwitchCase':
              this.scan(ast.test);
              this.scan(ast.consequent);
              break;
  
            case 'ThisExpression':
            case 'Literal':
            case 'DebuggerStatement':
            case 'EmptyStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
              break;
            default:
              throw new Error(`unhandled type "${ast.type}"`);
          }
        }
      }
  
      module.exports = {
        FunctionTracer,
      };
      },{"../utils":114}],12:[function(require,module,exports){
      const { glWiretap } = require('gl-wiretap');
      const { utils } = require('../../utils');
  
      function toStringWithoutUtils(fn) {
        return fn.toString()
          .replace('=>', '')
          .replace(/^function /, '')
          .replace(/utils[.]/g, '/*utils.*/');
      }
  
      function glKernelString(Kernel, args, originKernel, setupContextString, destroyContextString) {
        if (!originKernel.built) {
          originKernel.build.apply(originKernel, args);
        }
        args = args ? Array.from(args).map(arg => {
          switch (typeof arg) {
            case 'boolean':
              return new Boolean(arg);
            case 'number':
              return new Number(arg);
            default:
              return arg;
          }
        }) : null;
        const postResult = [];
        const context = glWiretap(originKernel.context, {
          useTrackablePrimitives: true,
          onReadPixels: (targetName) => {
            if (kernel.subKernels) {
              if (!subKernelsResultVariableSetup) {
                postResult.push(`    const result = { result: ${getRenderString(targetName, kernel)} };`);
                subKernelsResultVariableSetup = true;
              } else {
                const property = kernel.subKernels[subKernelsResultIndex++].property;
                postResult.push(`    result${isNaN(property) ? '.' + property : `[${property}]`} = ${getRenderString(targetName, kernel)};`);
              }
              if (subKernelsResultIndex === kernel.subKernels.length) {
                postResult.push('    return result;');
              }
              return;
            }
            if (targetName) {
              postResult.push(`    return ${getRenderString(targetName, kernel)};`);
            } else {
              postResult.push(`    return null;`);
            }
          },
          onUnrecognizedArgumentLookup: (argument) => {
            const argumentName = findKernelValue(argument, kernel.kernelArguments, [], context);
            if (argumentName) {
              return argumentName;
            }
            const constantName = findKernelValue(argument, kernel.kernelConstants, constants ? Object.keys(constants).map(key => constants[key]) : [], context);
            if (constantName) {
              return constantName;
            }
            return null;
          }
        });
        let subKernelsResultVariableSetup = false;
        let subKernelsResultIndex = 0;
        const {
          source,
          canvas,
          output,
          pipeline,
          graphical,
          loopMaxIterations,
          constants,
          optimizeFloatMemory,
          precision,
          fixIntegerDivisionAccuracy,
          functions,
          nativeFunctions,
          subKernels,
          immutable,
          argumentTypes,
          constantTypes,
          kernelArguments,
          kernelConstants,
          tactic,
        } = originKernel;
        const kernel = new Kernel(source, {
          canvas,
          context,
          checkContext: false,
          output,
          pipeline,
          graphical,
          loopMaxIterations,
          constants,
          optimizeFloatMemory,
          precision,
          fixIntegerDivisionAccuracy,
          functions,
          nativeFunctions,
          subKernels,
          immutable,
          argumentTypes,
          constantTypes,
          tactic,
        });
        let result = [];
        context.setIndent(2);
        kernel.build.apply(kernel, args);
        result.push(context.toString());
        context.reset();
  
        kernel.kernelArguments.forEach((kernelArgument, i) => {
          switch (kernelArgument.type) {
            case 'Integer':
            case 'Boolean':
            case 'Number':
            case 'Float':
            case 'Array':
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
            case 'HTMLCanvas':
            case 'HTMLImage':
            case 'HTMLVideo':
              context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);
              break;
            case 'HTMLImageArray':
              for (let imageIndex = 0; imageIndex < args[i].length; imageIndex++) {
                const arg = args[i];
                context.insertVariable(`uploadValue_${kernelArgument.name}[${imageIndex}]`, arg[imageIndex]);
              }
              break;
            case 'Input':
              context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);
              break;
            case 'MemoryOptimizedNumberTexture':
            case 'NumberTexture':
            case 'Array1D(2)':
            case 'Array1D(3)':
            case 'Array1D(4)':
            case 'Array2D(2)':
            case 'Array2D(3)':
            case 'Array2D(4)':
            case 'Array3D(2)':
            case 'Array3D(3)':
            case 'Array3D(4)':
            case 'ArrayTexture(1)':
            case 'ArrayTexture(2)':
            case 'ArrayTexture(3)':
            case 'ArrayTexture(4)':
              context.insertVariable(`uploadValue_${kernelArgument.name}`, args[i].texture);
              break;
            default:
              throw new Error(`unhandled kernelArgumentType insertion for glWiretap of type ${kernelArgument.type}`);
          }
        });
        result.push('/** start of injected functions **/');
        result.push(`function ${toStringWithoutUtils(utils.flattenTo)}`);
        result.push(`function ${toStringWithoutUtils(utils.flatten2dArrayTo)}`);
        result.push(`function ${toStringWithoutUtils(utils.flatten3dArrayTo)}`);
        result.push(`function ${toStringWithoutUtils(utils.flatten4dArrayTo)}`);
        result.push(`function ${toStringWithoutUtils(utils.isArray)}`);
        if (kernel.renderOutput !== kernel.renderTexture && kernel.formatValues) {
          result.push(
            `  const renderOutput = function ${toStringWithoutUtils(kernel.formatValues)};`
          );
        }
        result.push('/** end of injected functions **/');
        result.push(`  const innerKernel = function (${kernel.kernelArguments.map(kernelArgument => kernelArgument.varName).join(', ')}) {`);
        context.setIndent(4);
        kernel.run.apply(kernel, args);
        if (kernel.renderKernels) {
          kernel.renderKernels();
        } else if (kernel.renderOutput) {
          kernel.renderOutput();
        }
        result.push('    /** start setup uploads for kernel values **/');
        kernel.kernelArguments.forEach(kernelArgument => {
          result.push('    ' + kernelArgument.getStringValueHandler().split('\n').join('\n    '));
        });
        result.push('    /** end setup uploads for kernel values **/');
        result.push(context.toString());
        if (kernel.renderOutput === kernel.renderTexture) {
          context.reset();
          const framebufferName = context.getContextVariableName(kernel.framebuffer);
          if (kernel.renderKernels) {
            const results = kernel.renderKernels();
            const textureName = context.getContextVariableName(kernel.texture.texture);
            result.push(`    return {
        result: {
          texture: ${ textureName },
          type: '${ results.result.type }',
          toArray: ${ getToArrayString(results.result, textureName, framebufferName) }
        },`);
            const { subKernels, mappedTextures } = kernel;
            for (let i = 0; i < subKernels.length; i++) {
              const texture = mappedTextures[i];
              const subKernel = subKernels[i];
              const subKernelResult = results[subKernel.property];
              const subKernelTextureName = context.getContextVariableName(texture.texture);
              result.push(`
        ${subKernel.property}: {
          texture: ${ subKernelTextureName },
          type: '${ subKernelResult.type }',
          toArray: ${ getToArrayString(subKernelResult, subKernelTextureName, framebufferName) }
        },`);
            }
            result.push(`    };`);
          } else {
            const rendered = kernel.renderOutput();
            const textureName = context.getContextVariableName(kernel.texture.texture);
            result.push(`    return {
          texture: ${ textureName },
          type: '${ rendered.type }',
          toArray: ${ getToArrayString(rendered, textureName, framebufferName) }
        };`);
          }
        }
        result.push(`    ${destroyContextString ? '\n' + destroyContextString + '    ': ''}`);
        result.push(postResult.join('\n'));
        result.push('  };');
        if (kernel.graphical) {
          result.push(getGetPixelsString(kernel));
          result.push(`  innerKernel.getPixels = getPixels;`);
        }
        result.push('  return innerKernel;');
  
        let constantsUpload = [];
        kernelConstants.forEach((kernelConstant) => {
          constantsUpload.push(`${kernelConstant.getStringValueHandler()}`);
        });
        return `function kernel(settings) {
    const { context, constants } = settings;
    ${constantsUpload.join('')}
    ${setupContextString ? setupContextString : ''}
  ${result.join('\n')}
  }`;
      }
  
      function getRenderString(targetName, kernel) {
        const readBackValue = kernel.precision === 'single' ? targetName : `new Float32Array(${targetName}.buffer)`;
        if (kernel.output[2]) {
          return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]}, ${kernel.output[2]})`;
        }
        if (kernel.output[1]) {
          return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]})`;
        }
  
        return `renderOutput(${readBackValue}, ${kernel.output[0]})`;
      }
  
      function getGetPixelsString(kernel) {
        const getPixels = kernel.getPixels.toString();
        const useFunctionKeyword = !/^function/.test(getPixels);
        return utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ getPixels }`, {
          findDependency: (object, name) => {
            if (object === 'utils') {
              return `const ${name} = ${utils[name].toString()};`;
            }
            return null;
          },
          thisLookup: (property) => {
            if (property === 'context') {
              return null;
            }
            if (kernel.hasOwnProperty(property)) {
              return JSON.stringify(kernel[property]);
            }
            throw new Error(`unhandled thisLookup ${ property }`);
          }
        });
      }
  
      function getToArrayString(kernelResult, textureName, framebufferName) {
        const toArray = kernelResult.toArray.toString();
        const useFunctionKeyword = !/^function/.test(toArray);
        const flattenedFunctions = utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ toArray }`, {
          findDependency: (object, name) => {
            if (object === 'utils') {
              return `const ${name} = ${utils[name].toString()};`;
            } else if (object === 'this') {
              if (name === 'framebuffer') {
                return '';
              }
              return `${useFunctionKeyword ? 'function ' : ''}${kernelResult[name].toString()}`;
            } else {
              throw new Error('unhandled fromObject');
            }
          },
          thisLookup: (property, isDeclaration) => {
            if (property === 'texture') {
              return textureName;
            }
            if (property === 'context') {
              if (isDeclaration) return null;
              return 'gl';
            }
            if (kernelResult.hasOwnProperty(property)) {
              return JSON.stringify(kernelResult[property]);
            }
            throw new Error(`unhandled thisLookup ${ property }`);
          }
        });
        return `() => {
    function framebuffer() { return ${framebufferName}; };
    ${flattenedFunctions}
    return toArray();
    }`;
      }
  
      function findKernelValue(argument, kernelValues, values, context, uploadedValues) {
        if (argument === null) return null;
        if (kernelValues === null) return null;
        switch (typeof argument) {
          case 'boolean':
          case 'number':
            return null;
        }
        if (
          typeof HTMLImageElement !== 'undefined' &&
          argument instanceof HTMLImageElement
        ) {
          for (let i = 0; i < kernelValues.length; i++) {
            const kernelValue = kernelValues[i];
            if (kernelValue.type !== 'HTMLImageArray' && kernelValue) continue;
            if (kernelValue.uploadValue !== argument) continue;
            const variableIndex = values[i].indexOf(argument);
            if (variableIndex === -1) continue;
            const variableName = `uploadValue_${kernelValue.name}[${variableIndex}]`;
            context.insertVariable(variableName, argument);
            return variableName;
          }
        }
  
        for (let i = 0; i < kernelValues.length; i++) {
          const kernelValue = kernelValues[i];
          if (argument !== kernelValue.uploadValue) continue;
          const variable = `uploadValue_${kernelValue.name}`;
          context.insertVariable(variable, kernelValue);
          return variable;
        }
        return null;
      }
  
      module.exports = {
        glKernelString
      };
      },{"../../utils":114,"gl-wiretap":3}],13:[function(require,module,exports){
      const { Kernel } = require('../kernel');
      const { utils } = require('../../utils');
      const { GLTextureArray2Float } = require('./texture/array-2-float');
      const { GLTextureArray2Float2D } = require('./texture/array-2-float-2d');
      const { GLTextureArray2Float3D } = require('./texture/array-2-float-3d');
      const { GLTextureArray3Float } = require('./texture/array-3-float');
      const { GLTextureArray3Float2D } = require('./texture/array-3-float-2d');
      const { GLTextureArray3Float3D } = require('./texture/array-3-float-3d');
      const { GLTextureArray4Float } = require('./texture/array-4-float');
      const { GLTextureArray4Float2D } = require('./texture/array-4-float-2d');
      const { GLTextureArray4Float3D } = require('./texture/array-4-float-3d');
      const { GLTextureFloat } = require('./texture/float');
      const { GLTextureFloat2D } = require('./texture/float-2d');
      const { GLTextureFloat3D } = require('./texture/float-3d');
      const { GLTextureMemoryOptimized } = require('./texture/memory-optimized');
      const { GLTextureMemoryOptimized2D } = require('./texture/memory-optimized-2d');
      const { GLTextureMemoryOptimized3D } = require('./texture/memory-optimized-3d');
      const { GLTextureUnsigned } = require('./texture/unsigned');
      const { GLTextureUnsigned2D } = require('./texture/unsigned-2d');
      const { GLTextureUnsigned3D } = require('./texture/unsigned-3d');
      const { GLTextureGraphical } = require('./texture/graphical');
  
      class GLKernel extends Kernel {
        static get mode() {
          return 'gpu';
        }
  
        static getIsFloatRead() {
          const kernelString = `function kernelFunction() {
        return 1;
      }`;
          const kernel = new this(kernelString, {
            context: this.testContext,
            canvas: this.testCanvas,
            validate: false,
            output: [1],
            precision: 'single',
            returnType: 'Number',
            tactic: 'speed',
          });
          kernel.build();
          kernel.run();
          const result = kernel.renderOutput();
          kernel.destroy(true);
          return result[0] === 1;
        }
  
        static getIsIntegerDivisionAccurate() {
          function kernelFunction(v1, v2) {
            return v1[this.thread.x] / v2[this.thread.x];
          }
          const kernel = new this(kernelFunction.toString(), {
            context: this.testContext,
            canvas: this.testCanvas,
            validate: false,
            output: [2],
            returnType: 'Number',
            precision: 'unsigned',
            tactic: 'speed',
          });
          const args = [
            [6, 6030401],
            [3, 3991]
          ];
          kernel.build.apply(kernel, args);
          kernel.run.apply(kernel, args);
          const result = kernel.renderOutput();
          kernel.destroy(true);
          return result[0] === 2 && result[1] === 1511;
        }
  
        static getIsSpeedTacticSupported() {
          function kernelFunction(value) {
            return value[this.thread.x];
          }
          const kernel = new this(kernelFunction.toString(), {
            context: this.testContext,
            canvas: this.testCanvas,
            validate: false,
            output: [4],
            returnType: 'Number',
            precision: 'unsigned',
            tactic: 'speed',
          });
          const args = [
            [0, 1, 2, 3]
          ];
          kernel.build.apply(kernel, args);
          kernel.run.apply(kernel, args);
          const result = kernel.renderOutput();
          kernel.destroy(true);
          return Math.round(result[0]) === 0 && Math.round(result[1]) === 1 && Math.round(result[2]) === 2 && Math.round(result[3]) === 3;
        }
  
        static get testCanvas() {
          throw new Error(`"testCanvas" not defined on ${ this.name }`);
        }
  
        static get testContext() {
          throw new Error(`"testContext" not defined on ${ this.name }`);
        }
  
        static getFeatures() {
          const gl = this.testContext;
          const isDrawBuffers = this.getIsDrawBuffers();
          return Object.freeze({
            isFloatRead: this.getIsFloatRead(),
            isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
            isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
            isTextureFloat: this.getIsTextureFloat(),
            isDrawBuffers,
            kernelMap: isDrawBuffers,
            channelCount: this.getChannelCount(),
            maxTextureSize: this.getMaxTextureSize(),
            lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),
            lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),
            mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),
            mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),
            highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),
            highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),
          });
        }
  
        static setupFeatureChecks() {
          throw new Error(`"setupFeatureChecks" not defined on ${ this.name }`);
        }
  
        static getSignature(kernel, argumentTypes) {
          return kernel.getVariablePrecisionString() + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');
        }
  
        setFixIntegerDivisionAccuracy(fix) {
          this.fixIntegerDivisionAccuracy = fix;
          return this;
        }
  
        setPrecision(flag) {
          this.precision = flag;
          return this;
        }
  
        setFloatTextures(flag) {
          utils.warnDeprecated('method', 'setFloatTextures', 'setOptimizeFloatMemory');
          this.floatTextures = flag;
          return this;
        }
  
        static nativeFunctionArguments(source) {
          const argumentTypes = [];
          const argumentNames = [];
          const states = [];
          const isStartingVariableName = /^[a-zA-Z_]/;
          const isVariableChar = /[a-zA-Z_0-9]/;
          let i = 0;
          let argumentName = null;
          let argumentType = null;
          while (i < source.length) {
            const char = source[i];
            const nextChar = source[i + 1];
            const state = states.length > 0 ? states[states.length - 1] : null;
  
            if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '*') {
              states.push('MULTI_LINE_COMMENT');
              i += 2;
              continue;
            } else if (state === 'MULTI_LINE_COMMENT' && char === '*' && nextChar === '/') {
              states.pop();
              i += 2;
              continue;
            }
  
            else if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '/') {
              states.push('COMMENT');
              i += 2;
              continue;
            } else if (state === 'COMMENT' && char === '\n') {
              states.pop();
              i++;
              continue;
            }
  
            else if (state === null && char === '(') {
              states.push('FUNCTION_ARGUMENTS');
              i++;
              continue;
            } else if (state === 'FUNCTION_ARGUMENTS') {
              if (char === ')') {
                states.pop();
                break;
              }
              if (char === 'f' && nextChar === 'l' && source[i + 2] === 'o' && source[i + 3] === 'a' && source[i + 4] === 't' && source[i + 5] === ' ') {
                states.push('DECLARE_VARIABLE');
                argumentType = 'float';
                argumentName = '';
                i += 6;
                continue;
              } else if (char === 'i' && nextChar === 'n' && source[i + 2] === 't' && source[i + 3] === ' ') {
                states.push('DECLARE_VARIABLE');
                argumentType = 'int';
                argumentName = '';
                i += 4;
                continue;
              } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '2' && source[i + 4] === ' ') {
                states.push('DECLARE_VARIABLE');
                argumentType = 'vec2';
                argumentName = '';
                i += 5;
                continue;
              } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '3' && source[i + 4] === ' ') {
                states.push('DECLARE_VARIABLE');
                argumentType = 'vec3';
                argumentName = '';
                i += 5;
                continue;
              } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '4' && source[i + 4] === ' ') {
                states.push('DECLARE_VARIABLE');
                argumentType = 'vec4';
                argumentName = '';
                i += 5;
                continue;
              }
            }
  
            else if (state === 'DECLARE_VARIABLE') {
              if (argumentName === '') {
                if (char === ' ') {
                  i++;
                  continue;
                }
                if (!isStartingVariableName.test(char)) {
                  throw new Error('variable name is not expected string');
                }
              }
              argumentName += char;
              if (!isVariableChar.test(nextChar)) {
                states.pop();
                argumentNames.push(argumentName);
                argumentTypes.push(typeMap[argumentType]);
              }
            }
  
            i++;
          }
          if (states.length > 0) {
            throw new Error('GLSL function was not parsable');
          }
          return {
            argumentNames,
            argumentTypes,
          };
        }
  
        static nativeFunctionReturnType(source) {
          return typeMap[source.match(/int|float|vec[2-4]/)[0]];
        }
  
        static combineKernels(combinedKernel, lastKernel) {
          combinedKernel.apply(null, arguments);
          const {
            texSize,
            context,
            threadDim
          } = lastKernel.texSize;
          let result;
          if (lastKernel.precision === 'single') {
            const w = texSize[0];
            const h = Math.ceil(texSize[1] / 4);
            result = new Float32Array(w * h * 4 * 4);
            context.readPixels(0, 0, w, h * 4, context.RGBA, context.FLOAT, result);
          } else {
            const bytes = new Uint8Array(texSize[0] * texSize[1] * 4);
            context.readPixels(0, 0, texSize[0], texSize[1], context.RGBA, context.UNSIGNED_BYTE, bytes);
            result = new Float32Array(bytes.buffer);
          }
  
          result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);
  
          if (lastKernel.output.length === 1) {
            return result;
          } else if (lastKernel.output.length === 2) {
            return utils.splitArray(result, lastKernel.output[0]);
          } else if (lastKernel.output.length === 3) {
            const cube = utils.splitArray(result, lastKernel.output[0] * lastKernel.output[1]);
            return cube.map(function(x) {
              return utils.splitArray(x, lastKernel.output[0]);
            });
          }
        }
  
        constructor(source, settings) {
          super(source, settings);
          this.transferValues = null;
          this.formatValues = null;
          this.TextureConstructor = null;
          this.renderOutput = null;
          this.renderRawOutput = null;
          this.texSize = null;
          this.translatedSource = null;
          this.compiledFragmentShader = null;
          this.compiledVertexShader = null;
          this.switchingKernels = null;
          this._textureSwitched = null;
          this._mappedTextureSwitched = null;
        }
  
        checkTextureSize() {
          const { features } = this.constructor;
          if (this.texSize[0] > features.maxTextureSize || this.texSize[1] > features.maxTextureSize) {
            throw new Error(`Texture size [${this.texSize[0]},${this.texSize[1]}] generated by kernel is larger than supported size [${features.maxTextureSize},${features.maxTextureSize}]`);
          }
        }
  
        translateSource() {
          throw new Error(`"translateSource" not defined on ${this.constructor.name}`);
        }
  
        pickRenderStrategy(args) {
          if (this.graphical) {
            this.renderRawOutput = this.readPackedPixelsToUint8Array;
            this.transferValues = (pixels) => pixels;
            this.TextureConstructor = GLTextureGraphical;
            return null;
          }
          if (this.precision === 'unsigned') {
            this.renderRawOutput = this.readPackedPixelsToUint8Array;
            this.transferValues = this.readPackedPixelsToFloat32Array;
            if (this.pipeline) {
              this.renderOutput = this.renderTexture;
              if (this.subKernels !== null) {
                this.renderKernels = this.renderKernelsToTextures;
              }
              switch (this.returnType) {
                case 'LiteralInteger':
                case 'Float':
                case 'Number':
                case 'Integer':
                  if (this.output[2] > 0) {
                    this.TextureConstructor = GLTextureUnsigned3D;
                    return null;
                  } else if (this.output[1] > 0) {
                    this.TextureConstructor = GLTextureUnsigned2D;
                    return null;
                  } else {
                    this.TextureConstructor = GLTextureUnsigned;
                    return null;
                  }
                  case 'Array(2)':
                  case 'Array(3)':
                  case 'Array(4)':
                    return this.requestFallback(args);
              }
            } else {
              if (this.subKernels !== null) {
                this.renderKernels = this.renderKernelsToArrays;
              }
              switch (this.returnType) {
                case 'LiteralInteger':
                case 'Float':
                case 'Number':
                case 'Integer':
                  this.renderOutput = this.renderValues;
                  if (this.output[2] > 0) {
                    this.TextureConstructor = GLTextureUnsigned3D;
                    this.formatValues = utils.erect3DPackedFloat;
                    return null;
                  } else if (this.output[1] > 0) {
                    this.TextureConstructor = GLTextureUnsigned2D;
                    this.formatValues = utils.erect2DPackedFloat;
                    return null;
                  } else {
                    this.TextureConstructor = GLTextureUnsigned;
                    this.formatValues = utils.erectPackedFloat;
                    return null;
                  }
                  case 'Array(2)':
                  case 'Array(3)':
                  case 'Array(4)':
                    return this.requestFallback(args);
              }
            }
          } else if (this.precision === 'single') {
            this.renderRawOutput = this.readFloatPixelsToFloat32Array;
            this.transferValues = this.readFloatPixelsToFloat32Array;
            if (this.pipeline) {
              this.renderOutput = this.renderTexture;
              if (this.subKernels !== null) {
                this.renderKernels = this.renderKernelsToTextures;
              }
              switch (this.returnType) {
                case 'LiteralInteger':
                case 'Float':
                case 'Number':
                case 'Integer': {
                  if (this.optimizeFloatMemory) {
                    if (this.output[2] > 0) {
                      this.TextureConstructor = GLTextureMemoryOptimized3D;
                      return null;
                    } else if (this.output[1] > 0) {
                      this.TextureConstructor = GLTextureMemoryOptimized2D;
                      return null;
                    } else {
                      this.TextureConstructor = GLTextureMemoryOptimized;
                      return null;
                    }
                  } else {
                    if (this.output[2] > 0) {
                      this.TextureConstructor = GLTextureFloat3D;
                      return null;
                    } else if (this.output[1] > 0) {
                      this.TextureConstructor = GLTextureFloat2D;
                      return null;
                    } else {
                      this.TextureConstructor = GLTextureFloat;
                      return null;
                    }
                  }
                }
                case 'Array(2)': {
                  if (this.output[2] > 0) {
                    this.TextureConstructor = GLTextureArray2Float3D;
                    return null;
                  } else if (this.output[1] > 0) {
                    this.TextureConstructor = GLTextureArray2Float2D;
                    return null;
                  } else {
                    this.TextureConstructor = GLTextureArray2Float;
                    return null;
                  }
                }
                case 'Array(3)': {
                  if (this.output[2] > 0) {
                    this.TextureConstructor = GLTextureArray3Float3D;
                    return null;
                  } else if (this.output[1] > 0) {
                    this.TextureConstructor = GLTextureArray3Float2D;
                    return null;
                  } else {
                    this.TextureConstructor = GLTextureArray3Float;
                    return null;
                  }
                }
                case 'Array(4)': {
                  if (this.output[2] > 0) {
                    this.TextureConstructor = GLTextureArray4Float3D;
                    return null;
                  } else if (this.output[1] > 0) {
                    this.TextureConstructor = GLTextureArray4Float2D;
                    return null;
                  } else {
                    this.TextureConstructor = GLTextureArray4Float;
                    return null;
                  }
                }
              }
            }
            this.renderOutput = this.renderValues;
            if (this.subKernels !== null) {
              this.renderKernels = this.renderKernelsToArrays;
            }
            if (this.optimizeFloatMemory) {
              switch (this.returnType) {
                case 'LiteralInteger':
                case 'Float':
                case 'Number':
                case 'Integer': {
                  if (this.output[2] > 0) {
                    this.TextureConstructor = GLTextureMemoryOptimized3D;
                    this.formatValues = utils.erectMemoryOptimized3DFloat;
                    return null;
                  } else if (this.output[1] > 0) {
                    this.TextureConstructor = GLTextureMemoryOptimized2D;
                    this.formatValues = utils.erectMemoryOptimized2DFloat;
                    return null;
                  } else {
                    this.TextureConstructor = GLTextureMemoryOptimized;
                    this.formatValues = utils.erectMemoryOptimizedFloat;
                    return null;
                  }
                }
                case 'Array(2)': {
                  if (this.output[2] > 0) {
                    this.TextureConstructor = GLTextureArray2Float3D;
                    this.formatValues = utils.erect3DArray2;
                    return null;
                  } else if (this.output[1] > 0) {
                    this.TextureConstructor = GLTextureArray2Float2D;
                    this.formatValues = utils.erect2DArray2;
                    return null;
                  } else {
                    this.TextureConstructor = GLTextureArray2Float;
                    this.formatValues = utils.erectArray2;
                    return null;
                  }
                }
                case 'Array(3)': {
                  if (this.output[2] > 0) {
                    this.TextureConstructor = GLTextureArray3Float3D;
                    this.formatValues = utils.erect3DArray3;
                    return null;
                  } else if (this.output[1] > 0) {
                    this.TextureConstructor = GLTextureArray3Float2D;
                    this.formatValues = utils.erect2DArray3;
                    return null;
                  } else {
                    this.TextureConstructor = GLTextureArray3Float;
                    this.formatValues = utils.erectArray3;
                    return null;
                  }
                }
                case 'Array(4)': {
                  if (this.output[2] > 0) {
                    this.TextureConstructor = GLTextureArray4Float3D;
                    this.formatValues = utils.erect3DArray4;
                    return null;
                  } else if (this.output[1] > 0) {
                    this.TextureConstructor = GLTextureArray4Float2D;
                    this.formatValues = utils.erect2DArray4;
                    return null;
                  } else {
                    this.TextureConstructor = GLTextureArray4Float;
                    this.formatValues = utils.erectArray4;
                    return null;
                  }
                }
              }
            } else {
              switch (this.returnType) {
                case 'LiteralInteger':
                case 'Float':
                case 'Number':
                case 'Integer': {
                  if (this.output[2] > 0) {
                    this.TextureConstructor = GLTextureFloat3D;
                    this.formatValues = utils.erect3DFloat;
                    return null;
                  } else if (this.output[1] > 0) {
                    this.TextureConstructor = GLTextureFloat2D;
                    this.formatValues = utils.erect2DFloat;
                    return null;
                  } else {
                    this.TextureConstructor = GLTextureFloat;
                    this.formatValues = utils.erectFloat;
                    return null;
                  }
                }
                case 'Array(2)': {
                  if (this.output[2] > 0) {
                    this.TextureConstructor = GLTextureArray2Float3D;
                    this.formatValues = utils.erect3DArray2;
                    return null;
                  } else if (this.output[1] > 0) {
                    this.TextureConstructor = GLTextureArray2Float2D;
                    this.formatValues = utils.erect2DArray2;
                    return null;
                  } else {
                    this.TextureConstructor = GLTextureArray2Float;
                    this.formatValues = utils.erectArray2;
                    return null;
                  }
                }
                case 'Array(3)': {
                  if (this.output[2] > 0) {
                    this.TextureConstructor = GLTextureArray3Float3D;
                    this.formatValues = utils.erect3DArray3;
                    return null;
                  } else if (this.output[1] > 0) {
                    this.TextureConstructor = GLTextureArray3Float2D;
                    this.formatValues = utils.erect2DArray3;
                    return null;
                  } else {
                    this.TextureConstructor = GLTextureArray3Float;
                    this.formatValues = utils.erectArray3;
                    return null;
                  }
                }
                case 'Array(4)': {
                  if (this.output[2] > 0) {
                    this.TextureConstructor = GLTextureArray4Float3D;
                    this.formatValues = utils.erect3DArray4;
                    return null;
                  } else if (this.output[1] > 0) {
                    this.TextureConstructor = GLTextureArray4Float2D;
                    this.formatValues = utils.erect2DArray4;
                    return null;
                  } else {
                    this.TextureConstructor = GLTextureArray4Float;
                    this.formatValues = utils.erectArray4;
                    return null;
                  }
                }
              }
            }
          } else {
            throw new Error(`unhandled precision of "${this.precision}"`);
          }
  
          throw new Error(`unhandled return type "${this.returnType}"`);
        }
  
        getKernelString() {
          throw new Error(`abstract method call`);
        }
  
        getMainResultTexture() {
          switch (this.returnType) {
            case 'LiteralInteger':
            case 'Float':
            case 'Integer':
            case 'Number':
              return this.getMainResultNumberTexture();
            case 'Array(2)':
              return this.getMainResultArray2Texture();
            case 'Array(3)':
              return this.getMainResultArray3Texture();
            case 'Array(4)':
              return this.getMainResultArray4Texture();
            default:
              throw new Error(`unhandled returnType type ${ this.returnType }`);
          }
        }
  
        getMainResultKernelNumberTexture() {
          throw new Error(`abstract method call`);
        }
        getMainResultSubKernelNumberTexture() {
          throw new Error(`abstract method call`);
        }
        getMainResultKernelArray2Texture() {
          throw new Error(`abstract method call`);
        }
        getMainResultSubKernelArray2Texture() {
          throw new Error(`abstract method call`);
        }
        getMainResultKernelArray3Texture() {
          throw new Error(`abstract method call`);
        }
        getMainResultSubKernelArray3Texture() {
          throw new Error(`abstract method call`);
        }
        getMainResultKernelArray4Texture() {
          throw new Error(`abstract method call`);
        }
        getMainResultSubKernelArray4Texture() {
          throw new Error(`abstract method call`);
        }
        getMainResultGraphical() {
          throw new Error(`abstract method call`);
        }
        getMainResultMemoryOptimizedFloats() {
          throw new Error(`abstract method call`);
        }
        getMainResultPackedPixels() {
          throw new Error(`abstract method call`);
        }
  
        getMainResultString() {
          if (this.graphical) {
            return this.getMainResultGraphical();
          } else if (this.precision === 'single') {
            if (this.optimizeFloatMemory) {
              return this.getMainResultMemoryOptimizedFloats();
            }
            return this.getMainResultTexture();
          } else {
            return this.getMainResultPackedPixels();
          }
        }
  
        getMainResultNumberTexture() {
          return utils.linesToString(this.getMainResultKernelNumberTexture()) +
            utils.linesToString(this.getMainResultSubKernelNumberTexture());
        }
  
        getMainResultArray2Texture() {
          return utils.linesToString(this.getMainResultKernelArray2Texture()) +
            utils.linesToString(this.getMainResultSubKernelArray2Texture());
        }
  
        getMainResultArray3Texture() {
          return utils.linesToString(this.getMainResultKernelArray3Texture()) +
            utils.linesToString(this.getMainResultSubKernelArray3Texture());
        }
  
        getMainResultArray4Texture() {
          return utils.linesToString(this.getMainResultKernelArray4Texture()) +
            utils.linesToString(this.getMainResultSubKernelArray4Texture());
        }
  
        getFloatTacticDeclaration() {
          const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);
          return `precision ${variablePrecision} float;\n`;
        }
  
        getIntTacticDeclaration() {
          return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic, true)} int;\n`;
        }
  
        getSampler2DTacticDeclaration() {
          return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2D;\n`;
        }
  
        getSampler2DArrayTacticDeclaration() {
          return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2DArray;\n`;
        }
  
        renderTexture() {
          return this.immutable ? this.texture.clone() : this.texture;
        }
        readPackedPixelsToUint8Array() {
          if (this.precision !== 'unsigned') throw new Error('Requires this.precision to be "unsigned"');
          const {
            texSize,
            context: gl
          } = this;
          const result = new Uint8Array(texSize[0] * texSize[1] * 4);
          gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
          return result;
        }
  
        readPackedPixelsToFloat32Array() {
          return new Float32Array(this.readPackedPixelsToUint8Array().buffer);
        }
  
        readFloatPixelsToFloat32Array() {
          if (this.precision !== 'single') throw new Error('Requires this.precision to be "single"');
          const {
            texSize,
            context: gl
          } = this;
          const w = texSize[0];
          const h = texSize[1];
          const result = new Float32Array(w * h * 4);
          gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);
          return result;
        }
  
        getPixels(flip) {
          const {
            context: gl,
            output
          } = this;
          const [width, height] = output;
          const pixels = new Uint8Array(width * height * 4);
          gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
          return new Uint8ClampedArray((flip ? pixels : utils.flipPixels(pixels, width, height)).buffer);
        }
  
        renderKernelsToArrays() {
          const result = {
            result: this.renderOutput(),
          };
          for (let i = 0; i < this.subKernels.length; i++) {
            result[this.subKernels[i].property] = this.mappedTextures[i].toArray();
          }
          return result;
        }
  
        renderKernelsToTextures() {
          const result = {
            result: this.renderOutput(),
          };
          if (this.immutable) {
            for (let i = 0; i < this.subKernels.length; i++) {
              result[this.subKernels[i].property] = this.mappedTextures[i].clone();
            }
          } else {
            for (let i = 0; i < this.subKernels.length; i++) {
              result[this.subKernels[i].property] = this.mappedTextures[i];
            }
          }
          return result;
        }
  
        resetSwitchingKernels() {
          const existingValue = this.switchingKernels;
          this.switchingKernels = null;
          return existingValue;
        }
  
        setOutput(output) {
          const newOutput = this.toKernelOutput(output);
          if (this.program) {
            if (!this.dynamicOutput) {
              throw new Error('Resizing a kernel with dynamicOutput: false is not possible');
            }
            const newThreadDim = [newOutput[0], newOutput[1] || 1, newOutput[2] || 1];
            const newTexSize = utils.getKernelTextureSize({
              optimizeFloatMemory: this.optimizeFloatMemory,
              precision: this.precision,
            }, newThreadDim);
            const oldTexSize = this.texSize;
            if (oldTexSize) {
              const oldPrecision = this.getVariablePrecisionString(oldTexSize, this.tactic);
              const newPrecision = this.getVariablePrecisionString(newTexSize, this.tactic);
              if (oldPrecision !== newPrecision) {
                if (this.debug) {
                  console.warn('Precision requirement changed, asking GPU instance to recompile');
                }
                this.switchKernels({
                  type: 'outputPrecisionMismatch',
                  precision: newPrecision,
                  needed: output
                });
                return;
              }
            }
            this.output = newOutput;
            this.threadDim = newThreadDim;
            this.texSize = newTexSize;
            const { context: gl } = this;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
            this.updateMaxTexSize();
            this.framebuffer.width = this.texSize[0];
            this.framebuffer.height = this.texSize[1];
            gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
            this.canvas.width = this.maxTexSize[0];
            this.canvas.height = this.maxTexSize[1];
            if (this.texture) {
              this.texture.delete();
            }
            this.texture = null;
            this._setupOutputTexture();
            if (this.mappedTextures && this.mappedTextures.length > 0) {
              for (let i = 0; i < this.mappedTextures.length; i++) {
                this.mappedTextures[i].delete();
              }
              this.mappedTextures = null;
              this._setupSubOutputTextures();
            }
          } else {
            this.output = newOutput;
          }
          return this;
        }
        renderValues() {
          return this.formatValues(
            this.transferValues(),
            this.output[0],
            this.output[1],
            this.output[2]
          );
        }
        switchKernels(reason) {
          if (this.switchingKernels) {
            this.switchingKernels.push(reason);
          } else {
            this.switchingKernels = [reason];
          }
        }
        getVariablePrecisionString(textureSize = this.texSize, tactic = this.tactic, isInt = false) {
          if (!tactic) {
            if (!this.constructor.features.isSpeedTacticSupported) return 'highp';
            const low = this.constructor.features[isInt ? 'lowIntPrecision' : 'lowFloatPrecision'];
            const medium = this.constructor.features[isInt ? 'mediumIntPrecision' : 'mediumFloatPrecision'];
            const high = this.constructor.features[isInt ? 'highIntPrecision' : 'highFloatPrecision'];
            const requiredSize = Math.log2(textureSize[0] * textureSize[1]);
            if (requiredSize <= low.rangeMax) {
              return 'lowp';
            } else if (requiredSize <= medium.rangeMax) {
              return 'mediump';
            } else if (requiredSize <= high.rangeMax) {
              return 'highp';
            } else {
              throw new Error(`The required size exceeds that of the ability of your system`);
            }
          }
          switch (tactic) {
            case 'speed':
              return 'lowp';
            case 'balanced':
              return 'mediump';
            case 'precision':
              return 'highp';
            default:
              throw new Error(`Unknown tactic "${tactic}" use "speed", "balanced", "precision", or empty for auto`);
          }
        }
  
        updateTextureArgumentRefs(kernelValue, arg) {
          if (!this.immutable) return;
          if (this.texture.texture === arg.texture) {
            const { prevArg } = kernelValue;
            if (prevArg) {
              if (prevArg.texture._refs === 1) {
                this.texture.delete();
                this.texture = prevArg.clone();
                this._textureSwitched = true;
              }
              prevArg.delete();
            }
            kernelValue.prevArg = arg.clone();
          } else if (this.mappedTextures && this.mappedTextures.length > 0) {
            const { mappedTextures } = this;
            for (let i = 0; i < mappedTextures.length; i++) {
              const mappedTexture = mappedTextures[i];
              if (mappedTexture.texture === arg.texture) {
                const { prevArg } = kernelValue;
                if (prevArg) {
                  if (prevArg.texture._refs === 1) {
                    mappedTexture.delete();
                    mappedTextures[i] = prevArg.clone();
                    this._mappedTextureSwitched[i] = true;
                  }
                  prevArg.delete();
                }
                kernelValue.prevArg = arg.clone();
                return;
              }
            }
          }
        }
  
        onActivate(previousKernel) {
          this._textureSwitched = true;
          this.texture = previousKernel.texture;
          if (this.mappedTextures) {
            for (let i = 0; i < this.mappedTextures.length; i++) {
              this._mappedTextureSwitched[i] = true;
            }
            this.mappedTextures = previousKernel.mappedTextures;
          }
        }
  
        initCanvas() {}
      }
  
      const typeMap = {
        int: 'Integer',
        float: 'Number',
        vec2: 'Array(2)',
        vec3: 'Array(3)',
        vec4: 'Array(4)',
      };
  
      module.exports = {
        GLKernel
      };
      },{"../../utils":114,"../kernel":36,"./texture/array-2-float":16,"./texture/array-2-float-2d":14,"./texture/array-2-float-3d":15,"./texture/array-3-float":19,"./texture/array-3-float-2d":17,"./texture/array-3-float-3d":18,"./texture/array-4-float":22,"./texture/array-4-float-2d":20,"./texture/array-4-float-3d":21,"./texture/float":25,"./texture/float-2d":23,"./texture/float-3d":24,"./texture/graphical":26,"./texture/memory-optimized":30,"./texture/memory-optimized-2d":28,"./texture/memory-optimized-3d":29,"./texture/unsigned":33,"./texture/unsigned-2d":31,"./texture/unsigned-3d":32}],14:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTextureFloat } = require('./float');
  
      class GLTextureArray2Float2D extends GLTextureFloat {
        constructor(settings) {
          super(settings);
          this.type = 'ArrayTexture(2)';
        }
        toArray() {
          return utils.erect2DArray2(this.renderValues(), this.output[0], this.output[1]);
        }
      }
  
      module.exports = {
        GLTextureArray2Float2D
      };
      },{"../../../utils":114,"./float":25}],15:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTextureFloat } = require('./float');
  
      class GLTextureArray2Float3D extends GLTextureFloat {
        constructor(settings) {
          super(settings);
          this.type = 'ArrayTexture(2)';
        }
        toArray() {
          return utils.erect3DArray2(this.renderValues(), this.output[0], this.output[1], this.output[2]);
        }
      }
  
      module.exports = {
        GLTextureArray2Float3D
      };
      },{"../../../utils":114,"./float":25}],16:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTextureFloat } = require('./float');
  
      class GLTextureArray2Float extends GLTextureFloat {
        constructor(settings) {
          super(settings);
          this.type = 'ArrayTexture(2)';
        }
        toArray() {
          return utils.erectArray2(this.renderValues(), this.output[0], this.output[1]);
        }
      }
  
      module.exports = {
        GLTextureArray2Float
      };
      },{"../../../utils":114,"./float":25}],17:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTextureFloat } = require('./float');
  
      class GLTextureArray3Float2D extends GLTextureFloat {
        constructor(settings) {
          super(settings);
          this.type = 'ArrayTexture(3)';
        }
        toArray() {
          return utils.erect2DArray3(this.renderValues(), this.output[0], this.output[1]);
        }
      }
  
      module.exports = {
        GLTextureArray3Float2D
      };
      },{"../../../utils":114,"./float":25}],18:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTextureFloat } = require('./float');
  
      class GLTextureArray3Float3D extends GLTextureFloat {
        constructor(settings) {
          super(settings);
          this.type = 'ArrayTexture(3)';
        }
        toArray() {
          return utils.erect3DArray3(this.renderValues(), this.output[0], this.output[1], this.output[2]);
        }
      }
  
      module.exports = {
        GLTextureArray3Float3D
      };
      },{"../../../utils":114,"./float":25}],19:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTextureFloat } = require('./float');
  
      class GLTextureArray3Float extends GLTextureFloat {
        constructor(settings) {
          super(settings);
          this.type = 'ArrayTexture(3)';
        }
        toArray() {
          return utils.erectArray3(this.renderValues(), this.output[0]);
        }
      }
  
      module.exports = {
        GLTextureArray3Float
      };
      },{"../../../utils":114,"./float":25}],20:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTextureFloat } = require('./float');
  
      class GLTextureArray4Float2D extends GLTextureFloat {
        constructor(settings) {
          super(settings);
          this.type = 'ArrayTexture(4)';
        }
        toArray() {
          return utils.erect2DArray4(this.renderValues(), this.output[0], this.output[1]);
        }
      }
  
      module.exports = {
        GLTextureArray4Float2D
      };
      },{"../../../utils":114,"./float":25}],21:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTextureFloat } = require('./float');
  
      class GLTextureArray4Float3D extends GLTextureFloat {
        constructor(settings) {
          super(settings);
          this.type = 'ArrayTexture(4)';
        }
        toArray() {
          return utils.erect3DArray4(this.renderValues(), this.output[0], this.output[1], this.output[2]);
        }
      }
  
      module.exports = {
        GLTextureArray4Float3D
      };
      },{"../../../utils":114,"./float":25}],22:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTextureFloat } = require('./float');
  
      class GLTextureArray4Float extends GLTextureFloat {
        constructor(settings) {
          super(settings);
          this.type = 'ArrayTexture(4)';
        }
        toArray() {
          return utils.erectArray4(this.renderValues(), this.output[0]);
        }
      }
  
      module.exports = {
        GLTextureArray4Float
      };
      },{"../../../utils":114,"./float":25}],23:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTextureFloat } = require('./float');
  
      class GLTextureFloat2D extends GLTextureFloat {
        constructor(settings) {
          super(settings);
          this.type = 'ArrayTexture(1)';
        }
        toArray() {
          return utils.erect2DFloat(this.renderValues(), this.output[0], this.output[1]);
        }
      }
  
      module.exports = {
        GLTextureFloat2D
      };
      },{"../../../utils":114,"./float":25}],24:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTextureFloat } = require('./float');
  
      class GLTextureFloat3D extends GLTextureFloat {
        constructor(settings) {
          super(settings);
          this.type = 'ArrayTexture(1)';
        }
        toArray() {
          return utils.erect3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
        }
      }
  
      module.exports = {
        GLTextureFloat3D
      };
      },{"../../../utils":114,"./float":25}],25:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTexture } = require('./index');
  
      class GLTextureFloat extends GLTexture {
        get textureType() {
          return this.context.FLOAT;
        }
        constructor(settings) {
          super(settings);
          this.type = 'ArrayTexture(1)';
        }
        renderRawOutput() {
          const gl = this.context;
          const size = this.size;
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
          gl.framebufferTexture2D(
            gl.FRAMEBUFFER,
            gl.COLOR_ATTACHMENT0,
            gl.TEXTURE_2D,
            this.texture,
            0
          );
          const result = new Float32Array(size[0] * size[1] * 4);
          gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.FLOAT, result);
          return result;
        }
        renderValues() {
          if (this._deleted) return null;
          return this.renderRawOutput();
        }
        toArray() {
          return utils.erectFloat(this.renderValues(), this.output[0]);
        }
      }
  
      module.exports = {
        GLTextureFloat
      };
      },{"../../../utils":114,"./index":27}],26:[function(require,module,exports){
      const { GLTextureUnsigned } = require('./unsigned');
  
      class GLTextureGraphical extends GLTextureUnsigned {
        constructor(settings) {
          super(settings);
          this.type = 'ArrayTexture(4)';
        }
        toArray() {
          return this.renderValues();
        }
      }
  
      module.exports = {
        GLTextureGraphical
      };
      },{"./unsigned":33}],27:[function(require,module,exports){
      const { Texture } = require('../../../texture');
  
      class GLTexture extends Texture {
        get textureType() {
          throw new Error(`"textureType" not implemented on ${ this.name }`);
        }
  
        clone() {
          return new this.constructor(this);
        }
  
        beforeMutate() {
          if (this.texture._refs > 1) {
            this.newTexture();
            return true;
          }
          return false;
        }
  
        cloneTexture() {
          this.texture._refs--;
          const { context: gl, size, texture, kernel } = this;
          if (kernel.debug) {
            console.warn('cloning internal texture');
          }
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
          selectTexture(gl, texture);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          const target = gl.createTexture();
          selectTexture(gl, target);
          gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
          gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 0, 0, size[0], size[1]);
          target._refs = 1;
          this.texture = target;
        }
  
        newTexture() {
          this.texture._refs--;
          const gl = this.context;
          const size = this.size;
          const kernel = this.kernel;
          if (kernel.debug) {
            console.warn('new internal texture');
          }
          const target = gl.createTexture();
          selectTexture(gl, target);
          gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
          target._refs = 1;
          this.texture = target;
        }
  
        clear() {
          if (this.texture._refs) {
            this.texture._refs--;
            const gl = this.context;
            const target = this.texture = gl.createTexture();
            selectTexture(gl, target);
            const size = this.size;
            target._refs = 1;
            gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
          }
          const { context: gl, texture } = this;
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
          gl.bindTexture(gl.TEXTURE_2D, texture);
          selectTexture(gl, texture);
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          gl.clearColor(0, 0, 0, 0);
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        }
  
        delete() {
          if (this._deleted) return;
          this._deleted = true;
          if (this.texture._refs) {
            this.texture._refs--;
            if (this.texture._refs) return;
          }
          this.context.deleteTexture(this.texture);
        }
  
        framebuffer() {
          if (!this._framebuffer) {
            this._framebuffer = this.kernel.getRawValueFramebuffer(this.size[0], this.size[1]);
          }
          return this._framebuffer;
        }
      }
  
      function selectTexture(gl, texture) {
        gl.activeTexture(gl.TEXTURE15);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      }
  
      module.exports = { GLTexture };
      },{"../../../texture":113}],28:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTextureFloat } = require('./float');
  
      class GLTextureMemoryOptimized2D extends GLTextureFloat {
        constructor(settings) {
          super(settings);
          this.type = 'MemoryOptimizedNumberTexture';
        }
        toArray() {
          return utils.erectMemoryOptimized2DFloat(this.renderValues(), this.output[0], this.output[1]);
        }
      }
  
      module.exports = {
        GLTextureMemoryOptimized2D
      };
      },{"../../../utils":114,"./float":25}],29:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTextureFloat } = require('./float');
  
      class GLTextureMemoryOptimized3D extends GLTextureFloat {
        constructor(settings) {
          super(settings);
          this.type = 'MemoryOptimizedNumberTexture';
        }
        toArray() {
          return utils.erectMemoryOptimized3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
        }
      }
  
      module.exports = {
        GLTextureMemoryOptimized3D
      };
      },{"../../../utils":114,"./float":25}],30:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTextureFloat } = require('./float');
  
      class GLTextureMemoryOptimized extends GLTextureFloat {
        constructor(settings) {
          super(settings);
          this.type = 'MemoryOptimizedNumberTexture';
        }
        toArray() {
          return utils.erectMemoryOptimizedFloat(this.renderValues(), this.output[0]);
        }
      }
  
      module.exports = {
        GLTextureMemoryOptimized
      };
      },{"../../../utils":114,"./float":25}],31:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTextureUnsigned } = require('./unsigned');
  
      class GLTextureUnsigned2D extends GLTextureUnsigned {
        constructor(settings) {
          super(settings);
          this.type = 'NumberTexture';
        }
        toArray() {
          return utils.erect2DPackedFloat(this.renderValues(), this.output[0], this.output[1]);
        }
      }
  
      module.exports = {
        GLTextureUnsigned2D
      };
      },{"../../../utils":114,"./unsigned":33}],32:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTextureUnsigned } = require('./unsigned');
  
      class GLTextureUnsigned3D extends GLTextureUnsigned {
        constructor(settings) {
          super(settings);
          this.type = 'NumberTexture';
        }
        toArray() {
          return utils.erect3DPackedFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
        }
      }
  
      module.exports = {
        GLTextureUnsigned3D
      };
      },{"../../../utils":114,"./unsigned":33}],33:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { GLTexture } = require('./index');
  
      class GLTextureUnsigned extends GLTexture {
        get textureType() {
          return this.context.UNSIGNED_BYTE;
        }
        constructor(settings) {
          super(settings);
          this.type = 'NumberTexture';
        }
        renderRawOutput() {
          const { context: gl } = this;
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
          gl.framebufferTexture2D(
            gl.FRAMEBUFFER,
            gl.COLOR_ATTACHMENT0,
            gl.TEXTURE_2D,
            this.texture,
            0
          );
          const result = new Uint8Array(this.size[0] * this.size[1] * 4);
          gl.readPixels(0, 0, this.size[0], this.size[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
          return result;
        }
        renderValues() {
          if (this._deleted) return null;
          return new Float32Array(this.renderRawOutput().buffer);
        }
        toArray() {
          return utils.erectPackedFloat(this.renderValues(), this.output[0]);
        }
      }
  
      module.exports = {
        GLTextureUnsigned
      };
      },{"../../../utils":114,"./index":27}],34:[function(require,module,exports){
      const getContext = require('gl');
      const { WebGLKernel } = require('../web-gl/kernel');
      const { glKernelString } = require('../gl/kernel-string');
  
      let isSupported = null;
      let testCanvas = null;
      let testContext = null;
      let testExtensions = null;
      let features = null;
  
      class HeadlessGLKernel extends WebGLKernel {
        static get isSupported() {
          if (isSupported !== null) return isSupported;
          this.setupFeatureChecks();
          isSupported = testContext !== null;
          return isSupported;
        }
  
        static setupFeatureChecks() {
          testCanvas = null;
          testExtensions = null;
          if (typeof getContext !== 'function') return;
          try { 
            testContext = getContext(2, 2, {
              preserveDrawingBuffer: true
            });
            if (!testContext || !testContext.getExtension) return;
            testExtensions = {
              STACKGL_resize_drawingbuffer: testContext.getExtension('STACKGL_resize_drawingbuffer'),
              STACKGL_destroy_context: testContext.getExtension('STACKGL_destroy_context'),
              OES_texture_float: testContext.getExtension('OES_texture_float'),
              OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
              OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
              WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),
              WEBGL_color_buffer_float: testContext.getExtension('WEBGL_color_buffer_float'),
            };
            features = this.getFeatures();
          } catch (e) {
            console.warn(e);
          }
        }
  
        static isContextMatch(context) {
          try {
            return context.getParameter(context.RENDERER) === 'ANGLE';
          } catch (e) {
            return false;
          }
        }
  
        static getIsTextureFloat() {
          return Boolean(testExtensions.OES_texture_float);
        }
  
        static getIsDrawBuffers() {
          return Boolean(testExtensions.WEBGL_draw_buffers);
        }
  
        static getChannelCount() {
          return testExtensions.WEBGL_draw_buffers ?
            testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :
            1;
        }
  
        static getMaxTextureSize() {
          return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
        }
  
        static get testCanvas() {
          return testCanvas;
        }
  
        static get testContext() {
          return testContext;
        }
  
        static get features() {
          return features;
        }
  
        initCanvas() {
          return {};
        }
  
        initContext() {
          return getContext(2, 2, {
            preserveDrawingBuffer: true
          });
        }
  
        initExtensions() {
          this.extensions = {
            STACKGL_resize_drawingbuffer: this.context.getExtension('STACKGL_resize_drawingbuffer'),
            STACKGL_destroy_context: this.context.getExtension('STACKGL_destroy_context'),
            OES_texture_float: this.context.getExtension('OES_texture_float'),
            OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
            OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
            WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
          };
        }
  
        build() {
          super.build.apply(this, arguments);
          if (!this.fallbackRequested) {
            this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
          }
        }
  
        destroyExtensions() {
          this.extensions.STACKGL_resize_drawingbuffer = null;
          this.extensions.STACKGL_destroy_context = null;
          this.extensions.OES_texture_float = null;
          this.extensions.OES_texture_float_linear = null;
          this.extensions.OES_element_index_uint = null;
          this.extensions.WEBGL_draw_buffers = null;
        }
  
        static destroyContext(context) {
          const extension = context.getExtension('STACKGL_destroy_context');
          if (extension && extension.destroy) {
            extension.destroy();
          }
        }
  
        toString() {
          const setupContextString = `const gl = context || require('gl')(1, 1);\n`;
          const destroyContextString = `    if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }\n`;
          return glKernelString(this.constructor, arguments, this, setupContextString, destroyContextString);
        }
  
        setOutput(output) {
          super.setOutput(output);
          if (this.graphical && this.extensions.STACKGL_resize_drawingbuffer) {
            this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
          }
          return this;
        }
      }
  
      module.exports = {
        HeadlessGLKernel
      };
      },{"../gl/kernel-string":12,"../web-gl/kernel":70,"gl":2}],35:[function(require,module,exports){
      class KernelValue {
        constructor(value, settings) {
          const {
            name,
            kernel,
            context,
            checkContext,
            onRequestContextHandle,
            onUpdateValueMismatch,
            origin,
            strictIntegers,
            type,
            tactic,
          } = settings;
          if (!name) {
            throw new Error('name not set');
          }
          if (!type) {
            throw new Error('type not set');
          }
          if (!origin) {
            throw new Error('origin not set');
          }
          if (origin !== 'user' && origin !== 'constants') {
            throw new Error(`origin must be "user" or "constants" value is "${ origin }"`);
          }
          if (!onRequestContextHandle) {
            throw new Error('onRequestContextHandle is not set');
          }
          this.name = name;
          this.origin = origin;
          this.tactic = tactic;
          this.varName = origin === 'constants' ? `constants.${name}` : name;
          this.kernel = kernel;
          this.strictIntegers = strictIntegers;
          this.type = value.type || type;
          this.size = value.size || null;
          this.index = null;
          this.context = context;
          this.checkContext = checkContext !== null && checkContext !== undefined ? checkContext : true;
          this.contextHandle = null;
          this.onRequestContextHandle = onRequestContextHandle;
          this.onUpdateValueMismatch = onUpdateValueMismatch;
          this.forceUploadEachRun = null;
        }
  
        get id() {
          return `${this.origin}_${name}`;
        }
  
        getSource() {
          throw new Error(`"getSource" not defined on ${ this.constructor.name }`);
        }
  
        updateValue(value) {
          throw new Error(`"updateValue" not defined on ${ this.constructor.name }`);
        }
      }
  
      module.exports = {
        KernelValue
      };
      },{}],36:[function(require,module,exports){
      const { utils } = require('../utils');
      const { Input } = require('../input');
  
      class Kernel {
        static get isSupported() {
          throw new Error(`"isSupported" not implemented on ${ this.name }`);
        }
  
        static isContextMatch(context) {
          throw new Error(`"isContextMatch" not implemented on ${ this.name }`);
        }
  
        static getFeatures() {
          throw new Error(`"getFeatures" not implemented on ${ this.name }`);
        }
  
        static destroyContext(context) {
          throw new Error(`"destroyContext" called on ${ this.name }`);
        }
  
        static nativeFunctionArguments() {
          throw new Error(`"nativeFunctionArguments" called on ${ this.name }`);
        }
  
        static nativeFunctionReturnType() {
          throw new Error(`"nativeFunctionReturnType" called on ${ this.name }`);
        }
  
        static combineKernels() {
          throw new Error(`"combineKernels" called on ${ this.name }`);
        }
  
        constructor(source, settings) {
          if (typeof source !== 'object') {
            if (typeof source !== 'string') {
              throw new Error('source not a string');
            }
            if (!utils.isFunctionString(source)) {
              throw new Error('source not a function string');
            }
          }
          this.useLegacyEncoder = false;
          this.fallbackRequested = false;
          this.onRequestFallback = null;
  
          this.argumentNames = typeof source === 'string' ? utils.getArgumentNamesFromString(source) : null;
          this.argumentTypes = null;
          this.argumentSizes = null;
          this.argumentBitRatios = null;
          this.kernelArguments = null;
          this.kernelConstants = null;
          this.forceUploadKernelConstants = null;
  
  
          this.source = source;
  
          this.output = null;
  
          this.debug = false;
  
          this.graphical = false;
  
          this.loopMaxIterations = 0;
  
          this.constants = null;
  
          this.constantTypes = null;
  
          this.constantBitRatios = null;
  
          this.dynamicArguments = false;
  
          this.dynamicOutput = false;
  
          this.canvas = null;
  
          this.context = null;
  
          this.checkContext = null;
  
          this.gpu = null;
  
          this.functions = null;
  
          this.nativeFunctions = null;
  
          this.injectedNative = null;
  
          this.subKernels = null;
  
          this.validate = true;
  
          this.immutable = false;
  
          this.pipeline = false;
  
          this.precision = null;
  
          this.tactic = null;
  
          this.plugins = null;
  
          this.returnType = null;
          this.leadingReturnStatement = null;
          this.followingReturnStatement = null;
          this.optimizeFloatMemory = null;
          this.strictIntegers = false;
          this.fixIntegerDivisionAccuracy = null;
          this.built = false;
          this.signature = null;
        }
  
        mergeSettings(settings) {
          for (let p in settings) {
            if (!settings.hasOwnProperty(p) || !this.hasOwnProperty(p)) continue;
            switch (p) {
              case 'output':
                if (!Array.isArray(settings.output)) {
                  this.setOutput(settings.output); 
                  continue;
                }
                break;
              case 'functions':
                this.functions = [];
                for (let i = 0; i < settings.functions.length; i++) {
                  this.addFunction(settings.functions[i]);
                }
                continue;
              case 'graphical':
                if (settings[p] && !settings.hasOwnProperty('precision')) {
                  this.precision = 'unsigned';
                }
                this[p] = settings[p];
                continue;
              case 'nativeFunctions':
                if (!settings.nativeFunctions) continue;
                this.nativeFunctions = [];
                for (let i = 0; i < settings.nativeFunctions.length; i++) {
                  const s = settings.nativeFunctions[i];
                  const { name, source } = s;
                  this.addNativeFunction(name, source, s);
                }
                continue;
            }
            this[p] = settings[p];
          }
  
          if (!this.canvas) this.canvas = this.initCanvas();
          if (!this.context) this.context = this.initContext();
          if (!this.plugins) this.plugins = this.initPlugins(settings);
        }
        build() {
          throw new Error(`"build" not defined on ${ this.constructor.name }`);
        }
  
        run() {
          throw new Error(`"run" not defined on ${ this.constructor.name }`)
        }
  
        initCanvas() {
          throw new Error(`"initCanvas" not defined on ${ this.constructor.name }`);
        }
  
        initContext() {
          throw new Error(`"initContext" not defined on ${ this.constructor.name }`);
        }
  
        initPlugins(settings) {
          throw new Error(`"initPlugins" not defined on ${ this.constructor.name }`);
        }
  
        addFunction(source, settings = {}) {
          if (source.name && source.source && source.argumentTypes && 'returnType' in source) {
            this.functions.push(source);
          } else if ('settings' in source && 'source' in source) {
            this.functions.push(this.functionToIGPUFunction(source.source, source.settings));
          } else if (typeof source === 'string' || typeof source === 'function') {
            this.functions.push(this.functionToIGPUFunction(source, settings));
          } else {
            throw new Error(`function not properly defined`);
          }
          return this;
        }
  
        addNativeFunction(name, source, settings = {}) {
          const { argumentTypes, argumentNames } = settings.argumentTypes ?
            splitArgumentTypes(settings.argumentTypes) :
            this.constructor.nativeFunctionArguments(source) || {};
          this.nativeFunctions.push({
            name,
            source,
            settings,
            argumentTypes,
            argumentNames,
            returnType: settings.returnType || this.constructor.nativeFunctionReturnType(source)
          });
          return this;
        }
  
        setupArguments(args) {
          this.kernelArguments = [];
          if (!this.argumentTypes) {
            if (!this.argumentTypes) {
              this.argumentTypes = [];
              for (let i = 0; i < args.length; i++) {
                const argType = utils.getVariableType(args[i], this.strictIntegers);
                const type = argType === 'Integer' ? 'Number' : argType;
                this.argumentTypes.push(type);
                this.kernelArguments.push({
                  type
                });
              }
            }
          } else {
            for (let i = 0; i < this.argumentTypes.length; i++) {
              this.kernelArguments.push({
                type: this.argumentTypes[i]
              });
            }
          }
  
          this.argumentSizes = new Array(args.length);
          this.argumentBitRatios = new Int32Array(args.length);
  
          for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            this.argumentSizes[i] = arg.constructor === Input ? arg.size : null;
            this.argumentBitRatios[i] = this.getBitRatio(arg);
          }
  
          if (this.argumentNames.length !== args.length) {
            throw new Error(`arguments are miss-aligned`);
          }
        }
  
        setupConstants() {
          this.kernelConstants = [];
          let needsConstantTypes = this.constantTypes === null;
          if (needsConstantTypes) {
            this.constantTypes = {};
          }
          this.constantBitRatios = {};
          if (this.constants) {
            for (let name in this.constants) {
              if (needsConstantTypes) {
                const type = utils.getVariableType(this.constants[name], this.strictIntegers);
                this.constantTypes[name] = type;
                this.kernelConstants.push({
                  name,
                  type
                });
              } else {
                this.kernelConstants.push({
                  name,
                  type: this.constantTypes[name]
                });
              }
              this.constantBitRatios[name] = this.getBitRatio(this.constants[name]);
            }
          }
        }
  
        setOptimizeFloatMemory(flag) {
          this.optimizeFloatMemory = flag;
          return this;
        }
  
        toKernelOutput(output) {
          if (output.hasOwnProperty('x')) {
            if (output.hasOwnProperty('y')) {
              if (output.hasOwnProperty('z')) {
                return [output.x, output.y, output.z];
              } else {
                return [output.x, output.y];
              }
            } else {
              return [output.x];
            }
          } else {
            return output;
          }
        }
  
        setOutput(output) {
          this.output = this.toKernelOutput(output);
          return this;
        }
  
        setDebug(flag) {
          this.debug = flag;
          return this;
        }
  
        setGraphical(flag) {
          this.graphical = flag;
          this.precision = 'unsigned';
          return this;
        }
  
        setLoopMaxIterations(max) {
          this.loopMaxIterations = max;
          return this;
        }
  
        setConstants(constants) {
          this.constants = constants;
          return this;
        }
  
        setConstantTypes(constantTypes) {
          this.constantTypes = constantTypes;
          return this;
        }
  
        setFunctions(functions) {
          for (let i = 0; i < functions.length; i++) {
            this.addFunction(functions[i]);
          }
          return this;
        }
  
        setNativeFunctions(nativeFunctions) {
          for (let i = 0; i < nativeFunctions.length; i++) {
            const settings = nativeFunctions[i];
            const { name, source } = settings;
            this.addNativeFunction(name, source, settings);
          }
          return this;
        }
  
        setInjectedNative(injectedNative) {
          this.injectedNative = injectedNative;
          return this;
        }
  
        setPipeline(flag) {
          this.pipeline = flag;
          return this;
        }
  
        setPrecision(flag) {
          this.precision = flag;
          return this;
        }
  
        setDimensions(flag) {
          utils.warnDeprecated('method', 'setDimensions', 'setOutput');
          this.output = flag;
          return this;
        }
  
        setOutputToTexture(flag) {
          utils.warnDeprecated('method', 'setOutputToTexture', 'setPipeline');
          this.pipeline = flag;
          return this;
        }
  
        setImmutable(flag) {
          this.immutable = flag;
          return this;
        }
  
        setCanvas(canvas) {
          this.canvas = canvas;
          return this;
        }
  
        setStrictIntegers(flag) {
          this.strictIntegers = flag;
          return this;
        }
  
        setDynamicOutput(flag) {
          this.dynamicOutput = flag;
          return this;
        }
  
        setHardcodeConstants(flag) {
          utils.warnDeprecated('method', 'setHardcodeConstants');
          this.setDynamicOutput(flag);
          this.setDynamicArguments(flag);
          return this;
        }
  
        setDynamicArguments(flag) {
          this.dynamicArguments = flag;
          return this;
        }
  
        setUseLegacyEncoder(flag) {
          this.useLegacyEncoder = flag;
          return this;
        }
  
        setWarnVarUsage(flag) {
          utils.warnDeprecated('method', 'setWarnVarUsage');
          return this;
        }
  
        getCanvas() {
          utils.warnDeprecated('method', 'getCanvas');
          return this.canvas;
        }
  
        getWebGl() {
          utils.warnDeprecated('method', 'getWebGl');
          return this.context;
        }
  
        setContext(context) {
          this.context = context;
          return this;
        }
  
        setArgumentTypes(argumentTypes) {
          if (Array.isArray(argumentTypes)) {
            this.argumentTypes = argumentTypes;
          } else {
            this.argumentTypes = [];
            for (const p in argumentTypes) {
              if (!argumentTypes.hasOwnProperty(p)) continue;
              const argumentIndex = this.argumentNames.indexOf(p);
              if (argumentIndex === -1) throw new Error(`unable to find argument ${ p }`);
              this.argumentTypes[argumentIndex] = argumentTypes[p];
            }
          }
          return this;
        }
  
        setTactic(tactic) {
          this.tactic = tactic;
          return this;
        }
  
        requestFallback(args) {
          if (!this.onRequestFallback) {
            throw new Error(`"onRequestFallback" not defined on ${ this.constructor.name }`);
          }
          this.fallbackRequested = true;
          return this.onRequestFallback(args);
        }
  
        validateSettings() {
          throw new Error(`"validateSettings" not defined on ${ this.constructor.name }`);
        }
  
        addSubKernel(subKernel) {
          if (this.subKernels === null) {
            this.subKernels = [];
          }
          if (!subKernel.source) throw new Error('subKernel missing "source" property');
          if (!subKernel.property && isNaN(subKernel.property)) throw new Error('subKernel missing "property" property');
          if (!subKernel.name) throw new Error('subKernel missing "name" property');
          this.subKernels.push(subKernel);
          return this;
        }
  
        destroy(removeCanvasReferences) {
          throw new Error(`"destroy" called on ${ this.constructor.name }`);
        }
  
        getBitRatio(value) {
          if (this.precision === 'single') {
            return 4;
          } else if (Array.isArray(value[0])) {
            return this.getBitRatio(value[0]);
          } else if (value.constructor === Input) {
            return this.getBitRatio(value.value);
          }
          switch (value.constructor) {
            case Uint8ClampedArray:
            case Uint8Array:
            case Int8Array:
              return 1;
            case Uint16Array:
            case Int16Array:
              return 2;
            case Float32Array:
            case Int32Array:
            default:
              return 4;
          }
        }
  
        getPixels(flip) {
          throw new Error(`"getPixels" called on ${ this.constructor.name }`);
        }
  
        checkOutput() {
          if (!this.output || !utils.isArray(this.output)) throw new Error('kernel.output not an array');
          if (this.output.length < 1) throw new Error('kernel.output is empty, needs at least 1 value');
          for (let i = 0; i < this.output.length; i++) {
            if (isNaN(this.output[i]) || this.output[i] < 1) {
              throw new Error(`${ this.constructor.name }.output[${ i }] incorrectly defined as \`${ this.output[i] }\`, needs to be numeric, and greater than 0`);
            }
          }
        }
  
        prependString(value) {
          throw new Error(`"prependString" called on ${ this.constructor.name }`);
        }
  
        hasPrependString(value) {
          throw new Error(`"hasPrependString" called on ${ this.constructor.name }`);
        }
  
        toJSON() {
          return {
            settings: {
              output: this.output,
              pipeline: this.pipeline,
              argumentNames: this.argumentNames,
              argumentsTypes: this.argumentTypes,
              constants: this.constants,
              pluginNames: this.plugins ? this.plugins.map(plugin => plugin.name) : null,
              returnType: this.returnType,
            }
          };
        }
  
        buildSignature(args) {
          const Constructor = this.constructor;
          this.signature = Constructor.getSignature(this, Constructor.getArgumentTypes(this, args));
        }
  
        static getArgumentTypes(kernel, args) {
          const argumentTypes = new Array(args.length);
          for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            const type = kernel.argumentTypes[i];
            if (arg.type) {
              argumentTypes[i] = arg.type;
            } else {
              switch (type) {
                case 'Number':
                case 'Integer':
                case 'Float':
                case 'ArrayTexture(1)':
                  argumentTypes[i] = utils.getVariableType(arg);
                  break;
                default:
                  argumentTypes[i] = type;
              }
            }
          }
          return argumentTypes;
        }
  
        static getSignature(kernel, argumentTypes) {
          throw new Error(`"getSignature" not implemented on ${ this.name }`);
        }
  
        functionToIGPUFunction(source, settings = {}) {
          if (typeof source !== 'string' && typeof source !== 'function') throw new Error('source not a string or function');
          const sourceString = typeof source === 'string' ? source : source.toString();
          let argumentTypes = [];
  
          if (Array.isArray(settings.argumentTypes)) {
            argumentTypes = settings.argumentTypes;
          } else if (typeof settings.argumentTypes === 'object') {
            argumentTypes = utils.getArgumentNamesFromString(sourceString)
              .map(name => settings.argumentTypes[name]) || [];
          } else {
            argumentTypes = settings.argumentTypes || [];
          }
  
          return {
            name: utils.getFunctionNameFromString(sourceString) || null,
            source: sourceString,
            argumentTypes,
            returnType: settings.returnType || null,
          };
        }
  
        onActivate(previousKernel) {}
      }
  
      function splitArgumentTypes(argumentTypesObject) {
        const argumentNames = Object.keys(argumentTypesObject);
        const argumentTypes = [];
        for (let i = 0; i < argumentNames.length; i++) {
          const argumentName = argumentNames[i];
          argumentTypes.push(argumentTypesObject[argumentName]);
        }
        return { argumentTypes, argumentNames };
      }
  
      module.exports = {
        Kernel
      };
      },{"../input":110,"../utils":114}],37:[function(require,module,exports){
      const fragmentShader = `__HEADER__;
  __FLOAT_TACTIC_DECLARATION__;
  __INT_TACTIC_DECLARATION__;
  __SAMPLER_2D_TACTIC_DECLARATION__;
  
  const int LOOP_MAX = __LOOP_MAX__;
  
  __PLUGINS__;
  __CONSTANTS__;
  
  varying vec2 vTexCoord;
  
  float acosh(float x) {
    return log(x + sqrt(x * x - 1.0));
  }
  
  float sinh(float x) {
    return (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;
  }
  
  float asinh(float x) {
    return log(x + sqrt(x * x + 1.0));
  }
  
  float atan2(float v1, float v2) {
    if (v1 == 0.0 || v2 == 0.0) return 0.0;
    return atan(v1 / v2);
  }
  
  float atanh(float x) {
    x = (x + 1.0) / (x - 1.0);
    if (x < 0.0) {
      return 0.5 * log(-x);
    }
    return 0.5 * log(x);
  }
  
  float cbrt(float x) {
    if (x >= 0.0) {
      return pow(x, 1.0 / 3.0);
    } else {
      return -pow(x, 1.0 / 3.0);
    }
  }
  
  float cosh(float x) {
    return (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; 
  }
  
  float expm1(float x) {
    return pow(${Math.E}, x) - 1.0; 
  }
  
  float fround(highp float x) {
    return x;
  }
  
  float imul(float v1, float v2) {
    return float(int(v1) * int(v2));
  }
  
  float log10(float x) {
    return log2(x) * (1.0 / log2(10.0));
  }
  
  float log1p(float x) {
    return log(1.0 + x);
  }
  
  float _pow(float v1, float v2) {
    if (v2 == 0.0) return 1.0;
    return pow(v1, v2);
  }
  
  float tanh(float x) {
    float e = exp(2.0 * x);
    return (e - 1.0) / (e + 1.0);
  }
  
  float trunc(float x) {
    if (x >= 0.0) {
      return floor(x); 
    } else {
      return ceil(x);
    }
  }
  
  vec4 _round(vec4 x) {
    return floor(x + 0.5);
  }
  
  float _round(float x) {
    return floor(x + 0.5);
  }
  
  const int BIT_COUNT = 32;
  int modi(int x, int y) {
    return x - y * (x / y);
  }
  
  int bitwiseOr(int a, int b) {
    int result = 0;
    int n = 1;
    
    for (int i = 0; i < BIT_COUNT; i++) {
      if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
        result += n;
      }
      a = a / 2;
      b = b / 2;
      n = n * 2;
      if(!(a > 0 || b > 0)) {
        break;
      }
    }
    return result;
  }
  int bitwiseXOR(int a, int b) {
    int result = 0;
    int n = 1;
    
    for (int i = 0; i < BIT_COUNT; i++) {
      if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
        result += n;
      }
      a = a / 2;
      b = b / 2;
      n = n * 2;
      if(!(a > 0 || b > 0)) {
        break;
      }
    }
    return result;
  }
  int bitwiseAnd(int a, int b) {
    int result = 0;
    int n = 1;
    for (int i = 0; i < BIT_COUNT; i++) {
      if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
        result += n;
      }
      a = a / 2;
      b = b / 2;
      n = n * 2;
      if(!(a > 0 && b > 0)) {
        break;
      }
    }
    return result;
  }
  int bitwiseNot(int a) {
    int result = 0;
    int n = 1;
    
    for (int i = 0; i < BIT_COUNT; i++) {
      if (modi(a, 2) == 0) {
        result += n;    
      }
      a = a / 2;
      n = n * 2;
    }
    return result;
  }
  int bitwiseZeroFillLeftShift(int n, int shift) {
    int maxBytes = BIT_COUNT;
    for (int i = 0; i < BIT_COUNT; i++) {
      if (maxBytes >= n) {
        break;
      }
      maxBytes *= 2;
    }
    for (int i = 0; i < BIT_COUNT; i++) {
      if (i >= shift) {
        break;
      }
      n *= 2;
    }
  
    int result = 0;
    int byteVal = 1;
    for (int i = 0; i < BIT_COUNT; i++) {
      if (i >= maxBytes) break;
      if (modi(n, 2) > 0) { result += byteVal; }
      n = int(n / 2);
      byteVal *= 2;
    }
    return result;
  }
  
  int bitwiseSignedRightShift(int num, int shifts) {
    return int(floor(float(num) / pow(2.0, float(shifts))));
  }
  
  int bitwiseZeroFillRightShift(int n, int shift) {
    int maxBytes = BIT_COUNT;
    for (int i = 0; i < BIT_COUNT; i++) {
      if (maxBytes >= n) {
        break;
      }
      maxBytes *= 2;
    }
    for (int i = 0; i < BIT_COUNT; i++) {
      if (i >= shift) {
        break;
      }
      n /= 2;
    }
    int result = 0;
    int byteVal = 1;
    for (int i = 0; i < BIT_COUNT; i++) {
      if (i >= maxBytes) break;
      if (modi(n, 2) > 0) { result += byteVal; }
      n = int(n / 2);
      byteVal *= 2;
    }
    return result;
  }
  
  vec2 integerMod(vec2 x, float y) {
    vec2 res = floor(mod(x, y));
    return res * step(1.0 - floor(y), -res);
  }
  
  vec3 integerMod(vec3 x, float y) {
    vec3 res = floor(mod(x, y));
    return res * step(1.0 - floor(y), -res);
  }
  
  vec4 integerMod(vec4 x, vec4 y) {
    vec4 res = floor(mod(x, y));
    return res * step(1.0 - floor(y), -res);
  }
  
  float integerMod(float x, float y) {
    float res = floor(mod(x, y));
    return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
  }
  
  int integerMod(int x, int y) {
    return x - (y * int(x / y));
  }
  
  __DIVIDE_WITH_INTEGER_CHECK__;
  
  // Here be dragons!
  // DO NOT OPTIMIZE THIS CODE
  // YOU WILL BREAK SOMETHING ON SOMEBODY\'S MACHINE
  // LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
  const vec2 MAGIC_VEC = vec2(1.0, -256.0);
  const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
  const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
  float decode32(vec4 texel) {
    __DECODE32_ENDIANNESS__;
    texel *= 255.0;
    vec2 gte128;
    gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
    gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
    float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
    float res = exp2(_round(exponent));
    texel.b = texel.b - 128.0 * gte128.x;
    res = dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;
    res *= gte128.y * -2.0 + 1.0;
    return res;
  }
  
  float decode16(vec4 texel, int index) {
    int channel = integerMod(index, 2);
    if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;
    if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;
    return 0.0;
  }
  
  float decode8(vec4 texel, int index) {
    int channel = integerMod(index, 4);
    if (channel == 0) return texel.r * 255.0;
    if (channel == 1) return texel.g * 255.0;
    if (channel == 2) return texel.b * 255.0;
    if (channel == 3) return texel.a * 255.0;
    return 0.0;
  }
  
  vec4 legacyEncode32(float f) {
    float F = abs(f);
    float sign = f < 0.0 ? 1.0 : 0.0;
    float exponent = floor(log2(F));
    float mantissa = (exp2(-exponent) * F);
    // exponent += floor(log2(mantissa));
    vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
    texel.rg = integerMod(texel.rg, 256.0);
    texel.b = integerMod(texel.b, 128.0);
    texel.a = exponent*0.5 + 63.5;
    texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
    texel = floor(texel);
    texel *= 0.003921569; // 1/255
    __ENCODE32_ENDIANNESS__;
    return texel;
  }
  
  // https://github.com/gpujs/gpu.js/wiki/Encoder-details
  vec4 encode32(float value) {
    if (value == 0.0) return vec4(0, 0, 0, 0);
  
    float exponent;
    float mantissa;
    vec4  result;
    float sgn;
  
    sgn = step(0.0, -value);
    value = abs(value);
  
    exponent = floor(log2(value));
  
    mantissa = value*pow(2.0, -exponent)-1.0;
    exponent = exponent+127.0;
    result   = vec4(0,0,0,0);
  
    result.a = floor(exponent/2.0);
    exponent = exponent - result.a*2.0;
    result.a = result.a + 128.0*sgn;
  
    result.b = floor(mantissa * 128.0);
    mantissa = mantissa - result.b / 128.0;
    result.b = result.b + exponent*128.0;
  
    result.g = floor(mantissa*32768.0);
    mantissa = mantissa - result.g/32768.0;
  
    result.r = floor(mantissa*8388608.0);
    return result/255.0;
  }
  // Dragons end here
  
  int index;
  ivec3 threadId;
  
  ivec3 indexTo3D(int idx, ivec3 texDim) {
    int z = int(idx / (texDim.x * texDim.y));
    idx -= z * int(texDim.x * texDim.y);
    int y = int(idx / texDim.x);
    int x = int(integerMod(idx, texDim.x));
    return ivec3(x, y, z);
  }
  
  float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int index = x + texDim.x * (y + texDim.y * z);
    int w = texSize.x;
    vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
    vec4 texel = texture2D(tex, st / vec2(texSize));
    return decode32(texel);
  }
  
  float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int index = x + texDim.x * (y + texDim.y * z);
    int w = texSize.x * 2;
    vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
    vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));
    return decode16(texel, index);
  }
  
  float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int index = x + texDim.x * (y + texDim.y * z);
    int w = texSize.x * 4;
    vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
    vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));
    return decode8(texel, index);
  }
  
  float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int index = x + texDim.x * (y + texDim.y * z);
    int channel = integerMod(index, 4);
    index = index / 4;
    int w = texSize.x;
    vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
    vec4 texel = texture2D(tex, st / vec2(texSize));
    if (channel == 0) return texel.r;
    if (channel == 1) return texel.g;
    if (channel == 2) return texel.b;
    if (channel == 3) return texel.a;
    return 0.0;
  }
  
  vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int index = x + texDim.x * (y + texDim.y * z);
    int w = texSize.x;
    vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
    return texture2D(tex, st / vec2(texSize));
  }
  
  float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
    return result[0];
  }
  
  vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
    return vec2(result[0], result[1]);
  }
  
  vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int index = x + (texDim.x * (y + (texDim.y * z)));
    int channel = integerMod(index, 2);
    index = index / 2;
    int w = texSize.x;
    vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
    vec4 texel = texture2D(tex, st / vec2(texSize));
    if (channel == 0) return vec2(texel.r, texel.g);
    if (channel == 1) return vec2(texel.b, texel.a);
    return vec2(0.0, 0.0);
  }
  
  vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
    return vec3(result[0], result[1], result[2]);
  }
  
  vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
    int vectorIndex = fieldIndex / 4;
    int vectorOffset = fieldIndex - vectorIndex * 4;
    int readY = vectorIndex / texSize.x;
    int readX = vectorIndex - readY * texSize.x;
    vec4 tex1 = texture2D(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));
    
    if (vectorOffset == 0) {
      return tex1.xyz;
    } else if (vectorOffset == 1) {
      return tex1.yzw;
    } else {
      readX++;
      if (readX >= texSize.x) {
        readX = 0;
        readY++;
      }
      vec4 tex2 = texture2D(tex, vec2(readX, readY) / vec2(texSize));
      if (vectorOffset == 2) {
        return vec3(tex1.z, tex1.w, tex2.x);
      } else {
        return vec3(tex1.w, tex2.x, tex2.y);
      }
    }
  }
  
  vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    return getImage2D(tex, texSize, texDim, z, y, x);
  }
  
  vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int index = x + texDim.x * (y + texDim.y * z);
    int channel = integerMod(index, 2);
    int w = texSize.x;
    vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
    vec4 texel = texture2D(tex, st / vec2(texSize));
    return vec4(texel.r, texel.g, texel.b, texel.a);
  }
  
  vec4 actualColor;
  void color(float r, float g, float b, float a) {
    actualColor = vec4(r,g,b,a);
  }
  
  void color(float r, float g, float b) {
    color(r,g,b,1.0);
  }
  
  void color(sampler2D image) {
    actualColor = texture2D(image, vTexCoord);
  }
  
  float modulo(float number, float divisor) {
    if (number < 0.0) {
      number = abs(number);
      if (divisor < 0.0) {
        divisor = abs(divisor);
      }
      return -mod(number, divisor);
    }
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return mod(number, divisor);
  }
  
  __INJECTED_NATIVE__;
  __MAIN_CONSTANTS__;
  __MAIN_ARGUMENTS__;
  __KERNEL__;
  
  void main(void) {
    index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
    __MAIN_RESULT__;
  }`;
  
      module.exports = {
        fragmentShader
      };
      },{}],38:[function(require,module,exports){
      const { utils } = require('../../utils');
      const { FunctionNode } = require('../function-node');
  
      class WebGLFunctionNode extends FunctionNode {
        constructor(source, settings) {
          super(source, settings);
          if (settings && settings.hasOwnProperty('fixIntegerDivisionAccuracy')) {
            this.fixIntegerDivisionAccuracy = settings.fixIntegerDivisionAccuracy;
          }
        }
  
        astConditionalExpression(ast, retArr) {
          if (ast.type !== 'ConditionalExpression') {
            throw this.astErrorOutput('Not a conditional expression', ast);
          }
          const consequentType = this.getType(ast.consequent);
          const alternateType = this.getType(ast.alternate);
          if (consequentType === null && alternateType === null) {
            retArr.push('if (');
            this.astGeneric(ast.test, retArr);
            retArr.push(') {');
            this.astGeneric(ast.consequent, retArr);
            retArr.push(';');
            retArr.push('} else {');
            this.astGeneric(ast.alternate, retArr);
            retArr.push(';');
            retArr.push('}');
            return retArr;
          }
          retArr.push('(');
          this.astGeneric(ast.test, retArr);
          retArr.push('?');
          this.astGeneric(ast.consequent, retArr);
          retArr.push(':');
          this.astGeneric(ast.alternate, retArr);
          retArr.push(')');
          return retArr;
        }
  
        astFunction(ast, retArr) {
          if (this.isRootKernel) {
            retArr.push('void');
          } else {
            if (!this.returnType) {
              const lastReturn = this.findLastReturn();
              if (lastReturn) {
                this.returnType = this.getType(ast.body);
                if (this.returnType === 'LiteralInteger') {
                  this.returnType = 'Number';
                }
              }
            }
  
            const { returnType } = this;
            if (!returnType) {
              retArr.push('void');
            } else {
              const type = typeMap[returnType];
              if (!type) {
                throw new Error(`unknown type ${returnType}`);
              }
              retArr.push(type);
            }
          }
          retArr.push(' ');
          retArr.push(this.name);
          retArr.push('(');
  
          if (!this.isRootKernel) {
            for (let i = 0; i < this.argumentNames.length; ++i) {
              const argumentName = this.argumentNames[i];
  
              if (i > 0) {
                retArr.push(', ');
              }
              let argumentType = this.argumentTypes[this.argumentNames.indexOf(argumentName)];
              if (!argumentType) {
                throw this.astErrorOutput(`Unknown argument ${argumentName} type`, ast);
              }
              if (argumentType === 'LiteralInteger') {
                this.argumentTypes[i] = argumentType = 'Number';
              }
              const type = typeMap[argumentType];
              if (!type) {
                throw this.astErrorOutput('Unexpected expression', ast);
              }
              const name = utils.sanitizeName(argumentName);
              if (type === 'sampler2D' || type === 'sampler2DArray') {
                retArr.push(`${type} user_${name},ivec2 user_${name}Size,ivec3 user_${name}Dim`);
              } else {
                retArr.push(`${type} user_${name}`);
              }
            }
          }
  
          retArr.push(') {\n');
  
          for (let i = 0; i < ast.body.body.length; ++i) {
            this.astGeneric(ast.body.body[i], retArr);
            retArr.push('\n');
          }
  
          retArr.push('}\n');
          return retArr;
        }
  
        astReturnStatement(ast, retArr) {
          if (!ast.argument) throw this.astErrorOutput('Unexpected return statement', ast);
          this.pushState('skip-literal-correction');
          const type = this.getType(ast.argument);
          this.popState('skip-literal-correction');
  
          const result = [];
  
          if (!this.returnType) {
            if (type === 'LiteralInteger' || type === 'Integer') {
              this.returnType = 'Number';
            } else {
              this.returnType = type;
            }
          }
  
          switch (this.returnType) {
            case 'LiteralInteger':
            case 'Number':
            case 'Float':
              switch (type) {
                case 'Integer':
                  result.push('float(');
                  this.astGeneric(ast.argument, result);
                  result.push(')');
                  break;
                case 'LiteralInteger':
                  this.castLiteralToFloat(ast.argument, result);
  
                  if (this.getType(ast) === 'Integer') {
                    result.unshift('float(');
                    result.push(')');
                  }
                  break;
                default:
                  this.astGeneric(ast.argument, result);
              }
              break;
            case 'Integer':
              switch (type) {
                case 'Float':
                case 'Number':
                  this.castValueToInteger(ast.argument, result);
                  break;
                case 'LiteralInteger':
                  this.castLiteralToInteger(ast.argument, result);
                  break;
                default:
                  this.astGeneric(ast.argument, result);
              }
              break;
            case 'Array(4)':
            case 'Array(3)':
            case 'Array(2)':
            case 'Matrix(2)':
            case 'Matrix(3)':
            case 'Matrix(4)':
            case 'Input':
              this.astGeneric(ast.argument, result);
              break;
            default:
              throw this.astErrorOutput(`unhandled return type ${this.returnType}`, ast);
          }
  
          if (this.isRootKernel) {
            retArr.push(`kernelResult = ${ result.join('') };`);
            retArr.push('return;');
          } else if (this.isSubKernel) {
            retArr.push(`subKernelResult_${ this.name } = ${ result.join('') };`);
            retArr.push(`return subKernelResult_${ this.name };`);
          } else {
            retArr.push(`return ${ result.join('') };`);
          }
          return retArr;
        }
  
        astLiteral(ast, retArr) {
          if (isNaN(ast.value)) {
            throw this.astErrorOutput(
              'Non-numeric literal not supported : ' + ast.value,
              ast
            );
          }
  
          const key = this.astKey(ast);
          if (Number.isInteger(ast.value)) {
            if (this.isState('casting-to-integer') || this.isState('building-integer')) {
              this.literalTypes[key] = 'Integer';
              retArr.push(`${ast.value}`);
            } else if (this.isState('casting-to-float') || this.isState('building-float')) {
              this.literalTypes[key] = 'Number';
              retArr.push(`${ast.value}.0`);
            } else {
              this.literalTypes[key] = 'Number';
              retArr.push(`${ast.value}.0`);
            }
          } else if (this.isState('casting-to-integer') || this.isState('building-integer')) {
            this.literalTypes[key] = 'Integer';
            retArr.push(Math.round(ast.value));
          } else {
            this.literalTypes[key] = 'Number';
            retArr.push(`${ast.value}`);
          }
          return retArr;
        }
  
        astBinaryExpression(ast, retArr) {
          if (this.checkAndUpconvertOperator(ast, retArr)) {
            return retArr;
          }
  
          if (this.fixIntegerDivisionAccuracy && ast.operator === '/') {
            retArr.push('divWithIntCheck(');
            this.pushState('building-float');
            switch (this.getType(ast.left)) {
              case 'Integer':
                this.castValueToFloat(ast.left, retArr);
                break;
              case 'LiteralInteger':
                this.castLiteralToFloat(ast.left, retArr);
                break;
              default:
                this.astGeneric(ast.left, retArr);
            }
            retArr.push(', ');
            switch (this.getType(ast.right)) {
              case 'Integer':
                this.castValueToFloat(ast.right, retArr);
                break;
              case 'LiteralInteger':
                this.castLiteralToFloat(ast.right, retArr);
                break;
              default:
                this.astGeneric(ast.right, retArr);
            }
            this.popState('building-float');
            retArr.push(')');
            return retArr;
          }
  
          retArr.push('(');
          const leftType = this.getType(ast.left) || 'Number';
          const rightType = this.getType(ast.right) || 'Number';
          if (!leftType || !rightType) {
            throw this.astErrorOutput(`Unhandled binary expression`, ast);
          }
          const key = leftType + ' & ' + rightType;
          switch (key) {
            case 'Integer & Integer':
              this.pushState('building-integer');
              this.astGeneric(ast.left, retArr);
              retArr.push(operatorMap[ast.operator] || ast.operator);
              this.astGeneric(ast.right, retArr);
              this.popState('building-integer');
              break;
            case 'Number & Float':
            case 'Float & Number':
            case 'Float & Float':
            case 'Number & Number':
              this.pushState('building-float');
              this.astGeneric(ast.left, retArr);
              retArr.push(operatorMap[ast.operator] || ast.operator);
              this.astGeneric(ast.right, retArr);
              this.popState('building-float');
              break;
            case 'LiteralInteger & LiteralInteger':
              if (this.isState('casting-to-integer') || this.isState('building-integer')) {
                this.pushState('building-integer');
                this.astGeneric(ast.left, retArr);
                retArr.push(operatorMap[ast.operator] || ast.operator);
                this.astGeneric(ast.right, retArr);
                this.popState('building-integer');
              } else {
                this.pushState('building-float');
                this.castLiteralToFloat(ast.left, retArr);
                retArr.push(operatorMap[ast.operator] || ast.operator);
                this.castLiteralToFloat(ast.right, retArr);
                this.popState('building-float');
              }
              break;
  
            case 'Integer & Float':
            case 'Integer & Number':
              if (ast.operator === '>' || ast.operator === '<' && ast.right.type === 'Literal') {
                if (!Number.isInteger(ast.right.value)) {
                  this.pushState('building-float');
                  this.castValueToFloat(ast.left, retArr);
                  retArr.push(operatorMap[ast.operator] || ast.operator);
                  this.astGeneric(ast.right, retArr);
                  this.popState('building-float');
                  break;
                }
              }
              this.pushState('building-integer');
              this.astGeneric(ast.left, retArr);
              retArr.push(operatorMap[ast.operator] || ast.operator);
              this.pushState('casting-to-integer');
              if (ast.right.type === 'Literal') {
                const literalResult = [];
                this.astGeneric(ast.right, literalResult);
                const literalType = this.getType(ast.right);
                if (literalType === 'Integer') {
                  retArr.push(literalResult.join(''));
                } else {
                  throw this.astErrorOutput(`Unhandled binary expression with literal`, ast);
                }
              } else {
                retArr.push('int(');
                this.astGeneric(ast.right, retArr);
                retArr.push(')');
              }
              this.popState('casting-to-integer');
              this.popState('building-integer');
              break;
            case 'Integer & LiteralInteger':
              this.pushState('building-integer');
              this.astGeneric(ast.left, retArr);
              retArr.push(operatorMap[ast.operator] || ast.operator);
              this.castLiteralToInteger(ast.right, retArr);
              this.popState('building-integer');
              break;
  
            case 'Number & Integer':
              this.pushState('building-float');
              this.astGeneric(ast.left, retArr);
              retArr.push(operatorMap[ast.operator] || ast.operator);
              this.castValueToFloat(ast.right, retArr);
              this.popState('building-float');
              break;
            case 'Float & LiteralInteger':
            case 'Number & LiteralInteger':
              this.pushState('building-float');
              this.astGeneric(ast.left, retArr);
              retArr.push(operatorMap[ast.operator] || ast.operator);
              this.castLiteralToFloat(ast.right, retArr);
              this.popState('building-float');
              break;
            case 'LiteralInteger & Float':
            case 'LiteralInteger & Number':
              if (this.isState('casting-to-integer')) {
                this.pushState('building-integer');
                this.castLiteralToInteger(ast.left, retArr);
                retArr.push(operatorMap[ast.operator] || ast.operator);
                this.castValueToInteger(ast.right, retArr);
                this.popState('building-integer');
              } else {
                this.pushState('building-float');
                this.astGeneric(ast.left, retArr);
                retArr.push(operatorMap[ast.operator] || ast.operator);
                this.pushState('casting-to-float');
                this.astGeneric(ast.right, retArr);
                this.popState('casting-to-float');
                this.popState('building-float');
              }
              break;
            case 'LiteralInteger & Integer':
              this.pushState('building-integer');
              this.castLiteralToInteger(ast.left, retArr);
              retArr.push(operatorMap[ast.operator] || ast.operator);
              this.astGeneric(ast.right, retArr);
              this.popState('building-integer');
              break;
  
            case 'Boolean & Boolean':
              this.pushState('building-boolean');
              this.astGeneric(ast.left, retArr);
              retArr.push(operatorMap[ast.operator] || ast.operator);
              this.astGeneric(ast.right, retArr);
              this.popState('building-boolean');
              break;
  
            case 'Float & Integer':
              this.pushState('building-float');
              this.astGeneric(ast.left, retArr);
              retArr.push(operatorMap[ast.operator] || ast.operator);
              this.castValueToFloat(ast.right, retArr);
              this.popState('building-float');
              break;
  
            default:
              throw this.astErrorOutput(`Unhandled binary expression between ${key}`, ast);
          }
          retArr.push(')');
  
          return retArr;
        }
  
        checkAndUpconvertOperator(ast, retArr) {
          const bitwiseResult = this.checkAndUpconvertBitwiseOperators(ast, retArr);
          if (bitwiseResult) {
            return bitwiseResult;
          }
          const upconvertableOperators = {
            '%': this.fixIntegerDivisionAccuracy ? 'integerCorrectionModulo' : 'modulo',
            '**': 'pow',
          };
          const foundOperator = upconvertableOperators[ast.operator];
          if (!foundOperator) return null;
          retArr.push(foundOperator);
          retArr.push('(');
          switch (this.getType(ast.left)) {
            case 'Integer':
              this.castValueToFloat(ast.left, retArr);
              break;
            case 'LiteralInteger':
              this.castLiteralToFloat(ast.left, retArr);
              break;
            default:
              this.astGeneric(ast.left, retArr);
          }
          retArr.push(',');
          switch (this.getType(ast.right)) {
            case 'Integer':
              this.castValueToFloat(ast.right, retArr);
              break;
            case 'LiteralInteger':
              this.castLiteralToFloat(ast.right, retArr);
              break;
            default:
              this.astGeneric(ast.right, retArr);
          }
          retArr.push(')');
          return retArr;
        }
  
        checkAndUpconvertBitwiseOperators(ast, retArr) {
          const upconvertableOperators = {
            '&': 'bitwiseAnd',
            '|': 'bitwiseOr',
            '^': 'bitwiseXOR',
            '<<': 'bitwiseZeroFillLeftShift',
            '>>': 'bitwiseSignedRightShift',
            '>>>': 'bitwiseZeroFillRightShift',
          };
          const foundOperator = upconvertableOperators[ast.operator];
          if (!foundOperator) return null;
          retArr.push(foundOperator);
          retArr.push('(');
          const leftType = this.getType(ast.left);
          switch (leftType) {
            case 'Number':
            case 'Float':
              this.castValueToInteger(ast.left, retArr);
              break;
            case 'LiteralInteger':
              this.castLiteralToInteger(ast.left, retArr);
              break;
            default:
              this.astGeneric(ast.left, retArr);
          }
          retArr.push(',');
          const rightType = this.getType(ast.right);
          switch (rightType) {
            case 'Number':
            case 'Float':
              this.castValueToInteger(ast.right, retArr);
              break;
            case 'LiteralInteger':
              this.castLiteralToInteger(ast.right, retArr);
              break;
            default:
              this.astGeneric(ast.right, retArr);
          }
          retArr.push(')');
          return retArr;
        }
  
        checkAndUpconvertBitwiseUnary(ast, retArr) {
          const upconvertableOperators = {
            '~': 'bitwiseNot',
          };
          const foundOperator = upconvertableOperators[ast.operator];
          if (!foundOperator) return null;
          retArr.push(foundOperator);
          retArr.push('(');
          switch (this.getType(ast.argument)) {
            case 'Number':
            case 'Float':
              this.castValueToInteger(ast.argument, retArr);
              break;
            case 'LiteralInteger':
              this.castLiteralToInteger(ast.argument, retArr);
              break;
            default:
              this.astGeneric(ast.argument, retArr);
          }
          retArr.push(')');
          return retArr;
        }
  
        castLiteralToInteger(ast, retArr) {
          this.pushState('casting-to-integer');
          this.astGeneric(ast, retArr);
          this.popState('casting-to-integer');
          return retArr;
        }
  
        castLiteralToFloat(ast, retArr) {
          this.pushState('casting-to-float');
          this.astGeneric(ast, retArr);
          this.popState('casting-to-float');
          return retArr;
        }
  
        castValueToInteger(ast, retArr) {
          this.pushState('casting-to-integer');
          retArr.push('int(');
          this.astGeneric(ast, retArr);
          retArr.push(')');
          this.popState('casting-to-integer');
          return retArr;
        }
  
        castValueToFloat(ast, retArr) {
          this.pushState('casting-to-float');
          retArr.push('float(');
          this.astGeneric(ast, retArr);
          retArr.push(')');
          this.popState('casting-to-float');
          return retArr;
        }
  
        astIdentifierExpression(idtNode, retArr) {
          if (idtNode.type !== 'Identifier') {
            throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);
          }
  
          const type = this.getType(idtNode);
  
          const name = utils.sanitizeName(idtNode.name);
          if (idtNode.name === 'Infinity') {
            retArr.push('3.402823466e+38');
          } else if (type === 'Boolean') {
            if (this.argumentNames.indexOf(name) > -1) {
              retArr.push(`bool(user_${name})`);
            } else {
              retArr.push(`user_${name}`);
            }
          } else {
            retArr.push(`user_${name}`);
          }
  
          return retArr;
        }
  
        astForStatement(forNode, retArr) {
          if (forNode.type !== 'ForStatement') {
            throw this.astErrorOutput('Invalid for statement', forNode);
          }
  
          const initArr = [];
          const testArr = [];
          const updateArr = [];
          const bodyArr = [];
          let isSafe = null;
  
          if (forNode.init) {
            const { declarations } = forNode.init;
            if (declarations.length > 1) {
              isSafe = false;
            }
            this.astGeneric(forNode.init, initArr);
            for (let i = 0; i < declarations.length; i++) {
              if (declarations[i].init && declarations[i].init.type !== 'Literal') {
                isSafe = false;
              }
            }
          } else {
            isSafe = false;
          }
  
          if (forNode.test) {
            this.astGeneric(forNode.test, testArr);
          } else {
            isSafe = false;
          }
  
          if (forNode.update) {
            this.astGeneric(forNode.update, updateArr);
          } else {
            isSafe = false;
          }
  
          if (forNode.body) {
            this.pushState('loop-body');
            this.astGeneric(forNode.body, bodyArr);
            this.popState('loop-body');
          }
  
          if (isSafe === null) {
            isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
          }
  
          if (isSafe) {
            const initString = initArr.join('');
            const initNeedsSemiColon = initString[initString.length - 1] !== ';';
            retArr.push(`for (${initString}${initNeedsSemiColon ? ';' : ''}${testArr.join('')};${updateArr.join('')}){\n`);
            retArr.push(bodyArr.join(''));
            retArr.push('}\n');
          } else {
            const iVariableName = this.getInternalVariableName('safeI');
            if (initArr.length > 0) {
              retArr.push(initArr.join(''), '\n');
            }
            retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
            if (testArr.length > 0) {
              retArr.push(`if (!${testArr.join('')}) break;\n`);
            }
            retArr.push(bodyArr.join(''));
            retArr.push(`\n${updateArr.join('')};`);
            retArr.push('}\n');
          }
          return retArr;
        }
  
        astWhileStatement(whileNode, retArr) {
          if (whileNode.type !== 'WhileStatement') {
            throw this.astErrorOutput('Invalid while statement', whileNode);
          }
  
          const iVariableName = this.getInternalVariableName('safeI');
          retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
          retArr.push('if (!');
          this.astGeneric(whileNode.test, retArr);
          retArr.push(') break;\n');
          this.astGeneric(whileNode.body, retArr);
          retArr.push('}\n');
  
          return retArr;
        }
  
        astDoWhileStatement(doWhileNode, retArr) {
          if (doWhileNode.type !== 'DoWhileStatement') {
            throw this.astErrorOutput('Invalid while statement', doWhileNode);
          }
  
          const iVariableName = this.getInternalVariableName('safeI');
          retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
          this.astGeneric(doWhileNode.body, retArr);
          retArr.push('if (!');
          this.astGeneric(doWhileNode.test, retArr);
          retArr.push(') break;\n');
          retArr.push('}\n');
  
          return retArr;
        }
  
  
        astAssignmentExpression(assNode, retArr) {
          if (assNode.operator === '%=') {
            this.astGeneric(assNode.left, retArr);
            retArr.push('=');
            retArr.push('mod(');
            this.astGeneric(assNode.left, retArr);
            retArr.push(',');
            this.astGeneric(assNode.right, retArr);
            retArr.push(')');
          } else if (assNode.operator === '**=') {
            this.astGeneric(assNode.left, retArr);
            retArr.push('=');
            retArr.push('pow(');
            this.astGeneric(assNode.left, retArr);
            retArr.push(',');
            this.astGeneric(assNode.right, retArr);
            retArr.push(')');
          } else {
            const leftType = this.getType(assNode.left);
            const rightType = this.getType(assNode.right);
            this.astGeneric(assNode.left, retArr);
            retArr.push(assNode.operator);
            if (leftType !== 'Integer' && rightType === 'Integer') {
              retArr.push('float(');
              this.astGeneric(assNode.right, retArr);
              retArr.push(')');
            } else {
              this.astGeneric(assNode.right, retArr);
            }
            return retArr;
          }
        }
  
        astBlockStatement(bNode, retArr) {
          if (this.isState('loop-body')) {
            this.pushState('block-body'); 
            for (let i = 0; i < bNode.body.length; i++) {
              this.astGeneric(bNode.body[i], retArr);
            }
            this.popState('block-body');
          } else {
            retArr.push('{\n');
            for (let i = 0; i < bNode.body.length; i++) {
              this.astGeneric(bNode.body[i], retArr);
            }
            retArr.push('}\n');
          }
          return retArr;
        }
  
        astVariableDeclaration(varDecNode, retArr) {
          const declarations = varDecNode.declarations;
          if (!declarations || !declarations[0] || !declarations[0].init) {
            throw this.astErrorOutput('Unexpected expression', varDecNode);
          }
          const result = [];
          let lastType = null;
          const declarationSets = [];
          let declarationSet = [];
          for (let i = 0; i < declarations.length; i++) {
            const declaration = declarations[i];
            const init = declaration.init;
            const info = this.getDeclaration(declaration.id);
            const actualType = this.getType(declaration.init);
            let type = actualType;
            if (type === 'LiteralInteger') {
              if (info.suggestedType === 'Integer') {
                type = 'Integer';
              } else {
                type = 'Number';
              }
            }
            const markupType = typeMap[type];
            if (!markupType) {
              throw this.astErrorOutput(`Markup type ${ type } not handled`, varDecNode);
            }
            const declarationResult = [];
            if (actualType === 'Integer' && type === 'Integer') {
              info.valueType = 'Number';
              if (i === 0 || lastType === null) {
                declarationResult.push('float ');
              } else if (type !== lastType) {
                throw new Error('Unhandled declaration');
              }
              lastType = type;
              declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);
              declarationResult.push('float(');
              this.astGeneric(init, declarationResult);
              declarationResult.push(')');
            } else {
              info.valueType = type;
              if (i === 0 || lastType === null) {
                declarationResult.push(`${markupType} `);
              } else if (type !== lastType) {
                declarationSets.push(declarationSet.join(','));
                declarationSet = [];
                declarationResult.push(`${markupType} `);
              }
              lastType = type;
              declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);
              if (actualType === 'Number' && type === 'Integer') {
                if (init.left && init.left.type === 'Literal') {
                  this.astGeneric(init, declarationResult);
                } else {
                  declarationResult.push('int(');
                  this.astGeneric(init, declarationResult);
                  declarationResult.push(')');
                }
              } else if (actualType === 'LiteralInteger' && type === 'Integer') {
                this.castLiteralToInteger(init, declarationResult);
              } else {
                this.astGeneric(init, declarationResult);
              }
            }
            declarationSet.push(declarationResult.join(''));
          }
  
          if (declarationSet.length > 0) {
            declarationSets.push(declarationSet.join(','));
          }
  
          result.push(declarationSets.join(';'));
  
          retArr.push(result.join(''));
          retArr.push(';');
          return retArr;
        }
  
        astIfStatement(ifNode, retArr) {
          retArr.push('if (');
          this.astGeneric(ifNode.test, retArr);
          retArr.push(')');
          if (ifNode.consequent.type === 'BlockStatement') {
            this.astGeneric(ifNode.consequent, retArr);
          } else {
            retArr.push(' {\n');
            this.astGeneric(ifNode.consequent, retArr);
            retArr.push('\n}\n');
          }
  
          if (ifNode.alternate) {
            retArr.push('else ');
            if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {
              this.astGeneric(ifNode.alternate, retArr);
            } else {
              retArr.push(' {\n');
              this.astGeneric(ifNode.alternate, retArr);
              retArr.push('\n}\n');
            }
          }
          return retArr;
        }
  
        astSwitchStatement(ast, retArr) {
          if (ast.type !== 'SwitchStatement') {
            throw this.astErrorOutput('Invalid switch statement', ast);
          }
          const { discriminant, cases } = ast;
          const type = this.getType(discriminant);
          const varName = `switchDiscriminant${this.astKey(ast, '_')}`;
          switch (type) {
            case 'Float':
            case 'Number':
              retArr.push(`float ${varName} = `);
              this.astGeneric(discriminant, retArr);
              retArr.push(';\n');
              break;
            case 'Integer':
              retArr.push(`int ${varName} = `);
              this.astGeneric(discriminant, retArr);
              retArr.push(';\n');
              break;
          }
          if (cases.length === 1 && !cases[0].test) {
            this.astGeneric(cases[0].consequent, retArr);
            return retArr;
          }
  
          let fallingThrough = false;
          let defaultResult = [];
          let movingDefaultToEnd = false;
          let pastFirstIf = false;
          for (let i = 0; i < cases.length; i++) {
            if (!cases[i].test) {
              if (cases.length > i + 1) {
                movingDefaultToEnd = true;
                this.astGeneric(cases[i].consequent, defaultResult);
                continue;
              } else {
                retArr.push(' else {\n');
              }
            } else {
              if (i === 0 || !pastFirstIf) {
                pastFirstIf = true;
                retArr.push(`if (${varName} == `);
              } else {
                if (fallingThrough) {
                  retArr.push(`${varName} == `);
                  fallingThrough = false;
                } else {
                  retArr.push(` else if (${varName} == `);
                }
              }
              if (type === 'Integer') {
                const testType = this.getType(cases[i].test);
                switch (testType) {
                  case 'Number':
                  case 'Float':
                    this.castValueToInteger(cases[i].test, retArr);
                    break;
                  case 'LiteralInteger':
                    this.castLiteralToInteger(cases[i].test, retArr);
                    break;
                }
              } else if (type === 'Float') {
                const testType = this.getType(cases[i].test);
                switch (testType) {
                  case 'LiteralInteger':
                    this.castLiteralToFloat(cases[i].test, retArr);
                    break;
                  case 'Integer':
                    this.castValueToFloat(cases[i].test, retArr);
                    break;
                }
              } else {
                throw new Error('unhanlded');
              }
              if (!cases[i].consequent || cases[i].consequent.length === 0) {
                fallingThrough = true;
                retArr.push(' || ');
                continue;
              }
              retArr.push(`) {\n`);
            }
            this.astGeneric(cases[i].consequent, retArr);
            retArr.push('\n}');
          }
          if (movingDefaultToEnd) {
            retArr.push(' else {');
            retArr.push(defaultResult.join(''));
            retArr.push('}');
          }
          return retArr;
        }
  
        astThisExpression(tNode, retArr) {
          retArr.push('this');
          return retArr;
        }
  
        astMemberExpression(mNode, retArr) {
          const {
            property,
            name,
            signature,
            origin,
            type,
            xProperty,
            yProperty,
            zProperty
          } = this.getMemberExpressionDetails(mNode);
          switch (signature) {
            case 'value.thread.value':
            case 'this.thread.value':
              if (name !== 'x' && name !== 'y' && name !== 'z') {
                throw this.astErrorOutput('Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`', mNode);
              }
              retArr.push(`threadId.${name}`);
              return retArr;
            case 'this.output.value':
              if (this.dynamicOutput) {
                switch (name) {
                  case 'x':
                    if (this.isState('casting-to-float')) {
                      retArr.push('float(uOutputDim.x)');
                    } else {
                      retArr.push('uOutputDim.x');
                    }
                    break;
                  case 'y':
                    if (this.isState('casting-to-float')) {
                      retArr.push('float(uOutputDim.y)');
                    } else {
                      retArr.push('uOutputDim.y');
                    }
                    break;
                  case 'z':
                    if (this.isState('casting-to-float')) {
                      retArr.push('float(uOutputDim.z)');
                    } else {
                      retArr.push('uOutputDim.z');
                    }
                    break;
                  default:
                    throw this.astErrorOutput('Unexpected expression', mNode);
                }
              } else {
                switch (name) {
                  case 'x':
                    if (this.isState('casting-to-integer')) {
                      retArr.push(this.output[0]);
                    } else {
                      retArr.push(this.output[0], '.0');
                    }
                    break;
                  case 'y':
                    if (this.isState('casting-to-integer')) {
                      retArr.push(this.output[1]);
                    } else {
                      retArr.push(this.output[1], '.0');
                    }
                    break;
                  case 'z':
                    if (this.isState('casting-to-integer')) {
                      retArr.push(this.output[2]);
                    } else {
                      retArr.push(this.output[2], '.0');
                    }
                    break;
                  default:
                    throw this.astErrorOutput('Unexpected expression', mNode);
                }
              }
              return retArr;
            case 'value':
              throw this.astErrorOutput('Unexpected expression', mNode);
            case 'value[]':
            case 'value[][]':
            case 'value[][][]':
            case 'value[][][][]':
            case 'value.value':
              if (origin === 'Math') {
                retArr.push(Math[name]);
                return retArr;
              }
              const cleanName = utils.sanitizeName(name);
              switch (property) {
                case 'r':
                  retArr.push(`user_${ cleanName }.r`);
                  return retArr;
                case 'g':
                  retArr.push(`user_${ cleanName }.g`);
                  return retArr;
                case 'b':
                  retArr.push(`user_${ cleanName }.b`);
                  return retArr;
                case 'a':
                  retArr.push(`user_${ cleanName }.a`);
                  return retArr;
              }
              break;
            case 'this.constants.value':
              if (typeof xProperty === 'undefined') {
                switch (type) {
                  case 'Array(2)':
                  case 'Array(3)':
                  case 'Array(4)':
                    retArr.push(`constants_${ utils.sanitizeName(name) }`);
                    return retArr;
                }
              }
              case 'this.constants.value[]':
              case 'this.constants.value[][]':
              case 'this.constants.value[][][]':
              case 'this.constants.value[][][][]':
                break;
              case 'fn()[]':
                this.astCallExpression(mNode.object, retArr);
                retArr.push('[');
                retArr.push(this.memberExpressionPropertyMarkup(property));
                retArr.push(']');
                return retArr;
              case 'fn()[][]':
                this.astCallExpression(mNode.object.object, retArr);
                retArr.push('[');
                retArr.push(this.memberExpressionPropertyMarkup(mNode.object.property));
                retArr.push(']');
                retArr.push('[');
                retArr.push(this.memberExpressionPropertyMarkup(mNode.property));
                retArr.push(']');
                return retArr;
              case '[][]':
                this.astArrayExpression(mNode.object, retArr);
                retArr.push('[');
                retArr.push(this.memberExpressionPropertyMarkup(property));
                retArr.push(']');
                return retArr;
              default:
                throw this.astErrorOutput('Unexpected expression', mNode);
          }
  
          if (mNode.computed === false) {
            switch (type) {
              case 'Number':
              case 'Integer':
              case 'Float':
              case 'Boolean':
                retArr.push(`${origin}_${utils.sanitizeName(name)}`);
                return retArr;
            }
          }
  
          const markupName = `${origin}_${utils.sanitizeName(name)}`;
  
          switch (type) {
            case 'Array(2)':
            case 'Array(3)':
            case 'Array(4)':
              this.astGeneric(mNode.object, retArr);
              retArr.push('[');
              retArr.push(this.memberExpressionPropertyMarkup(xProperty));
              retArr.push(']');
              break;
            case 'HTMLImageArray':
              retArr.push(`getImage3D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
              retArr.push(')');
              break;
            case 'ArrayTexture(1)':
              retArr.push(`getFloatFromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
              retArr.push(')');
              break;
            case 'Array1D(2)':
            case 'Array2D(2)':
            case 'Array3D(2)':
              retArr.push(`getMemoryOptimizedVec2(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
              retArr.push(')');
              break;
            case 'ArrayTexture(2)':
              retArr.push(`getVec2FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
              retArr.push(')');
              break;
            case 'Array1D(3)':
            case 'Array2D(3)':
            case 'Array3D(3)':
              retArr.push(`getMemoryOptimizedVec3(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
              retArr.push(')');
              break;
            case 'ArrayTexture(3)':
              retArr.push(`getVec3FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
              retArr.push(')');
              break;
            case 'Array1D(4)':
            case 'Array2D(4)':
            case 'Array3D(4)':
              retArr.push(`getMemoryOptimizedVec4(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
              retArr.push(')');
              break;
            case 'ArrayTexture(4)':
            case 'HTMLCanvas':
            case 'OffscreenCanvas':
            case 'HTMLImage':
            case 'ImageBitmap':
            case 'ImageData':
            case 'HTMLVideo':
              retArr.push(`getVec4FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
              retArr.push(')');
              break;
            case 'NumberTexture':
            case 'Array':
            case 'Array2D':
            case 'Array3D':
            case 'Array4D':
            case 'Input':
            case 'Number':
            case 'Float':
            case 'Integer':
              if (this.precision === 'single') {
                retArr.push(`getMemoryOptimized32(${markupName}, ${markupName}Size, ${markupName}Dim, `);
                this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
                retArr.push(')');
              } else {
                const bitRatio = (origin === 'user' ?
                  this.lookupFunctionArgumentBitRatio(this.name, name) :
                  this.constantBitRatios[name]
                );
                switch (bitRatio) {
                  case 1:
                    retArr.push(`get8(${markupName}, ${markupName}Size, ${markupName}Dim, `);
                    break;
                  case 2:
                    retArr.push(`get16(${markupName}, ${markupName}Size, ${markupName}Dim, `);
                    break;
                  case 4:
                  case 0:
                    retArr.push(`get32(${markupName}, ${markupName}Size, ${markupName}Dim, `);
                    break;
                  default:
                    throw new Error(`unhandled bit ratio of ${bitRatio}`);
                }
                this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
                retArr.push(')');
              }
              break;
            case 'MemoryOptimizedNumberTexture':
              retArr.push(`getMemoryOptimized32(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
              retArr.push(')');
              break;
            case 'Matrix(2)':
            case 'Matrix(3)':
            case 'Matrix(4)':
              retArr.push(`${markupName}[${this.memberExpressionPropertyMarkup(yProperty)}]`);
              if (yProperty) {
                retArr.push(`[${this.memberExpressionPropertyMarkup(xProperty)}]`);
              }
              break;
            default:
              throw new Error(`unhandled member expression "${ type }"`);
          }
          return retArr;
        }
  
        astCallExpression(ast, retArr) {
          if (!ast.callee) {
            throw this.astErrorOutput('Unknown CallExpression', ast);
          }
  
          let functionName = null;
          const isMathFunction = this.isAstMathFunction(ast);
  
          if (isMathFunction || (ast.callee.object && ast.callee.object.type === 'ThisExpression')) {
            functionName = ast.callee.property.name;
          }
          else if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[0].type === 'Literal' && !isNaN(ast.callee.expressions[0].raw)) {
            functionName = ast.callee.expressions[1].property.name;
          } else {
            functionName = ast.callee.name;
          }
  
          if (!functionName) {
            throw this.astErrorOutput(`Unhandled function, couldn't find name`, ast);
          }
  
          switch (functionName) {
            case 'pow':
              functionName = '_pow';
              break;
            case 'round':
              functionName = '_round';
              break;
          }
  
          if (this.calledFunctions.indexOf(functionName) < 0) {
            this.calledFunctions.push(functionName);
          }
  
          if (functionName === 'random' && this.plugins && this.plugins.length > 0) {
            for (let i = 0; i < this.plugins.length; i++) {
              const plugin = this.plugins[i];
              if (plugin.functionMatch === 'Math.random()' && plugin.functionReplace) {
                retArr.push(plugin.functionReplace);
                return retArr;
              }
            }
          }
  
          if (this.onFunctionCall) {
            this.onFunctionCall(this.name, functionName, ast.arguments);
          }
  
          retArr.push(functionName);
  
          retArr.push('(');
  
          if (isMathFunction) {
            for (let i = 0; i < ast.arguments.length; ++i) {
              const argument = ast.arguments[i];
              const argumentType = this.getType(argument);
              if (i > 0) {
                retArr.push(', ');
              }
  
              switch (argumentType) {
                case 'Integer':
                  this.castValueToFloat(argument, retArr);
                  break;
                default:
                  this.astGeneric(argument, retArr);
                  break;
              }
            }
          } else {
            const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];
            for (let i = 0; i < ast.arguments.length; ++i) {
              const argument = ast.arguments[i];
              let targetType = targetTypes[i];
              if (i > 0) {
                retArr.push(', ');
              }
              const argumentType = this.getType(argument);
              if (!targetType) {
                this.triggerImplyArgumentType(functionName, i, argumentType, this);
                targetType = argumentType;
              }
              switch (argumentType) {
                case 'Boolean':
                  this.astGeneric(argument, retArr);
                  continue;
                case 'Number':
                case 'Float':
                  if (targetType === 'Integer') {
                    retArr.push('int(');
                    this.astGeneric(argument, retArr);
                    retArr.push(')');
                    continue;
                  } else if (targetType === 'Number' || targetType === 'Float') {
                    this.astGeneric(argument, retArr);
                    continue;
                  } else if (targetType === 'LiteralInteger') {
                    this.castLiteralToFloat(argument, retArr);
                    continue;
                  }
                  break;
                case 'Integer':
                  if (targetType === 'Number' || targetType === 'Float') {
                    retArr.push('float(');
                    this.astGeneric(argument, retArr);
                    retArr.push(')');
                    continue;
                  } else if (targetType === 'Integer') {
                    this.astGeneric(argument, retArr);
                    continue;
                  }
                  break;
                case 'LiteralInteger':
                  if (targetType === 'Integer') {
                    this.castLiteralToInteger(argument, retArr);
                    continue;
                  } else if (targetType === 'Number' || targetType === 'Float') {
                    this.castLiteralToFloat(argument, retArr);
                    continue;
                  } else if (targetType === 'LiteralInteger') {
                    this.astGeneric(argument, retArr);
                    continue;
                  }
                  break;
                case 'Array(2)':
                case 'Array(3)':
                case 'Array(4)':
                  if (targetType === argumentType) {
                    if (argument.type === 'Identifier') {
                      retArr.push(`user_${utils.sanitizeName(argument.name)}`);
                    } else if (argument.type === 'ArrayExpression' || argument.type === 'MemberExpression' || argument.type === 'CallExpression') {
                      this.astGeneric(argument, retArr);
                    } else {
                      throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);
                    }
                    continue;
                  }
                  break;
                case 'HTMLCanvas':
                case 'OffscreenCanvas':
                case 'HTMLImage':
                case 'ImageBitmap':
                case 'ImageData':
                case 'HTMLImageArray':
                case 'HTMLVideo':
                case 'ArrayTexture(1)':
                case 'ArrayTexture(2)':
                case 'ArrayTexture(3)':
                case 'ArrayTexture(4)':
                case 'Array':
                case 'Input':
                  if (targetType === argumentType) {
                    if (argument.type !== 'Identifier') throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);
                    this.triggerImplyArgumentBitRatio(this.name, argument.name, functionName, i);
                    const name = utils.sanitizeName(argument.name);
                    retArr.push(`user_${name},user_${name}Size,user_${name}Dim`);
                    continue;
                  }
                  break;
              }
              throw this.astErrorOutput(`Unhandled argument combination of ${ argumentType } and ${ targetType } for argument named "${ argument.name }"`, ast);
            }
          }
          retArr.push(')');
  
          return retArr;
        }
  
        astArrayExpression(arrNode, retArr) {
          const returnType = this.getType(arrNode);
  
          const arrLen = arrNode.elements.length;
  
          switch (returnType) {
            case 'Matrix(2)':
            case 'Matrix(3)':
            case 'Matrix(4)':
              retArr.push(`mat${arrLen}(`);
              break;
            default:
              retArr.push(`vec${arrLen}(`);
          }
          for (let i = 0; i < arrLen; ++i) {
            if (i > 0) {
              retArr.push(', ');
            }
            const subNode = arrNode.elements[i];
            this.astGeneric(subNode, retArr);
          }
          retArr.push(')');
  
          return retArr;
        }
  
        memberExpressionXYZ(x, y, z, retArr) {
          if (z) {
            retArr.push(this.memberExpressionPropertyMarkup(z), ', ');
          } else {
            retArr.push('0, ');
          }
          if (y) {
            retArr.push(this.memberExpressionPropertyMarkup(y), ', ');
          } else {
            retArr.push('0, ');
          }
          retArr.push(this.memberExpressionPropertyMarkup(x));
          return retArr;
        }
  
        memberExpressionPropertyMarkup(property) {
          if (!property) {
            throw new Error('Property not set');
          }
          const type = this.getType(property);
          const result = [];
          switch (type) {
            case 'Number':
            case 'Float':
              this.castValueToInteger(property, result);
              break;
            case 'LiteralInteger':
              this.castLiteralToInteger(property, result);
              break;
            default:
              this.astGeneric(property, result);
          }
          return result.join('');
        }
      }
  
      const typeMap = {
        'Array': 'sampler2D',
        'Array(2)': 'vec2',
        'Array(3)': 'vec3',
        'Array(4)': 'vec4',
        'Matrix(2)': 'mat2',
        'Matrix(3)': 'mat3',
        'Matrix(4)': 'mat4',
        'Array2D': 'sampler2D',
        'Array3D': 'sampler2D',
        'Boolean': 'bool',
        'Float': 'float',
        'Input': 'sampler2D',
        'Integer': 'int',
        'Number': 'float',
        'LiteralInteger': 'float',
        'NumberTexture': 'sampler2D',
        'MemoryOptimizedNumberTexture': 'sampler2D',
        'ArrayTexture(1)': 'sampler2D',
        'ArrayTexture(2)': 'sampler2D',
        'ArrayTexture(3)': 'sampler2D',
        'ArrayTexture(4)': 'sampler2D',
        'HTMLVideo': 'sampler2D',
        'HTMLCanvas': 'sampler2D',
        'OffscreenCanvas': 'sampler2D',
        'HTMLImage': 'sampler2D',
        'ImageBitmap': 'sampler2D',
        'ImageData': 'sampler2D',
        'HTMLImageArray': 'sampler2DArray',
      };
  
      const operatorMap = {
        '===': '==',
        '!==': '!='
      };
  
      module.exports = {
        WebGLFunctionNode
      };
      },{"../../utils":114,"../function-node":10}],39:[function(require,module,exports){
      const { WebGLKernelValueBoolean } = require('./kernel-value/boolean');
      const { WebGLKernelValueFloat } = require('./kernel-value/float');
      const { WebGLKernelValueInteger } = require('./kernel-value/integer');
  
      const { WebGLKernelValueHTMLImage } = require('./kernel-value/html-image');
      const { WebGLKernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');
  
      const { WebGLKernelValueHTMLVideo } = require('./kernel-value/html-video');
      const { WebGLKernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');
  
      const { WebGLKernelValueSingleInput } = require('./kernel-value/single-input');
      const { WebGLKernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');
  
      const { WebGLKernelValueUnsignedInput } = require('./kernel-value/unsigned-input');
      const { WebGLKernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');
  
      const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');
      const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');
  
      const { WebGLKernelValueNumberTexture } = require('./kernel-value/number-texture');
      const { WebGLKernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');
  
      const { WebGLKernelValueSingleArray } = require('./kernel-value/single-array');
      const { WebGLKernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');
  
      const { WebGLKernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');
      const { WebGLKernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');
  
      const { WebGLKernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');
      const { WebGLKernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');
  
      const { WebGLKernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');
      const { WebGLKernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');
  
      const { WebGLKernelValueArray2 } = require('./kernel-value/array2');
      const { WebGLKernelValueArray3 } = require('./kernel-value/array3');
      const { WebGLKernelValueArray4 } = require('./kernel-value/array4');
  
      const { WebGLKernelValueUnsignedArray } = require('./kernel-value/unsigned-array');
      const { WebGLKernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');
  
      const kernelValueMaps = {
        unsigned: {
          dynamic: {
            'Boolean': WebGLKernelValueBoolean,
            'Integer': WebGLKernelValueInteger,
            'Float': WebGLKernelValueFloat,
            'Array': WebGLKernelValueDynamicUnsignedArray,
            'Array(2)': WebGLKernelValueArray2,
            'Array(3)': WebGLKernelValueArray3,
            'Array(4)': WebGLKernelValueArray4,
            'Array1D(2)': false,
            'Array1D(3)': false,
            'Array1D(4)': false,
            'Array2D(2)': false,
            'Array2D(3)': false,
            'Array2D(4)': false,
            'Array3D(2)': false,
            'Array3D(3)': false,
            'Array3D(4)': false,
            'Input': WebGLKernelValueDynamicUnsignedInput,
            'NumberTexture': WebGLKernelValueDynamicNumberTexture,
            'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,
            'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,
            'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,
            'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,
            'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
            'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,
            'OffscreenCanvas': WebGLKernelValueDynamicHTMLImage,
            'HTMLImage': WebGLKernelValueDynamicHTMLImage,
            'ImageBitmap': WebGLKernelValueDynamicHTMLImage,
            'ImageData': WebGLKernelValueDynamicHTMLImage,
            'HTMLImageArray': false,
            'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,
          },
          static: {
            'Boolean': WebGLKernelValueBoolean,
            'Float': WebGLKernelValueFloat,
            'Integer': WebGLKernelValueInteger,
            'Array': WebGLKernelValueUnsignedArray,
            'Array(2)': WebGLKernelValueArray2,
            'Array(3)': WebGLKernelValueArray3,
            'Array(4)': WebGLKernelValueArray4,
            'Array1D(2)': false,
            'Array1D(3)': false,
            'Array1D(4)': false,
            'Array2D(2)': false,
            'Array2D(3)': false,
            'Array2D(4)': false,
            'Array3D(2)': false,
            'Array3D(3)': false,
            'Array3D(4)': false,
            'Input': WebGLKernelValueUnsignedInput,
            'NumberTexture': WebGLKernelValueNumberTexture,
            'ArrayTexture(1)': WebGLKernelValueNumberTexture,
            'ArrayTexture(2)': WebGLKernelValueNumberTexture,
            'ArrayTexture(3)': WebGLKernelValueNumberTexture,
            'ArrayTexture(4)': WebGLKernelValueNumberTexture,
            'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,
            'HTMLCanvas': WebGLKernelValueHTMLImage,
            'OffscreenCanvas': WebGLKernelValueHTMLImage,
            'HTMLImage': WebGLKernelValueHTMLImage,
            'ImageBitmap': WebGLKernelValueHTMLImage,
            'ImageData': WebGLKernelValueHTMLImage,
            'HTMLImageArray': false,
            'HTMLVideo': WebGLKernelValueHTMLVideo,
          }
        },
        single: {
          dynamic: {
            'Boolean': WebGLKernelValueBoolean,
            'Integer': WebGLKernelValueInteger,
            'Float': WebGLKernelValueFloat,
            'Array': WebGLKernelValueDynamicSingleArray,
            'Array(2)': WebGLKernelValueArray2,
            'Array(3)': WebGLKernelValueArray3,
            'Array(4)': WebGLKernelValueArray4,
            'Array1D(2)': WebGLKernelValueDynamicSingleArray1DI,
            'Array1D(3)': WebGLKernelValueDynamicSingleArray1DI,
            'Array1D(4)': WebGLKernelValueDynamicSingleArray1DI,
            'Array2D(2)': WebGLKernelValueDynamicSingleArray2DI,
            'Array2D(3)': WebGLKernelValueDynamicSingleArray2DI,
            'Array2D(4)': WebGLKernelValueDynamicSingleArray2DI,
            'Array3D(2)': WebGLKernelValueDynamicSingleArray3DI,
            'Array3D(3)': WebGLKernelValueDynamicSingleArray3DI,
            'Array3D(4)': WebGLKernelValueDynamicSingleArray3DI,
            'Input': WebGLKernelValueDynamicSingleInput,
            'NumberTexture': WebGLKernelValueDynamicNumberTexture,
            'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,
            'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,
            'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,
            'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,
            'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
            'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,
            'OffscreenCanvas': WebGLKernelValueDynamicHTMLImage,
            'HTMLImage': WebGLKernelValueDynamicHTMLImage,
            'ImageBitmap': WebGLKernelValueDynamicHTMLImage,
            'ImageData': WebGLKernelValueDynamicHTMLImage,
            'HTMLImageArray': false,
            'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,
          },
          static: {
            'Boolean': WebGLKernelValueBoolean,
            'Float': WebGLKernelValueFloat,
            'Integer': WebGLKernelValueInteger,
            'Array': WebGLKernelValueSingleArray,
            'Array(2)': WebGLKernelValueArray2,
            'Array(3)': WebGLKernelValueArray3,
            'Array(4)': WebGLKernelValueArray4,
            'Array1D(2)': WebGLKernelValueSingleArray1DI,
            'Array1D(3)': WebGLKernelValueSingleArray1DI,
            'Array1D(4)': WebGLKernelValueSingleArray1DI,
            'Array2D(2)': WebGLKernelValueSingleArray2DI,
            'Array2D(3)': WebGLKernelValueSingleArray2DI,
            'Array2D(4)': WebGLKernelValueSingleArray2DI,
            'Array3D(2)': WebGLKernelValueSingleArray3DI,
            'Array3D(3)': WebGLKernelValueSingleArray3DI,
            'Array3D(4)': WebGLKernelValueSingleArray3DI,
            'Input': WebGLKernelValueSingleInput,
            'NumberTexture': WebGLKernelValueNumberTexture,
            'ArrayTexture(1)': WebGLKernelValueNumberTexture,
            'ArrayTexture(2)': WebGLKernelValueNumberTexture,
            'ArrayTexture(3)': WebGLKernelValueNumberTexture,
            'ArrayTexture(4)': WebGLKernelValueNumberTexture,
            'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,
            'HTMLCanvas': WebGLKernelValueHTMLImage,
            'OffscreenCanvas': WebGLKernelValueHTMLImage,
            'HTMLImage': WebGLKernelValueHTMLImage,
            'ImageBitmap': WebGLKernelValueHTMLImage,
            'ImageData': WebGLKernelValueHTMLImage,
            'HTMLImageArray': false,
            'HTMLVideo': WebGLKernelValueHTMLVideo,
          }
        },
      };
  
      function lookupKernelValueType(type, dynamic, precision, value) {
        if (!type) {
          throw new Error('type missing');
        }
        if (!dynamic) {
          throw new Error('dynamic missing');
        }
        if (!precision) {
          throw new Error('precision missing');
        }
        if (value.type) {
          type = value.type;
        }
        const types = kernelValueMaps[precision][dynamic];
        if (types[type] === false) {
          return null;
        } else if (types[type] === undefined) {
          throw new Error(`Could not find a KernelValue for ${ type }`);
        }
        return types[type];
      }
  
      module.exports = {
        lookupKernelValueType,
        kernelValueMaps,
      };
      },{"./kernel-value/array2":41,"./kernel-value/array3":42,"./kernel-value/array4":43,"./kernel-value/boolean":44,"./kernel-value/dynamic-html-image":45,"./kernel-value/dynamic-html-video":46,"./kernel-value/dynamic-memory-optimized-number-texture":47,"./kernel-value/dynamic-number-texture":48,"./kernel-value/dynamic-single-array":49,"./kernel-value/dynamic-single-array1d-i":50,"./kernel-value/dynamic-single-array2d-i":51,"./kernel-value/dynamic-single-array3d-i":52,"./kernel-value/dynamic-single-input":53,"./kernel-value/dynamic-unsigned-array":54,"./kernel-value/dynamic-unsigned-input":55,"./kernel-value/float":56,"./kernel-value/html-image":57,"./kernel-value/html-video":58,"./kernel-value/integer":60,"./kernel-value/memory-optimized-number-texture":61,"./kernel-value/number-texture":62,"./kernel-value/single-array":63,"./kernel-value/single-array1d-i":64,"./kernel-value/single-array2d-i":65,"./kernel-value/single-array3d-i":66,"./kernel-value/single-input":67,"./kernel-value/unsigned-array":68,"./kernel-value/unsigned-input":69}],40:[function(require,module,exports){
      const { WebGLKernelValue } = require('./index');
      const { Input } = require('../../../input');
  
      class WebGLKernelArray extends WebGLKernelValue {
        checkSize(width, height) {
          if (!this.kernel.validate) return;
          const { maxTextureSize } = this.kernel.constructor.features;
          if (width > maxTextureSize || height > maxTextureSize) {
            if (width > height) {
              throw new Error(`Argument texture width of ${width} larger than maximum size of ${maxTextureSize} for your GPU`);
            } else if (width < height) {
              throw new Error(`Argument texture height of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);
            } else {
              throw new Error(`Argument texture height and width of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);
            }
          }
        }
  
        setup() {
          this.requestTexture();
          this.setupTexture();
          this.defineTexture();
        }
  
        requestTexture() {
          this.texture = this.onRequestTexture();
        }
  
        defineTexture() {
          const { context: gl } = this;
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        }
  
        setupTexture() {
          this.contextHandle = this.onRequestContextHandle();
          this.index = this.onRequestIndex();
          this.dimensionsId = this.id + 'Dim';
          this.sizeId = this.id + 'Size';
        }
  
        getBitRatio(value) {
          if (Array.isArray(value[0])) {
            return this.getBitRatio(value[0]);
          } else if (value.constructor === Input) {
            return this.getBitRatio(value.value);
          }
          switch (value.constructor) {
            case Uint8ClampedArray:
            case Uint8Array:
            case Int8Array:
              return 1;
            case Uint16Array:
            case Int16Array:
              return 2;
            case Float32Array:
            case Int32Array:
            default:
              return 4;
          }
        }
  
        destroy() {
          if (this.prevArg) {
            this.prevArg.delete();
          }
          this.context.deleteTexture(this.texture);
        }
      }
  
      module.exports = {
        WebGLKernelArray
      };
      },{"../../../input":110,"./index":59}],41:[function(require,module,exports){
      const { WebGLKernelValue } = require('./index');
  
      class WebGLKernelValueArray2 extends WebGLKernelValue {
        constructor(value, settings) {
          super(value, settings);
          this.uploadValue = value;
        }
        getSource(value) {
          if (this.origin === 'constants') {
            return `const vec2 ${this.id} = vec2(${value[0]},${value[1]});\n`;
          }
          return `uniform vec2 ${this.id};\n`;
        }
  
        getStringValueHandler() {
          if (this.origin === 'constants') return '';
          return `const uploadValue_${this.name} = ${this.varName};\n`;
        }
  
        updateValue(value) {
          if (this.origin === 'constants') return;
          this.kernel.setUniform2fv(this.id, this.uploadValue = value);
        }
      }
  
      module.exports = {
        WebGLKernelValueArray2
      };
      },{"./index":59}],42:[function(require,module,exports){
      const { WebGLKernelValue } = require('./index');
  
      class WebGLKernelValueArray3 extends WebGLKernelValue {
        constructor(value, settings) {
          super(value, settings);
          this.uploadValue = value;
        }
        getSource(value) {
          if (this.origin === 'constants') {
            return `const vec3 ${this.id} = vec3(${value[0]},${value[1]},${value[2]});\n`;
          }
          return `uniform vec3 ${this.id};\n`;
        }
  
        getStringValueHandler() {
          if (this.origin === 'constants') return '';
          return `const uploadValue_${this.name} = ${this.varName};\n`;
        }
  
        updateValue(value) {
          if (this.origin === 'constants') return;
          this.kernel.setUniform3fv(this.id, this.uploadValue = value);
        }
      }
  
      module.exports = {
        WebGLKernelValueArray3
      };
      },{"./index":59}],43:[function(require,module,exports){
      const { WebGLKernelValue } = require('./index');
  
      class WebGLKernelValueArray4 extends WebGLKernelValue {
        constructor(value, settings) {
          super(value, settings);
          this.uploadValue = value;
        }
        getSource(value) {
          if (this.origin === 'constants') {
            return `const vec4 ${this.id} = vec4(${value[0]},${value[1]},${value[2]},${value[3]});\n`;
          }
          return `uniform vec4 ${this.id};\n`;
        }
  
        getStringValueHandler() {
          if (this.origin === 'constants') return '';
          return `const uploadValue_${this.name} = ${this.varName};\n`;
        }
  
        updateValue(value) {
          if (this.origin === 'constants') return;
          this.kernel.setUniform4fv(this.id, this.uploadValue = value);
        }
      }
  
      module.exports = {
        WebGLKernelValueArray4
      };
      },{"./index":59}],44:[function(require,module,exports){
      require('../../../utils');
      const { WebGLKernelValue } = require('./index');
  
      class WebGLKernelValueBoolean extends WebGLKernelValue {
        constructor(value, settings) {
          super(value, settings);
          this.uploadValue = value;
        }
        getSource(value) {
          if (this.origin === 'constants') {
            return `const bool ${this.id} = ${value};\n`;
          }
          return `uniform bool ${this.id};\n`;
        }
  
        getStringValueHandler() {
          return `const uploadValue_${this.name} = ${this.varName};\n`;
        }
  
        updateValue(value) {
          if (this.origin === 'constants') return;
          this.kernel.setUniform1i(this.id, this.uploadValue = value);
        }
      }
  
      module.exports = {
        WebGLKernelValueBoolean
      };
      },{"../../../utils":114,"./index":59}],45:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueHTMLImage } = require('./html-image');
  
      class WebGLKernelValueDynamicHTMLImage extends WebGLKernelValueHTMLImage {
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `uniform ivec2 ${this.sizeId}`,
            `uniform ivec3 ${this.dimensionsId}`,
          ]);
        }
  
        updateValue(value) {
          const { width, height } = value;
          this.checkSize(width, height);
          this.dimensions = [width, height, 1];
          this.textureSize = [width, height];
          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
          this.kernel.setUniform2iv(this.sizeId, this.textureSize);
          super.updateValue(value);
        }
      }
  
      module.exports = {
        WebGLKernelValueDynamicHTMLImage
      };
      },{"../../../utils":114,"./html-image":57}],46:[function(require,module,exports){
      const { WebGLKernelValueDynamicHTMLImage } = require('./dynamic-html-image');
  
      class WebGLKernelValueDynamicHTMLVideo extends WebGLKernelValueDynamicHTMLImage {}
  
      module.exports = {
        WebGLKernelValueDynamicHTMLVideo
      };
      },{"./dynamic-html-image":45}],47:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./memory-optimized-number-texture');
  
      class WebGLKernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `uniform ivec2 ${this.sizeId}`,
            `uniform ivec3 ${this.dimensionsId}`,
          ]);
        }
  
        updateValue(inputTexture) {
          this.dimensions = inputTexture.dimensions;
          this.checkSize(inputTexture.size[0], inputTexture.size[1]);
          this.textureSize = inputTexture.size;
          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
          this.kernel.setUniform2iv(this.sizeId, this.textureSize);
          super.updateValue(inputTexture);
        }
      }
  
      module.exports = {
        WebGLKernelValueDynamicMemoryOptimizedNumberTexture
      };
      },{"../../../utils":114,"./memory-optimized-number-texture":61}],48:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueNumberTexture } = require('./number-texture');
  
      class WebGLKernelValueDynamicNumberTexture extends WebGLKernelValueNumberTexture {
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `uniform ivec2 ${this.sizeId}`,
            `uniform ivec3 ${this.dimensionsId}`,
          ]);
        }
  
        updateValue(value) {
          this.dimensions = value.dimensions;
          this.checkSize(value.size[0], value.size[1]);
          this.textureSize = value.size;
          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
          this.kernel.setUniform2iv(this.sizeId, this.textureSize);
          super.updateValue(value);
        }
      }
  
      module.exports = {
        WebGLKernelValueDynamicNumberTexture
      };
      },{"../../../utils":114,"./number-texture":62}],49:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueSingleArray } = require('./single-array');
  
      class WebGLKernelValueDynamicSingleArray extends WebGLKernelValueSingleArray {
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `uniform ivec2 ${this.sizeId}`,
            `uniform ivec3 ${this.dimensionsId}`,
          ]);
        }
  
        updateValue(value) {
          this.dimensions = utils.getDimensions(value, true);
          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
          this.checkSize(this.textureSize[0], this.textureSize[1]);
          this.uploadValue = new Float32Array(this.uploadArrayLength);
          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
          this.kernel.setUniform2iv(this.sizeId, this.textureSize);
          super.updateValue(value);
        }
      }
  
      module.exports = {
        WebGLKernelValueDynamicSingleArray
      };
      },{"../../../utils":114,"./single-array":63}],50:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueSingleArray1DI } = require('./single-array1d-i');
  
      class WebGLKernelValueDynamicSingleArray1DI extends WebGLKernelValueSingleArray1DI {
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `uniform ivec2 ${this.sizeId}`,
            `uniform ivec3 ${this.dimensionsId}`,
          ]);
        }
  
        updateValue(value) {
          this.setShape(value);
          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
          this.kernel.setUniform2iv(this.sizeId, this.textureSize);
          super.updateValue(value);
        }
      }
  
      module.exports = {
        WebGLKernelValueDynamicSingleArray1DI
      };
      },{"../../../utils":114,"./single-array1d-i":64}],51:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueSingleArray2DI } = require('./single-array2d-i');
  
      class WebGLKernelValueDynamicSingleArray2DI extends WebGLKernelValueSingleArray2DI {
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `uniform ivec2 ${this.sizeId}`,
            `uniform ivec3 ${this.dimensionsId}`,
          ]);
        }
  
        updateValue(value) {
          this.setShape(value);
          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
          this.kernel.setUniform2iv(this.sizeId, this.textureSize);
          super.updateValue(value);
        }
      }
  
      module.exports = {
        WebGLKernelValueDynamicSingleArray2DI
      };
      },{"../../../utils":114,"./single-array2d-i":65}],52:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueSingleArray3DI } = require('./single-array3d-i');
  
      class WebGLKernelValueDynamicSingleArray3DI extends WebGLKernelValueSingleArray3DI {
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `uniform ivec2 ${this.sizeId}`,
            `uniform ivec3 ${this.dimensionsId}`,
          ]);
        }
  
        updateValue(value) {
          this.setShape(value);
          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
          this.kernel.setUniform2iv(this.sizeId, this.textureSize);
          super.updateValue(value);
        }
      }
  
      module.exports = {
        WebGLKernelValueDynamicSingleArray3DI
      };
      },{"../../../utils":114,"./single-array3d-i":66}],53:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueSingleInput } = require('./single-input');
  
      class WebGLKernelValueDynamicSingleInput extends WebGLKernelValueSingleInput {
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `uniform ivec2 ${this.sizeId}`,
            `uniform ivec3 ${this.dimensionsId}`,
          ]);
        }
  
        updateValue(value) {
          let [w, h, d] = value.size;
          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
          this.checkSize(this.textureSize[0], this.textureSize[1]);
          this.uploadValue = new Float32Array(this.uploadArrayLength);
          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
          this.kernel.setUniform2iv(this.sizeId, this.textureSize);
          super.updateValue(value);
        }
      }
  
      module.exports = {
        WebGLKernelValueDynamicSingleInput
      };
      },{"../../../utils":114,"./single-input":67}],54:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueUnsignedArray } = require('./unsigned-array');
  
      class WebGLKernelValueDynamicUnsignedArray extends WebGLKernelValueUnsignedArray {
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `uniform ivec2 ${this.sizeId}`,
            `uniform ivec3 ${this.dimensionsId}`,
          ]);
        }
  
        updateValue(value) {
          this.dimensions = utils.getDimensions(value, true);
          this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
          this.checkSize(this.textureSize[0], this.textureSize[1]);
          const Type = this.getTransferArrayType(value);
          this.preUploadValue = new Type(this.uploadArrayLength);
          this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
          this.kernel.setUniform2iv(this.sizeId, this.textureSize);
          super.updateValue(value);
        }
      }
  
      module.exports = {
        WebGLKernelValueDynamicUnsignedArray
      };
      },{"../../../utils":114,"./unsigned-array":68}],55:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueUnsignedInput } = require('./unsigned-input');
  
      class WebGLKernelValueDynamicUnsignedInput extends WebGLKernelValueUnsignedInput {
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `uniform ivec2 ${this.sizeId}`,
            `uniform ivec3 ${this.dimensionsId}`,
          ]);
        }
  
        updateValue(value) {
          let [w, h, d] = value.size;
          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
          this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
          this.checkSize(this.textureSize[0], this.textureSize[1]);
          const Type = this.getTransferArrayType(value.value);
          this.preUploadValue = new Type(this.uploadArrayLength);
          this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
          this.kernel.setUniform2iv(this.sizeId, this.textureSize);
          super.updateValue(value);
        }
      }
  
      module.exports = {
        WebGLKernelValueDynamicUnsignedInput
      };
      },{"../../../utils":114,"./unsigned-input":69}],56:[function(require,module,exports){
      require('../../../utils');
      const { WebGLKernelValue } = require('./index');
  
      class WebGLKernelValueFloat extends WebGLKernelValue {
        constructor(value, settings) {
          super(value, settings);
          this.uploadValue = value;
        }
        getStringValueHandler() {
          return `const uploadValue_${this.name} = ${this.varName};\n`;
        }
        getSource(value) {
          if (this.origin === 'constants') {
            if (Number.isInteger(value)) {
              return `const float ${this.id} = ${value}.0;\n`;
            }
            return `const float ${this.id} = ${value};\n`;
          }
          return `uniform float ${this.id};\n`;
        }
  
        updateValue(value) {
          if (this.origin === 'constants') return;
          this.kernel.setUniform1f(this.id, this.uploadValue = value);
        }
      }
  
      module.exports = {
        WebGLKernelValueFloat
      };
      },{"../../../utils":114,"./index":59}],57:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelArray } = require('./array');
  
      class WebGLKernelValueHTMLImage extends WebGLKernelArray {
        constructor(value, settings) {
          super(value, settings);
          const { width, height } = value;
          this.checkSize(width, height);
          this.dimensions = [width, height, 1];
          this.textureSize = [width, height];
          this.uploadValue = value;
        }
  
        getStringValueHandler() {
          return `const uploadValue_${this.name} = ${this.varName};\n`;
        }
  
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
          ]);
        }
  
        updateValue(inputImage) {
          if (inputImage.constructor !== this.initialValueConstructor) {
            this.onUpdateValueMismatch(inputImage.constructor);
            return;
          }
          const { context: gl } = this;
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue = inputImage);
          this.kernel.setUniform1i(this.id, this.index);
        }
      }
  
      module.exports = {
        WebGLKernelValueHTMLImage
      };
      },{"../../../utils":114,"./array":40}],58:[function(require,module,exports){
      const { WebGLKernelValueHTMLImage } = require('./html-image');
  
      class WebGLKernelValueHTMLVideo extends WebGLKernelValueHTMLImage {}
  
      module.exports = {
        WebGLKernelValueHTMLVideo
      };
      },{"./html-image":57}],59:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { KernelValue } = require('../../kernel-value');
  
      class WebGLKernelValue extends KernelValue {
        constructor(value, settings) {
          super(value, settings);
          this.dimensionsId = null;
          this.sizeId = null;
          this.initialValueConstructor = value.constructor;
          this.onRequestTexture = settings.onRequestTexture;
          this.onRequestIndex = settings.onRequestIndex;
          this.uploadValue = null;
          this.textureSize = null;
          this.bitRatio = null;
          this.prevArg = null;
        }
  
        get id() {
          return `${this.origin}_${utils.sanitizeName(this.name)}`;
        }
  
        setup() {}
  
        getTransferArrayType(value) {
          if (Array.isArray(value[0])) {
            return this.getTransferArrayType(value[0]);
          }
          switch (value.constructor) {
            case Array:
            case Int32Array:
            case Int16Array:
            case Int8Array:
              return Float32Array;
            case Uint8ClampedArray:
            case Uint8Array:
            case Uint16Array:
            case Uint32Array:
            case Float32Array:
            case Float64Array:
              return value.constructor;
          }
          console.warn('Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros');
          return value.constructor;
        }
  
        getStringValueHandler() {
          throw new Error(`"getStringValueHandler" not implemented on ${this.constructor.name}`);
        }
  
        getVariablePrecisionString() {
          return this.kernel.getVariablePrecisionString(this.textureSize || undefined, this.tactic || undefined);
        }
  
        destroy() {}
      }
  
      module.exports = {
        WebGLKernelValue
      };
      },{"../../../utils":114,"../../kernel-value":35}],60:[function(require,module,exports){
      require('../../../utils');
      const { WebGLKernelValue } = require('./index');
  
      class WebGLKernelValueInteger extends WebGLKernelValue {
        constructor(value, settings) {
          super(value, settings);
          this.uploadValue = value;
        }
        getStringValueHandler() {
          return `const uploadValue_${this.name} = ${this.varName};\n`;
        }
        getSource(value) {
          if (this.origin === 'constants') {
            return `const int ${this.id} = ${ parseInt(value) };\n`;
          }
          return `uniform int ${this.id};\n`;
        }
  
        updateValue(value) {
          if (this.origin === 'constants') return;
          this.kernel.setUniform1i(this.id, this.uploadValue = value);
        }
      }
  
      module.exports = {
        WebGLKernelValueInteger
      };
      },{"../../../utils":114,"./index":59}],61:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelArray } = require('./array');
  
      const sameError = `Source and destination textures are the same.  Use immutable = true and manually cleanup kernel output texture memory with texture.delete()`;
  
      class WebGLKernelValueMemoryOptimizedNumberTexture extends WebGLKernelArray {
        constructor(value, settings) {
          super(value, settings);
          const [width, height] = value.size;
          this.checkSize(width, height);
          this.dimensions = value.dimensions;
          this.textureSize = value.size;
          this.uploadValue = value.texture;
          this.forceUploadEachRun = true;
        }
  
        setup() {
          this.setupTexture();
        }
  
        getStringValueHandler() {
          return `const uploadValue_${this.name} = ${this.varName}.texture;\n`;
        }
  
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
          ]);
        }
  
        updateValue(inputTexture) {
          if (inputTexture.constructor !== this.initialValueConstructor) {
            this.onUpdateValueMismatch(inputTexture.constructor);
            return;
          }
          if (this.checkContext && inputTexture.context !== this.context) {
            throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
          }
  
          const { kernel, context: gl } = this;
          if (kernel.pipeline) {
            if (kernel.immutable) {
              kernel.updateTextureArgumentRefs(this, inputTexture);
            } else {
              if (kernel.texture && kernel.texture.texture === inputTexture.texture) {
                throw new Error(sameError);
              } else if (kernel.mappedTextures) {
                const { mappedTextures } = kernel;
                for (let i = 0; i < mappedTextures.length; i++) {
                  if (mappedTextures[i].texture === inputTexture.texture) {
                    throw new Error(sameError);
                  }
                }
              }
            }
          }
  
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);
          this.kernel.setUniform1i(this.id, this.index);
        }
      }
  
      module.exports = {
        WebGLKernelValueMemoryOptimizedNumberTexture,
        sameError
      };
      },{"../../../utils":114,"./array":40}],62:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelArray } = require('./array');
      const { sameError } = require('./memory-optimized-number-texture');
  
      class WebGLKernelValueNumberTexture extends WebGLKernelArray {
        constructor(value, settings) {
          super(value, settings);
          const [width, height] = value.size;
          this.checkSize(width, height);
          const { size: textureSize, dimensions } = value;
          this.bitRatio = this.getBitRatio(value);
          this.dimensions = dimensions;
          this.textureSize = textureSize;
          this.uploadValue = value.texture;
          this.forceUploadEachRun = true;
        }
  
        setup() {
          this.setupTexture();
        }
  
        getStringValueHandler() {
          return `const uploadValue_${this.name} = ${this.varName}.texture;\n`;
        }
  
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
          ]);
        }
  
        updateValue(inputTexture) {
          if (inputTexture.constructor !== this.initialValueConstructor) {
            this.onUpdateValueMismatch(inputTexture.constructor);
            return;
          }
          if (this.checkContext && inputTexture.context !== this.context) {
            throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
          }
  
          const { kernel, context: gl } = this;
          if (kernel.pipeline) {
            if (kernel.immutable) {
              kernel.updateTextureArgumentRefs(this, inputTexture);
            } else {
              if (kernel.texture && kernel.texture.texture === inputTexture.texture) {
                throw new Error(sameError);
              } else if (kernel.mappedTextures) {
                const { mappedTextures } = kernel;
                for (let i = 0; i < mappedTextures.length; i++) {
                  if (mappedTextures[i].texture === inputTexture.texture) {
                    throw new Error(sameError);
                  }
                }
              }
            }
          }
  
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);
          this.kernel.setUniform1i(this.id, this.index);
        }
      }
  
      module.exports = {
        WebGLKernelValueNumberTexture
      };
      },{"../../../utils":114,"./array":40,"./memory-optimized-number-texture":61}],63:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelArray } = require('./array');
  
      class WebGLKernelValueSingleArray extends WebGLKernelArray {
        constructor(value, settings) {
          super(value, settings);
          this.bitRatio = 4;
          this.dimensions = utils.getDimensions(value, true);
          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
          this.checkSize(this.textureSize[0], this.textureSize[1]);
          this.uploadValue = new Float32Array(this.uploadArrayLength);
        }
  
        getStringValueHandler() {
          return utils.linesToString([
            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
            `flattenTo(${this.varName}, uploadValue_${this.name})`,
          ]);
        }
  
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
          ]);
        }
  
        updateValue(value) {
          if (value.constructor !== this.initialValueConstructor) {
            this.onUpdateValueMismatch(value.constructor);
            return;
          }
          const { context: gl } = this;
          utils.flattenTo(value, this.uploadValue);
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
          this.kernel.setUniform1i(this.id, this.index);
        }
      }
  
      module.exports = {
        WebGLKernelValueSingleArray
      };
      },{"../../../utils":114,"./array":40}],64:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelArray } = require('./array');
  
      class WebGLKernelValueSingleArray1DI extends WebGLKernelArray {
        constructor(value, settings) {
          super(value, settings);
          this.bitRatio = 4;
          this.setShape(value);
        }
  
        setShape(value) {
          const valueDimensions = utils.getDimensions(value, true);
          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
          this.dimensions = new Int32Array([valueDimensions[1], 1, 1]);
          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
          this.checkSize(this.textureSize[0], this.textureSize[1]);
          this.uploadValue = new Float32Array(this.uploadArrayLength);
        }
  
        getStringValueHandler() {
          return utils.linesToString([
            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
            `flattenTo(${this.varName}, uploadValue_${this.name})`,
          ]);
        }
  
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
          ]);
        }
  
        updateValue(value) {
          if (value.constructor !== this.initialValueConstructor) {
            this.onUpdateValueMismatch(value.constructor);
            return;
          }
          const { context: gl } = this;
          utils.flatten2dArrayTo(value, this.uploadValue);
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
          this.kernel.setUniform1i(this.id, this.index);
        }
      }
  
      module.exports = {
        WebGLKernelValueSingleArray1DI
      };
      },{"../../../utils":114,"./array":40}],65:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelArray } = require('./array');
  
      class WebGLKernelValueSingleArray2DI extends WebGLKernelArray {
        constructor(value, settings) {
          super(value, settings);
          this.bitRatio = 4;
          this.setShape(value);
        }
  
        setShape(value) {
          const valueDimensions = utils.getDimensions(value, true);
          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
          this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], 1]);
          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
          this.checkSize(this.textureSize[0], this.textureSize[1]);
          this.uploadValue = new Float32Array(this.uploadArrayLength);
        }
  
        getStringValueHandler() {
          return utils.linesToString([
            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
            `flattenTo(${this.varName}, uploadValue_${this.name})`,
          ]);
        }
  
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
          ]);
        }
  
        updateValue(value) {
          if (value.constructor !== this.initialValueConstructor) {
            this.onUpdateValueMismatch(value.constructor);
            return;
          }
          const { context: gl } = this;
          utils.flatten3dArrayTo(value, this.uploadValue);
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
          this.kernel.setUniform1i(this.id, this.index);
        }
      }
  
      module.exports = {
        WebGLKernelValueSingleArray2DI
      };
      },{"../../../utils":114,"./array":40}],66:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelArray } = require('./array');
  
      class WebGLKernelValueSingleArray3DI extends WebGLKernelArray {
        constructor(value, settings) {
          super(value, settings);
          this.bitRatio = 4;
          this.setShape(value);
        }
  
        setShape(value) {
          const valueDimensions = utils.getDimensions(value, true);
          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
          this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], valueDimensions[3]]);
          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
          this.checkSize(this.textureSize[0], this.textureSize[1]);
          this.uploadValue = new Float32Array(this.uploadArrayLength);
        }
  
        getStringValueHandler() {
          return utils.linesToString([
            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
            `flattenTo(${this.varName}, uploadValue_${this.name})`,
          ]);
        }
  
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
          ]);
        }
  
        updateValue(value) {
          if (value.constructor !== this.initialValueConstructor) {
            this.onUpdateValueMismatch(value.constructor);
            return;
          }
          const { context: gl } = this;
          utils.flatten4dArrayTo(value, this.uploadValue);
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
          this.kernel.setUniform1i(this.id, this.index);
        }
      }
  
      module.exports = {
        WebGLKernelValueSingleArray3DI
      };
      },{"../../../utils":114,"./array":40}],67:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelArray } = require('./array');
  
      class WebGLKernelValueSingleInput extends WebGLKernelArray {
        constructor(value, settings) {
          super(value, settings);
          this.bitRatio = 4;
          let [w, h, d] = value.size;
          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
          this.checkSize(this.textureSize[0], this.textureSize[1]);
          this.uploadValue = new Float32Array(this.uploadArrayLength);
        }
  
        getStringValueHandler() {
          return utils.linesToString([
            `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
            `flattenTo(${this.varName}.value, uploadValue_${this.name})`,
          ]);
        }
  
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
          ]);
        }
  
        updateValue(input) {
          if (input.constructor !== this.initialValueConstructor) {
            this.onUpdateValueMismatch(input.constructor);
            return;
          }
          const { context: gl } = this;
          utils.flattenTo(input.value, this.uploadValue);
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
          this.kernel.setUniform1i(this.id, this.index);
        }
      }
  
      module.exports = {
        WebGLKernelValueSingleInput
      };
      },{"../../../utils":114,"./array":40}],68:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelArray } = require('./array');
  
      class WebGLKernelValueUnsignedArray extends WebGLKernelArray {
        constructor(value, settings) {
          super(value, settings);
          this.bitRatio = this.getBitRatio(value);
          this.dimensions = utils.getDimensions(value, true);
          this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
          this.checkSize(this.textureSize[0], this.textureSize[1]);
          this.TranserArrayType = this.getTransferArrayType(value);
          this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);
          this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
        }
  
        getStringValueHandler() {
          return utils.linesToString([
            `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,
            `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,
            `flattenTo(${this.varName}, preUploadValue_${this.name})`,
          ]);
        }
  
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
          ]);
        }
  
        updateValue(value) {
          if (value.constructor !== this.initialValueConstructor) {
            this.onUpdateValueMismatch(value.constructor);
            return;
          }
          const { context: gl } = this;
          utils.flattenTo(value, this.preUploadValue);
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);
          this.kernel.setUniform1i(this.id, this.index);
        }
      }
  
      module.exports = {
        WebGLKernelValueUnsignedArray
      };
      },{"../../../utils":114,"./array":40}],69:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelArray } = require('./array');
  
      class WebGLKernelValueUnsignedInput extends WebGLKernelArray {
        constructor(value, settings) {
          super(value, settings);
          this.bitRatio = this.getBitRatio(value);
          const [w, h, d] = value.size;
          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
          this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
          this.checkSize(this.textureSize[0], this.textureSize[1]);
          this.TranserArrayType = this.getTransferArrayType(value.value);
          this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);
          this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
        }
  
        getStringValueHandler() {
          return utils.linesToString([
            `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,
            `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,
            `flattenTo(${this.varName}.value, preUploadValue_${this.name})`,
          ]);
        }
  
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
            `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
          ]);
        }
  
        updateValue(input) {
          if (input.constructor !== this.initialValueConstructor) {
            this.onUpdateValueMismatch(value.constructor);
            return;
          }
          const { context: gl } = this;
          utils.flattenTo(input.value, this.preUploadValue);
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);
          this.kernel.setUniform1i(this.id, this.index);
        }
      }
  
      module.exports = {
        WebGLKernelValueUnsignedInput
      };
      },{"../../../utils":114,"./array":40}],70:[function(require,module,exports){
      const { GLKernel } = require('../gl/kernel');
      const { FunctionBuilder } = require('../function-builder');
      const { WebGLFunctionNode } = require('./function-node');
      const { utils } = require('../../utils');
      const mrud = require('../../plugins/math-random-uniformly-distributed');
      const { fragmentShader } = require('./fragment-shader');
      const { vertexShader } = require('./vertex-shader');
      const { glKernelString } = require('../gl/kernel-string');
      const { lookupKernelValueType } = require('./kernel-value-maps');
  
      let isSupported = null;
      let testCanvas = null;
      let testContext = null;
      let testExtensions = null;
      let features = null;
  
      const plugins = [mrud];
      const canvases = [];
      const maxTexSizes = {};
  
  
      class WebGLKernel extends GLKernel {
        static get isSupported() {
          if (isSupported !== null) {
            return isSupported;
          }
          this.setupFeatureChecks();
          isSupported = this.isContextMatch(testContext);
          return isSupported;
        }
  
        static setupFeatureChecks() {
          if (typeof document !== 'undefined') {
            testCanvas = document.createElement('canvas');
          } else if (typeof OffscreenCanvas !== 'undefined') {
            testCanvas = new OffscreenCanvas(0, 0);
          }
          if (!testCanvas) return;
          testContext = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
          if (!testContext || !testContext.getExtension) return;
          testExtensions = {
            OES_texture_float: testContext.getExtension('OES_texture_float'),
            OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
            OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
            WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),
          };
          features = this.getFeatures();
        }
  
        static isContextMatch(context) {
          if (typeof WebGLRenderingContext !== 'undefined') {
            return context instanceof WebGLRenderingContext;
          }
          return false;
        }
  
        static getIsTextureFloat() {
          return Boolean(testExtensions.OES_texture_float);
        }
  
        static getIsDrawBuffers() {
          return Boolean(testExtensions.WEBGL_draw_buffers);
        }
  
        static getChannelCount() {
          return testExtensions.WEBGL_draw_buffers ?
            testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :
            1;
        }
  
        static getMaxTextureSize() {
          return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
        }
  
        static lookupKernelValueType(type, dynamic, precision, value) {
          return lookupKernelValueType(type, dynamic, precision, value);
        }
  
        static get testCanvas() {
          return testCanvas;
        }
  
        static get testContext() {
          return testContext;
        }
  
        static get features() {
          return features;
        }
  
        static get fragmentShader() {
          return fragmentShader;
        }
  
        static get vertexShader() {
          return vertexShader;
        }
  
        constructor(source, settings) {
          super(source, settings);
          this.program = null;
          this.pipeline = settings.pipeline;
          this.endianness = utils.systemEndianness();
          this.extensions = {};
          this.argumentTextureCount = 0;
          this.constantTextureCount = 0;
          this.fragShader = null;
          this.vertShader = null;
          this.drawBuffersMap = null;
  
          this.maxTexSize = null;
          this.onRequestSwitchKernel = null;
  
          this.texture = null;
          this.mappedTextures = null;
          this.mergeSettings(source.settings || settings);
  
          this.threadDim = null;
          this.framebuffer = null;
          this.buffer = null;
  
          this.textureCache = [];
          this.programUniformLocationCache = {};
          this.uniform1fCache = {};
          this.uniform1iCache = {};
          this.uniform2fCache = {};
          this.uniform2fvCache = {};
          this.uniform2ivCache = {};
          this.uniform3fvCache = {};
          this.uniform3ivCache = {};
          this.uniform4fvCache = {};
          this.uniform4ivCache = {};
        }
  
        initCanvas() {
          if (typeof document !== 'undefined') {
            const canvas = document.createElement('canvas');
            canvas.width = 2;
            canvas.height = 2;
            return canvas;
          } else if (typeof OffscreenCanvas !== 'undefined') {
            return new OffscreenCanvas(0, 0);
          }
        }
  
        initContext() {
          const settings = {
            alpha: false,
            depth: false,
            antialias: false
          };
          return this.canvas.getContext('webgl', settings) || this.canvas.getContext('experimental-webgl', settings);
        }
  
        initPlugins(settings) {
          const pluginsToUse = [];
          const { source } = this;
          if (typeof source === 'string') {
            for (let i = 0; i < plugins.length; i++) {
              const plugin = plugins[i];
              if (source.match(plugin.functionMatch)) {
                pluginsToUse.push(plugin);
              }
            }
          } else if (typeof source === 'object') {
            if (settings.pluginNames) { 
              for (let i = 0; i < plugins.length; i++) {
                const plugin = plugins[i];
                const usePlugin = settings.pluginNames.some(pluginName => pluginName === plugin.name);
                if (usePlugin) {
                  pluginsToUse.push(plugin);
                }
              }
            }
          }
          return pluginsToUse;
        }
  
        initExtensions() {
          this.extensions = {
            OES_texture_float: this.context.getExtension('OES_texture_float'),
            OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
            OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
            WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
            WEBGL_color_buffer_float: this.context.getExtension('WEBGL_color_buffer_float'),
          };
        }
  
        validateSettings(args) {
          if (!this.validate) {
            this.texSize = utils.getKernelTextureSize({
              optimizeFloatMemory: this.optimizeFloatMemory,
              precision: this.precision,
            }, this.output);
            return;
          }
  
          const { features } = this.constructor;
  
          if (this.optimizeFloatMemory === true && !features.isTextureFloat) {
            throw new Error('Float textures are not supported');
          } else if (this.precision === 'single' && !features.isFloatRead) {
            throw new Error('Single precision not supported');
          } else if (!this.graphical && this.precision === null && features.isTextureFloat) {
            this.precision = features.isFloatRead ? 'single' : 'unsigned';
          }
  
          if (this.subKernels && this.subKernels.length > 0 && !this.extensions.WEBGL_draw_buffers) {
            throw new Error('could not instantiate draw buffers extension');
          }
  
          if (this.fixIntegerDivisionAccuracy === null) {
            this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
          } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
            this.fixIntegerDivisionAccuracy = false;
          }
  
          this.checkOutput();
  
          if (!this.output || this.output.length === 0) {
            if (args.length !== 1) {
              throw new Error('Auto output only supported for kernels with only one input');
            }
  
            const argType = utils.getVariableType(args[0], this.strictIntegers);
            switch (argType) {
              case 'Array':
                this.output = utils.getDimensions(argType);
                break;
              case 'NumberTexture':
              case 'MemoryOptimizedNumberTexture':
              case 'ArrayTexture(1)':
              case 'ArrayTexture(2)':
              case 'ArrayTexture(3)':
              case 'ArrayTexture(4)':
                this.output = args[0].output;
                break;
              default:
                throw new Error('Auto output not supported for input type: ' + argType);
            }
          }
  
          if (this.graphical) {
            if (this.output.length !== 2) {
              throw new Error('Output must have 2 dimensions on graphical mode');
            }
  
            if (this.precision === 'precision') {
              this.precision = 'unsigned';
              console.warn('Cannot use graphical mode and single precision at the same time');
            }
  
            this.texSize = utils.clone(this.output);
            return;
          } else if (this.precision === null && features.isTextureFloat) {
            this.precision = 'single';
          }
  
          this.texSize = utils.getKernelTextureSize({
            optimizeFloatMemory: this.optimizeFloatMemory,
            precision: this.precision,
          }, this.output);
  
          this.checkTextureSize();
        }
  
        updateMaxTexSize() {
          const { texSize, canvas } = this;
          if (this.maxTexSize === null) {
            let canvasIndex = canvases.indexOf(canvas);
            if (canvasIndex === -1) {
              canvasIndex = canvases.length;
              canvases.push(canvas);
              maxTexSizes[canvasIndex] = [texSize[0], texSize[1]];
            }
            this.maxTexSize = maxTexSizes[canvasIndex];
          }
          if (this.maxTexSize[0] < texSize[0]) {
            this.maxTexSize[0] = texSize[0];
          }
          if (this.maxTexSize[1] < texSize[1]) {
            this.maxTexSize[1] = texSize[1];
          }
        }
  
        setupArguments(args) {
          this.kernelArguments = [];
          this.argumentTextureCount = 0;
          const needsArgumentTypes = this.argumentTypes === null;
          if (needsArgumentTypes) {
            this.argumentTypes = [];
          }
          this.argumentSizes = [];
          this.argumentBitRatios = [];
  
          if (args.length < this.argumentNames.length) {
            throw new Error('not enough arguments for kernel');
          } else if (args.length > this.argumentNames.length) {
            throw new Error('too many arguments for kernel');
          }
  
          const { context: gl } = this;
          let textureIndexes = 0;
  
          const onRequestTexture = () => {
            return this.createTexture();
          };
          const onRequestIndex = () => {
            return this.constantTextureCount + textureIndexes++;
          };
          const onUpdateValueMismatch = (constructor) => {
            this.switchKernels({
              type: 'argumentMismatch',
              needed: constructor
            });
          };
          const onRequestContextHandle = () => {
            return gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount++;
          };
  
          for (let index = 0; index < args.length; index++) {
            const value = args[index];
            const name = this.argumentNames[index];
            let type;
            if (needsArgumentTypes) {
              type = utils.getVariableType(value, this.strictIntegers);
              this.argumentTypes.push(type);
            } else {
              type = this.argumentTypes[index];
            }
            const KernelValue = this.constructor.lookupKernelValueType(type, this.dynamicArguments ? 'dynamic' : 'static', this.precision, args[index]);
            if (KernelValue === null) {
              return this.requestFallback(args);
            }
            const kernelArgument = new KernelValue(value, {
              name,
              type,
              tactic: this.tactic,
              origin: 'user',
              context: gl,
              checkContext: this.checkContext,
              kernel: this,
              strictIntegers: this.strictIntegers,
              onRequestTexture,
              onRequestIndex,
              onUpdateValueMismatch,
              onRequestContextHandle,
            });
            this.kernelArguments.push(kernelArgument);
            kernelArgument.setup();
            this.argumentSizes.push(kernelArgument.textureSize);
            this.argumentBitRatios[index] = kernelArgument.bitRatio;
          }
        }
  
        createTexture() {
          const texture = this.context.createTexture();
          this.textureCache.push(texture);
          return texture;
        }
  
        setupConstants(args) {
          const { context: gl } = this;
          this.kernelConstants = [];
          this.forceUploadKernelConstants = [];
          let needsConstantTypes = this.constantTypes === null;
          if (needsConstantTypes) {
            this.constantTypes = {};
          }
          this.constantBitRatios = {};
          let textureIndexes = 0;
          for (const name in this.constants) {
            const value = this.constants[name];
            let type;
            if (needsConstantTypes) {
              type = utils.getVariableType(value, this.strictIntegers);
              this.constantTypes[name] = type;
            } else {
              type = this.constantTypes[name];
            }
            const KernelValue = this.constructor.lookupKernelValueType(type, 'static', this.precision, value);
            if (KernelValue === null) {
              return this.requestFallback(args);
            }
            const kernelValue = new KernelValue(value, {
              name,
              type,
              tactic: this.tactic,
              origin: 'constants',
              context: this.context,
              checkContext: this.checkContext,
              kernel: this,
              strictIntegers: this.strictIntegers,
              onRequestTexture: () => {
                return this.createTexture();
              },
              onRequestIndex: () => {
                return textureIndexes++;
              },
              onRequestContextHandle: () => {
                return gl.TEXTURE0 + this.constantTextureCount++;
              }
            });
            this.constantBitRatios[name] = kernelValue.bitRatio;
            this.kernelConstants.push(kernelValue);
            kernelValue.setup();
            if (kernelValue.forceUploadEachRun) {
              this.forceUploadKernelConstants.push(kernelValue);
            }
          }
        }
  
        build() {
          if (this.built) return;
          this.initExtensions();
          this.validateSettings(arguments);
          this.setupConstants(arguments);
          if (this.fallbackRequested) return;
          this.setupArguments(arguments);
          if (this.fallbackRequested) return;
          this.updateMaxTexSize();
          this.translateSource();
          const failureResult = this.pickRenderStrategy(arguments);
          if (failureResult) {
            return failureResult;
          }
          const { texSize, context: gl, canvas } = this;
          gl.enable(gl.SCISSOR_TEST);
          if (this.pipeline && this.precision === 'single') {
            gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
            canvas.width = this.maxTexSize[0];
            canvas.height = this.maxTexSize[1];
          } else {
            gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
            canvas.width = this.maxTexSize[0];
            canvas.height = this.maxTexSize[1];
          }
          const threadDim = this.threadDim = Array.from(this.output);
          while (threadDim.length < 3) {
            threadDim.push(1);
          }
  
          const compiledVertexShader = this.getVertexShader(arguments);
          const vertShader = gl.createShader(gl.VERTEX_SHADER);
          gl.shaderSource(vertShader, compiledVertexShader);
          gl.compileShader(vertShader);
          this.vertShader = vertShader;
  
          const compiledFragmentShader = this.getFragmentShader(arguments);
          const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
          gl.shaderSource(fragShader, compiledFragmentShader);
          gl.compileShader(fragShader);
          this.fragShader = fragShader;
  
          if (this.debug) {
            console.log('GLSL Shader Output:');
            console.log(compiledFragmentShader);
          }
  
          if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
            throw new Error('Error compiling vertex shader: ' + gl.getShaderInfoLog(vertShader));
          }
          if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
            throw new Error('Error compiling fragment shader: ' + gl.getShaderInfoLog(fragShader));
          }
  
          const program = this.program = gl.createProgram();
          gl.attachShader(program, vertShader);
          gl.attachShader(program, fragShader);
          gl.linkProgram(program);
          this.framebuffer = gl.createFramebuffer();
          this.framebuffer.width = texSize[0];
          this.framebuffer.height = texSize[1];
          this.rawValueFramebuffers = {};
  
          const vertices = new Float32Array([-1, -1,
            1, -1, -1, 1,
            1, 1
          ]);
          const texCoords = new Float32Array([
            0, 0,
            1, 0,
            0, 1,
            1, 1
          ]);
  
          const texCoordOffset = vertices.byteLength;
  
          let buffer = this.buffer;
          if (!buffer) {
            buffer = this.buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices.byteLength + texCoords.byteLength, gl.STATIC_DRAW);
          } else {
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          }
  
          gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);
          gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);
  
          const aPosLoc = gl.getAttribLocation(this.program, 'aPos');
          gl.enableVertexAttribArray(aPosLoc);
          gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);
          const aTexCoordLoc = gl.getAttribLocation(this.program, 'aTexCoord');
          gl.enableVertexAttribArray(aTexCoordLoc);
          gl.vertexAttribPointer(aTexCoordLoc, 2, gl.FLOAT, false, 0, texCoordOffset);
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
  
          let i = 0;
          gl.useProgram(this.program);
          for (let p in this.constants) {
            this.kernelConstants[i++].updateValue(this.constants[p]);
          }
  
          this._setupOutputTexture();
          if (
            this.subKernels !== null &&
            this.subKernels.length > 0
          ) {
            this._mappedTextureSwitched = {};
            this._setupSubOutputTextures();
          }
          this.buildSignature(arguments);
          this.built = true;
        }
  
        translateSource() {
          const functionBuilder = FunctionBuilder.fromKernel(this, WebGLFunctionNode, {
            fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
          });
          this.translatedSource = functionBuilder.getPrototypeString('kernel');
          this.setupReturnTypes(functionBuilder);
        }
  
        setupReturnTypes(functionBuilder) {
          if (!this.graphical && !this.returnType) {
            this.returnType = functionBuilder.getKernelResultType();
          }
  
          if (this.subKernels && this.subKernels.length > 0) {
            for (let i = 0; i < this.subKernels.length; i++) {
              const subKernel = this.subKernels[i];
              if (!subKernel.returnType) {
                subKernel.returnType = functionBuilder.getSubKernelResultType(i);
              }
            }
          }
        }
  
        run() {
          const { kernelArguments, texSize, forceUploadKernelConstants, context: gl } = this;
  
          gl.useProgram(this.program);
          gl.scissor(0, 0, texSize[0], texSize[1]);
          if (this.dynamicOutput) {
            this.setUniform3iv('uOutputDim', new Int32Array(this.threadDim));
            this.setUniform2iv('uTexSize', texSize);
          }
  
          this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);
  
          for (let i = 0; i < forceUploadKernelConstants.length; i++) {
            const constant = forceUploadKernelConstants[i];
            constant.updateValue(this.constants[constant.name]);
            if (this.switchingKernels) return;
          }
          for (let i = 0; i < kernelArguments.length; i++) {
            kernelArguments[i].updateValue(arguments[i]);
            if (this.switchingKernels) return;
          }
  
          if (this.plugins) {
            for (let i = 0; i < this.plugins.length; i++) {
              const plugin = this.plugins[i];
              if (plugin.onBeforeRun) {
                plugin.onBeforeRun(this);
              }
            }
          }
  
          if (this.graphical) {
            if (this.pipeline) {
              gl.bindRenderbuffer(gl.RENDERBUFFER, null);
              gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
              if (this.immutable) {
                this._replaceOutputTexture();
              }
              gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
              return this.immutable ? this.texture.clone() : this.texture;
            }
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            return;
          }
  
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
          if (this.immutable) {
            this._replaceOutputTexture();
          }
  
          if (this.subKernels !== null) {
            if (this.immutable) {
              this._replaceSubOutputTextures();
            }
            this.drawBuffers();
          }
  
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        }
  
        drawBuffers() {
          this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap);
        }
  
        getInternalFormat() {
          return this.context.RGBA;
        }
        getTextureFormat() {
          const { context: gl } = this;
          switch (this.getInternalFormat()) {
            case gl.RGBA:
              return gl.RGBA;
            default:
              throw new Error('Unknown internal format');
          }
        }
  
        _replaceOutputTexture() {
          if (this.texture.beforeMutate() || this._textureSwitched) {
            const gl = this.context;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
            this._textureSwitched = false;
          }
        }
  
        _setupOutputTexture() {
          const gl = this.context;
          const texSize = this.texSize;
          if (this.texture) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
            return;
          }
          const texture = this.createTexture();
          gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          const format = this.getInternalFormat();
          if (this.precision === 'single') {
            gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
          } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);
          }
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          this.texture = new this.TextureConstructor({
            texture,
            size: texSize,
            dimensions: this.threadDim,
            output: this.output,
            context: this.context,
            internalFormat: this.getInternalFormat(),
            textureFormat: this.getTextureFormat(),
            kernel: this,
          });
        }
  
        _replaceSubOutputTextures() {
          const gl = this.context;
          for (let i = 0; i < this.mappedTextures.length; i++) {
            const mappedTexture = this.mappedTextures[i];
            if (mappedTexture.beforeMutate() || this._mappedTextureSwitched[i]) {
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, mappedTexture.texture, 0);
              this._mappedTextureSwitched[i] = false;
            }
          }
        }
  
        _setupSubOutputTextures() {
          const gl = this.context;
          if (this.mappedTextures) {
            for (let i = 0; i < this.subKernels.length; i++) {
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);
            }
            return;
          }
          const texSize = this.texSize;
          this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
          this.mappedTextures = [];
          for (let i = 0; i < this.subKernels.length; i++) {
            const texture = this.createTexture();
            this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
            gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            if (this.precision === 'single') {
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
            } else {
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            }
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);
  
            this.mappedTextures.push(new this.TextureConstructor({
              texture,
              size: texSize,
              dimensions: this.threadDim,
              output: this.output,
              context: this.context,
              internalFormat: this.getInternalFormat(),
              textureFormat: this.getTextureFormat(),
              kernel: this,
            }));
          }
        }
  
        setUniform1f(name, value) {
          if (this.uniform1fCache.hasOwnProperty(name)) {
            const cache = this.uniform1fCache[name];
            if (value === cache) {
              return;
            }
          }
          this.uniform1fCache[name] = value;
          const loc = this.getUniformLocation(name);
          this.context.uniform1f(loc, value);
        }
  
        setUniform1i(name, value) {
          if (this.uniform1iCache.hasOwnProperty(name)) {
            const cache = this.uniform1iCache[name];
            if (value === cache) {
              return;
            }
          }
          this.uniform1iCache[name] = value;
          const loc = this.getUniformLocation(name);
          this.context.uniform1i(loc, value);
        }
  
        setUniform2f(name, value1, value2) {
          if (this.uniform2fCache.hasOwnProperty(name)) {
            const cache = this.uniform2fCache[name];
            if (
              value1 === cache[0] &&
              value2 === cache[1]
            ) {
              return;
            }
          }
          this.uniform2fCache[name] = [value1, value2];
          const loc = this.getUniformLocation(name);
          this.context.uniform2f(loc, value1, value2);
        }
  
        setUniform2fv(name, value) {
          if (this.uniform2fvCache.hasOwnProperty(name)) {
            const cache = this.uniform2fvCache[name];
            if (
              value[0] === cache[0] &&
              value[1] === cache[1]
            ) {
              return;
            }
          }
          this.uniform2fvCache[name] = value;
          const loc = this.getUniformLocation(name);
          this.context.uniform2fv(loc, value);
        }
  
        setUniform2iv(name, value) {
          if (this.uniform2ivCache.hasOwnProperty(name)) {
            const cache = this.uniform2ivCache[name];
            if (
              value[0] === cache[0] &&
              value[1] === cache[1]
            ) {
              return;
            }
          }
          this.uniform2ivCache[name] = value;
          const loc = this.getUniformLocation(name);
          this.context.uniform2iv(loc, value);
        }
  
        setUniform3fv(name, value) {
          if (this.uniform3fvCache.hasOwnProperty(name)) {
            const cache = this.uniform3fvCache[name];
            if (
              value[0] === cache[0] &&
              value[1] === cache[1] &&
              value[2] === cache[2]
            ) {
              return;
            }
          }
          this.uniform3fvCache[name] = value;
          const loc = this.getUniformLocation(name);
          this.context.uniform3fv(loc, value);
        }
  
        setUniform3iv(name, value) {
          if (this.uniform3ivCache.hasOwnProperty(name)) {
            const cache = this.uniform3ivCache[name];
            if (
              value[0] === cache[0] &&
              value[1] === cache[1] &&
              value[2] === cache[2]
            ) {
              return;
            }
          }
          this.uniform3ivCache[name] = value;
          const loc = this.getUniformLocation(name);
          this.context.uniform3iv(loc, value);
        }
  
        setUniform4fv(name, value) {
          if (this.uniform4fvCache.hasOwnProperty(name)) {
            const cache = this.uniform4fvCache[name];
            if (
              value[0] === cache[0] &&
              value[1] === cache[1] &&
              value[2] === cache[2] &&
              value[3] === cache[3]
            ) {
              return;
            }
          }
          this.uniform4fvCache[name] = value;
          const loc = this.getUniformLocation(name);
          this.context.uniform4fv(loc, value);
        }
  
        setUniform4iv(name, value) {
          if (this.uniform4ivCache.hasOwnProperty(name)) {
            const cache = this.uniform4ivCache[name];
            if (
              value[0] === cache[0] &&
              value[1] === cache[1] &&
              value[2] === cache[2] &&
              value[3] === cache[3]
            ) {
              return;
            }
          }
          this.uniform4ivCache[name] = value;
          const loc = this.getUniformLocation(name);
          this.context.uniform4iv(loc, value);
        }
  
        getUniformLocation(name) {
          if (this.programUniformLocationCache.hasOwnProperty(name)) {
            return this.programUniformLocationCache[name];
          }
          return this.programUniformLocationCache[name] = this.context.getUniformLocation(this.program, name);
        }
  
        _getFragShaderArtifactMap(args) {
          return {
            HEADER: this._getHeaderString(),
            LOOP_MAX: this._getLoopMaxString(),
            PLUGINS: this._getPluginsString(),
            CONSTANTS: this._getConstantsString(),
            DECODE32_ENDIANNESS: this._getDecode32EndiannessString(),
            ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(),
            DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(),
            INJECTED_NATIVE: this._getInjectedNative(),
            MAIN_CONSTANTS: this._getMainConstantsString(),
            MAIN_ARGUMENTS: this._getMainArgumentsString(args),
            KERNEL: this.getKernelString(),
            MAIN_RESULT: this.getMainResultString(),
            FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
            INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
            SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
            SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),
          };
        }
  
        _getVertShaderArtifactMap(args) {
          return {
            FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
            INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
            SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
            SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),
          };
        }
  
        _getHeaderString() {
          return (
            this.subKernels !== null ?
            '#extension GL_EXT_draw_buffers : require\n' :
            ''
          );
        }
  
        _getLoopMaxString() {
          return (
            this.loopMaxIterations ?
            ` ${parseInt(this.loopMaxIterations)};\n` :
            ' 1000;\n'
          );
        }
  
        _getPluginsString() {
          if (!this.plugins) return '\n';
          return this.plugins.map(plugin => plugin.source && this.source.match(plugin.functionMatch) ? plugin.source : '').join('\n');
        }
  
        _getConstantsString() {
          const result = [];
          const { threadDim, texSize } = this;
          if (this.dynamicOutput) {
            result.push(
              'uniform ivec3 uOutputDim',
              'uniform ivec2 uTexSize'
            );
          } else {
            result.push(
              `ivec3 uOutputDim = ivec3(${threadDim[0]}, ${threadDim[1]}, ${threadDim[2]})`,
              `ivec2 uTexSize = ivec2(${texSize[0]}, ${texSize[1]})`
            );
          }
          return utils.linesToString(result);
        }
  
        _getTextureCoordinate() {
          const subKernels = this.subKernels;
          if (subKernels === null || subKernels.length < 1) {
            return 'varying vec2 vTexCoord;\n';
          } else {
            return 'out vec2 vTexCoord;\n';
          }
        }
  
        _getDecode32EndiannessString() {
          return (
            this.endianness === 'LE' ?
            '' :
            '  texel.rgba = texel.abgr;\n'
          );
        }
  
        _getEncode32EndiannessString() {
          return (
            this.endianness === 'LE' ?
            '' :
            '  texel.rgba = texel.abgr;\n'
          );
        }
  
        _getDivideWithIntegerCheckString() {
          return this.fixIntegerDivisionAccuracy ?
            `float divWithIntCheck(float x, float y) {
    if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {
      return float(int(x) / int(y));
    }
    return x / y;
  }
  
  float integerCorrectionModulo(float number, float divisor) {
    if (number < 0.0) {
      number = abs(number);
      if (divisor < 0.0) {
        divisor = abs(divisor);
      }
      return -(number - (divisor * floor(divWithIntCheck(number, divisor))));
    }
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return number - (divisor * floor(divWithIntCheck(number, divisor)));
  }` :
            '';
        }
  
        _getMainArgumentsString(args) {
          const results = [];
          const { argumentNames } = this;
          for (let i = 0; i < argumentNames.length; i++) {
            results.push(this.kernelArguments[i].getSource(args[i]));
          }
          return results.join('');
        }
  
        _getInjectedNative() {
          return this.injectedNative || '';
        }
  
        _getMainConstantsString() {
          const result = [];
          const { constants } = this;
          if (constants) {
            let i = 0;
            for (const name in constants) {
              if (!this.constants.hasOwnProperty(name)) continue;
              result.push(this.kernelConstants[i++].getSource(this.constants[name]));
            }
          }
          return result.join('');
        }
  
        getRawValueFramebuffer(width, height) {
          if (!this.rawValueFramebuffers[width]) {
            this.rawValueFramebuffers[width] = {};
          }
          if (!this.rawValueFramebuffers[width][height]) {
            const framebuffer = this.context.createFramebuffer();
            framebuffer.width = width;
            framebuffer.height = height;
            this.rawValueFramebuffers[width][height] = framebuffer;
          }
          return this.rawValueFramebuffers[width][height];
        }
  
        getKernelResultDeclaration() {
          switch (this.returnType) {
            case 'Array(2)':
              return 'vec2 kernelResult';
            case 'Array(3)':
              return 'vec3 kernelResult';
            case 'Array(4)':
              return 'vec4 kernelResult';
            case 'LiteralInteger':
            case 'Float':
            case 'Number':
            case 'Integer':
              return 'float kernelResult';
            default:
              if (this.graphical) {
                return 'float kernelResult';
              } else {
                throw new Error(`unrecognized output type "${ this.returnType }"`);
              }
          }
        }
        getKernelString() {
          const result = [this.getKernelResultDeclaration()];
          const { subKernels } = this;
          if (subKernels !== null) {
            switch (this.returnType) {
              case 'Number':
              case 'Float':
              case 'Integer':
                for (let i = 0; i < subKernels.length; i++) {
                  const subKernel = subKernels[i];
                  result.push(
                    subKernel.returnType === 'Integer' ?
                    `int subKernelResult_${ subKernel.name } = 0` :
                    `float subKernelResult_${ subKernel.name } = 0.0`
                  );
                }
                break;
              case 'Array(2)':
                for (let i = 0; i < subKernels.length; i++) {
                  result.push(
                    `vec2 subKernelResult_${ subKernels[i].name }`
                  );
                }
                break;
              case 'Array(3)':
                for (let i = 0; i < subKernels.length; i++) {
                  result.push(
                    `vec3 subKernelResult_${ subKernels[i].name }`
                  );
                }
                break;
              case 'Array(4)':
                for (let i = 0; i < subKernels.length; i++) {
                  result.push(
                    `vec4 subKernelResult_${ subKernels[i].name }`
                  );
                }
                break;
            }
          }
  
          return utils.linesToString(result) + this.translatedSource;
        }
  
        getMainResultGraphical() {
          return utils.linesToString([
            '  threadId = indexTo3D(index, uOutputDim)',
            '  kernel()',
            '  gl_FragColor = actualColor',
          ]);
        }
  
        getMainResultPackedPixels() {
          switch (this.returnType) {
            case 'LiteralInteger':
            case 'Number':
            case 'Integer':
            case 'Float':
              return this.getMainResultKernelPackedPixels() +
                this.getMainResultSubKernelPackedPixels();
            default:
              throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
          }
        }
  
        getMainResultKernelPackedPixels() {
          return utils.linesToString([
            '  threadId = indexTo3D(index, uOutputDim)',
            '  kernel()',
            `  gl_FragData[0] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`
          ]);
        }
  
        getMainResultSubKernelPackedPixels() {
          const result = [];
          if (!this.subKernels) return '';
          for (let i = 0; i < this.subKernels.length; i++) {
            const subKernel = this.subKernels[i];
            if (subKernel.returnType === 'Integer') {
              result.push(
                `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`
              );
            } else {
              result.push(
                `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`
              );
            }
          }
          return utils.linesToString(result);
        }
  
        getMainResultMemoryOptimizedFloats() {
          const result = [
            '  index *= 4',
          ];
  
          switch (this.returnType) {
            case 'Number':
            case 'Integer':
            case 'Float':
              const channels = ['r', 'g', 'b', 'a'];
              for (let i = 0; i < channels.length; i++) {
                const channel = channels[i];
                this.getMainResultKernelMemoryOptimizedFloats(result, channel);
                this.getMainResultSubKernelMemoryOptimizedFloats(result, channel);
                if (i + 1 < channels.length) {
                  result.push('  index += 1');
                }
              }
              break;
            default:
              throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`);
          }
  
          return utils.linesToString(result);
        }
  
        getMainResultKernelMemoryOptimizedFloats(result, channel) {
          result.push(
            '  threadId = indexTo3D(index, uOutputDim)',
            '  kernel()',
            `  gl_FragData[0].${channel} = kernelResult`
          );
        }
  
        getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
          if (!this.subKernels) return result;
          for (let i = 0; i < this.subKernels.length; i++) {
            const subKernel = this.subKernels[i];
            if (subKernel.returnType === 'Integer') {
              result.push(
                `  gl_FragData[${i + 1}].${channel} = float(subKernelResult_${this.subKernels[i].name})`
              );
            } else {
              result.push(
                `  gl_FragData[${i + 1}].${channel} = subKernelResult_${this.subKernels[i].name}`
              );
            }
          }
        }
  
        getMainResultKernelNumberTexture() {
          return [
            '  threadId = indexTo3D(index, uOutputDim)',
            '  kernel()',
            '  gl_FragData[0][0] = kernelResult',
          ];
        }
  
        getMainResultSubKernelNumberTexture() {
          const result = [];
          if (!this.subKernels) return result;
          for (let i = 0; i < this.subKernels.length; ++i) {
            const subKernel = this.subKernels[i];
            if (subKernel.returnType === 'Integer') {
              result.push(
                `  gl_FragData[${i + 1}][0] = float(subKernelResult_${subKernel.name})`
              );
            } else {
              result.push(
                `  gl_FragData[${i + 1}][0] = subKernelResult_${subKernel.name}`
              );
            }
          }
          return result;
        }
  
        getMainResultKernelArray2Texture() {
          return [
            '  threadId = indexTo3D(index, uOutputDim)',
            '  kernel()',
            '  gl_FragData[0][0] = kernelResult[0]',
            '  gl_FragData[0][1] = kernelResult[1]',
          ];
        }
  
        getMainResultSubKernelArray2Texture() {
          const result = [];
          if (!this.subKernels) return result;
          for (let i = 0; i < this.subKernels.length; ++i) {
            result.push(
              `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
              `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`
            );
          }
          return result;
        }
  
        getMainResultKernelArray3Texture() {
          return [
            '  threadId = indexTo3D(index, uOutputDim)',
            '  kernel()',
            '  gl_FragData[0][0] = kernelResult[0]',
            '  gl_FragData[0][1] = kernelResult[1]',
            '  gl_FragData[0][2] = kernelResult[2]',
          ];
        }
  
        getMainResultSubKernelArray3Texture() {
          const result = [];
          if (!this.subKernels) return result;
          for (let i = 0; i < this.subKernels.length; ++i) {
            result.push(
              `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
              `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
              `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`
            );
          }
          return result;
        }
  
        getMainResultKernelArray4Texture() {
          return [
            '  threadId = indexTo3D(index, uOutputDim)',
            '  kernel()',
            '  gl_FragData[0] = kernelResult',
          ];
        }
  
        getMainResultSubKernelArray4Texture() {
          const result = [];
          if (!this.subKernels) return result;
          switch (this.returnType) {
            case 'Number':
            case 'Float':
            case 'Integer':
              for (let i = 0; i < this.subKernels.length; ++i) {
                const subKernel = this.subKernels[i];
                if (subKernel.returnType === 'Integer') {
                  result.push(
                    `  gl_FragData[${i + 1}] = float(subKernelResult_${this.subKernels[i].name})`
                  );
                } else {
                  result.push(
                    `  gl_FragData[${i + 1}] = subKernelResult_${this.subKernels[i].name}`
                  );
                }
              }
              break;
            case 'Array(2)':
              for (let i = 0; i < this.subKernels.length; ++i) {
                result.push(
                  `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
                  `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`
                );
              }
              break;
            case 'Array(3)':
              for (let i = 0; i < this.subKernels.length; ++i) {
                result.push(
                  `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
                  `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
                  `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`
                );
              }
              break;
            case 'Array(4)':
              for (let i = 0; i < this.subKernels.length; ++i) {
                result.push(
                  `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
                  `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
                  `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`,
                  `  gl_FragData[${i + 1}][3] = subKernelResult_${this.subKernels[i].name}[3]`
                );
              }
              break;
          }
  
          return result;
        }
  
        replaceArtifacts(src, map) {
          return src.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\n/g, (match, artifact) => {
            if (map.hasOwnProperty(artifact)) {
              return map[artifact];
            }
            throw `unhandled artifact ${artifact}`;
          });
        }
  
        getFragmentShader(args) {
          if (this.compiledFragmentShader !== null) {
            return this.compiledFragmentShader;
          }
          return this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(args));
        }
  
        getVertexShader(args) {
          if (this.compiledVertexShader !== null) {
            return this.compiledVertexShader;
          }
          return this.compiledVertexShader = this.replaceArtifacts(this.constructor.vertexShader, this._getVertShaderArtifactMap(args));
        }
  
        toString() {
          const setupContextString = utils.linesToString([
            `const gl = context`,
          ]);
          return glKernelString(this.constructor, arguments, this, setupContextString);
        }
  
        destroy(removeCanvasReferences) {
          if (!this.context) return;
          if (this.buffer) {
            this.context.deleteBuffer(this.buffer);
          }
          if (this.framebuffer) {
            this.context.deleteFramebuffer(this.framebuffer);
          }
          for (const width in this.rawValueFramebuffers) {
            for (const height in this.rawValueFramebuffers[width]) {
              this.context.deleteFramebuffer(this.rawValueFramebuffers[width][height]);
              delete this.rawValueFramebuffers[width][height];
            }
            delete this.rawValueFramebuffers[width];
          }
          if (this.vertShader) {
            this.context.deleteShader(this.vertShader);
          }
          if (this.fragShader) {
            this.context.deleteShader(this.fragShader);
          }
          if (this.program) {
            this.context.deleteProgram(this.program);
          }
          if (this.texture) {
            this.texture.delete();
            const textureCacheIndex = this.textureCache.indexOf(this.texture.texture);
            if (textureCacheIndex > -1) {
              this.textureCache.splice(textureCacheIndex, 1);
            }
            this.texture = null;
          }
          if (this.mappedTextures && this.mappedTextures.length) {
            for (let i = 0; i < this.mappedTextures.length; i++) {
              const mappedTexture = this.mappedTextures[i];
              mappedTexture.delete();
              const textureCacheIndex = this.textureCache.indexOf(mappedTexture.texture);
              if (textureCacheIndex > -1) {
                this.textureCache.splice(textureCacheIndex, 1);
              }
            }
            this.mappedTextures = null;
          }
          if (this.kernelArguments) {
            for (let i = 0; i < this.kernelArguments.length; i++) {
              this.kernelArguments[i].destroy();
            }
          }
          if (this.kernelConstants) {
            for (let i = 0; i < this.kernelConstants.length; i++) {
              this.kernelConstants[i].destroy();
            }
          }
          while (this.textureCache.length > 0) {
            const texture = this.textureCache.pop();
            this.context.deleteTexture(texture);
          }
          if (removeCanvasReferences) {
            const idx = canvases.indexOf(this.canvas);
            if (idx >= 0) {
              canvases[idx] = null;
              maxTexSizes[idx] = null;
            }
          }
          this.destroyExtensions();
          delete this.context;
          delete this.canvas;
          if (!this.gpu) return;
          const i = this.gpu.kernels.indexOf(this);
          if (i === -1) return;
          this.gpu.kernels.splice(i, 1);
        }
  
        destroyExtensions() {
          this.extensions.OES_texture_float = null;
          this.extensions.OES_texture_float_linear = null;
          this.extensions.OES_element_index_uint = null;
          this.extensions.WEBGL_draw_buffers = null;
        }
  
        static destroyContext(context) {
          const extension = context.getExtension('WEBGL_lose_context');
          if (extension) {
            extension.loseContext();
          }
        }
  
        toJSON() {
          const json = super.toJSON();
          json.functionNodes = FunctionBuilder.fromKernel(this, WebGLFunctionNode).toJSON();
          json.settings.threadDim = this.threadDim;
          return json;
        }
      }
  
      module.exports = {
        WebGLKernel
      };
      },{"../../plugins/math-random-uniformly-distributed":112,"../../utils":114,"../function-builder":9,"../gl/kernel":13,"../gl/kernel-string":12,"./fragment-shader":37,"./function-node":38,"./kernel-value-maps":39,"./vertex-shader":71}],71:[function(require,module,exports){
      const vertexShader = `__FLOAT_TACTIC_DECLARATION__;
  __INT_TACTIC_DECLARATION__;
  __SAMPLER_2D_TACTIC_DECLARATION__;
  
  attribute vec2 aPos;
  attribute vec2 aTexCoord;
  
  varying vec2 vTexCoord;
  uniform vec2 ratio;
  
  void main(void) {
    gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
    vTexCoord = aTexCoord;
  }`;
  
      module.exports = {
        vertexShader
      };
      },{}],72:[function(require,module,exports){
      const fragmentShader = `#version 300 es
  __HEADER__;
  __FLOAT_TACTIC_DECLARATION__;
  __INT_TACTIC_DECLARATION__;
  __SAMPLER_2D_TACTIC_DECLARATION__;
  __SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;
  
  const int LOOP_MAX = __LOOP_MAX__;
  
  __PLUGINS__;
  __CONSTANTS__;
  
  in vec2 vTexCoord;
  
  float atan2(float v1, float v2) {
    if (v1 == 0.0 || v2 == 0.0) return 0.0;
    return atan(v1 / v2);
  }
  
  float cbrt(float x) {
    if (x >= 0.0) {
      return pow(x, 1.0 / 3.0);
    } else {
      return -pow(x, 1.0 / 3.0);
    }
  }
  
  float expm1(float x) {
    return pow(${Math.E}, x) - 1.0; 
  }
  
  float fround(highp float x) {
    return x;
  }
  
  float imul(float v1, float v2) {
    return float(int(v1) * int(v2));
  }
  
  float log10(float x) {
    return log2(x) * (1.0 / log2(10.0));
  }
  
  float log1p(float x) {
    return log(1.0 + x);
  }
  
  float _pow(float v1, float v2) {
    if (v2 == 0.0) return 1.0;
    return pow(v1, v2);
  }
  
  float _round(float x) {
    return floor(x + 0.5);
  }
  
  
  const int BIT_COUNT = 32;
  int modi(int x, int y) {
    return x - y * (x / y);
  }
  
  int bitwiseOr(int a, int b) {
    int result = 0;
    int n = 1;
    
    for (int i = 0; i < BIT_COUNT; i++) {
      if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
        result += n;
      }
      a = a / 2;
      b = b / 2;
      n = n * 2;
      if(!(a > 0 || b > 0)) {
        break;
      }
    }
    return result;
  }
  int bitwiseXOR(int a, int b) {
    int result = 0;
    int n = 1;
    
    for (int i = 0; i < BIT_COUNT; i++) {
      if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
        result += n;
      }
      a = a / 2;
      b = b / 2;
      n = n * 2;
      if(!(a > 0 || b > 0)) {
        break;
      }
    }
    return result;
  }
  int bitwiseAnd(int a, int b) {
    int result = 0;
    int n = 1;
    for (int i = 0; i < BIT_COUNT; i++) {
      if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
        result += n;
      }
      a = a / 2;
      b = b / 2;
      n = n * 2;
      if(!(a > 0 && b > 0)) {
        break;
      }
    }
    return result;
  }
  int bitwiseNot(int a) {
    int result = 0;
    int n = 1;
    
    for (int i = 0; i < BIT_COUNT; i++) {
      if (modi(a, 2) == 0) {
        result += n;    
      }
      a = a / 2;
      n = n * 2;
    }
    return result;
  }
  int bitwiseZeroFillLeftShift(int n, int shift) {
    int maxBytes = BIT_COUNT;
    for (int i = 0; i < BIT_COUNT; i++) {
      if (maxBytes >= n) {
        break;
      }
      maxBytes *= 2;
    }
    for (int i = 0; i < BIT_COUNT; i++) {
      if (i >= shift) {
        break;
      }
      n *= 2;
    }
  
    int result = 0;
    int byteVal = 1;
    for (int i = 0; i < BIT_COUNT; i++) {
      if (i >= maxBytes) break;
      if (modi(n, 2) > 0) { result += byteVal; }
      n = int(n / 2);
      byteVal *= 2;
    }
    return result;
  }
  
  int bitwiseSignedRightShift(int num, int shifts) {
    return int(floor(float(num) / pow(2.0, float(shifts))));
  }
  
  int bitwiseZeroFillRightShift(int n, int shift) {
    int maxBytes = BIT_COUNT;
    for (int i = 0; i < BIT_COUNT; i++) {
      if (maxBytes >= n) {
        break;
      }
      maxBytes *= 2;
    }
    for (int i = 0; i < BIT_COUNT; i++) {
      if (i >= shift) {
        break;
      }
      n /= 2;
    }
    int result = 0;
    int byteVal = 1;
    for (int i = 0; i < BIT_COUNT; i++) {
      if (i >= maxBytes) break;
      if (modi(n, 2) > 0) { result += byteVal; }
      n = int(n / 2);
      byteVal *= 2;
    }
    return result;
  }
  
  vec2 integerMod(vec2 x, float y) {
    vec2 res = floor(mod(x, y));
    return res * step(1.0 - floor(y), -res);
  }
  
  vec3 integerMod(vec3 x, float y) {
    vec3 res = floor(mod(x, y));
    return res * step(1.0 - floor(y), -res);
  }
  
  vec4 integerMod(vec4 x, vec4 y) {
    vec4 res = floor(mod(x, y));
    return res * step(1.0 - floor(y), -res);
  }
  
  float integerMod(float x, float y) {
    float res = floor(mod(x, y));
    return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
  }
  
  int integerMod(int x, int y) {
    return x - (y * int(x/y));
  }
  
  __DIVIDE_WITH_INTEGER_CHECK__;
  
  // Here be dragons!
  // DO NOT OPTIMIZE THIS CODE
  // YOU WILL BREAK SOMETHING ON SOMEBODY\'S MACHINE
  // LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
  const vec2 MAGIC_VEC = vec2(1.0, -256.0);
  const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
  const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
  float decode32(vec4 texel) {
    __DECODE32_ENDIANNESS__;
    texel *= 255.0;
    vec2 gte128;
    gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
    gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
    float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
    float res = exp2(round(exponent));
    texel.b = texel.b - 128.0 * gte128.x;
    res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;
    res *= gte128.y * -2.0 + 1.0;
    return res;
  }
  
  float decode16(vec4 texel, int index) {
    int channel = integerMod(index, 2);
    return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;
  }
  
  float decode8(vec4 texel, int index) {
    int channel = integerMod(index, 4);
    return texel[channel] * 255.0;
  }
  
  vec4 legacyEncode32(float f) {
    float F = abs(f);
    float sign = f < 0.0 ? 1.0 : 0.0;
    float exponent = floor(log2(F));
    float mantissa = (exp2(-exponent) * F);
    // exponent += floor(log2(mantissa));
    vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
    texel.rg = integerMod(texel.rg, 256.0);
    texel.b = integerMod(texel.b, 128.0);
    texel.a = exponent*0.5 + 63.5;
    texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
    texel = floor(texel);
    texel *= 0.003921569; // 1/255
    __ENCODE32_ENDIANNESS__;
    return texel;
  }
  
  // https://github.com/gpujs/gpu.js/wiki/Encoder-details
  vec4 encode32(float value) {
    if (value == 0.0) return vec4(0, 0, 0, 0);
  
    float exponent;
    float mantissa;
    vec4  result;
    float sgn;
  
    sgn = step(0.0, -value);
    value = abs(value);
  
    exponent = floor(log2(value));
  
    mantissa = value*pow(2.0, -exponent)-1.0;
    exponent = exponent+127.0;
    result   = vec4(0,0,0,0);
  
    result.a = floor(exponent/2.0);
    exponent = exponent - result.a*2.0;
    result.a = result.a + 128.0*sgn;
  
    result.b = floor(mantissa * 128.0);
    mantissa = mantissa - result.b / 128.0;
    result.b = result.b + exponent*128.0;
  
    result.g = floor(mantissa*32768.0);
    mantissa = mantissa - result.g/32768.0;
  
    result.r = floor(mantissa*8388608.0);
    return result/255.0;
  }
  // Dragons end here
  
  int index;
  ivec3 threadId;
  
  ivec3 indexTo3D(int idx, ivec3 texDim) {
    int z = int(idx / (texDim.x * texDim.y));
    idx -= z * int(texDim.x * texDim.y);
    int y = int(idx / texDim.x);
    int x = int(integerMod(idx, texDim.x));
    return ivec3(x, y, z);
  }
  
  float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int index = x + texDim.x * (y + texDim.y * z);
    int w = texSize.x;
    vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
    vec4 texel = texture(tex, st / vec2(texSize));
    return decode32(texel);
  }
  
  float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int index = x + (texDim.x * (y + (texDim.y * z)));
    int w = texSize.x * 2;
    vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
    vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));
    return decode16(texel, index);
  }
  
  float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int index = x + (texDim.x * (y + (texDim.y * z)));
    int w = texSize.x * 4;
    vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
    vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));
    return decode8(texel, index);
  }
  
  float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int index = x + (texDim.x * (y + (texDim.y * z)));
    int channel = integerMod(index, 4);
    index = index / 4;
    int w = texSize.x;
    vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
    index = index / 4;
    vec4 texel = texture(tex, st / vec2(texSize));
    return texel[channel];
  }
  
  vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int index = x + texDim.x * (y + texDim.y * z);
    int w = texSize.x;
    vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
    return texture(tex, st / vec2(texSize));
  }
  
  vec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int index = x + texDim.x * (y + texDim.y * z);
    int w = texSize.x;
    vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
    return texture(tex, vec3(st / vec2(texSize), z));
  }
  
  float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
    return result[0];
  }
  
  vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
    return vec2(result[0], result[1]);
  }
  
  vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int index = x + texDim.x * (y + texDim.y * z);
    int channel = integerMod(index, 2);
    index = index / 2;
    int w = texSize.x;
    vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
    vec4 texel = texture(tex, st / vec2(texSize));
    if (channel == 0) return vec2(texel.r, texel.g);
    if (channel == 1) return vec2(texel.b, texel.a);
    return vec2(0.0, 0.0);
  }
  
  vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
    return vec3(result[0], result[1], result[2]);
  }
  
  vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
    int vectorIndex = fieldIndex / 4;
    int vectorOffset = fieldIndex - vectorIndex * 4;
    int readY = vectorIndex / texSize.x;
    int readX = vectorIndex - readY * texSize.x;
    vec4 tex1 = texture(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));
  
    if (vectorOffset == 0) {
      return tex1.xyz;
    } else if (vectorOffset == 1) {
      return tex1.yzw;
    } else {
      readX++;
      if (readX >= texSize.x) {
        readX = 0;
        readY++;
      }
      vec4 tex2 = texture(tex, vec2(readX, readY) / vec2(texSize));
      if (vectorOffset == 2) {
        return vec3(tex1.z, tex1.w, tex2.x);
      } else {
        return vec3(tex1.w, tex2.x, tex2.y);
      }
    }
  }
  
  vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    return getImage2D(tex, texSize, texDim, z, y, x);
  }
  
  vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
    int index = x + texDim.x * (y + texDim.y * z);
    int channel = integerMod(index, 2);
    int w = texSize.x;
    vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
    vec4 texel = texture(tex, st / vec2(texSize));
    return vec4(texel.r, texel.g, texel.b, texel.a);
  }
  
  vec4 actualColor;
  void color(float r, float g, float b, float a) {
    actualColor = vec4(r,g,b,a);
  }
  
  void color(float r, float g, float b) {
    color(r,g,b,1.0);
  }
  
  float modulo(float number, float divisor) {
    if (number < 0.0) {
      number = abs(number);
      if (divisor < 0.0) {
        divisor = abs(divisor);
      }
      return -mod(number, divisor);
    }
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return mod(number, divisor);
  }
  
  __INJECTED_NATIVE__;
  __MAIN_CONSTANTS__;
  __MAIN_ARGUMENTS__;
  __KERNEL__;
  
  void main(void) {
    index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
    __MAIN_RESULT__;
  }`;
  
      module.exports = {
        fragmentShader
      };
      },{}],73:[function(require,module,exports){
      const { utils } = require('../../utils');
      const { WebGLFunctionNode } = require('../web-gl/function-node');
  
      class WebGL2FunctionNode extends WebGLFunctionNode {
  
        astIdentifierExpression(idtNode, retArr) {
          if (idtNode.type !== 'Identifier') {
            throw this.astErrorOutput(
              'IdentifierExpression - not an Identifier',
              idtNode
            );
          }
  
          const type = this.getType(idtNode);
  
          const name = utils.sanitizeName(idtNode.name);
          if (idtNode.name === 'Infinity') {
            retArr.push('intBitsToFloat(2139095039)');
          } else if (type === 'Boolean') {
            if (this.argumentNames.indexOf(name) > -1) {
              retArr.push(`bool(user_${name})`);
            } else {
              retArr.push(`user_${name}`);
            }
          } else {
            retArr.push(`user_${name}`);
          }
  
          return retArr;
        }
      }
  
      module.exports = {
        WebGL2FunctionNode
      };
      },{"../../utils":114,"../web-gl/function-node":38}],74:[function(require,module,exports){
      const { WebGL2KernelValueBoolean } = require('./kernel-value/boolean');
      const { WebGL2KernelValueFloat } = require('./kernel-value/float');
      const { WebGL2KernelValueInteger } = require('./kernel-value/integer');
  
      const { WebGL2KernelValueHTMLImage } = require('./kernel-value/html-image');
      const { WebGL2KernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');
  
      const { WebGL2KernelValueHTMLImageArray } = require('./kernel-value/html-image-array');
      const { WebGL2KernelValueDynamicHTMLImageArray } = require('./kernel-value/dynamic-html-image-array');
  
      const { WebGL2KernelValueHTMLVideo } = require('./kernel-value/html-video');
      const { WebGL2KernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');
  
      const { WebGL2KernelValueSingleInput } = require('./kernel-value/single-input');
      const { WebGL2KernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');
  
      const { WebGL2KernelValueUnsignedInput } = require('./kernel-value/unsigned-input');
      const { WebGL2KernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');
  
      const { WebGL2KernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');
      const { WebGL2KernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');
  
      const { WebGL2KernelValueNumberTexture } = require('./kernel-value/number-texture');
      const { WebGL2KernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');
  
      const { WebGL2KernelValueSingleArray } = require('./kernel-value/single-array');
      const { WebGL2KernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');
  
      const { WebGL2KernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');
      const { WebGL2KernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');
  
      const { WebGL2KernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');
      const { WebGL2KernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');
  
      const { WebGL2KernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');
      const { WebGL2KernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');
  
      const { WebGL2KernelValueArray2 } = require('./kernel-value/array2');
      const { WebGL2KernelValueArray3 } = require('./kernel-value/array3');
      const { WebGL2KernelValueArray4 } = require('./kernel-value/array4');
  
      const { WebGL2KernelValueUnsignedArray } = require('./kernel-value/unsigned-array');
      const { WebGL2KernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');
  
      const kernelValueMaps = {
        unsigned: {
          dynamic: {
            'Boolean': WebGL2KernelValueBoolean,
            'Integer': WebGL2KernelValueInteger,
            'Float': WebGL2KernelValueFloat,
            'Array': WebGL2KernelValueDynamicUnsignedArray,
            'Array(2)': WebGL2KernelValueArray2,
            'Array(3)': WebGL2KernelValueArray3,
            'Array(4)': WebGL2KernelValueArray4,
            'Array1D(2)': false,
            'Array1D(3)': false,
            'Array1D(4)': false,
            'Array2D(2)': false,
            'Array2D(3)': false,
            'Array2D(4)': false,
            'Array3D(2)': false,
            'Array3D(3)': false,
            'Array3D(4)': false,
            'Input': WebGL2KernelValueDynamicUnsignedInput,
            'NumberTexture': WebGL2KernelValueDynamicNumberTexture,
            'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,
            'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,
            'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,
            'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,
            'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
            'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,
            'OffscreenCanvas': WebGL2KernelValueDynamicHTMLImage,
            'HTMLImage': WebGL2KernelValueDynamicHTMLImage,
            'ImageBitmap': WebGL2KernelValueDynamicHTMLImage,
            'ImageData': WebGL2KernelValueDynamicHTMLImage,
            'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,
            'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,
          },
          static: {
            'Boolean': WebGL2KernelValueBoolean,
            'Float': WebGL2KernelValueFloat,
            'Integer': WebGL2KernelValueInteger,
            'Array': WebGL2KernelValueUnsignedArray,
            'Array(2)': WebGL2KernelValueArray2,
            'Array(3)': WebGL2KernelValueArray3,
            'Array(4)': WebGL2KernelValueArray4,
            'Array1D(2)': false,
            'Array1D(3)': false,
            'Array1D(4)': false,
            'Array2D(2)': false,
            'Array2D(3)': false,
            'Array2D(4)': false,
            'Array3D(2)': false,
            'Array3D(3)': false,
            'Array3D(4)': false,
            'Input': WebGL2KernelValueUnsignedInput,
            'NumberTexture': WebGL2KernelValueNumberTexture,
            'ArrayTexture(1)': WebGL2KernelValueNumberTexture,
            'ArrayTexture(2)': WebGL2KernelValueNumberTexture,
            'ArrayTexture(3)': WebGL2KernelValueNumberTexture,
            'ArrayTexture(4)': WebGL2KernelValueNumberTexture,
            'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
            'HTMLCanvas': WebGL2KernelValueHTMLImage,
            'OffscreenCanvas': WebGL2KernelValueHTMLImage,
            'HTMLImage': WebGL2KernelValueHTMLImage,
            'ImageBitmap': WebGL2KernelValueHTMLImage,
            'ImageData': WebGL2KernelValueHTMLImage,
            'HTMLImageArray': WebGL2KernelValueHTMLImageArray,
            'HTMLVideo': WebGL2KernelValueHTMLVideo,
          }
        },
        single: {
          dynamic: {
            'Boolean': WebGL2KernelValueBoolean,
            'Integer': WebGL2KernelValueInteger,
            'Float': WebGL2KernelValueFloat,
            'Array': WebGL2KernelValueDynamicSingleArray,
            'Array(2)': WebGL2KernelValueArray2,
            'Array(3)': WebGL2KernelValueArray3,
            'Array(4)': WebGL2KernelValueArray4,
            'Array1D(2)': WebGL2KernelValueDynamicSingleArray1DI,
            'Array1D(3)': WebGL2KernelValueDynamicSingleArray1DI,
            'Array1D(4)': WebGL2KernelValueDynamicSingleArray1DI,
            'Array2D(2)': WebGL2KernelValueDynamicSingleArray2DI,
            'Array2D(3)': WebGL2KernelValueDynamicSingleArray2DI,
            'Array2D(4)': WebGL2KernelValueDynamicSingleArray2DI,
            'Array3D(2)': WebGL2KernelValueDynamicSingleArray3DI,
            'Array3D(3)': WebGL2KernelValueDynamicSingleArray3DI,
            'Array3D(4)': WebGL2KernelValueDynamicSingleArray3DI,
            'Input': WebGL2KernelValueDynamicSingleInput,
            'NumberTexture': WebGL2KernelValueDynamicNumberTexture,
            'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,
            'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,
            'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,
            'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,
            'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
            'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,
            'OffscreenCanvas': WebGL2KernelValueDynamicHTMLImage,
            'HTMLImage': WebGL2KernelValueDynamicHTMLImage,
            'ImageBitmap': WebGL2KernelValueDynamicHTMLImage,
            'ImageData': WebGL2KernelValueDynamicHTMLImage,
            'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,
            'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,
          },
          static: {
            'Boolean': WebGL2KernelValueBoolean,
            'Float': WebGL2KernelValueFloat,
            'Integer': WebGL2KernelValueInteger,
            'Array': WebGL2KernelValueSingleArray,
            'Array(2)': WebGL2KernelValueArray2,
            'Array(3)': WebGL2KernelValueArray3,
            'Array(4)': WebGL2KernelValueArray4,
            'Array1D(2)': WebGL2KernelValueSingleArray1DI,
            'Array1D(3)': WebGL2KernelValueSingleArray1DI,
            'Array1D(4)': WebGL2KernelValueSingleArray1DI,
            'Array2D(2)': WebGL2KernelValueSingleArray2DI,
            'Array2D(3)': WebGL2KernelValueSingleArray2DI,
            'Array2D(4)': WebGL2KernelValueSingleArray2DI,
            'Array3D(2)': WebGL2KernelValueSingleArray3DI,
            'Array3D(3)': WebGL2KernelValueSingleArray3DI,
            'Array3D(4)': WebGL2KernelValueSingleArray3DI,
            'Input': WebGL2KernelValueSingleInput,
            'NumberTexture': WebGL2KernelValueNumberTexture,
            'ArrayTexture(1)': WebGL2KernelValueNumberTexture,
            'ArrayTexture(2)': WebGL2KernelValueNumberTexture,
            'ArrayTexture(3)': WebGL2KernelValueNumberTexture,
            'ArrayTexture(4)': WebGL2KernelValueNumberTexture,
            'MemoryOptimizedNumberTexture': WebGL2KernelValueMemoryOptimizedNumberTexture,
            'HTMLCanvas': WebGL2KernelValueHTMLImage,
            'OffscreenCanvas': WebGL2KernelValueHTMLImage,
            'HTMLImage': WebGL2KernelValueHTMLImage,
            'ImageBitmap': WebGL2KernelValueHTMLImage,
            'ImageData': WebGL2KernelValueHTMLImage,
            'HTMLImageArray': WebGL2KernelValueHTMLImageArray,
            'HTMLVideo': WebGL2KernelValueHTMLVideo,
          }
        },
      };
  
      function lookupKernelValueType(type, dynamic, precision, value) {
        if (!type) {
          throw new Error('type missing');
        }
        if (!dynamic) {
          throw new Error('dynamic missing');
        }
        if (!precision) {
          throw new Error('precision missing');
        }
        if (value.type) {
          type = value.type;
        }
        const types = kernelValueMaps[precision][dynamic];
        if (types[type] === false) {
          return null;
        } else if (types[type] === undefined) {
          throw new Error(`Could not find a KernelValue for ${ type }`);
        }
        return types[type];
      }
  
      module.exports = {
        kernelValueMaps,
        lookupKernelValueType
      };
      },{"./kernel-value/array2":75,"./kernel-value/array3":76,"./kernel-value/array4":77,"./kernel-value/boolean":78,"./kernel-value/dynamic-html-image":80,"./kernel-value/dynamic-html-image-array":79,"./kernel-value/dynamic-html-video":81,"./kernel-value/dynamic-memory-optimized-number-texture":82,"./kernel-value/dynamic-number-texture":83,"./kernel-value/dynamic-single-array":84,"./kernel-value/dynamic-single-array1d-i":85,"./kernel-value/dynamic-single-array2d-i":86,"./kernel-value/dynamic-single-array3d-i":87,"./kernel-value/dynamic-single-input":88,"./kernel-value/dynamic-unsigned-array":89,"./kernel-value/dynamic-unsigned-input":90,"./kernel-value/float":91,"./kernel-value/html-image":93,"./kernel-value/html-image-array":92,"./kernel-value/html-video":94,"./kernel-value/integer":95,"./kernel-value/memory-optimized-number-texture":96,"./kernel-value/number-texture":97,"./kernel-value/single-array":98,"./kernel-value/single-array1d-i":99,"./kernel-value/single-array2d-i":100,"./kernel-value/single-array3d-i":101,"./kernel-value/single-input":102,"./kernel-value/unsigned-array":103,"./kernel-value/unsigned-input":104}],75:[function(require,module,exports){
      const { WebGLKernelValueArray2 } = require('../../web-gl/kernel-value/array2');
  
      class WebGL2KernelValueArray2 extends WebGLKernelValueArray2 {}
  
      module.exports = {
        WebGL2KernelValueArray2
      };
      },{"../../web-gl/kernel-value/array2":41}],76:[function(require,module,exports){
      const { WebGLKernelValueArray3 } = require('../../web-gl/kernel-value/array3');
  
      class WebGL2KernelValueArray3 extends WebGLKernelValueArray3 {}
  
      module.exports = {
        WebGL2KernelValueArray3
      };
      },{"../../web-gl/kernel-value/array3":42}],77:[function(require,module,exports){
      const { WebGLKernelValueArray4 } = require('../../web-gl/kernel-value/array4');
  
      class WebGL2KernelValueArray4 extends WebGLKernelValueArray4 {}
  
      module.exports = {
        WebGL2KernelValueArray4
      };
      },{"../../web-gl/kernel-value/array4":43}],78:[function(require,module,exports){
      const { WebGLKernelValueBoolean } = require('../../web-gl/kernel-value/boolean');
  
      class WebGL2KernelValueBoolean extends WebGLKernelValueBoolean {}
  
      module.exports = {
        WebGL2KernelValueBoolean
      };
      },{"../../web-gl/kernel-value/boolean":44}],79:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGL2KernelValueHTMLImageArray } = require('./html-image-array');
  
      class WebGL2KernelValueDynamicHTMLImageArray extends WebGL2KernelValueHTMLImageArray {
        getSource() {
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2DArray ${this.id}`,
            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
          ]);
        }
  
        updateValue(images) {
          const { width, height } = images[0];
          this.checkSize(width, height);
          this.dimensions = [width, height, images.length];
          this.textureSize = [width, height];
          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
          this.kernel.setUniform2iv(this.sizeId, this.textureSize);
          super.updateValue(images);
        }
      }
  
      module.exports = {
        WebGL2KernelValueDynamicHTMLImageArray
      };
      },{"../../../utils":114,"./html-image-array":92}],80:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueDynamicHTMLImage } = require('../../web-gl/kernel-value/dynamic-html-image');
  
      class WebGL2KernelValueDynamicHTMLImage extends WebGLKernelValueDynamicHTMLImage {
        getSource() {
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2D ${this.id}`,
            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
          ]);
        }
      }
  
      module.exports = {
        WebGL2KernelValueDynamicHTMLImage
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/dynamic-html-image":45}],81:[function(require,module,exports){
      require('../../../utils');
      const { WebGL2KernelValueDynamicHTMLImage } = require('./dynamic-html-image');
  
      class WebGL2KernelValueDynamicHTMLVideo extends WebGL2KernelValueDynamicHTMLImage {}
  
      module.exports = {
        WebGL2KernelValueDynamicHTMLVideo
      };
      },{"../../../utils":114,"./dynamic-html-image":80}],82:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/dynamic-memory-optimized-number-texture');
  
      class WebGL2KernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueDynamicMemoryOptimizedNumberTexture {
        getSource() {
          return utils.linesToString([
            `uniform sampler2D ${this.id}`,
            `uniform ivec2 ${this.sizeId}`,
            `uniform ivec3 ${this.dimensionsId}`,
          ]);
        }
      }
  
      module.exports = {
        WebGL2KernelValueDynamicMemoryOptimizedNumberTexture
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/dynamic-memory-optimized-number-texture":47}],83:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueDynamicNumberTexture } = require('../../web-gl/kernel-value/dynamic-number-texture');
  
      class WebGL2KernelValueDynamicNumberTexture extends WebGLKernelValueDynamicNumberTexture {
        getSource() {
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2D ${this.id}`,
            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
          ]);
        }
      }
  
      module.exports = {
        WebGL2KernelValueDynamicNumberTexture
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/dynamic-number-texture":48}],84:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGL2KernelValueSingleArray } = require('../../web-gl2/kernel-value/single-array');
  
      class WebGL2KernelValueDynamicSingleArray extends WebGL2KernelValueSingleArray {
        getSource() {
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2D ${this.id}`,
            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
          ]);
        }
  
        updateValue(value) {
          this.dimensions = utils.getDimensions(value, true);
          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
          this.checkSize(this.textureSize[0], this.textureSize[1]);
          this.uploadValue = new Float32Array(this.uploadArrayLength);
          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
          this.kernel.setUniform2iv(this.sizeId, this.textureSize);
          super.updateValue(value);
        }
      }
  
      module.exports = {
        WebGL2KernelValueDynamicSingleArray
      };
      },{"../../../utils":114,"../../web-gl2/kernel-value/single-array":98}],85:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGL2KernelValueSingleArray1DI } = require('../../web-gl2/kernel-value/single-array1d-i');
  
      class WebGL2KernelValueDynamicSingleArray1DI extends WebGL2KernelValueSingleArray1DI {
        getSource() {
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2D ${this.id}`,
            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
          ]);
        }
  
        updateValue(value) {
          this.setShape(value);
          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
          this.kernel.setUniform2iv(this.sizeId, this.textureSize);
          super.updateValue(value);
        }
      }
  
      module.exports = {
        WebGL2KernelValueDynamicSingleArray1DI
      };
      },{"../../../utils":114,"../../web-gl2/kernel-value/single-array1d-i":99}],86:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGL2KernelValueSingleArray2DI } = require('../../web-gl2/kernel-value/single-array2d-i');
  
      class WebGL2KernelValueDynamicSingleArray2DI extends WebGL2KernelValueSingleArray2DI {
        getSource() {
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2D ${this.id}`,
            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
          ]);
        }
  
        updateValue(value) {
          this.setShape(value);
          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
          this.kernel.setUniform2iv(this.sizeId, this.textureSize);
          super.updateValue(value);
        }
      }
  
      module.exports = {
        WebGL2KernelValueDynamicSingleArray2DI
      };
      },{"../../../utils":114,"../../web-gl2/kernel-value/single-array2d-i":100}],87:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGL2KernelValueSingleArray3DI } = require('../../web-gl2/kernel-value/single-array3d-i');
  
      class WebGL2KernelValueDynamicSingleArray3DI extends WebGL2KernelValueSingleArray3DI {
        getSource() {
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2D ${this.id}`,
            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
          ]);
        }
  
        updateValue(value) {
          this.setShape(value);
          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
          this.kernel.setUniform2iv(this.sizeId, this.textureSize);
          super.updateValue(value);
        }
      }
  
      module.exports = {
        WebGL2KernelValueDynamicSingleArray3DI
      };
      },{"../../../utils":114,"../../web-gl2/kernel-value/single-array3d-i":101}],88:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGL2KernelValueSingleInput } = require('../../web-gl2/kernel-value/single-input');
  
      class WebGL2KernelValueDynamicSingleInput extends WebGL2KernelValueSingleInput {
        getSource() {
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2D ${this.id}`,
            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
          ]);
        }
  
        updateValue(value) {
          let [w, h, d] = value.size;
          this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
          this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
          this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
          this.checkSize(this.textureSize[0], this.textureSize[1]);
          this.uploadValue = new Float32Array(this.uploadArrayLength);
          this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
          this.kernel.setUniform2iv(this.sizeId, this.textureSize);
          super.updateValue(value);
        }
      }
  
      module.exports = {
        WebGL2KernelValueDynamicSingleInput
      };
      },{"../../../utils":114,"../../web-gl2/kernel-value/single-input":102}],89:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueDynamicUnsignedArray } = require('../../web-gl/kernel-value/dynamic-unsigned-array');
  
      class WebGL2KernelValueDynamicUnsignedArray extends WebGLKernelValueDynamicUnsignedArray {
        getSource() {
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2D ${this.id}`,
            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
          ]);
        }
      }
  
      module.exports = {
        WebGL2KernelValueDynamicUnsignedArray
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-array":54}],90:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueDynamicUnsignedInput } = require('../../web-gl/kernel-value/dynamic-unsigned-input');
  
      class WebGL2KernelValueDynamicUnsignedInput extends WebGLKernelValueDynamicUnsignedInput {
        getSource() {
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2D ${this.id}`,
            `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
            `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
          ]);
        }
      }
  
      module.exports = {
        WebGL2KernelValueDynamicUnsignedInput
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-input":55}],91:[function(require,module,exports){
      require('../../../utils');
      const { WebGLKernelValueFloat } = require('../../web-gl/kernel-value/float');
  
      class WebGL2KernelValueFloat extends WebGLKernelValueFloat {}
  
      module.exports = {
        WebGL2KernelValueFloat
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/float":56}],92:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelArray } = require('../../web-gl/kernel-value/array');
  
      class WebGL2KernelValueHTMLImageArray extends WebGLKernelArray {
        constructor(value, settings) {
          super(value, settings);
          this.checkSize(value[0].width, value[0].height);
          this.dimensions = [value[0].width, value[0].height, value.length];
          this.textureSize = [value[0].width, value[0].height];
        }
        defineTexture() {
          const { context: gl } = this;
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);
          gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        }
  
        getStringValueHandler() {
          return `const uploadValue_${this.name} = ${this.varName};\n`;
        }
        getSource() {
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2DArray ${this.id}`,
            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
          ]);
        }
  
        updateValue(images) {
          const { context: gl } = this;
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.texImage3D(
            gl.TEXTURE_2D_ARRAY,
            0,
            gl.RGBA,
            images[0].width,
            images[0].height,
            images.length,
            0,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            null
          );
          for (let i = 0; i < images.length; i++) {
            const xOffset = 0;
            const yOffset = 0;
            const imageDepth = 1;
            gl.texSubImage3D(
              gl.TEXTURE_2D_ARRAY,
              0,
              xOffset,
              yOffset,
              i,
              images[i].width,
              images[i].height,
              imageDepth,
              gl.RGBA,
              gl.UNSIGNED_BYTE,
              this.uploadValue = images[i]
            );
          }
          this.kernel.setUniform1i(this.id, this.index);
        }
      }
  
      module.exports = {
        WebGL2KernelValueHTMLImageArray
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/array":40}],93:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueHTMLImage } = require('../../web-gl/kernel-value/html-image');
  
      class WebGL2KernelValueHTMLImage extends WebGLKernelValueHTMLImage {
        getSource() {
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2D ${this.id}`,
            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
          ]);
        }
      }
  
      module.exports = {
        WebGL2KernelValueHTMLImage
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/html-image":57}],94:[function(require,module,exports){
      require('../../../utils');
      const { WebGL2KernelValueHTMLImage } = require('./html-image');
  
      class WebGL2KernelValueHTMLVideo extends WebGL2KernelValueHTMLImage {}
  
      module.exports = {
        WebGL2KernelValueHTMLVideo
      };
      },{"../../../utils":114,"./html-image":93}],95:[function(require,module,exports){
      const { WebGLKernelValueInteger } = require('../../web-gl/kernel-value/integer');
  
      class WebGL2KernelValueInteger extends WebGLKernelValueInteger {
        getSource(value) {
          const variablePrecision = this.getVariablePrecisionString();
          if (this.origin === 'constants') {
            return `const ${ variablePrecision } int ${this.id} = ${ parseInt(value) };\n`;
          }
          return `uniform ${ variablePrecision } int ${this.id};\n`;
        }
  
        updateValue(value) {
          if (this.origin === 'constants') return;
          this.kernel.setUniform1i(this.id, this.uploadValue = value);
        }
      }
  
      module.exports = {
        WebGL2KernelValueInteger
      };
      },{"../../web-gl/kernel-value/integer":60}],96:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/memory-optimized-number-texture');
  
      class WebGL2KernelValueMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {
        getSource() {
          const { id, sizeId, textureSize, dimensionsId, dimensions } = this;
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform sampler2D ${id}`,
            `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,
            `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,
          ]);
        }
      }
  
      module.exports = {
        WebGL2KernelValueMemoryOptimizedNumberTexture
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/memory-optimized-number-texture":61}],97:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueNumberTexture } = require('../../web-gl/kernel-value/number-texture');
  
      class WebGL2KernelValueNumberTexture extends WebGLKernelValueNumberTexture {
        getSource() {
          const { id, sizeId, textureSize, dimensionsId, dimensions } = this;
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2D ${id}`,
            `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,
            `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,
          ]);
        }
      }
  
      module.exports = {
        WebGL2KernelValueNumberTexture
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/number-texture":62}],98:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueSingleArray } = require('../../web-gl/kernel-value/single-array');
  
      class WebGL2KernelValueSingleArray extends WebGLKernelValueSingleArray {
        getSource() {
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2D ${this.id}`,
            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
          ]);
        }
  
        updateValue(value) {
          if (value.constructor !== this.initialValueConstructor) {
            this.onUpdateValueMismatch(value.constructor);
            return;
          }
          const { context: gl } = this;
          utils.flattenTo(value, this.uploadValue);
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
          this.kernel.setUniform1i(this.id, this.index);
        }
      }
  
      module.exports = {
        WebGL2KernelValueSingleArray
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/single-array":63}],99:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueSingleArray1DI } = require('../../web-gl/kernel-value/single-array1d-i');
  
      class WebGL2KernelValueSingleArray1DI extends WebGLKernelValueSingleArray1DI {
        updateValue(value) {
          if (value.constructor !== this.initialValueConstructor) {
            this.onUpdateValueMismatch(value.constructor);
            return;
          }
          const { context: gl } = this;
          utils.flattenTo(value, this.uploadValue);
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
          this.kernel.setUniform1i(this.id, this.index);
        }
      }
  
      module.exports = {
        WebGL2KernelValueSingleArray1DI
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/single-array1d-i":64}],100:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueSingleArray2DI } = require('../../web-gl/kernel-value/single-array2d-i');
  
      class WebGL2KernelValueSingleArray2DI extends WebGLKernelValueSingleArray2DI {
        updateValue(value) {
          if (value.constructor !== this.initialValueConstructor) {
            this.onUpdateValueMismatch(value.constructor);
            return;
          }
          const { context: gl } = this;
          utils.flattenTo(value, this.uploadValue);
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
          this.kernel.setUniform1i(this.id, this.index);
        }
      }
  
      module.exports = {
        WebGL2KernelValueSingleArray2DI
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/single-array2d-i":65}],101:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueSingleArray3DI } = require('../../web-gl/kernel-value/single-array3d-i');
  
      class WebGL2KernelValueSingleArray3DI extends WebGLKernelValueSingleArray3DI {
        updateValue(value) {
          if (value.constructor !== this.initialValueConstructor) {
            this.onUpdateValueMismatch(value.constructor);
            return;
          }
          const { context: gl } = this;
          utils.flattenTo(value, this.uploadValue);
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
          this.kernel.setUniform1i(this.id, this.index);
        }
      }
  
      module.exports = {
        WebGL2KernelValueSingleArray3DI
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/single-array3d-i":66}],102:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueSingleInput } = require('../../web-gl/kernel-value/single-input');
  
      class WebGL2KernelValueSingleInput extends WebGLKernelValueSingleInput {
        getSource() {
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2D ${this.id}`,
            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
          ]);
        }
  
        updateValue(input) {
          const { context: gl } = this;
          utils.flattenTo(input.value, this.uploadValue);
          gl.activeTexture(this.contextHandle);
          gl.bindTexture(gl.TEXTURE_2D, this.texture);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
          this.kernel.setUniform1i(this.id, this.index);
        }
      }
  
      module.exports = {
        WebGL2KernelValueSingleInput
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/single-input":67}],103:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueUnsignedArray } = require('../../web-gl/kernel-value/unsigned-array');
  
      class WebGL2KernelValueUnsignedArray extends WebGLKernelValueUnsignedArray {
        getSource() {
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2D ${this.id}`,
            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
          ]);
        }
      }
  
      module.exports = {
        WebGL2KernelValueUnsignedArray
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/unsigned-array":68}],104:[function(require,module,exports){
      const { utils } = require('../../../utils');
      const { WebGLKernelValueUnsignedInput } = require('../../web-gl/kernel-value/unsigned-input');
  
      class WebGL2KernelValueUnsignedInput extends WebGLKernelValueUnsignedInput {
        getSource() {
          const variablePrecision = this.getVariablePrecisionString();
          return utils.linesToString([
            `uniform ${ variablePrecision } sampler2D ${this.id}`,
            `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
            `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
          ]);
        }
      }
  
      module.exports = {
        WebGL2KernelValueUnsignedInput
      };
      },{"../../../utils":114,"../../web-gl/kernel-value/unsigned-input":69}],105:[function(require,module,exports){
      const { WebGLKernel } = require('../web-gl/kernel');
      const { WebGL2FunctionNode } = require('./function-node');
      const { FunctionBuilder } = require('../function-builder');
      const { utils } = require('../../utils');
      const { fragmentShader } = require('./fragment-shader');
      const { vertexShader } = require('./vertex-shader');
      const { lookupKernelValueType } = require('./kernel-value-maps');
  
      let isSupported = null;
      let testCanvas = null;
      let testContext = null;
  
      let features = null;
  
      class WebGL2Kernel extends WebGLKernel {
        static get isSupported() {
          if (isSupported !== null) {
            return isSupported;
          }
          this.setupFeatureChecks();
          isSupported = this.isContextMatch(testContext);
          return isSupported;
        }
  
        static setupFeatureChecks() {
          if (typeof document !== 'undefined') {
            testCanvas = document.createElement('canvas');
          } else if (typeof OffscreenCanvas !== 'undefined') {
            testCanvas = new OffscreenCanvas(0, 0);
          }
          if (!testCanvas) return;
          testContext = testCanvas.getContext('webgl2');
          if (!testContext || !testContext.getExtension) return;
          ({
            EXT_color_buffer_float: testContext.getExtension('EXT_color_buffer_float'),
            OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
          });
          features = this.getFeatures();
        }
  
        static isContextMatch(context) {
          if (typeof WebGL2RenderingContext !== 'undefined') {
            return context instanceof WebGL2RenderingContext;
          }
          return false;
        }
  
        static getFeatures() {
          const gl = this.testContext;
          return Object.freeze({
            isFloatRead: this.getIsFloatRead(),
            isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
            isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
            kernelMap: true,
            isTextureFloat: true,
            isDrawBuffers: true,
            channelCount: this.getChannelCount(),
            maxTextureSize: this.getMaxTextureSize(),
            lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),
            lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),
            mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),
            mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),
            highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),
            highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),
          });
        }
  
        static getIsTextureFloat() {
          return true;
        }
  
        static getChannelCount() {
          return testContext.getParameter(testContext.MAX_DRAW_BUFFERS);
        }
  
        static getMaxTextureSize() {
          return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
        }
  
        static lookupKernelValueType(type, dynamic, precision, value) {
          return lookupKernelValueType(type, dynamic, precision, value);
        }
  
        static get testCanvas() {
          return testCanvas;
        }
  
        static get testContext() {
          return testContext;
        }
  
        static get features() {
          return features;
        }
  
        static get fragmentShader() {
          return fragmentShader;
        }
        static get vertexShader() {
          return vertexShader;
        }
  
        initContext() {
          const settings = {
            alpha: false,
            depth: false,
            antialias: false
          };
          return this.canvas.getContext('webgl2', settings);
        }
  
        initExtensions() {
          this.extensions = {
            EXT_color_buffer_float: this.context.getExtension('EXT_color_buffer_float'),
            OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
          };
        }
  
        validateSettings(args) {
          if (!this.validate) {
            this.texSize = utils.getKernelTextureSize({
              optimizeFloatMemory: this.optimizeFloatMemory,
              precision: this.precision,
            }, this.output);
            return;
          }
  
          const { features } = this.constructor;
          if (this.precision === 'single' && !features.isFloatRead) {
            throw new Error('Float texture outputs are not supported');
          } else if (!this.graphical && this.precision === null) {
            this.precision = features.isFloatRead ? 'single' : 'unsigned';
          }
  
          if (this.fixIntegerDivisionAccuracy === null) {
            this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
          } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
            this.fixIntegerDivisionAccuracy = false;
          }
  
          this.checkOutput();
  
          if (!this.output || this.output.length === 0) {
            if (args.length !== 1) {
              throw new Error('Auto output only supported for kernels with only one input');
            }
  
            const argType = utils.getVariableType(args[0], this.strictIntegers);
            switch (argType) {
              case 'Array':
                this.output = utils.getDimensions(argType);
                break;
              case 'NumberTexture':
              case 'MemoryOptimizedNumberTexture':
              case 'ArrayTexture(1)':
              case 'ArrayTexture(2)':
              case 'ArrayTexture(3)':
              case 'ArrayTexture(4)':
                this.output = args[0].output;
                break;
              default:
                throw new Error('Auto output not supported for input type: ' + argType);
            }
          }
  
          if (this.graphical) {
            if (this.output.length !== 2) {
              throw new Error('Output must have 2 dimensions on graphical mode');
            }
  
            if (this.precision === 'single') {
              console.warn('Cannot use graphical mode and single precision at the same time');
              this.precision = 'unsigned';
            }
  
            this.texSize = utils.clone(this.output);
            return;
          } else if (!this.graphical && this.precision === null && features.isTextureFloat) {
            this.precision = 'single';
          }
  
          this.texSize = utils.getKernelTextureSize({
            optimizeFloatMemory: this.optimizeFloatMemory,
            precision: this.precision,
          }, this.output);
  
          this.checkTextureSize();
        }
  
        translateSource() {
          const functionBuilder = FunctionBuilder.fromKernel(this, WebGL2FunctionNode, {
            fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
          });
          this.translatedSource = functionBuilder.getPrototypeString('kernel');
          this.setupReturnTypes(functionBuilder);
        }
  
        drawBuffers() {
          this.context.drawBuffers(this.drawBuffersMap);
        }
  
        getTextureFormat() {
          const { context: gl } = this;
          switch (this.getInternalFormat()) {
            case gl.R32F:
              return gl.RED;
            case gl.RG32F:
              return gl.RG;
            case gl.RGBA32F:
              return gl.RGBA;
            case gl.RGBA:
              return gl.RGBA;
            default:
              throw new Error('Unknown internal format');
          }
        }
        getInternalFormat() {
          const { context: gl } = this;
  
          if (this.precision === 'single') {
            if (this.pipeline) {
              switch (this.returnType) {
                case 'Number':
                case 'Float':
                case 'Integer':
                  if (this.optimizeFloatMemory) {
                    return gl.RGBA32F;
                  } else {
                    return gl.R32F;
                  }
                  case 'Array(2)':
                    return gl.RG32F;
                  case 'Array(3)': 
                  case 'Array(4)':
                    return gl.RGBA32F;
                  default:
                    throw new Error('Unhandled return type');
              }
            }
            return gl.RGBA32F;
          }
          return gl.RGBA;
        }
  
        _setupOutputTexture() {
          const gl = this.context;
          if (this.texture) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
            return;
          }
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
          const texture = gl.createTexture();
          const texSize = this.texSize;
          gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          const format = this.getInternalFormat();
          if (this.precision === 'single') {
            gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);
          } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);
          }
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
          this.texture = new this.TextureConstructor({
            texture,
            size: texSize,
            dimensions: this.threadDim,
            output: this.output,
            context: this.context,
            internalFormat: this.getInternalFormat(),
            textureFormat: this.getTextureFormat(),
            kernel: this,
          });
        }
  
        _setupSubOutputTextures() {
          const gl = this.context;
          if (this.mappedTextures) {
            for (let i = 0; i < this.subKernels.length; i++) {
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);
            }
            return;
          }
          const texSize = this.texSize;
          this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
          this.mappedTextures = [];
          for (let i = 0; i < this.subKernels.length; i++) {
            const texture = this.createTexture();
            this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
            gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            const format = this.getInternalFormat();
            if (this.precision === 'single') {
              gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);
            } else {
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            }
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);
  
            this.mappedTextures.push(new this.TextureConstructor({
              texture,
              size: texSize,
              dimensions: this.threadDim,
              output: this.output,
              context: this.context,
              internalFormat: this.getInternalFormat(),
              textureFormat: this.getTextureFormat(),
              kernel: this,
            }));
          }
        }
  
        _getHeaderString() {
          return '';
        }
  
        _getTextureCoordinate() {
          const subKernels = this.subKernels;
          const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);
          if (subKernels === null || subKernels.length < 1) {
            return `in ${ variablePrecision } vec2 vTexCoord;\n`;
          } else {
            return `out ${ variablePrecision } vec2 vTexCoord;\n`;
          }
        }
  
        _getMainArgumentsString(args) {
          const result = [];
          const argumentNames = this.argumentNames;
          for (let i = 0; i < argumentNames.length; i++) {
            result.push(this.kernelArguments[i].getSource(args[i]));
          }
          return result.join('');
        }
  
        getKernelString() {
          const result = [this.getKernelResultDeclaration()];
          const subKernels = this.subKernels;
          if (subKernels !== null) {
            result.push(
              'layout(location = 0) out vec4 data0'
            );
            switch (this.returnType) {
              case 'Number':
              case 'Float':
              case 'Integer':
                for (let i = 0; i < subKernels.length; i++) {
                  const subKernel = subKernels[i];
                  result.push(
                    subKernel.returnType === 'Integer' ?
                    `int subKernelResult_${ subKernel.name } = 0` :
                    `float subKernelResult_${ subKernel.name } = 0.0`,
                    `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
                  );
                }
                break;
              case 'Array(2)':
                for (let i = 0; i < subKernels.length; i++) {
                  result.push(
                    `vec2 subKernelResult_${ subKernels[i].name }`,
                    `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
                  );
                }
                break;
              case 'Array(3)':
                for (let i = 0; i < subKernels.length; i++) {
                  result.push(
                    `vec3 subKernelResult_${ subKernels[i].name }`,
                    `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
                  );
                }
                break;
              case 'Array(4)':
                for (let i = 0; i < subKernels.length; i++) {
                  result.push(
                    `vec4 subKernelResult_${ subKernels[i].name }`,
                    `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
                  );
                }
                break;
            }
          } else {
            result.push(
              'out vec4 data0'
            );
          }
  
          return utils.linesToString(result) + this.translatedSource;
        }
  
        getMainResultGraphical() {
          return utils.linesToString([
            '  threadId = indexTo3D(index, uOutputDim)',
            '  kernel()',
            '  data0 = actualColor',
          ]);
        }
  
        getMainResultPackedPixels() {
          switch (this.returnType) {
            case 'LiteralInteger':
            case 'Number':
            case 'Integer':
            case 'Float':
              return this.getMainResultKernelPackedPixels() +
                this.getMainResultSubKernelPackedPixels();
            default:
              throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
          }
        }
  
        getMainResultKernelPackedPixels() {
          return utils.linesToString([
            '  threadId = indexTo3D(index, uOutputDim)',
            '  kernel()',
            `  data0 = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`
          ]);
        }
  
        getMainResultSubKernelPackedPixels() {
          const result = [];
          if (!this.subKernels) return '';
          for (let i = 0; i < this.subKernels.length; i++) {
            const subKernel = this.subKernels[i];
            if (subKernel.returnType === 'Integer') {
              result.push(
                `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`
              );
            } else {
              result.push(
                `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`
              );
            }
          }
          return utils.linesToString(result);
        }
  
        getMainResultKernelMemoryOptimizedFloats(result, channel) {
          result.push(
            '  threadId = indexTo3D(index, uOutputDim)',
            '  kernel()',
            `  data0.${channel} = kernelResult`
          );
        }
  
        getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
          if (!this.subKernels) return result;
          for (let i = 0; i < this.subKernels.length; i++) {
            const subKernel = this.subKernels[i];
            if (subKernel.returnType === 'Integer') {
              result.push(
                `  data${i + 1}.${channel} = float(subKernelResult_${subKernel.name})`
              );
            } else {
              result.push(
                `  data${i + 1}.${channel} = subKernelResult_${subKernel.name}`
              );
            }
          }
        }
  
        getMainResultKernelNumberTexture() {
          return [
            '  threadId = indexTo3D(index, uOutputDim)',
            '  kernel()',
            '  data0[0] = kernelResult',
          ];
        }
  
        getMainResultSubKernelNumberTexture() {
          const result = [];
          if (!this.subKernels) return result;
          for (let i = 0; i < this.subKernels.length; ++i) {
            const subKernel = this.subKernels[i];
            if (subKernel.returnType === 'Integer') {
              result.push(
                `  data${i + 1}[0] = float(subKernelResult_${subKernel.name})`
              );
            } else {
              result.push(
                `  data${i + 1}[0] = subKernelResult_${subKernel.name}`
              );
            }
          }
          return result;
        }
  
        getMainResultKernelArray2Texture() {
          return [
            '  threadId = indexTo3D(index, uOutputDim)',
            '  kernel()',
            '  data0[0] = kernelResult[0]',
            '  data0[1] = kernelResult[1]',
          ];
        }
  
        getMainResultSubKernelArray2Texture() {
          const result = [];
          if (!this.subKernels) return result;
          for (let i = 0; i < this.subKernels.length; ++i) {
            const subKernel = this.subKernels[i];
            result.push(
              `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,
              `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`
            );
          }
          return result;
        }
  
        getMainResultKernelArray3Texture() {
          return [
            '  threadId = indexTo3D(index, uOutputDim)',
            '  kernel()',
            '  data0[0] = kernelResult[0]',
            '  data0[1] = kernelResult[1]',
            '  data0[2] = kernelResult[2]',
          ];
        }
  
        getMainResultSubKernelArray3Texture() {
          const result = [];
          if (!this.subKernels) return result;
          for (let i = 0; i < this.subKernels.length; ++i) {
            const subKernel = this.subKernels[i];
            result.push(
              `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,
              `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`,
              `  data${i + 1}[2] = subKernelResult_${subKernel.name}[2]`
            );
          }
          return result;
        }
  
        getMainResultKernelArray4Texture() {
          return [
            '  threadId = indexTo3D(index, uOutputDim)',
            '  kernel()',
            '  data0 = kernelResult',
          ];
        }
  
        getMainResultSubKernelArray4Texture() {
          const result = [];
          if (!this.subKernels) return result;
          for (let i = 0; i < this.subKernels.length; ++i) {
            result.push(
              `  data${i + 1} = subKernelResult_${this.subKernels[i].name}`
            );
          }
          return result;
        }
  
        destroyExtensions() {
          this.extensions.EXT_color_buffer_float = null;
          this.extensions.OES_texture_float_linear = null;
        }
  
        toJSON() {
          const json = super.toJSON();
          json.functionNodes = FunctionBuilder.fromKernel(this, WebGL2FunctionNode).toJSON();
          json.settings.threadDim = this.threadDim;
          return json;
        }
      }
  
      module.exports = {
        WebGL2Kernel
      };
      },{"../../utils":114,"../function-builder":9,"../web-gl/kernel":70,"./fragment-shader":72,"./function-node":73,"./kernel-value-maps":74,"./vertex-shader":106}],106:[function(require,module,exports){
      const vertexShader = `#version 300 es
  __FLOAT_TACTIC_DECLARATION__;
  __INT_TACTIC_DECLARATION__;
  __SAMPLER_2D_TACTIC_DECLARATION__;
  
  in vec2 aPos;
  in vec2 aTexCoord;
  
  out vec2 vTexCoord;
  uniform vec2 ratio;
  
  void main(void) {
    gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
    vTexCoord = aTexCoord;
  }`;
  
      module.exports = {
        vertexShader
      };
      },{}],107:[function(require,module,exports){
      const lib = require('./index');
      const GPU = lib.GPU;
      for (const p in lib) {
        if (!lib.hasOwnProperty(p)) continue;
        if (p === 'GPU') continue; 
        GPU[p] = lib[p];
      }
  
      if (typeof window !== 'undefined') {
        bindTo(window);
      }
      if (typeof self !== 'undefined') {
        bindTo(self);
      }
  
      function bindTo(target) {
        if (target.GPU) return;
        Object.defineProperty(target, 'GPU', {
          get() {
            return GPU;
          }
        });
      }
  
      module.exports = lib;
      },{"./index":109}],108:[function(require,module,exports){
      const { gpuMock } = require('gpu-mock.js');
      const { utils } = require('./utils');
      require('./backend/kernel');
      const { CPUKernel } = require('./backend/cpu/kernel');
      const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');
      const { WebGL2Kernel } = require('./backend/web-gl2/kernel');
      const { WebGLKernel } = require('./backend/web-gl/kernel');
      const { kernelRunShortcut } = require('./kernel-run-shortcut');
  
  
      const kernelOrder = [HeadlessGLKernel, WebGL2Kernel, WebGLKernel];
  
      const kernelTypes = ['gpu', 'cpu'];
  
      const internalKernels = {
        'headlessgl': HeadlessGLKernel,
        'webgl2': WebGL2Kernel,
        'webgl': WebGLKernel,
      };
  
      let validate = true;
  
      class GPU {
        static disableValidation() {
          validate = false;
        }
  
        static enableValidation() {
          validate = true;
        }
  
        static get isGPUSupported() {
          return kernelOrder.some(Kernel => Kernel.isSupported);
        }
  
        static get isKernelMapSupported() {
          return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.kernelMap);
        }
  
        static get isOffscreenCanvasSupported() {
          return (typeof Worker !== 'undefined' && typeof OffscreenCanvas !== 'undefined') || typeof importScripts !== 'undefined';
        }
  
        static get isWebGLSupported() {
          return WebGLKernel.isSupported;
        }
  
        static get isWebGL2Supported() {
          return WebGL2Kernel.isSupported;
        }
  
        static get isHeadlessGLSupported() {
          return HeadlessGLKernel.isSupported;
        }
  
        static get isCanvasSupported() {
          return typeof HTMLCanvasElement !== 'undefined';
        }
  
        static get isGPUHTMLImageArraySupported() {
          return WebGL2Kernel.isSupported;
        }
  
        static get isSinglePrecisionSupported() {
          return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.isFloatRead && Kernel.features.isTextureFloat);
        }
  
        constructor(settings) {
          settings = settings || {};
          this.canvas = settings.canvas || null;
          this.context = settings.context || null;
          this.mode = settings.mode;
          this.Kernel = null;
          this.kernels = [];
          this.functions = [];
          this.nativeFunctions = [];
          this.injectedNative = null;
          if (this.mode === 'dev') return;
          this.chooseKernel();
          if (settings.functions) {
            for (let i = 0; i < settings.functions.length; i++) {
              this.addFunction(settings.functions[i]);
            }
          }
  
          if (settings.nativeFunctions) {
            for (const p in settings.nativeFunctions) {
              if (!settings.nativeFunctions.hasOwnProperty(p)) continue;
              const s = settings.nativeFunctions[p];
              const { name, source } = s;
              this.addNativeFunction(name, source, s);
            }
          }
        }
  
        chooseKernel() {
          if (this.Kernel) return;
  
          let Kernel = null;
  
          if (this.context) {
            for (let i = 0; i < kernelOrder.length; i++) {
              const ExternalKernel = kernelOrder[i];
              if (ExternalKernel.isContextMatch(this.context)) {
                if (!ExternalKernel.isSupported) {
                  throw new Error(`Kernel type ${ExternalKernel.name} not supported`);
                }
                Kernel = ExternalKernel;
                break;
              }
            }
            if (Kernel === null) {
              throw new Error('unknown Context');
            }
          } else if (this.mode) {
            if (this.mode in internalKernels) {
              if (!validate || internalKernels[this.mode].isSupported) {
                Kernel = internalKernels[this.mode];
              }
            } else if (this.mode === 'gpu') {
              for (let i = 0; i < kernelOrder.length; i++) {
                if (kernelOrder[i].isSupported) {
                  Kernel = kernelOrder[i];
                  break;
                }
              }
            } else if (this.mode === 'cpu') {
              Kernel = CPUKernel;
            }
            if (!Kernel) {
              throw new Error(`A requested mode of "${this.mode}" and is not supported`);
            }
          } else {
            for (let i = 0; i < kernelOrder.length; i++) {
              if (kernelOrder[i].isSupported) {
                Kernel = kernelOrder[i];
                break;
              }
            }
            if (!Kernel) {
              Kernel = CPUKernel;
            }
          }
  
          if (!this.mode) {
            this.mode = Kernel.mode;
          }
          this.Kernel = Kernel;
        }
  
        createKernel(source, settings) {
          if (typeof source === 'undefined') {
            throw new Error('Missing source parameter');
          }
          if (typeof source !== 'object' && !utils.isFunction(source) && typeof source !== 'string') {
            throw new Error('source parameter not a function');
          }
  
          const kernels = this.kernels;
          if (this.mode === 'dev') {
            const devKernel = gpuMock(source, upgradeDeprecatedCreateKernelSettings(settings));
            kernels.push(devKernel);
            return devKernel;
          }
  
          source = typeof source === 'function' ? source.toString() : source;
          const switchableKernels = {};
          const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings) || {};
          if (settings && typeof settings.argumentTypes === 'object') {
            settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);
          }
  
          function onRequestFallback(args) {
            console.warn('Falling back to CPU');
            const fallbackKernel = new CPUKernel(source, {
              argumentTypes: kernelRun.argumentTypes,
              constantTypes: kernelRun.constantTypes,
              graphical: kernelRun.graphical,
              loopMaxIterations: kernelRun.loopMaxIterations,
              constants: kernelRun.constants,
              dynamicOutput: kernelRun.dynamicOutput,
              dynamicArgument: kernelRun.dynamicArguments,
              output: kernelRun.output,
              precision: kernelRun.precision,
              pipeline: kernelRun.pipeline,
              immutable: kernelRun.immutable,
              optimizeFloatMemory: kernelRun.optimizeFloatMemory,
              fixIntegerDivisionAccuracy: kernelRun.fixIntegerDivisionAccuracy,
              functions: kernelRun.functions,
              nativeFunctions: kernelRun.nativeFunctions,
              injectedNative: kernelRun.injectedNative,
              subKernels: kernelRun.subKernels,
              strictIntegers: kernelRun.strictIntegers,
              debug: kernelRun.debug,
            });
            fallbackKernel.build.apply(fallbackKernel, args);
            const result = fallbackKernel.run.apply(fallbackKernel, args);
            kernelRun.replaceKernel(fallbackKernel);
            return result;
          }
  
          function onRequestSwitchKernel(reasons, args, _kernel) {
            if (_kernel.debug) {
              console.warn('Switching kernels');
            }
            let newOutput = null;
            if (_kernel.signature && !switchableKernels[_kernel.signature]) {
              switchableKernels[_kernel.signature] = _kernel;
            }
            if (_kernel.dynamicOutput) {
              for (let i = reasons.length - 1; i >= 0; i--) {
                const reason = reasons[i];
                if (reason.type === 'outputPrecisionMismatch') {
                  newOutput = reason.needed;
                }
              }
            }
  
            const Constructor = _kernel.constructor;
            const argumentTypes = Constructor.getArgumentTypes(_kernel, args);
            const signature = Constructor.getSignature(_kernel, argumentTypes);
            const existingKernel = switchableKernels[signature];
            if (existingKernel) {
              existingKernel.onActivate(_kernel);
              return existingKernel;
            }
  
            const newKernel = switchableKernels[signature] = new Constructor(source, {
              argumentTypes,
              constantTypes: _kernel.constantTypes,
              graphical: _kernel.graphical,
              loopMaxIterations: _kernel.loopMaxIterations,
              constants: _kernel.constants,
              dynamicOutput: _kernel.dynamicOutput,
              dynamicArgument: _kernel.dynamicArguments,
              context: _kernel.context,
              canvas: _kernel.canvas,
              output: newOutput || _kernel.output,
              precision: _kernel.precision,
              pipeline: _kernel.pipeline,
              immutable: _kernel.immutable,
              optimizeFloatMemory: _kernel.optimizeFloatMemory,
              fixIntegerDivisionAccuracy: _kernel.fixIntegerDivisionAccuracy,
              functions: _kernel.functions,
              nativeFunctions: _kernel.nativeFunctions,
              injectedNative: _kernel.injectedNative,
              subKernels: _kernel.subKernels,
              strictIntegers: _kernel.strictIntegers,
              debug: _kernel.debug,
              gpu: _kernel.gpu,
              validate,
              returnType: _kernel.returnType,
              tactic: _kernel.tactic,
              onRequestFallback,
              onRequestSwitchKernel,
              texture: _kernel.texture,
              mappedTextures: _kernel.mappedTextures,
              drawBuffersMap: _kernel.drawBuffersMap,
            });
            newKernel.build.apply(newKernel, args);
            kernelRun.replaceKernel(newKernel);
            kernels.push(newKernel);
            return newKernel;
          }
          const mergedSettings = Object.assign({
            context: this.context,
            canvas: this.canvas,
            functions: this.functions,
            nativeFunctions: this.nativeFunctions,
            injectedNative: this.injectedNative,
            gpu: this,
            validate,
            onRequestFallback,
            onRequestSwitchKernel
          }, settingsCopy);
  
          const kernel = new this.Kernel(source, mergedSettings);
          const kernelRun = kernelRunShortcut(kernel);
  
          if (!this.canvas) {
            this.canvas = kernel.canvas;
          }
  
          if (!this.context) {
            this.context = kernel.context;
          }
  
          kernels.push(kernel);
  
          return kernelRun;
        }
  
        createKernelMap() {
          let fn;
          let settings;
          const argument2Type = typeof arguments[arguments.length - 2];
          if (argument2Type === 'function' || argument2Type === 'string') {
            fn = arguments[arguments.length - 2];
            settings = arguments[arguments.length - 1];
          } else {
            fn = arguments[arguments.length - 1];
          }
  
          if (this.mode !== 'dev') {
            if (!this.Kernel.isSupported || !this.Kernel.features.kernelMap) {
              if (this.mode && kernelTypes.indexOf(this.mode) < 0) {
                throw new Error(`kernelMap not supported on ${this.Kernel.name}`);
              }
            }
          }
  
          const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings);
          if (settings && typeof settings.argumentTypes === 'object') {
            settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);
          }
  
          if (Array.isArray(arguments[0])) {
            settingsCopy.subKernels = [];
            const functions = arguments[0];
            for (let i = 0; i < functions.length; i++) {
              const source = functions[i].toString();
              const name = utils.getFunctionNameFromString(source);
              settingsCopy.subKernels.push({
                name,
                source,
                property: i,
              });
            }
          } else {
            settingsCopy.subKernels = [];
            const functions = arguments[0];
            for (let p in functions) {
              if (!functions.hasOwnProperty(p)) continue;
              const source = functions[p].toString();
              const name = utils.getFunctionNameFromString(source);
              settingsCopy.subKernels.push({
                name: name || p,
                source,
                property: p,
              });
            }
          }
          return this.createKernel(fn, settingsCopy);
        }
  
        combineKernels() {
          const firstKernel = arguments[0];
          const combinedKernel = arguments[arguments.length - 1];
          if (firstKernel.kernel.constructor.mode === 'cpu') return combinedKernel;
          const canvas = arguments[0].canvas;
          const context = arguments[0].context;
          const max = arguments.length - 1;
          for (let i = 0; i < max; i++) {
            arguments[i]
              .setCanvas(canvas)
              .setContext(context)
              .setPipeline(true);
          }
  
          return function() {
            const texture = combinedKernel.apply(this, arguments);
            if (texture.toArray) {
              return texture.toArray();
            }
            return texture;
          };
        }
  
        setFunctions(functions) {
          this.functions = functions;
          return this;
        }
  
        setNativeFunctions(nativeFunctions) {
          this.nativeFunctions = nativeFunctions;
          return this;
        }
  
        addFunction(source, settings) {
          this.functions.push({ source, settings });
          return this;
        }
  
        addNativeFunction(name, source, settings) {
          if (this.kernels.length > 0) {
            throw new Error('Cannot call "addNativeFunction" after "createKernels" has been called.');
          }
          this.nativeFunctions.push(Object.assign({ name, source }, settings));
          return this;
        }
  
        injectNative(source) {
          this.injectedNative = source;
          return this;
        }
  
        destroy() {
          return new Promise((resolve, reject) => {
            if (!this.kernels) {
              resolve();
            }
            setTimeout(() => {
              try {
                for (let i = 0; i < this.kernels.length; i++) {
                  this.kernels[i].destroy(true); 
                }
                let firstKernel = this.kernels[0];
                if (firstKernel) {
                  if (firstKernel.kernel) {
                    firstKernel = firstKernel.kernel;
                  }
                  if (firstKernel.constructor.destroyContext) {
                    firstKernel.constructor.destroyContext(this.context);
                  }
                }
              } catch (e) {
                reject(e);
              }
              resolve();
            }, 0);
          });
        }
      }
  
  
      function upgradeDeprecatedCreateKernelSettings(settings) {
        if (!settings) {
          return {};
        }
        const upgradedSettings = Object.assign({}, settings);
  
        if (settings.hasOwnProperty('floatOutput')) {
          utils.warnDeprecated('setting', 'floatOutput', 'precision');
          upgradedSettings.precision = settings.floatOutput ? 'single' : 'unsigned';
        }
        if (settings.hasOwnProperty('outputToTexture')) {
          utils.warnDeprecated('setting', 'outputToTexture', 'pipeline');
          upgradedSettings.pipeline = Boolean(settings.outputToTexture);
        }
        if (settings.hasOwnProperty('outputImmutable')) {
          utils.warnDeprecated('setting', 'outputImmutable', 'immutable');
          upgradedSettings.immutable = Boolean(settings.outputImmutable);
        }
        if (settings.hasOwnProperty('floatTextures')) {
          utils.warnDeprecated('setting', 'floatTextures', 'optimizeFloatMemory');
          upgradedSettings.optimizeFloatMemory = Boolean(settings.floatTextures);
        }
        return upgradedSettings;
      }
  
      module.exports = {
        GPU,
        kernelOrder,
        kernelTypes
      };
      },{"./backend/cpu/kernel":8,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/kernel":70,"./backend/web-gl2/kernel":105,"./kernel-run-shortcut":111,"./utils":114,"gpu-mock.js":4}],109:[function(require,module,exports){
      const { GPU } = require('./gpu');
      const { alias } = require('./alias');
      const { utils } = require('./utils');
      const { Input, input } = require('./input');
      const { Texture } = require('./texture');
      const { FunctionBuilder } = require('./backend/function-builder');
      const { FunctionNode } = require('./backend/function-node');
      const { CPUFunctionNode } = require('./backend/cpu/function-node');
      const { CPUKernel } = require('./backend/cpu/kernel');
  
      const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');
  
      const { WebGLFunctionNode } = require('./backend/web-gl/function-node');
      const { WebGLKernel } = require('./backend/web-gl/kernel');
      const { kernelValueMaps: webGLKernelValueMaps } = require('./backend/web-gl/kernel-value-maps');
  
      const { WebGL2FunctionNode } = require('./backend/web-gl2/function-node');
      const { WebGL2Kernel } = require('./backend/web-gl2/kernel');
      const { kernelValueMaps: webGL2KernelValueMaps } = require('./backend/web-gl2/kernel-value-maps');
  
      const { GLKernel } = require('./backend/gl/kernel');
  
      const { Kernel } = require('./backend/kernel');
  
      const { FunctionTracer } = require('./backend/function-tracer');
  
      const mathRandom = require('./plugins/math-random-uniformly-distributed');
  
      module.exports = {
        alias,
        CPUFunctionNode,
        CPUKernel,
        GPU,
        FunctionBuilder,
        FunctionNode,
        HeadlessGLKernel,
        Input,
        input,
        Texture,
        utils,
  
        WebGL2FunctionNode,
        WebGL2Kernel,
        webGL2KernelValueMaps,
  
        WebGLFunctionNode,
        WebGLKernel,
        webGLKernelValueMaps,
  
        GLKernel,
        Kernel,
        FunctionTracer,
  
        plugins: {
          mathRandom
        }
      };
      },{"./alias":5,"./backend/cpu/function-node":6,"./backend/cpu/kernel":8,"./backend/function-builder":9,"./backend/function-node":10,"./backend/function-tracer":11,"./backend/gl/kernel":13,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/function-node":38,"./backend/web-gl/kernel":70,"./backend/web-gl/kernel-value-maps":39,"./backend/web-gl2/function-node":73,"./backend/web-gl2/kernel":105,"./backend/web-gl2/kernel-value-maps":74,"./gpu":108,"./input":110,"./plugins/math-random-uniformly-distributed":112,"./texture":113,"./utils":114}],110:[function(require,module,exports){
      class Input {
        constructor(value, size) {
          this.value = value;
          if (Array.isArray(size)) {
            this.size = size;
          } else {
            this.size = new Int32Array(3);
            if (size.z) {
              this.size = new Int32Array([size.x, size.y, size.z]);
            } else if (size.y) {
              this.size = new Int32Array([size.x, size.y]);
            } else {
              this.size = new Int32Array([size.x]);
            }
          }
  
          const [w, h, d] = this.size;
          if (d) {
            if (this.value.length !== (w * h * d)) {
              throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} * ${d} = ${(h * w * d)}`);
            }
          } else if (h) {
            if (this.value.length !== (w * h)) {
              throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} = ${(h * w)}`);
            }
          } else {
            if (this.value.length !== w) {
              throw new Error(`Input size ${this.value.length} does not match ${w}`);
            }
          }
  
        }
  
        toArray() {
          const { utils } = require('./utils');
          const [w, h, d] = this.size;
          if (d) {
            return utils.erectMemoryOptimized3DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h, d);
          } else if (h) {
            return utils.erectMemoryOptimized2DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h);
          } else {
            return this.value;
          }
        }
      }
  
      function input(value, size) {
        return new Input(value, size);
      }
  
      module.exports = {
        Input,
        input
      };
      },{"./utils":114}],111:[function(require,module,exports){
      const { utils } = require('./utils');
  
      function kernelRunShortcut(kernel) {
        let run = function() {
          kernel.build.apply(kernel, arguments);
          run = function() {
            let result = kernel.run.apply(kernel, arguments);
            if (kernel.switchingKernels) {
              const reasons = kernel.resetSwitchingKernels();
              const newKernel = kernel.onRequestSwitchKernel(reasons, arguments, kernel);
              shortcut.kernel = kernel = newKernel;
              result = newKernel.run.apply(newKernel, arguments);
            }
            if (kernel.renderKernels) {
              return kernel.renderKernels();
            } else if (kernel.renderOutput) {
              return kernel.renderOutput();
            } else {
              return result;
            }
          };
          return run.apply(kernel, arguments);
        };
        const shortcut = function() {
          return run.apply(kernel, arguments);
        };
        shortcut.exec = function() {
          return new Promise((accept, reject) => {
            try {
              accept(run.apply(this, arguments));
            } catch (e) {
              reject(e);
            }
          });
        };
        shortcut.replaceKernel = function(replacementKernel) {
          kernel = replacementKernel;
          bindKernelToShortcut(kernel, shortcut);
        };
  
        bindKernelToShortcut(kernel, shortcut);
        return shortcut;
      }
  
      function bindKernelToShortcut(kernel, shortcut) {
        if (shortcut.kernel) {
          shortcut.kernel = kernel;
          return;
        }
        const properties = utils.allPropertiesOf(kernel);
        for (let i = 0; i < properties.length; i++) {
          const property = properties[i];
          if (property[0] === '_' && property[1] === '_') continue;
          if (typeof kernel[property] === 'function') {
            if (property.substring(0, 3) === 'add' || property.substring(0, 3) === 'set') {
              shortcut[property] = function() {
                shortcut.kernel[property].apply(shortcut.kernel, arguments);
                return shortcut;
              };
            } else {
              shortcut[property] = function() {
                return shortcut.kernel[property].apply(shortcut.kernel, arguments);
              };
            }
          } else {
            shortcut.__defineGetter__(property, () => shortcut.kernel[property]);
            shortcut.__defineSetter__(property, (value) => {
              shortcut.kernel[property] = value;
            });
          }
        }
        shortcut.kernel = kernel;
      }
      module.exports = {
        kernelRunShortcut
      };
      },{"./utils":114}],112:[function(require,module,exports){
      const source = `// https://www.shadertoy.com/view/4t2SDh
  //note: uniformly distributed, normalized rand, [0,1]
  highp float randomSeedShift = 1.0;
  highp float slide = 1.0;
  uniform highp float randomSeed1;
  uniform highp float randomSeed2;
  
  highp float nrand(highp vec2 n) {
    highp float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);
    randomSeedShift = result;
    if (randomSeedShift > 0.5) {
      slide += 0.00009; 
    } else {
      slide += 0.0009;
    }
    return result;
  }`;
  
      const name = 'math-random-uniformly-distributed';
  
      const functionMatch = `Math.random()`;
  
      const functionReplace = `nrand(vTexCoord)`;
  
      const functionReturnType = 'Number';
      const onBeforeRun = (kernel) => {
        kernel.setUniform1f('randomSeed1', Math.random());
        kernel.setUniform1f('randomSeed2', Math.random());
      };
  
      const plugin = {
        name,
        onBeforeRun,
        functionMatch,
        functionReplace,
        functionReturnType,
        source
      };
  
      module.exports = plugin;
      },{}],113:[function(require,module,exports){
      class Texture {
        constructor(settings) {
          const {
            texture,
            size,
            dimensions,
            output,
            context,
            type = 'NumberTexture',
            kernel,
            internalFormat,
            textureFormat
          } = settings;
          if (!output) throw new Error('settings property "output" required.');
          if (!context) throw new Error('settings property "context" required.');
          if (!texture) throw new Error('settings property "texture" required.');
          if (!kernel) throw new Error('settings property "kernel" required.');
          this.texture = texture;
          if (texture._refs) {
            texture._refs++;
          } else {
            texture._refs = 1;
          }
          this.size = size;
          this.dimensions = dimensions;
          this.output = output;
          this.context = context;
          this.kernel = kernel;
          this.type = type;
          this._deleted = false;
          this.internalFormat = internalFormat;
          this.textureFormat = textureFormat;
        }
  
        toArray() {
          throw new Error(`Not implemented on ${this.constructor.name}`);
        }
  
        clone() {
          throw new Error(`Not implemented on ${this.constructor.name}`);
        }
  
        delete() {
          throw new Error(`Not implemented on ${this.constructor.name}`);
        }
  
        clear() {
          throw new Error(`Not implemented on ${this.constructor.name}`);
        }
      }
  
      module.exports = {
        Texture
      };
      },{}],114:[function(require,module,exports){
      const acorn = require('acorn');
      const { Input } = require('./input');
      const { Texture } = require('./texture');
  
      const FUNCTION_NAME = /function ([^(]*)/;
      const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
      const ARGUMENT_NAMES = /([^\s,]+)/g;
  
      const utils = {
        systemEndianness() {
          return _systemEndianness;
        },
        getSystemEndianness() {
          const b = new ArrayBuffer(4);
          const a = new Uint32Array(b);
          const c = new Uint8Array(b);
          a[0] = 0xdeadbeef;
          if (c[0] === 0xef) return 'LE';
          if (c[0] === 0xde) return 'BE';
          throw new Error('unknown endianness');
        },
  
        isFunction(funcObj) {
          return typeof(funcObj) === 'function';
        },
  
        isFunctionString(fn) {
          if (typeof fn === 'string') {
            return (fn
              .slice(0, 'function'.length)
              .toLowerCase() === 'function');
          }
          return false;
        },
  
        getFunctionNameFromString(funcStr) {
          const result = FUNCTION_NAME.exec(funcStr);
          if (!result || result.length === 0) return null;
          return result[1].trim();
        },
  
        getFunctionBodyFromString(funcStr) {
          return funcStr.substring(funcStr.indexOf('{') + 1, funcStr.lastIndexOf('}'));
        },
  
        getArgumentNamesFromString(fn) {
          const fnStr = fn.replace(STRIP_COMMENTS, '');
          let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
          if (result === null) {
            result = [];
          }
          return result;
        },
  
        clone(obj) {
          if (obj === null || typeof obj !== 'object' || obj.hasOwnProperty('isActiveClone')) return obj;
  
          const temp = obj.constructor(); 
  
          for (let key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              obj.isActiveClone = null;
              temp[key] = utils.clone(obj[key]);
              delete obj.isActiveClone;
            }
          }
  
          return temp;
        },
  
        isArray(array) {
          return !isNaN(array.length);
        },
  
        getVariableType(value, strictIntegers) {
          if (utils.isArray(value)) {
            if (value.length > 0 && value[0].nodeName === 'IMG') {
              return 'HTMLImageArray';
            }
            return 'Array';
          }
  
          switch (value.constructor) {
            case Boolean:
              return 'Boolean';
            case Number:
              if (strictIntegers && Number.isInteger(value)) {
                return 'Integer';
              }
              return 'Float';
            case Texture:
              return value.type;
            case Input:
              return 'Input';
          }
          if ('nodeName' in value) {
            switch (value.nodeName) {
              case 'IMG':
                return 'HTMLImage';
              case 'CANVAS':
                return 'HTMLImage';
              case 'VIDEO':
                return 'HTMLVideo';
            }
          } else if (value.hasOwnProperty('type')) {
            return value.type;
          } else if (typeof OffscreenCanvas !== 'undefined' && value instanceof OffscreenCanvas) {
            return 'OffscreenCanvas';
          } else if (typeof ImageBitmap !== 'undefined' && value instanceof ImageBitmap) {
            return 'ImageBitmap';
          } else if (typeof ImageData !== 'undefined' && value instanceof ImageData) {
            return 'ImageData';
          }
          return 'Unknown';
        },
  
        getKernelTextureSize(settings, dimensions) {
          let [w, h, d] = dimensions;
          let texelCount = (w || 1) * (h || 1) * (d || 1);
  
          if (settings.optimizeFloatMemory && settings.precision === 'single') {
            w = texelCount = Math.ceil(texelCount / 4);
          }
          if (h > 1 && w * h === texelCount) {
            return new Int32Array([w, h]);
          }
          return utils.closestSquareDimensions(texelCount);
        },
  
        closestSquareDimensions(length) {
          const sqrt = Math.sqrt(length);
          let high = Math.ceil(sqrt);
          let low = Math.floor(sqrt);
          while (high * low < length) {
            high--;
            low = Math.ceil(length / high);
          }
          return new Int32Array([low, Math.ceil(length / low)]);
        },
  
        getMemoryOptimizedFloatTextureSize(dimensions, bitRatio) {
          const totalArea = utils.roundTo((dimensions[0] || 1) * (dimensions[1] || 1) * (dimensions[2] || 1) * (dimensions[3] || 1), 4);
          const texelCount = totalArea / bitRatio;
          return utils.closestSquareDimensions(texelCount);
        },
  
        getMemoryOptimizedPackedTextureSize(dimensions, bitRatio) {
          const [w, h, d] = dimensions;
          const totalArea = utils.roundTo((w || 1) * (h || 1) * (d || 1), 4);
          const texelCount = totalArea / (4 / bitRatio);
          return utils.closestSquareDimensions(texelCount);
        },
  
        roundTo(n, d) {
          return Math.floor((n + d - 1) / d) * d;
        },
        getDimensions(x, pad) {
          let ret;
          if (utils.isArray(x)) {
            const dim = [];
            let temp = x;
            while (utils.isArray(temp)) {
              dim.push(temp.length);
              temp = temp[0];
            }
            ret = dim.reverse();
          } else if (x instanceof Texture) {
            ret = x.output;
          } else if (x instanceof Input) {
            ret = x.size;
          } else {
            throw new Error(`Unknown dimensions of ${x}`);
          }
  
          if (pad) {
            ret = Array.from(ret);
            while (ret.length < 3) {
              ret.push(1);
            }
          }
  
          return new Int32Array(ret);
        },
  
        flatten2dArrayTo(array, target) {
          let offset = 0;
          for (let y = 0; y < array.length; y++) {
            target.set(array[y], offset);
            offset += array[y].length;
          }
        },
  
        flatten3dArrayTo(array, target) {
          let offset = 0;
          for (let z = 0; z < array.length; z++) {
            for (let y = 0; y < array[z].length; y++) {
              target.set(array[z][y], offset);
              offset += array[z][y].length;
            }
          }
        },
  
        flatten4dArrayTo(array, target) {
          let offset = 0;
          for (let l = 0; l < array.length; l++) {
            for (let z = 0; z < array[l].length; z++) {
              for (let y = 0; y < array[l][z].length; y++) {
                target.set(array[l][z][y], offset);
                offset += array[l][z][y].length;
              }
            }
          }
        },
  
        flattenTo(array, target) {
          if (utils.isArray(array[0])) {
            if (utils.isArray(array[0][0])) {
              if (utils.isArray(array[0][0][0])) {
                utils.flatten4dArrayTo(array, target);
              } else {
                utils.flatten3dArrayTo(array, target);
              }
            } else {
              utils.flatten2dArrayTo(array, target);
            }
          } else {
            target.set(array);
          }
        },
  
        splitArray(array, part) {
          const result = [];
          for (let i = 0; i < array.length; i += part) {
            result.push(new array.constructor(array.buffer, i * 4 + array.byteOffset, part));
          }
          return result;
        },
  
        getAstString(source, ast) {
          const lines = Array.isArray(source) ? source : source.split(/\r?\n/g);
          const start = ast.loc.start;
          const end = ast.loc.end;
          const result = [];
          if (start.line === end.line) {
            result.push(lines[start.line - 1].substring(start.column, end.column));
          } else {
            result.push(lines[start.line - 1].slice(start.column));
            for (let i = start.line; i < end.line; i++) {
              result.push(lines[i]);
            }
            result.push(lines[end.line - 1].slice(0, end.column));
          }
          return result.join('\n');
        },
  
        allPropertiesOf(obj) {
          const props = [];
  
          do {
            props.push.apply(props, Object.getOwnPropertyNames(obj));
          } while (obj = Object.getPrototypeOf(obj));
  
          return props;
        },
  
        linesToString(lines) {
          if (lines.length > 0) {
            return lines.join(';\n') + ';\n';
          } else {
            return '\n';
          }
        },
        warnDeprecated(type, oldName, newName) {
          if (newName) {
            console.warn(`You are using a deprecated ${ type } "${ oldName }". It has been replaced with "${ newName }". Fixing, but please upgrade as it will soon be removed.`);
          } else {
            console.warn(`You are using a deprecated ${ type } "${ oldName }". It has been removed. Fixing, but please upgrade as it will soon be removed.`);
          }
        },
        flipPixels: (pixels, width, height) => {
          const halfHeight = height / 2 | 0; 
          const bytesPerRow = width * 4;
          const temp = new Uint8ClampedArray(width * 4);
          const result = pixels.slice(0);
          for (let y = 0; y < halfHeight; ++y) {
            const topOffset = y * bytesPerRow;
            const bottomOffset = (height - y - 1) * bytesPerRow;
  
            temp.set(result.subarray(topOffset, topOffset + bytesPerRow));
  
            result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
  
            result.set(temp, bottomOffset);
          }
          return result;
        },
        erectPackedFloat: (array, width) => {
          return array.subarray(0, width);
        },
        erect2DPackedFloat: (array, width, height) => {
          const yResults = new Array(height);
          for (let y = 0; y < height; y++) {
            const xStart = y * width;
            const xEnd = xStart + width;
            yResults[y] = array.subarray(xStart, xEnd);
          }
          return yResults;
        },
        erect3DPackedFloat: (array, width, height, depth) => {
          const zResults = new Array(depth);
          for (let z = 0; z < depth; z++) {
            const yResults = new Array(height);
            for (let y = 0; y < height; y++) {
              const xStart = (z * height * width) + y * width;
              const xEnd = xStart + width;
              yResults[y] = array.subarray(xStart, xEnd);
            }
            zResults[z] = yResults;
          }
          return zResults;
        },
        erectMemoryOptimizedFloat: (array, width) => {
          return array.subarray(0, width);
        },
        erectMemoryOptimized2DFloat: (array, width, height) => {
          const yResults = new Array(height);
          for (let y = 0; y < height; y++) {
            const offset = y * width;
            yResults[y] = array.subarray(offset, offset + width);
          }
          return yResults;
        },
        erectMemoryOptimized3DFloat: (array, width, height, depth) => {
          const zResults = new Array(depth);
          for (let z = 0; z < depth; z++) {
            const yResults = new Array(height);
            for (let y = 0; y < height; y++) {
              const offset = (z * height * width) + (y * width);
              yResults[y] = array.subarray(offset, offset + width);
            }
            zResults[z] = yResults;
          }
          return zResults;
        },
        erectFloat: (array, width) => {
          const xResults = new Float32Array(width);
          let i = 0;
          for (let x = 0; x < width; x++) {
            xResults[x] = array[i];
            i += 4;
          }
          return xResults;
        },
        erect2DFloat: (array, width, height) => {
          const yResults = new Array(height);
          let i = 0;
          for (let y = 0; y < height; y++) {
            const xResults = new Float32Array(width);
            for (let x = 0; x < width; x++) {
              xResults[x] = array[i];
              i += 4;
            }
            yResults[y] = xResults;
          }
          return yResults;
        },
        erect3DFloat: (array, width, height, depth) => {
          const zResults = new Array(depth);
          let i = 0;
          for (let z = 0; z < depth; z++) {
            const yResults = new Array(height);
            for (let y = 0; y < height; y++) {
              const xResults = new Float32Array(width);
              for (let x = 0; x < width; x++) {
                xResults[x] = array[i];
                i += 4;
              }
              yResults[y] = xResults;
            }
            zResults[z] = yResults;
          }
          return zResults;
        },
        erectArray2: (array, width) => {
          const xResults = new Array(width);
          const xResultsMax = width * 4;
          let i = 0;
          for (let x = 0; x < xResultsMax; x += 4) {
            xResults[i++] = array.subarray(x, x + 2);
          }
          return xResults;
        },
        erect2DArray2: (array, width, height) => {
          const yResults = new Array(height);
          const XResultsMax = width * 4;
          for (let y = 0; y < height; y++) {
            const xResults = new Array(width);
            const offset = y * XResultsMax;
            let i = 0;
            for (let x = 0; x < XResultsMax; x += 4) {
              xResults[i++] = array.subarray(x + offset, x + offset + 2);
            }
            yResults[y] = xResults;
          }
          return yResults;
        },
        erect3DArray2: (array, width, height, depth) => {
          const xResultsMax = width * 4;
          const zResults = new Array(depth);
          for (let z = 0; z < depth; z++) {
            const yResults = new Array(height);
            for (let y = 0; y < height; y++) {
              const xResults = new Array(width);
              const offset = (z * xResultsMax * height) + (y * xResultsMax);
              let i = 0;
              for (let x = 0; x < xResultsMax; x += 4) {
                xResults[i++] = array.subarray(x + offset, x + offset + 2);
              }
              yResults[y] = xResults;
            }
            zResults[z] = yResults;
          }
          return zResults;
        },
        erectArray3: (array, width) => {
          const xResults = new Array(width);
          const xResultsMax = width * 4;
          let i = 0;
          for (let x = 0; x < xResultsMax; x += 4) {
            xResults[i++] = array.subarray(x, x + 3);
          }
          return xResults;
        },
        erect2DArray3: (array, width, height) => {
          const xResultsMax = width * 4;
          const yResults = new Array(height);
          for (let y = 0; y < height; y++) {
            const xResults = new Array(width);
            const offset = y * xResultsMax;
            let i = 0;
            for (let x = 0; x < xResultsMax; x += 4) {
              xResults[i++] = array.subarray(x + offset, x + offset + 3);
            }
            yResults[y] = xResults;
          }
          return yResults;
        },
        erect3DArray3: (array, width, height, depth) => {
          const xResultsMax = width * 4;
          const zResults = new Array(depth);
          for (let z = 0; z < depth; z++) {
            const yResults = new Array(height);
            for (let y = 0; y < height; y++) {
              const xResults = new Array(width);
              const offset = (z * xResultsMax * height) + (y * xResultsMax);
              let i = 0;
              for (let x = 0; x < xResultsMax; x += 4) {
                xResults[i++] = array.subarray(x + offset, x + offset + 3);
              }
              yResults[y] = xResults;
            }
            zResults[z] = yResults;
          }
          return zResults;
        },
        erectArray4: (array, width) => {
          const xResults = new Array(array);
          const xResultsMax = width * 4;
          let i = 0;
          for (let x = 0; x < xResultsMax; x += 4) {
            xResults[i++] = array.subarray(x, x + 4);
          }
          return xResults;
        },
        erect2DArray4: (array, width, height) => {
          const xResultsMax = width * 4;
          const yResults = new Array(height);
          for (let y = 0; y < height; y++) {
            const xResults = new Array(width);
            const offset = y * xResultsMax;
            let i = 0;
            for (let x = 0; x < xResultsMax; x += 4) {
              xResults[i++] = array.subarray(x + offset, x + offset + 4);
            }
            yResults[y] = xResults;
          }
          return yResults;
        },
        erect3DArray4: (array, width, height, depth) => {
          const xResultsMax = width * 4;
          const zResults = new Array(depth);
          for (let z = 0; z < depth; z++) {
            const yResults = new Array(height);
            for (let y = 0; y < height; y++) {
              const xResults = new Array(width);
              const offset = (z * xResultsMax * height) + (y * xResultsMax);
              let i = 0;
              for (let x = 0; x < xResultsMax; x += 4) {
                xResults[i++] = array.subarray(x + offset, x + offset + 4);
              }
              yResults[y] = xResults;
            }
            zResults[z] = yResults;
          }
          return zResults;
        },
  
        flattenFunctionToString: (source, settings) => {
          const { findDependency, thisLookup, doNotDefine } = settings;
          let flattened = settings.flattened;
          if (!flattened) {
            flattened = settings.flattened = {};
          }
          const ast = acorn.parse(source);
          const functionDependencies = [];
          let indent = 0;
  
          function flatten(ast) {
            if (Array.isArray(ast)) {
              const results = [];
              for (let i = 0; i < ast.length; i++) {
                results.push(flatten(ast[i]));
              }
              return results.join('');
            }
            switch (ast.type) {
              case 'Program':
                return flatten(ast.body) + (ast.body[0].type === 'VariableDeclaration' ? ';' : '');
              case 'FunctionDeclaration':
                return `function ${ast.id.name}(${ast.params.map(flatten).join(', ')}) ${ flatten(ast.body) }`;
              case 'BlockStatement': {
                const result = [];
                indent += 2;
                for (let i = 0; i < ast.body.length; i++) {
                  const flat = flatten(ast.body[i]);
                  if (flat) {
                    result.push(' '.repeat(indent) + flat, ';\n');
                  }
                }
                indent -= 2;
                return `{\n${result.join('')}}`;
              }
              case 'VariableDeclaration':
                const declarations = utils.normalizeDeclarations(ast)
                  .map(flatten)
                  .filter(r => r !== null);
                if (declarations.length < 1) {
                  return '';
                } else {
                  return `${ast.kind} ${declarations.join(',')}`;
                }
                case 'VariableDeclarator':
                  if (ast.init.object && ast.init.object.type === 'ThisExpression') {
                    const lookup = thisLookup(ast.init.property.name, true);
                    if (lookup) {
                      return `${ast.id.name} = ${flatten(ast.init)}`;
                    } else {
                      return null;
                    }
                  } else {
                    return `${ast.id.name} = ${flatten(ast.init)}`;
                  }
                  case 'CallExpression': {
                    if (ast.callee.property.name === 'subarray') {
                      return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                    }
                    if (ast.callee.object.name === 'gl' || ast.callee.object.name === 'context') {
                      return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                    }
                    if (ast.callee.object.type === 'ThisExpression') {
                      functionDependencies.push(findDependency('this', ast.callee.property.name));
                      return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                    } else if (ast.callee.object.name) {
                      const foundSource = findDependency(ast.callee.object.name, ast.callee.property.name);
                      if (foundSource === null) {
                        return `${ast.callee.object.name}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                      } else {
                        functionDependencies.push(foundSource);
                        return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                      }
                    } else if (ast.callee.object.type === 'MemberExpression') {
                      return `${flatten(ast.callee.object)}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                    } else {
                      throw new Error('unknown ast.callee');
                    }
                  }
                  case 'ReturnStatement':
                    return `return ${flatten(ast.argument)}`;
                  case 'BinaryExpression':
                    return `(${flatten(ast.left)}${ast.operator}${flatten(ast.right)})`;
                  case 'UnaryExpression':
                    if (ast.prefix) {
                      return `${ast.operator} ${flatten(ast.argument)}`;
                    } else {
                      return `${flatten(ast.argument)} ${ast.operator}`;
                    }
                    case 'ExpressionStatement':
                      return `${flatten(ast.expression)}`;
                    case 'SequenceExpression':
                      return `(${flatten(ast.expressions)})`;
                    case 'ArrowFunctionExpression':
                      return `(${ast.params.map(flatten).join(', ')}) => ${flatten(ast.body)}`;
                    case 'Literal':
                      return ast.raw;
                    case 'Identifier':
                      return ast.name;
                    case 'MemberExpression':
                      if (ast.object.type === 'ThisExpression') {
                        return thisLookup(ast.property.name);
                      }
                      if (ast.computed) {
                        return `${flatten(ast.object)}[${flatten(ast.property)}]`;
                      }
                      return flatten(ast.object) + '.' + flatten(ast.property);
                    case 'ThisExpression':
                      return 'this';
                    case 'NewExpression':
                      return `new ${flatten(ast.callee)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                    case 'ForStatement':
                      return `for (${flatten(ast.init)};${flatten(ast.test)};${flatten(ast.update)}) ${flatten(ast.body)}`;
                    case 'AssignmentExpression':
                      return `${flatten(ast.left)}${ast.operator}${flatten(ast.right)}`;
                    case 'UpdateExpression':
                      return `${flatten(ast.argument)}${ast.operator}`;
                    case 'IfStatement':
                      return `if (${flatten(ast.test)}) ${flatten(ast.consequent)}`;
                    case 'ThrowStatement':
                      return `throw ${flatten(ast.argument)}`;
                    case 'ObjectPattern':
                      return ast.properties.map(flatten).join(', ');
                    case 'ArrayPattern':
                      return ast.elements.map(flatten).join(', ');
                    case 'DebuggerStatement':
                      return 'debugger;';
                    case 'ConditionalExpression':
                      return `${flatten(ast.test)}?${flatten(ast.consequent)}:${flatten(ast.alternate)}`;
                    case 'Property':
                      if (ast.kind === 'init') {
                        return flatten(ast.key);
                      }
            }
            throw new Error(`unhandled ast.type of ${ ast.type }`);
          }
          const result = flatten(ast);
          if (functionDependencies.length > 0) {
            const flattenedFunctionDependencies = [];
            for (let i = 0; i < functionDependencies.length; i++) {
              const functionDependency = functionDependencies[i];
              if (!flattened[functionDependency]) {
                flattened[functionDependency] = true;
              }
              functionDependency ? flattenedFunctionDependencies.push(utils.flattenFunctionToString(functionDependency, settings) + '\n') : '';
            }
            return flattenedFunctionDependencies.join('') + result;
          }
          return result;
        },
  
        normalizeDeclarations: (ast) => {
          if (ast.type !== 'VariableDeclaration') throw new Error('Ast is not of type "VariableDeclaration"');
          const normalizedDeclarations = [];
          for (let declarationIndex = 0; declarationIndex < ast.declarations.length; declarationIndex++) {
            const declaration = ast.declarations[declarationIndex];
            if (declaration.id && declaration.id.type === 'ObjectPattern' && declaration.id.properties) {
              const { properties } = declaration.id;
              for (let propertyIndex = 0; propertyIndex < properties.length; propertyIndex++) {
                const property = properties[propertyIndex];
                if (property.value.type === 'ObjectPattern' && property.value.properties) {
                  for (let subPropertyIndex = 0; subPropertyIndex < property.value.properties.length; subPropertyIndex++) {
                    const subProperty = property.value.properties[subPropertyIndex];
                    if (subProperty.type === 'Property') {
                      normalizedDeclarations.push({
                        type: 'VariableDeclarator',
                        id: {
                          type: 'Identifier',
                          name: subProperty.key.name
                        },
                        init: {
                          type: 'MemberExpression',
                          object: {
                            type: 'MemberExpression',
                            object: declaration.init,
                            property: {
                              type: 'Identifier',
                              name: property.key.name
                            },
                            computed: false
                          },
                          property: {
                            type: 'Identifier',
                            name: subProperty.key.name
                          },
                          computed: false
                        }
                      });
                    } else {
                      throw new Error('unexpected state');
                    }
                  }
                } else if (property.value.type === 'Identifier') {
                  normalizedDeclarations.push({
                    type: 'VariableDeclarator',
                    id: {
                      type: 'Identifier',
                      name: property.value && property.value.name ? property.value.name : property.key.name
                    },
                    init: {
                      type: 'MemberExpression',
                      object: declaration.init,
                      property: {
                        type: 'Identifier',
                        name: property.key.name
                      },
                      computed: false
                    }
                  });
                } else {
                  throw new Error('unexpected state');
                }
              }
            } else if (declaration.id && declaration.id.type === 'ArrayPattern' && declaration.id.elements) {
              const { elements } = declaration.id;
              for (let elementIndex = 0; elementIndex < elements.length; elementIndex++) {
                const element = elements[elementIndex];
                if (element.type === 'Identifier') {
                  normalizedDeclarations.push({
                    type: 'VariableDeclarator',
                    id: {
                      type: 'Identifier',
                      name: element.name
                    },
                    init: {
                      type: 'MemberExpression',
                      object: declaration.init,
                      property: {
                        type: 'Literal',
                        value: elementIndex,
                        raw: elementIndex.toString(),
                        start: element.start,
                        end: element.end
                      },
                      computed: true
                    }
                  });
                } else {
                  throw new Error('unexpected state');
                }
              }
            } else {
              normalizedDeclarations.push(declaration);
            }
          }
          return normalizedDeclarations;
        },
  
        splitHTMLImageToRGB: (gpu, image) => {
          const rKernel = gpu.createKernel(function(a) {
            const pixel = a[this.thread.y][this.thread.x];
            return pixel.r * 255;
          }, {
            output: [image.width, image.height],
            precision: 'unsigned',
            argumentTypes: { a: 'HTMLImage' },
          });
          const gKernel = gpu.createKernel(function(a) {
            const pixel = a[this.thread.y][this.thread.x];
            return pixel.g * 255;
          }, {
            output: [image.width, image.height],
            precision: 'unsigned',
            argumentTypes: { a: 'HTMLImage' },
          });
          const bKernel = gpu.createKernel(function(a) {
            const pixel = a[this.thread.y][this.thread.x];
            return pixel.b * 255;
          }, {
            output: [image.width, image.height],
            precision: 'unsigned',
            argumentTypes: { a: 'HTMLImage' },
          });
          const aKernel = gpu.createKernel(function(a) {
            const pixel = a[this.thread.y][this.thread.x];
            return pixel.a * 255;
          }, {
            output: [image.width, image.height],
            precision: 'unsigned',
            argumentTypes: { a: 'HTMLImage' },
          });
          const result = [
            rKernel(image),
            gKernel(image),
            bKernel(image),
            aKernel(image),
          ];
          result.rKernel = rKernel;
          result.gKernel = gKernel;
          result.bKernel = bKernel;
          result.aKernel = aKernel;
          result.gpu = gpu;
          return result;
        },
  
        splitRGBAToCanvases: (gpu, rgba, width, height) => {
          const visualKernelR = gpu.createKernel(function(v) {
            const pixel = v[this.thread.y][this.thread.x];
            this.color(pixel.r / 255, 0, 0, 255);
          }, {
            output: [width, height],
            graphical: true,
            argumentTypes: { v: 'Array2D(4)' }
          });
          visualKernelR(rgba);
  
          const visualKernelG = gpu.createKernel(function(v) {
            const pixel = v[this.thread.y][this.thread.x];
            this.color(0, pixel.g / 255, 0, 255);
          }, {
            output: [width, height],
            graphical: true,
            argumentTypes: { v: 'Array2D(4)' }
          });
          visualKernelG(rgba);
  
          const visualKernelB = gpu.createKernel(function(v) {
            const pixel = v[this.thread.y][this.thread.x];
            this.color(0, 0, pixel.b / 255, 255);
          }, {
            output: [width, height],
            graphical: true,
            argumentTypes: { v: 'Array2D(4)' }
          });
          visualKernelB(rgba);
  
          const visualKernelA = gpu.createKernel(function(v) {
            const pixel = v[this.thread.y][this.thread.x];
            this.color(255, 255, 255, pixel.a / 255);
          }, {
            output: [width, height],
            graphical: true,
            argumentTypes: { v: 'Array2D(4)' }
          });
          visualKernelA(rgba);
          return [
            visualKernelR.canvas,
            visualKernelG.canvas,
            visualKernelB.canvas,
            visualKernelA.canvas,
          ];
        },
  
        getMinifySafeName: (fn) => {
          try {
            const ast = acorn.parse(`const value = ${fn.toString()}`);
            const { init } = ast.body[0].declarations[0];
            return init.body.name || init.body.body[0].argument.name;
          } catch (e) {
            throw new Error('Unrecognized function type.  Please use `() => yourFunctionVariableHere` or function() { return yourFunctionVariableHere; }');
          }
        },
        sanitizeName: function(name) {
          if (dollarSign.test(name)) {
            name = name.replace(dollarSign, 'S_S');
          }
          if (doubleUnderscore.test(name)) {
            name = name.replace(doubleUnderscore, 'U_U');
          } else if (singleUnderscore.test(name)) {
            name = name.replace(singleUnderscore, 'u_u');
          }
          return name;
        }
      };
  
      const dollarSign = /\$/;
      const doubleUnderscore = /__/;
      const singleUnderscore = /_/;
  
      const _systemEndianness = utils.getSystemEndianness();
  
      module.exports = {
        utils
      };
      },{"./input":110,"./texture":113,"acorn":1}]},{},[107])(107)
      });
      });
  
      let gpuInstance = null;
      /**
       * Sets up the gpu.js instance
       */
      function setup(value) {
          gpuInstance = value;
      }
      function makeKernel(fn, settings) {
          let _gpuInstance = gpuInstance;
          if (_gpuInstance === null) {
              _gpuInstance = new gpuBrowser.GPU({ mode: 'gpu' });
              setup(_gpuInstance);
          }
          return _gpuInstance
              .createKernel(fn, settings)
              .setPipeline(true);
      }
      function makeKernelMap(map, fn, settings) {
          let _gpuInstance = gpuInstance;
          if (_gpuInstance === null) {
              _gpuInstance = new gpuBrowser.GPU({ mode: 'gpu' });
              setup(_gpuInstance);
          }
          return _gpuInstance
              .createKernelMap(map, fn, settings)
              .setPipeline(true);
      }
      /**
       * Compiles a function into a gpu.js dev mode kernel
       */
      // export function makeDevKernel(
      //   fn: ThreadFunction,
      //   settings: makeKernelSettings
      // ): IKernelRunShortcut {
      //   if ('map' in settings) {
      //     throw new Error('map kernels are not supported by dev kernels');
      //   }
      //   const gpu = new GPU({ mode: 'dev' });
      //   return gpu.createKernel(fn, settings);
      // }
      function kernelInput(value, size) {
          return new gpuBrowser.Input(value, size);
      }
      /**
       * Deletes a gpu.js texture and frees VRAM
       */
      function release(possibleTexture) {
          if (possibleTexture instanceof gpuBrowser.Texture) {
              possibleTexture.delete();
          }
      }
      /**
       * Cleans ie sets all elements to 0 of a Texture or a js array
       */
      function clear(value) {
          if (value instanceof gpuBrowser.Texture) {
              value.clear();
              return;
          }
          // array
          if (Array.isArray(value)) {
              if (typeof value[0] === 'number') {
                  value.fill(0);
              }
              else if (typeof value[0][0] === 'number') {
                  for (let x = 0; x < value.length; x++) {
                      value[x].fill(0);
                  }
                  return;
              }
              else if (typeof value[0][0][0] === 'number') {
                  // cube
                  for (let y = 0; y < value.length; y++) {
                      const row = value[y];
                      for (let x = 0; x < row.length; x++) {
                          row[x].fill(0);
                      }
                  }
                  return;
              }
          }
          if (value instanceof Float32Array) {
              value.fill(0);
              return;
          }
          throw new Error('unhandled value');
      }
      /**
       * Clones a value
       */
      function clone(value) {
          if (value instanceof gpuBrowser.Texture) {
              return value.clone();
          }
          if (value instanceof Float32Array) {
              return value.slice(0);
          }
          if (Array.isArray(value)) {
              if (typeof value[0] === 'number') {
                  return value.slice(0);
              }
              else if (typeof value[0][0] === 'number') {
                  const matrix = new Array(value.length);
                  for (let x = 0; x < value.length; x++) {
                      matrix[x] = value[x].slice(0);
                  }
                  return matrix;
              }
              else if (typeof value[0][0][0] === 'number') {
                  const cube = new Array(value.length);
                  for (let y = 0; y < value.length; y++) {
                      const row = value[y];
                      const matrix = new Array(row.length);
                      for (let x = 0; x < row.length; x++) {
                          matrix[x] = row[x].slice(0);
                      }
                  }
                  return cube;
              }
          }
          throw new Error('unhandled value');
      }
  
      /**
       * 2D Mean Squared Error
       */
      function mse2d(errors) {
          let sum = 0;
          for (let y = 0; y < this.constants.height; y++) {
              for (let x = 0; x < this.constants.width; x++) {
                  sum += errors[y][x] ** 2;
              }
          }
          return sum / this.constants.length;
      }
      class MeanSquaredError {
          constructor({ width, height }) {
              this.calculate = makeKernel(mse2d, {
                  output: [1],
                  constants: {
                      width,
                      height,
                      length: width * height,
                  },
                  immutable: true,
              });
              this.addAbsolute = makeKernel(function (prevError, prevLayerErrors) {
                  return prevError[0] + Math.abs(prevLayerErrors[0][0]);
              }, {
                  output: [1],
                  immutable: true,
              });
              this.add = makeKernel(function (value1, value2) {
                  return value1[0] + value2[0];
              }, {
                  output: [1],
                  immutable: true,
              });
              this.divide = makeKernel(function (length, mseSum) {
                  const value = mseSum[0];
                  if (value > 0) {
                      return value / length;
                  }
                  return 0;
              }, {
                  output: [1],
                  immutable: true,
              });
          }
      }
  
      const baseLayerDefaultSettings = {
          width: 1,
          height: 1,
          depth: null,
          weights: null,
          deltas: null,
          praxis: null,
          praxisOpts: null,
          cleanupDeltas: true,
      };
      class BaseLayer {
          constructor(settings) {
              this.praxis = null;
              this.predictKernel = null;
              this.compareKernel = null;
              if (settings) {
                  this.settings = { ...baseLayerDefaultSettings, ...settings };
              }
              else {
                  this.settings = { ...baseLayerDefaultSettings };
              }
              this.setupPraxis();
          }
          get width() {
              var _a;
              return (_a = this.settings.width) !== null && _a !== void 0 ? _a : 0;
          }
          get height() {
              var _a;
              return (_a = this.settings.height) !== null && _a !== void 0 ? _a : 0;
          }
          get depth() {
              var _a;
              return (_a = this.settings.depth) !== null && _a !== void 0 ? _a : 0;
          }
          get weights() {
              return this.settings.weights;
          }
          set weights(weights) {
              this.settings.weights = weights;
              if (this.settings.cleanupDeltas && this.deltas) {
                  clear(this.deltas);
              }
          }
          get deltas() {
              return this.settings.deltas;
          }
          set deltas(deltas) {
              this.settings.deltas = deltas;
          }
          get id() {
              var _a;
              return (_a = this.settings.id) !== null && _a !== void 0 ? _a : '';
          }
          set id(title) {
              this.settings.id = title;
          }
          setupPraxis() {
              const { initPraxis, praxis, praxisOpts } = this.settings;
              if (!this.praxis) {
                  if (initPraxis) {
                      if (praxisOpts) {
                          this.praxis = initPraxis(this, praxisOpts);
                      }
                      else {
                          this.praxis = initPraxis(this);
                      }
                  }
                  else if (praxis) {
                      this.praxis = praxis;
                  }
              }
          }
          /*
          get weights() {
            return this._weights;
          }
        
          set weights(value) {
            if (value) {
              if (value.dimensions) {
                if (value.dimensions[0] !== this.width) {
                  throw new Error(`${this.constructor.name}.weights being set with improper value width`);
                }
                if (value.dimensions[1] !== this.height) {
                  throw new Error(`${this.constructor.name}.weights being set with improper value height`);
                }
              } else {
                if (value[0].length !== this.width) {
                  throw new Error(`${this.constructor.name}.weights being set with improper value width`);
                }
                if (value.length !== this.height) {
                  throw new Error(`${this.constructor.name}.weights being set with improper value height`);
                }
              }
            }
            this._weights = value;
          }
        
          get deltas() {
            return this._deltas;
          }
        
          set deltas(value) {
            if (value) {
              if (value.dimensions) {
                if (value.dimensions[0] !== this.width) {
                  throw new Error(`${this.constructor.name}.deltas being set with improper value width`);
                }
                if (value.dimensions[1] !== this.height) {
                  throw new Error(`${this.constructor.name}.deltas being set with improper value height`);
                }
              } else {
                if (value[0].length !== this.width) {
                  throw new Error(`${this.constructor.name}.deltas being set with improper value width`);
                }
                if (value.length !== this.height) {
                  throw new Error(`${this.constructor.name}.deltas being set with improper value height`);
                }
              }
            }
            this._deltas = value;
          } */
          validate() {
              if (Number.isNaN(this.height)) {
                  throw new Error(`${this.constructor.name} layer height is not a number`);
              }
              if (Number.isNaN(this.width)) {
                  throw new Error(`${this.constructor.name} layer width is not a number`);
              }
              if (this.height < 1) {
                  throw new Error(`${this.constructor.name} layer height is less than 1`);
              }
              if (this.width < 1) {
                  throw new Error(`${this.constructor.name} layer width is less than 1`);
              }
          }
          setupKernels(isTraining) { }
          reuseKernels(layer) {
              if (layer.width !== this.width) {
                  throw new Error(`${this.constructor.name} kernel width mismatch ${layer.width} is not ${this.width}`);
              }
              if (layer.height !== this.height) {
                  throw new Error(`${this.constructor.name} kernel width mismatch ${layer.height} is not ${this.height}`);
              }
              if (layer.hasOwnProperty('predictKernel') && layer.predictKernel !== null) {
                  if (!layer.predictKernel.immutable) {
                      throw new Error(`${layer.constructor.name}.predictKernel is not reusable, set kernel.immutable = true`);
                  }
                  this.predictKernel = layer.predictKernel;
              }
              if (layer.hasOwnProperty('compareKernel') && layer.compareKernel !== null) {
                  if (!layer.compareKernel.immutable) {
                      throw new Error(`${layer.constructor.name}.compareKernel is not reusable, set kernel.immutable = true`);
                  }
                  this.compareKernel = layer.compareKernel;
              }
              this.praxis = layer.praxis;
          }
          predict(inputs) { }
          compare(targetValues) { }
          learn(learningRate) { }
          toArray() {
              return Array.isArray(this.weights)
                  ? this.weights
                  : this.weights.toArray();
          }
          toJSON() {
              return BaseLayer.toJSON(this);
          }
          static toJSON(layer) {
              const { weights } = layer;
              return {
                  width: layer.width,
                  height: layer.height,
                  depth: layer.depth,
                  weights: toUntypedArray((weights && weights instanceof gpuBrowser.Texture
                      ? weights.toArray()
                      : weights)),
                  type: layer.constructor.name,
                  praxisOpts: layer.praxis ? layer.praxis.toJSON() : null,
              };
          }
      }
      function toUntypedArray(weights) {
          if (weights === null)
              return null;
          if (Array.isArray(weights)) {
              if (typeof weights[0] === 'number') {
                  return weights;
              }
              else if (Array.isArray(weights[0]) && typeof weights[0][0] === 'number') {
                  return weights;
              }
              else if (Array.isArray(weights[0][0]) &&
                  typeof weights[0][0][0] === 'number') {
                  return weights;
              }
              else if (weights[0] instanceof Float32Array) {
                  const matrix = weights;
                  return matrix.map((row) => {
                      return Array.from(row);
                  });
              }
              else if (weights[0][0] instanceof Float32Array) {
                  const cube = weights;
                  return cube.map((matrix) => {
                      return matrix.map((row) => {
                          return Array.from(row);
                      });
                  });
              }
          }
          else if (weights) {
              return Array.from(weights);
          }
          throw new Error('unexpected value');
      }
  
      /**
       * Returns an array of zeros
       */
      function zeros$1(size) {
          return new Float32Array(size);
      }
  
      /**
       * Returns a 2D tensor(matrix) of zeros
       */
      function zeros2D(width, height) {
          const result = new Array(height);
          for (let y = 0; y < height; y++) {
              result[y] = zeros$1(width);
          }
          return result;
      }
  
      /**
       * Returns a 3D tensor of arrays
       */
      function zeros3D(width, height, depth) {
          const result = new Array(depth);
          for (let z = 0; z < depth; z++) {
              result[z] = zeros2D(width, height);
          }
          return result;
      }
  
      class Activation extends BaseLayer {
          constructor(inputLayer, settings) {
              super(settings);
              this.inputLayer = inputLayer;
              const { width, height, depth } = this;
              this.predictKernel = null;
              this.compareKernel = null;
              this.validate();
              if (depth > 0) {
                  this.weights = zeros3D(width, height, depth);
                  this.deltas = zeros3D(width, height, depth);
              }
              else if (height > 0) {
                  this.weights = zeros2D(width, height);
                  this.deltas = zeros2D(width, height);
              }
              this.setupPraxis();
          }
          get width() {
              return this.inputLayer.width;
          }
          get height() {
              return this.inputLayer.height;
          }
          get depth() {
              return this.inputLayer.depth;
          }
      }
  
      class Filter extends BaseLayer {
          constructor(settings, inputLayer) {
              super();
              this.settings = settings;
              this.inputLayer = inputLayer;
          }
          get width() {
              return this.inputLayer.width;
          }
          get height() {
              return this.inputLayer.height;
          }
          get depth() {
              return this.inputLayer.depth;
          }
          get filterCount() {
              return this.settings.filterCount;
          }
          get filterWidth() {
              return this.settings.filterWidth;
          }
          get filterHeight() {
              return this.settings.filterHeight;
          }
          get filters() {
              return this.settings.filters;
          }
          set filters(filters) {
              this.settings.filters = filters;
          }
          get filterDeltas() {
              return this.settings.filterDeltas;
          }
          set filterDeltas(filterDeltas) {
              this.settings.filterDeltas = filterDeltas;
          }
      }
  
      class Internal {
          constructor() {
              this.predictKernel = null;
              this.compareKernel = null;
              this.praxis = null;
          }
          get width() {
              return this.settings.width;
          }
          get height() {
              return this.settings.height;
          }
          get depth() {
              return this.settings.depth;
          }
          get weights() {
              return this.settings.weights;
          }
          set weights(weights) {
              this.settings.weights = weights;
          }
          get deltas() {
              return this.settings.deltas;
          }
          set deltas(deltas) {
              this.settings.deltas = deltas;
          }
          toJSON() {
              return BaseLayer.toJSON(this);
          }
      }
  
      class Modifier extends BaseLayer {
          constructor(inputLayer, settings) {
              super({
                  ...settings,
                  width: inputLayer.width,
                  height: inputLayer.height,
                  depth: inputLayer.depth,
              });
              this.inputLayer = inputLayer;
          }
          validate() {
              var _a;
              super.validate();
              if (this.width !== this.inputLayer.width) {
                  throw new Error(`width of ${this.width} does not match inputLayer.width of ${this.inputLayer.width}`);
              }
              if (this.height !== this.inputLayer.height) {
                  throw new Error(`height of ${this.height} does not match inputLayer.height of ${this.inputLayer.height}`);
              }
              if (this.depth !== ((_a = this.inputLayer.depth) !== null && _a !== void 0 ? _a : 0)) {
                  throw new Error(`depth of ${this.depth} does not match inputLayer.depth of ${this.inputLayer.depth}`);
              }
          }
      }
  
      class Operator extends BaseLayer {
          constructor(inputLayer1, inputLayer2, settings) {
              super(settings);
              this.inputLayer1 = inputLayer1;
              this.inputLayer2 = inputLayer2;
              this.validate();
              this.weights = zeros2D(this.width, this.height);
              this.deltas = zeros2D(this.width, this.height);
              this.setupPraxis();
          }
      }
  
      function compare1D(weights, targetValues) {
          return weights[this.thread.y][this.thread.x] - targetValues[this.thread.x];
      }
      function compare2D$5(weights, targetValues) {
          return (weights[this.thread.y][this.thread.x] -
              targetValues[this.thread.y][this.thread.x]);
      }
      class Target extends BaseLayer {
          constructor(settings, inputLayer) {
              super(settings);
              this.inputLayer = inputLayer;
              this.validate();
              if (this.depth) {
                  throw new Error('Target layer not implemented for depth');
              }
              else if (this.height) {
                  this.weights = zeros2D(this.width, this.height);
                  this.deltas = zeros2D(this.width, this.height);
                  this.errors = zeros2D(this.width, this.height);
              }
              else {
                  this.weights = zeros$1(this.width);
                  this.deltas = zeros$1(this.width);
                  this.errors = zeros$1(this.width);
              }
          }
          setupKernels() {
              if (this.width === 1) {
                  this.compareKernel = makeKernel(compare1D, {
                      output: [this.width, this.height],
                      immutable: true,
                  });
              }
              else {
                  this.compareKernel = makeKernel(compare2D$5, {
                      output: [this.width, this.height],
                      immutable: true,
                  });
              }
          }
          predict() {
              // TODO: should we clone here?
              // NOTE: this looks like it shouldn't be, but the weights are immutable, and this is where they are reused.
              release(this.weights);
              this.weights = clone(this.inputLayer.weights);
          }
          compare(targetValues) {
              // this is where weights attach to deltas
              // deltas will be zero on learn, so save it in error for comparing to mse later
              release(this.deltas);
              release(this.errors);
              release(this.inputLayer.deltas);
              this.deltas = this.compareKernel(this.weights, targetValues);
              this.inputLayer.deltas = clone(this.deltas);
              this.errors = clone(this.deltas);
          }
          setupPraxis() { }
      }
      function target(settings, inputLayer) {
          return new Target(settings, inputLayer);
      }
  
      // eslint-disable-next-line @typescript-eslint/no-extraneous-class
      class InternalModel {
      }
      // eslint-disable-next-line @typescript-eslint/no-extraneous-class
      class EntryPoint extends BaseLayer {
      }
      // eslint-disable-next-line @typescript-eslint/no-extraneous-class
      class Model extends BaseLayer {
          learn(learningRate) {
              // TODO: do we need to release here?
              const { weights: oldWeights } = this;
              if (!this.praxis)
                  throw new Error('this.praxis not defined');
              this.weights = this.praxis.run(this, learningRate);
              release(oldWeights);
          }
      }
  
      /* Functions for turning sparse hashes into arrays and vice versa */
      const lookup = {
          /**
           * Performs `[{a: 1}, {b: 6, c: 7}] -> {a: 0, b: 1, c: 2}`
           * @param {Object} hashes
           * @returns {Object}
           */
          toTable(hashes) {
              const hash = hashes.reduce((memo, hash) => {
                  return Object.assign(memo, hash);
              }, {});
              return lookup.toHash(hash);
          },
          /**
           * Performs `[{a: 1}, {b: 6, c: 7}] -> {a: 0, b: 1, c: 2}`
           */
          toTable2D(objects2D) {
              const table = {};
              let valueIndex = 0;
              for (let i = 0; i < objects2D.length; i++) {
                  const objects = objects2D[i];
                  for (let j = 0; j < objects.length; j++) {
                      const object = objects[j];
                      for (const p in object) {
                          if (object.hasOwnProperty(p) && !table.hasOwnProperty(p)) {
                              table[p] = valueIndex++;
                          }
                      }
                  }
              }
              return table;
          },
          toInputTable2D(data) {
              const table = {};
              let tableIndex = 0;
              for (let dataIndex = 0; dataIndex < data.length; dataIndex++) {
                  const input = data[dataIndex].input;
                  for (let i = 0; i < input.length; i++) {
                      const object = input[i];
                      for (const p in object) {
                          if (!object.hasOwnProperty(p))
                              continue;
                          if (!table.hasOwnProperty(p)) {
                              table[p] = tableIndex++;
                          }
                      }
                  }
              }
              return table;
          },
          toOutputTable2D(data) {
              const table = {};
              let tableIndex = 0;
              for (let dataIndex = 0; dataIndex < data.length; dataIndex++) {
                  const output = data[dataIndex].output;
                  for (let i = 0; i < output.length; i++) {
                      const object = output[i];
                      for (const p in object) {
                          if (!object.hasOwnProperty(p))
                              continue;
                          if (!table.hasOwnProperty(p)) {
                              table[p] = tableIndex++;
                          }
                      }
                  }
              }
              return table;
          },
          /**
           * performs `{a: 6, b: 7} -> {a: 0, b: 1}`
           */
          toHash(hash) {
              const lookup = {};
              let index = 0;
              const keys = Object.keys(hash);
              for (let i = 0; i < keys.length; i++) {
                  lookup[keys[i]] = index++;
              }
              return lookup;
          },
          /**
           * performs `{a: 0, b: 1}, {a: 6} -> [6, 0]`
           */
          toArray(lookup, object, arrayLength) {
              const result = new Float32Array(arrayLength);
              for (const p in lookup) {
                  if (!lookup.hasOwnProperty(p))
                      continue;
                  result[lookup[p]] = object.hasOwnProperty(p) ? object[p] : 0;
              }
              return result;
          },
          toArrayShort(lookup, object) {
              const result = [];
              for (const p in lookup) {
                  if (!lookup.hasOwnProperty(p))
                      continue;
                  if (!object.hasOwnProperty(p))
                      break;
                  result[lookup[p]] = object[p];
              }
              return Float32Array.from(result);
          },
          toArrays(lookup, objects, arrayLength) {
              const result = [];
              for (let i = 0; i < objects.length; i++) {
                  result.push(this.toArray(lookup, objects[i], arrayLength));
              }
              return result;
          },
          /**
           * performs `{a: 0, b: 1}, [6, 7] -> {a: 6, b: 7}`
           * @param {Object} lookup
           * @param {Array} array
           * @returns {Object}
           */
          toObject(lookup, array) {
              const object = {};
              for (const p in lookup) {
                  if (!lookup.hasOwnProperty(p))
                      continue;
                  object[p] = array[lookup[p]];
              }
              return object;
          },
          toObjectPartial(lookup, array, offset = 0, limit = 0) {
              const object = {};
              let i = 0;
              for (const p in lookup) {
                  if (!lookup.hasOwnProperty(p))
                      continue;
                  if (offset > 0) {
                      if (i++ < offset)
                          continue;
                  }
                  if (limit > 0) {
                      if (i++ >= limit)
                          continue;
                  }
                  object[p] = array[lookup[p] - offset];
              }
              return object;
          },
          dataShape(data) {
              const shape = [];
              let lastData;
              if (data.hasOwnProperty('input')) {
                  shape.push('datum');
                  lastData = data.input;
              }
              else if (Array.isArray(data)) {
                  if (data[0] &&
                      data[0].input) {
                      shape.push('array', 'datum');
                      lastData = data[0].input;
                  }
                  else if (Array.isArray(data[0])) {
                      shape.push('array');
                      lastData = data[0];
                  }
                  else {
                      lastData = data;
                  }
              }
              else {
                  lastData = data;
              }
              let p;
              while (lastData) {
                  p = Object.keys(lastData)[0];
                  if (Array.isArray(lastData) ||
                      typeof lastData.buffer === 'object') {
                      shape.push('array');
                      const possibleNumber = lastData[parseInt(p)];
                      if (typeof possibleNumber === 'number') {
                          shape.push('number');
                          break;
                      }
                      else {
                          lastData = possibleNumber;
                      }
                  }
                  else if (typeof lastData === 'object' &&
                      typeof lastData.buffer !== 'object') {
                      shape.push('object');
                      const possibleNumber = lastData[p];
                      if (typeof possibleNumber === 'number') {
                          shape.push('number');
                          break;
                      }
                      else {
                          lastData = possibleNumber;
                      }
                  }
                  else {
                      throw new Error('unhandled signature');
                  }
              }
              return shape;
          },
          addKeys(value, table) {
              if (Array.isArray(value))
                  return table;
              let i = Object.keys(table).length;
              for (const p in value) {
                  if (!value.hasOwnProperty(p))
                      continue;
                  if (table.hasOwnProperty(p))
                      continue;
                  table[p] = i++;
              }
              return table;
          },
      };
  
      class BasePraxis {
          constructor(layerTemplate, settings = {}) {
              this.layerTemplate = layerTemplate;
              this.settings = { ...settings };
              this.kernel = null;
          }
          get width() {
              return this.layerTemplate.width;
          }
          get height() {
              return this.layerTemplate.height;
          }
          get depth() {
              return this.layerTemplate.depth;
          }
          setupKernels() { }
          reuseKernels(praxis) {
              if (praxis.width !== this.width) {
                  throw new Error(`${this.constructor.name} kernel width mismatch ${praxis.width} is not ${this.width}`);
              }
              if (praxis.height !== this.height) {
                  throw new Error(`${this.constructor.name} kernel width mismatch ${praxis.height} is not ${this.height}`);
              }
              if (praxis.hasOwnProperty('kernel')) {
                  this.kernel = praxis.kernel;
              }
          }
          toJSON() {
              return { ...this.settings };
          }
      }
  
      function update$2(weights, deltas) {
          return (weights[this.thread.y][this.thread.x] +
              this.constants.learningRate * deltas[this.thread.y][this.thread.x]);
      }
      const defaultSettings$1 = {
          learningRate: 0.3,
      };
      class ArthurDeviationBiases extends BasePraxis {
          constructor(layer, settings) {
              super(layer);
              this.settings = { ...defaultSettings$1, ...settings };
              this.kernel = null;
          }
          run(layer) {
              return this.kernel(layer.weights, layer.deltas);
          }
          setupKernels() {
              var _a;
              this.kernel = makeKernel(update$2, {
                  output: [this.width, this.height],
                  constants: {
                      learningRate: (_a = this.settings.learningRate) !== null && _a !== void 0 ? _a : 0.01,
                  },
              });
          }
      }
      function arthurDeviationBiases(layer, settings) {
          return new ArthurDeviationBiases(layer, settings);
      }
  
      function updateChange(value) {
          return value;
      }
      function update$1(changes, weights, incomingWeights, inputDeltas) {
          const lastChange = changes[this.thread.y][this.thread.x];
          const inputDelta = inputDeltas[this.thread.y][0];
          const weight = weights[this.thread.y][this.thread.x];
          const incoming = incomingWeights[this.thread.x][0];
          const change = this.constants.learningRate * inputDelta * incoming +
              this.constants.momentum * lastChange;
          return weight + change;
      }
      const defaultSettings = {
          learningRate: 0.3,
          momentum: 0.1,
          weightsLayer: null,
          incomingLayer: null,
          deltaLayer: null,
      };
      class ArthurDeviationWeights extends BasePraxis {
          constructor(layer, settings) {
              super(layer);
              this.kernelMap = null;
              this.settings = { ...defaultSettings, ...settings };
              this.changes = zeros2D(layer.width, layer.height);
          }
          get learningRate() {
              return this.settings.learningRate;
          }
          get momentum() {
              return this.settings.momentum;
          }
          get weightsLayer() {
              return this.settings.weightsLayer;
          }
          set weightsLayer(layer) {
              this.settings.weightsLayer = layer;
          }
          get deltaLayer() {
              return this.settings.deltaLayer;
          }
          set deltaLayer(layer) {
              this.settings.deltaLayer = layer;
          }
          get incomingLayer() {
              return this.settings.incomingLayer;
          }
          set incomingLayer(layer) {
              this.settings.incomingLayer = layer;
          }
          run() {
              const output = this.kernelMap(this.changes, this.weightsLayer.weights, this.incomingLayer.weights, this.deltaLayer.deltas);
              this.changes = output.changes;
              return output.result;
          }
          setupKernels() {
              this.kernelMap = makeKernelMap({
                  changes: updateChange,
              }, update$1, {
                  output: [this.width, this.height],
                  constants: {
                      learningRate: this.learningRate,
                      momentum: this.momentum,
                  },
              });
          }
      }
      function arthurDeviationWeights(layer, settings) {
          return new ArthurDeviationWeights(layer, settings);
      }
  
      function getMomentum(delta, decay, previousMomentum) {
          return previousMomentum * decay + (1 - decay) * delta * delta;
      }
      function clipByValue(value, max, min) {
          if (value > max) {
              return max;
          }
          if (value < min) {
              return min;
          }
          return value;
      }
      /**
       * @description Momentum Root Mean Square Propagation Function
       */
      function update(weights, deltas, previousMomenta) {
          const delta = deltas[this.thread.y][this.thread.x];
          const clippedDelta = clipByValue(delta, this.constants.clipValue, -this.constants.clipValue);
          const weight = weights[this.thread.y][this.thread.x];
          const previousMomentum = previousMomenta[this.thread.y][this.thread.x];
          const momentum = getMomentum(delta, this.constants.decayRate, previousMomentum);
          return (weight +
              (-this.constants.learningRate * clippedDelta) /
                  Math.sqrt(momentum + this.constants.smoothEps) -
              this.constants.regularizationStrength * weight);
      }
      const defaults$8 = {
          decayRate: 0.999,
          regularizationStrength: 0.000001,
          learningRate: 0.01,
          smoothEps: 1e-8,
          clipValue: 5,
      };
      class MomentumRootMeanSquaredPropagation extends BasePraxis {
          constructor(layerTemplate, settings = {}) {
              super(layerTemplate);
              this.kernelMap = null;
              this.settings = { ...defaults$8, ...settings };
              this.momenta = zeros2D(layerTemplate.width, layerTemplate.height);
          }
          get clipValue() {
              return this.settings.clipValue;
          }
          get decayRate() {
              return this.settings.decayRate;
          }
          get learningRate() {
              return this.settings.learningRate;
          }
          get regularizationStrength() {
              return this.settings.regularizationStrength;
          }
          get smoothEps() {
              return this.settings.smoothEps;
          }
          run(layer) {
              const { momenta, result } = this.kernelMap(layer.weights, layer.deltas, this.momenta);
              release(this.momenta);
              this.momenta = momenta;
              return result;
          }
          setupKernels() {
              this.kernelMap = makeKernelMap({
                  momenta: getMomentum,
              }, update, {
                  output: [this.width, this.height],
                  constants: {
                      clipValue: this.clipValue,
                      decayRate: this.decayRate,
                      learningRate: this.learningRate,
                      regularizationStrength: this.regularizationStrength,
                      smoothEps: this.smoothEps,
                  },
                  functions: [clipByValue],
                  immutable: true,
              });
          }
      }
      function momentumRootMeanSquaredPropagation(layer, settings) {
          return new MomentumRootMeanSquaredPropagation(layer, settings);
      }
      /**
       * @description Mathematician friendly name of MomentumRootMeanSquaredPropagation class. For those that are not mere mortals
       */
      const MRmsProp = MomentumRootMeanSquaredPropagation;
      const mRmsProp = momentumRootMeanSquaredPropagation;
  
      var index = /*#__PURE__*/Object.freeze({
          __proto__: null,
          ArthurDeviationBiases: ArthurDeviationBiases,
          arthurDeviationBiases: arthurDeviationBiases,
          ArthurDeviationWeights: ArthurDeviationWeights,
          arthurDeviationWeights: arthurDeviationWeights,
          MomentumRootMeanSquaredPropagation: MomentumRootMeanSquaredPropagation,
          momentumRootMeanSquaredPropagation: momentumRootMeanSquaredPropagation,
          MRmsProp: MRmsProp,
          mRmsProp: mRmsProp
      });
  
      function traverseLayersFrom(layer, cb) {
          if (layer.hasOwnProperty('inputLayer')) {
              traverseLayersFrom(layer.inputLayer, cb);
          }
          else {
              if (layer.hasOwnProperty('inputLayer1')) {
                  traverseLayersFrom(layer.inputLayer1, cb);
              }
              if (layer.hasOwnProperty('inputLayer2')) {
                  traverseLayersFrom(layer.inputLayer2, cb);
              }
          }
          cb(layer);
      }
  
      function flattenLayers(layers) {
          const result = layers.slice(0);
          for (let i = 0; i < result.length; i++) {
              let offset = 0;
              traverseLayersFrom(result[i], (layer) => {
                  if (!result.includes(layer)) {
                      result.splice(i + offset, 0, layer);
                      offset++;
                  }
              });
          }
          return result;
      }
  
      function checkSameSize(layer1, layer2) {
          if (layer1.width !== layer2.width) {
              throw new Error(`Layer width mismatch of ${layer1.width} and ${layer2.width}`);
          }
          if (layer1.height !== layer2.height) {
              throw new Error(`Layer height mismatch of ${layer1.height} and ${layer2.height}`);
          }
      }
  
      function predict$8(inputWeights1, inputWeights2) {
          return (inputWeights1[this.thread.y][this.thread.x] +
              inputWeights2[this.thread.y][this.thread.x]);
      }
      class Add extends Operator {
          get width() {
              return this.inputLayer1.width;
          }
          get height() {
              return this.inputLayer1.height;
          }
          get depth() {
              return this.inputLayer1.depth;
          }
          validate() {
              super.validate();
              checkSameSize(this.inputLayer1, this.inputLayer2);
          }
          setupKernels() {
              this.predictKernel = makeKernel(predict$8, {
                  output: [this.width, this.height],
                  immutable: true,
              });
          }
          predict() {
              release(this.weights);
              this.weights = this.predictKernel(this.inputLayer1.weights, this.inputLayer2.weights);
          }
          compare() {
              // TODO: Do we need release and clone here?
              release(this.inputLayer1.deltas);
              release(this.inputLayer2.deltas);
              this.inputLayer1.deltas = clone(this.deltas);
              this.inputLayer2.deltas = clone(this.deltas);
          }
      }
      function add$1(inputLayer1, inputLayer2, settings) {
          return new Add(inputLayer1, inputLayer2, settings);
      }
  
      function randomWeight() {
          return Math.random() * 0.4 - 0.2;
      }
  
      /**
       * Returns a random float between given min and max bounds (inclusive)
       * @param min Minimum value of the ranfom float
       * @param max Maximum value of the random float
       */
      function randomFloat(min, max) {
          return Math.random() * (max - min) + min;
      }
      /**
       * Complicated math. All you need to know is that it returns a random number.
       * More info: https://en.wikipedia.org/wiki/Normal_distribution
       */
      function gaussRandom() {
          if (gaussRandom.returnV) {
              gaussRandom.returnV = false;
              return gaussRandom.vVal;
          }
          const u = 2 * Math.random() - 1;
          const v = 2 * Math.random() - 1;
          const r = u * u + v * v;
          if (r === 0 || r > 1) {
              return gaussRandom();
          }
          const c = Math.sqrt((-2 * Math.log(r)) / r);
          gaussRandom.vVal = v * c; // cache this
          gaussRandom.returnV = true;
          return u * c;
      }
      /**
       * Returns a random integer between given min and max bounds
       * @param min Minimum value of the random integer
       * @param max Maximum value of the random integer
       */
      function randomInteger(min, max) {
          return Math.floor(Math.random() * (max - min) + min);
      }
      /**
       * If you know what this is: https://en.wikipedia.org/wiki/Normal_distribution
       * @param mu
       * @param std
       */
      function randomN(mu, std) {
          return mu + gaussRandom() * std;
      }
      gaussRandom.returnV = false;
      gaussRandom.vVal = 0;
  
      var random$1 = /*#__PURE__*/Object.freeze({
          __proto__: null,
          randomFloat: randomFloat,
          gaussRandom: gaussRandom,
          randomInteger: randomInteger,
          randomN: randomN
      });
  
      /**
       * Returns an array of given size, full of randomness
       */
      function randos(size, std = null) {
          const array = new Float32Array(size);
          if (std === null) {
              for (let i = 0; i < size; i++) {
                  array[i] = randomWeight();
              }
          }
          else {
              for (let i = 0; i < size; i++) {
                  array[i] = randomFloat(-std, std);
              }
          }
          return array;
      }
      /**
       * Returns a 2D matrix of given size, full of randomness
       */
      function randos2D(width, height, std) {
          const result = new Array(height);
          for (let y = 0; y < height; y++) {
              result[y] = randos(width, std);
          }
          return result;
      }
      /**
       * Returns a 3D tensor of given size, full of randomness
       */
      function randos3D(width, height, depth, std) {
          const result = new Array(depth);
          for (let z = 0; z < depth; z++) {
              result[z] = randos2D(width, height, std);
          }
          return result;
      }
  
      const defaults$7 = {
          ...baseLayerDefaultSettings,
          std: null,
      };
      class Random extends Model {
          constructor(settings) {
              super();
              this.settings = { ...defaults$7, ...settings };
              this.setupPraxis();
              this.validate();
              if (!this.weights) {
                  this.weights = randos2D(this.width, this.height, settings.std);
              }
              if (!this.deltas) {
                  this.deltas = zeros2D(this.width, this.height);
              }
          }
          predict() { }
          compare() { }
      }
      function random(settings) {
          return new Random(settings);
      }
  
      function predict$7(weights1, weights2) {
          let sum = 0;
          for (let i = 0; i < this.constants.size; i++) {
              sum += weights1[this.thread.y][i] * weights2[i][this.thread.x];
          }
          return sum;
      }
      function compareFromX(deltas, inputDeltas, inputWeights) {
          let sum = inputDeltas[this.thread.y][this.thread.x];
          for (let i = 0; i < this.constants.size; i++) {
              sum += deltas[this.thread.y][i] * inputWeights[this.thread.x][i];
          }
          return sum;
      }
      function compareFromY(deltas, inputDeltas, inputWeights) {
          let sum = inputDeltas[this.thread.y][this.thread.x];
          for (let i = 0; i < this.constants.size; i++) {
              sum += deltas[i][this.thread.x] * inputWeights[i][this.thread.y];
          }
          return sum;
      }
      class Multiply extends Operator {
          constructor() {
              super(...arguments);
              this.compareKernel1 = null;
              this.compareKernel2 = null;
          }
          get width() {
              return this.inputLayer2.width;
          }
          set width(width) {
              throw new Error('Cannot set width on Multiply');
          }
          get height() {
              return this.inputLayer1.height;
          }
          set height(height) {
              throw new Error('Cannot set height on Multiply');
          }
          get depth() {
              return this.inputLayer1.depth;
          }
          set depth(depth) {
              throw new Error('Cannot set depth on Multiply');
          }
          validate() {
              super.validate();
              if (this.inputLayer1.width !== this.inputLayer2.height) {
                  throw new Error(`Layer width mismatch of ${this.inputLayer1.width} and ${this.inputLayer2.height}`);
              }
          }
          setupKernels() {
              this.predictKernel = makeKernel(predict$7, {
                  output: [this.width, this.height],
                  constants: {
                      size: this.inputLayer2.height,
                  },
                  immutable: true,
              });
              this.compareKernel1 = makeKernel(compareFromX, {
                  output: [this.inputLayer1.width, this.inputLayer1.height],
                  constants: {
                      size: this.inputLayer2.width,
                  },
                  immutable: true,
              });
              this.compareKernel2 = makeKernel(compareFromY, {
                  output: [this.inputLayer2.width, this.inputLayer2.height],
                  constants: {
                      size: this.inputLayer1.height,
                  },
                  immutable: true,
              });
          }
          reuseKernels(layer) {
              super.reuseKernels(layer);
              this.compareKernel1 = layer.compareKernel1;
              this.compareKernel2 = layer.compareKernel2;
          }
          predict() {
              release(this.weights);
              if (!this.predictKernel)
                  throw new Error('this.predictKernel is not set');
              this.weights = this.predictKernel(this.inputLayer1.weights, this.inputLayer2.weights);
          }
          compare() {
              if (!this.compareKernel1)
                  throw new Error('this.compareKernel1 not set');
              if (!this.compareKernel2)
                  throw new Error('this.compareKernel2 not set');
              const inputLayer1Deltas = this.inputLayer1.deltas;
              const inputLayer2Deltas = this.inputLayer2.deltas;
              const newDeltas1 = this.compareKernel1(this.deltas, this.inputLayer1.deltas, this.inputLayer2.weights);
              const newDeltas2 = this.compareKernel2(this.deltas, this.inputLayer2.deltas, this.inputLayer1.weights);
              this.inputLayer2.deltas = newDeltas2;
              this.inputLayer1.deltas = newDeltas1;
              release(inputLayer1Deltas);
              release(inputLayer2Deltas);
          }
          setupPraxis() { }
          toJSON() {
              return {
                  ...super.toJSON(),
                  width: this.width,
                  height: this.height,
              };
          }
      }
      function multiply$1(inputLayer1, inputLayer2, settings) {
          return new Multiply(inputLayer1, inputLayer2, settings);
      }
  
      function predict2D$4(inputs) {
          return 1 / (1 + Math.exp(-inputs[this.thread.y][this.thread.x]));
      }
      function predict3D$5(inputs) {
          return (1 / (1 + Math.exp(-inputs[this.thread.z][this.thread.y][this.thread.x])));
      }
      function compare2D$4(weights, deltas) {
          const weight = weights[this.thread.y][this.thread.x];
          const delta = deltas[this.thread.y][this.thread.x];
          return weight * (1 - weight) * delta;
      }
      function compare3D$4(weights, deltas) {
          const weight = weights[this.thread.z][this.thread.y][this.thread.x];
          const delta = deltas[this.thread.z][this.thread.y][this.thread.x];
          return weight * (1 - weight) * delta;
      }
      class Sigmoid extends Activation {
          setupKernels() {
              if (this.depth > 0) {
                  this.predictKernel = makeKernel(predict3D$5, {
                      output: [this.width, this.height, this.depth],
                      functions: [activate$2],
                      immutable: true,
                  });
                  this.compareKernel = makeKernel(compare3D$4, {
                      output: [this.width, this.height, this.depth],
                      functions: [measure$2],
                      immutable: true,
                  });
              }
              else {
                  this.predictKernel = makeKernel(predict2D$4, {
                      output: [this.width, this.height],
                      functions: [activate$2],
                      immutable: true,
                  });
                  this.compareKernel = makeKernel(compare2D$4, {
                      output: [this.width, this.height],
                      functions: [measure$2],
                      immutable: true,
                  });
              }
          }
          predict() {
              release(this.weights);
              this.weights = this.predictKernel(this.inputLayer.weights);
          }
          compare() {
              release(this.inputLayer.deltas);
              this.inputLayer.deltas = this.compareKernel(this.weights, this.deltas);
          }
          learn(learningRate) { }
      }
      function sigmoid$1(inputLayer, settings) {
          return new Sigmoid(inputLayer, settings);
      }
  
      function arthurFeedForward(settings, inputLayer) {
          const { height } = settings;
          function initWeightsPraxis(layerTemplate, settings) {
              const praxis = arthurDeviationWeights(layerTemplate, settings);
              praxis.setupKernels();
              return praxis;
          }
          function initBiasesPraxis(layerTemplate, settings) {
              const praxis = arthurDeviationBiases(layerTemplate, settings);
              praxis.setupKernels();
              return praxis;
          }
          const weightsLayer = random({
              id: 'weights',
              height,
              width: inputLayer.height,
              initPraxis: initWeightsPraxis,
          });
          const biasesLayer = random({
              id: 'biases',
              height,
              initPraxis: initBiasesPraxis,
          });
          const multiplyLayer = multiply$1(weightsLayer, inputLayer);
          const addLayer = add$1(multiplyLayer, biasesLayer);
          const sigmoidLayer = sigmoid$1(addLayer);
          const weightsPraxis = weightsLayer.praxis;
          weightsPraxis.weightsLayer = weightsLayer;
          weightsPraxis.incomingLayer = inputLayer;
          weightsPraxis.deltaLayer = sigmoidLayer;
          return sigmoidLayer;
      }
  
      function getStride(settings, defaults) {
          if (typeof settings.stride === 'number') {
              return { strideX: settings.stride, strideY: settings.stride };
          }
          else {
              let strideX = defaults.stride;
              let strideY = defaults.stride;
              if (typeof settings.strideX === 'number') {
                  strideX = settings.strideX;
              }
              if (typeof settings.strideY === 'number') {
                  strideY = settings.strideY;
              }
              return { strideX, strideY };
          }
      }
      function getPadding(settings, defaults) {
          if (typeof settings.padding === 'number') {
              return { paddingX: settings.padding, paddingY: settings.padding };
          }
          else {
              let paddingX = defaults.padding;
              let paddingY = defaults.padding;
              if (typeof settings.paddingX === 'number') {
                  paddingX = settings.paddingX;
              }
              if (typeof settings.paddingY === 'number') {
                  paddingY = settings.paddingY;
              }
              return { paddingX, paddingY };
          }
      }
  
      /**
       * Returns an array of a given size with each element filled with a single value
       */
      function values(size, value) {
          return new Float32Array(size).fill(value);
      }
  
      function predict$6(inputs, filters, biases) {
          const startFilterX = this.constants.paddingX - this.thread.x * this.constants.strideX;
          const startInputX = this.thread.x * this.constants.strideX - this.constants.paddingX;
          const endFilterX = Math.min(this.constants.filterWidth, startFilterX + this.constants.inputWidth);
          const startFilterY = this.constants.paddingY - this.thread.y * this.constants.strideY;
          const startInputY = this.thread.y * this.constants.strideY - this.constants.paddingY;
          const endFilterY = Math.min(this.constants.filterHeight, startFilterY + this.constants.inputHeight);
          let sum = 0;
          for (let z = 0; z < this.constants.inputDepth; z++) {
              for (let filterY = Math.max(0, startFilterY), inputY = Math.max(0, startInputY); filterY < endFilterY; filterY++, inputY++) {
                  for (let filterX = Math.max(0, startFilterX), inputX = Math.max(0, startInputX); filterX < endFilterX; filterX++, inputX++) {
                      sum += filters[z][filterY][filterX] * inputs[z][inputY][inputX];
                  }
              }
          }
          return sum + biases[this.thread.z];
      }
      function compareFilterDeltas$1(filterDeltas, inputs, deltas) {
          const startDeltaX = Math.max(0, Math.ceil((this.constants.paddingX - this.thread.x) / this.constants.strideX));
          const startInputX = startDeltaX * this.constants.strideX +
              this.thread.x -
              this.constants.paddingX;
          const endDeltaX = Math.min(this.constants.deltaWidth, Math.floor((this.constants.inputWidth -
              1 -
              this.thread.x +
              this.constants.paddingX) /
              this.constants.strideX) + 1);
          const startDeltaY = Math.max(0, Math.ceil((this.constants.paddingY - this.thread.y) / this.constants.strideY));
          const startInputY = startDeltaY * this.constants.strideY +
              this.thread.y -
              this.constants.paddingY;
          const endDeltaY = Math.min(this.constants.deltaHeight, Math.floor((this.constants.inputHeight -
              1 -
              this.thread.y +
              this.constants.paddingY) /
              this.constants.strideY) + 1);
          let sum = filterDeltas[this.thread.z][this.thread.y][this.thread.x];
          for (let deltaY = startDeltaY, inputY = startInputY; deltaY < endDeltaY; deltaY++, inputY += this.constants.strideY) {
              for (let deltaX = startDeltaX, inputX = startInputX; deltaX < endDeltaX; deltaX++, inputX += this.constants.strideX) {
                  sum +=
                      inputs[this.thread.z][inputY][inputX] *
                          deltas[this.constants.deltaZ][deltaY][deltaX];
              }
          }
          return sum;
      }
      function compareInputDeltas$1(inputDeltas, filters, deltas) {
          const x = this.thread.x + this.constants.paddingX;
          const startDeltaX = x < this.constants.filterWidth
              ? 0
              : Math.floor((x - this.constants.filterWidth + this.constants.strideX) /
                  this.constants.strideX);
          const startFilterX = x - startDeltaX * this.constants.strideX;
          const endDeltaX = Math.min(startDeltaX + Math.floor(startFilterX / this.constants.strideX) + 1, this.constants.deltaWidth);
          const y = this.thread.y + this.constants.paddingY;
          const startDeltaY = y < this.constants.filterHeight
              ? 0
              : Math.floor((y - this.constants.filterHeight + this.constants.strideY) /
                  this.constants.strideY);
          const startFilterY = y - startDeltaY * this.constants.strideY;
          const endDeltaY = Math.min(startDeltaY + Math.floor(startFilterY / this.constants.strideY) + 1, this.constants.deltaHeight);
          let sum = inputDeltas[this.thread.z][this.thread.y][this.thread.x];
          let deltaY = startDeltaY;
          for (let filterY = startFilterY; deltaY < endDeltaY; filterY -= this.constants.strideY, deltaY++) {
              let deltaX = startDeltaX;
              for (let filterX = startFilterX; deltaX < endDeltaX; filterX -= this.constants.strideX, deltaX++) {
                  sum +=
                      filters[this.thread.z][filterY][filterX] *
                          deltas[this.constants.deltaZ][deltaY][deltaX];
              }
          }
          return sum;
      }
      function compareBiases$1(biasDeltas, deltas) {
          let sum = 0;
          for (let y = 0; y < this.constants.deltaHeight; y++) {
              for (let x = 0; x < this.constants.deltaWidth; x++) {
                  sum += deltas[this.thread.z][y][x];
              }
          }
          return biasDeltas[this.thread.z][this.thread.y][this.thread.x] + sum;
      }
      const defaults$6 = {
          stride: 0,
          padding: 0,
          bias: 0.1,
          filterCount: 1,
          filterWidth: 0,
          filterHeight: 0,
      };
      class Convolution extends Filter {
          constructor(settings, inputLayer) {
              var _a, _b, _c;
              super(settings, inputLayer);
              this.compareFilterDeltasKernel = null;
              this.compareInputDeltasKernel = null;
              this.compareBiasesKernel = null;
              this.settings = {
                  ...defaults$6,
                  ...settings,
                  ...getPadding(settings, defaults$6),
                  ...getStride(settings, defaults$6),
              };
              this.weights = (_a = settings.weights) !== null && _a !== void 0 ? _a : randos3D(this.width, this.height, this.depth);
              this.deltas = zeros3D(this.width, this.height, this.depth);
              this.biases = values(this.depth, this.bias);
              this.biasDeltas = (_b = settings.biasDeltas) !== null && _b !== void 0 ? _b : randos(this.depth);
              this.filters = (_c = settings.filters) !== null && _c !== void 0 ? _c : randos3D(this.filterWidth, this.filterHeight, this.filterCount);
              this.filterDeltas = zeros3D(this.filterWidth, this.filterHeight, this.filterCount);
              this.validate();
          }
          get strideX() {
              return this.settings.strideX;
          }
          get strideY() {
              return this.settings.strideY;
          }
          get paddingX() {
              return this.settings.paddingX;
          }
          get paddingY() {
              return this.settings.paddingX;
          }
          get width() {
              return Math.floor((this.inputLayer.width + this.paddingX * 2 - this.filterWidth) /
                  this.strideX +
                  1);
          }
          get height() {
              return Math.floor((this.inputLayer.height + this.paddingY * 2 - this.filterHeight) /
                  this.strideY +
                  1);
          }
          get bias() {
              return this.settings.bias;
          }
          get depth() {
              return this.filterCount;
          }
          get biases() {
              return this.settings.biases;
          }
          set biases(biases) {
              this.settings.biases = biases;
          }
          get biasDeltas() {
              return this.settings.biasDeltas;
          }
          set biasDeltas(weights) {
              this.settings.biasDeltas = weights;
          }
          get filters() {
              return this.settings.filters;
          }
          set filters(filters) {
              this.settings.filters = filters;
          }
          get filterDeltas() {
              return this.settings.filterDeltas;
          }
          set filterDeltas(filterDeltas) {
              this.settings.filterDeltas = filterDeltas;
          }
          setupKernels() {
              this.predictKernel = makeKernel(predict$6, {
                  constants: {
                      inputWidth: this.inputLayer.width,
                      inputHeight: this.inputLayer.height,
                      inputDepth: this.inputLayer.depth,
                      strideX: this.strideX,
                      strideY: this.strideY,
                      paddingX: this.paddingX,
                      paddingY: this.paddingY,
                      filterWidth: this.filterWidth,
                      filterHeight: this.filterHeight,
                  },
                  output: [this.width, this.height, this.depth],
                  immutable: true,
              });
              this.compareFilterDeltasKernel = makeKernel(compareFilterDeltas$1, {
                  constants: {
                      deltaWidth: this.width,
                      deltaHeight: this.height,
                      deltaZ: this.depth,
                      inputWidth: this.inputLayer.width,
                      inputHeight: this.inputLayer.height,
                      inputDepth: this.inputLayer.depth,
                      strideX: this.strideX,
                      strideY: this.strideY,
                      paddingX: this.paddingX,
                      paddingY: this.paddingY,
                      filterWidth: this.filterWidth,
                      filterHeight: this.filterHeight,
                  },
                  output: [this.width, this.height, this.depth],
                  immutable: true,
              });
              this.compareInputDeltasKernel = makeKernel(compareInputDeltas$1, {
                  constants: {
                      deltaWidth: this.width,
                      deltaHeight: this.height,
                      deltaZ: this.depth,
                      strideX: this.strideX,
                      strideY: this.strideY,
                      paddingX: this.paddingX,
                      paddingY: this.paddingY,
                      filterWidth: this.filterWidth,
                      filterHeight: this.filterHeight,
                      filterCount: this.filterCount,
                  },
                  output: [
                      this.inputLayer.width,
                      this.inputLayer.height,
                      this.inputLayer.depth,
                  ],
                  immutable: true,
              });
              this.compareBiasesKernel = makeKernel(compareBiases$1, {
                  output: [1, 1, this.depth],
                  constants: {
                      deltaWidth: this.width,
                      deltaHeight: this.height,
                  },
                  immutable: true,
              });
          }
          predict() {
              this.weights = this.predictKernel(this.inputLayer.weights, this.filters, this.biases);
          }
          compare() {
              const { filterDeltas, biasDeltas } = this;
              this.filterDeltas = this.compareFilterDeltasKernel(filterDeltas, this.inputLayer.weights, this.deltas);
              release(filterDeltas);
              this.biasDeltas = this.compareBiasesKernel(biasDeltas, this.deltas);
              release(biasDeltas);
              release(this.deltas);
              this.deltas = this.compareInputDeltasKernel(this.filters, this.inputLayer.deltas);
              release(this.inputLayer.deltas);
              // TODO: do we need to clone here?
              this.inputLayer.deltas = clone(this.deltas);
          }
          learn(learningRate) {
              // TODO: handle filters
              // TODO: do we need to release here?
              const { weights: oldWeights } = this;
              this.weights = this.praxis.run(this, learningRate);
              release(oldWeights);
          }
      }
      function convolution(settings, inputLayer) {
          return new Convolution(settings, inputLayer);
      }
  
      function setDropout(dropout) {
          return dropout;
      }
      function trainingPredict(inputs) {
          if (setDropout(Math.random()) < this.constants.probability) {
              return 0;
          }
          return inputs[this.thread.y][this.thread.x];
      }
      function predict$5(inputs) {
          return inputs[this.thread.y][this.thread.x] * this.constants.probability;
      }
      function compare$3(dropouts, deltas) {
          if (dropouts[this.thread.y][this.thread.x] === 0) {
              return 0;
          }
          return deltas[this.thread.y][this.thread.x];
      }
      const dropoutDefaults = {
          ...baseLayerDefaultSettings,
          probability: 0.5,
      };
      class Dropout extends Filter {
          constructor(inputLayer, settings) {
              super(settings, inputLayer);
              this.predictKernelMap = null;
              this.settings = { ...dropoutDefaults, ...settings };
              this.dropouts = null;
              this.validate();
          }
          setupKernels(isTraining) {
              const output = [this.width, this.height];
              if (isTraining) {
                  this.predictKernelMap = makeKernelMap({ dropouts: setDropout }, trainingPredict, {
                      output,
                      immutable: true,
                  });
                  this.compareKernel = makeKernel(compare$3, { output, immutable: true });
              }
              else {
                  this.predictKernelMap = makeKernelMap({}, predict$5, { output, immutable: true });
              }
          }
          predict() {
              release(this.weights);
              if (this.dropouts) {
                  release(this.dropouts);
              }
              const { result, dropouts } = this
                  .predictKernelMap(this.inputLayer.weights);
              this.weights = result;
              this.dropouts = dropouts;
          }
          compare() {
              release(this.deltas);
              this.deltas = this.compareKernel(this.dropouts, this.inputLayer.deltas);
          }
      }
      function dropout(inputLayer, settings) {
          return new Dropout(inputLayer, settings);
      }
  
      function feedForward(settings, input) {
          const { height, praxisOpts = null } = settings;
          const weights = random({
              id: 'weights',
              height,
              width: input.height,
              praxisOpts,
          });
          const biases = random({ id: 'biases', height, praxisOpts });
          return sigmoid$1(add$1(multiply$1(weights, input, { praxisOpts }), biases, { praxisOpts }), { praxisOpts });
      }
  
      function predict$4(inputs, filters, biases) {
          let output = 0;
          let i = 0;
          for (let y = 0; y < this.constants.inputHeight; y++) {
              for (let x = 0; x < this.constants.inputWidth; x++) {
                  output += inputs[y][x] * filters[this.thread.x][i];
                  i++;
              }
          }
          return output + biases[this.thread.x];
      }
      function predict3D$4(inputs, filters, biases) {
          let output = 0;
          let i = 0;
          for (let z = 0; z < this.constants.inputDepth; z++) {
              for (let y = 0; y < this.constants.inputHeight; y++) {
                  for (let x = 0; x < this.constants.inputWidth; x++) {
                      output += inputs[z][y][x] * filters[this.thread.x][i];
                      i++;
                  }
              }
          }
          return output + biases[this.thread.x];
      }
      function compareInputDeltas(inputDeltas, deltas, filters) {
          let sum = 0;
          const filterX = this.thread.x + this.thread.y * this.output.x;
          for (let filterY = 0; filterY < this.constants.filterCount; filterY++) {
              sum += filters[filterY][filterX] * deltas[0][filterY];
          }
          return sum + inputDeltas[this.thread.y][this.thread.x];
      }
      function compareInputDeltas3D(inputDeltas, deltas, filters) {
          let sum = 0;
          const filterX = this.thread.x + this.thread.y * this.output.x;
          for (let filterY = 0; filterY < this.constants.filterCount; filterY++) {
              sum += filters[filterY][filterX] * deltas[0][filterY];
          }
          return sum + inputDeltas[this.thread.z][this.thread.y][this.thread.x];
      }
      function compareBiases(biases, deltas) {
          return biases[this.thread.x] + deltas[this.thread.y][this.thread.x];
      }
      function compareFilterDeltas(filterDeltas, inputWeights, deltas) {
          return (filterDeltas[this.thread.y][this.thread.x] +
              inputWeights[this.thread.y][this.thread.x] *
                  deltas[this.constants.deltaY][this.constants.deltaX]);
      }
      function compareFilterDeltas3D(filterDeltas, inputWeights, deltas) {
          const inputZ = Math.floor(this.thread.x / (this.constants.inputWidth * this.constants.inputHeight));
          const inputY = Math.floor((this.thread.x -
              inputZ * this.constants.inputWidth * this.constants.inputHeight) /
              this.constants.inputWidth);
          const inputX = this.thread.x -
              this.constants.inputWidth * (inputY + this.constants.inputHeight * inputZ);
          return (filterDeltas[this.thread.y][this.thread.x] +
              inputWeights[inputZ][inputY][inputX] * deltas[0][this.thread.y]);
      }
      class FullyConnected extends Filter {
          constructor(settings, inputLayer) {
              super(settings, inputLayer);
              this.compareFilterDeltasKernel = null;
              this.compareInputDeltasKernel = null;
              this.compareBiasesKernel = null;
              this.settings = { ...settings };
              this.validate();
              const connectionCount = inputLayer.width * inputLayer.height * inputLayer.depth;
              this.biases = values(this.height, this.bias);
              this.biasDeltas = zeros$1(this.height);
              this.filters = randos2D(connectionCount, this.height);
              this.filterDeltas = zeros2D(connectionCount, this.height);
              if (this.depth > 0) {
                  this.weights = randos3D(this.width, this.height, this.depth);
                  this.deltas = zeros3D(this.width, this.height, this.depth);
              }
              else if (this.height > 0) {
                  this.weights = randos2D(this.width, this.height);
                  this.deltas = zeros2D(this.width, this.height);
              }
          }
          get bias() {
              return this.settings.bias;
          }
          get biases() {
              return this.settings.biases;
          }
          set biases(biases) {
              this.settings.biases = biases;
          }
          get biasDeltas() {
              return this.settings.biases;
          }
          set biasDeltas(biasDeltas) {
              this.settings.biasDeltas = biasDeltas;
          }
          validate() {
              super.validate();
              if (this.depth > 0)
                  throw new Error('depth not supported');
          }
          setupKernels() {
              const { inputLayer } = this;
              const connectionCount = inputLayer.width * inputLayer.height * inputLayer.depth;
              if (inputLayer.depth > 0) {
                  this.predictKernel = makeKernel(predict3D$4, {
                      output: [this.width, this.height],
                      constants: {
                          inputHeight: inputLayer.height,
                          inputWidth: inputLayer.width,
                          inputDepth: inputLayer.depth,
                      },
                  });
                  this.compareFilterDeltasKernel = makeKernel(compareFilterDeltas3D, {
                      output: [connectionCount, this.height],
                      constants: {
                          deltaX: 0,
                          deltaY: 0,
                          inputWidth: inputLayer.width,
                          inputHeight: inputLayer.height,
                      },
                      immutable: true,
                  });
                  this.compareInputDeltasKernel = makeKernel(compareInputDeltas3D, {
                      output: [inputLayer.width, inputLayer.height, inputLayer.depth],
                      constants: {
                          filterCount: this.height,
                      },
                      immutable: true,
                  });
              }
              else {
                  this.predictKernel = makeKernel(predict$4, {
                      output: [this.width, this.height],
                      constants: {
                          inputHeight: inputLayer.height,
                          inputWidth: inputLayer.width,
                      },
                  });
                  this.compareFilterDeltasKernel = makeKernel(compareFilterDeltas, {
                      output: [connectionCount, this.height],
                      constants: {
                          deltaX: 0,
                          deltaY: 0,
                          inputWidth: inputLayer.width,
                          inputHeight: inputLayer.height,
                      },
                  });
                  this.compareInputDeltasKernel = makeKernel(compareInputDeltas, {
                      output: [inputLayer.width, inputLayer.height],
                      constants: {
                          filterCount: this.height,
                      },
                  });
              }
              this.compareBiasesKernel = makeKernel(compareBiases, {
                  output: [this.width, this.height],
              });
          }
          predict() {
              this.weights = this.predictKernel(this.inputLayer.weights, this.filters, this.biases);
          }
          compare() {
              const inputLayerDeltas = this.inputLayer.deltas;
              this.inputLayer.deltas = this
                  .compareInputDeltasKernel(inputLayerDeltas, this.deltas, this.filters);
              release(inputLayerDeltas);
              const { biasDeltas, filterDeltas } = this;
              // TODO: handle biasDeltas learn
              this.biasDeltas = this.compareBiasesKernel(this.biases, this.deltas);
              // TODO: handle filterDeltas learn
              this.filterDeltas = this.compareFilterDeltasKernel(filterDeltas, this.inputLayer.weights, this.deltas);
              release(biasDeltas);
              release(filterDeltas);
          }
      }
      function fullyConnected(settings, inputLayer) {
          return new FullyConnected(settings, inputLayer);
      }
  
      function predict$3(weights) {
          return -weights[this.thread.y][this.thread.x];
      }
      class Negative extends Modifier {
          constructor(inputLayer, settings) {
              super(inputLayer, settings);
              this.validate();
          }
          setupKernels() {
              this.predictKernel = makeKernel(predict$3, {
                  output: [this.width, this.height],
              });
          }
          predict() {
              this.weights = this.predictKernel(this.inputLayer.weights);
          }
      }
      function negative(inputLayer, settings) {
          return new Negative(inputLayer, settings);
      }
  
      function predict$2(inputLayerWeights1, inputLayerWeights2) {
          return (inputLayerWeights1[this.thread.y][this.thread.x] *
              inputLayerWeights2[this.thread.y][this.thread.x]);
      }
      function compare$2(weights, deltas) {
          return (weights[this.thread.y][this.thread.x] * deltas[this.thread.y][this.thread.x]);
      }
      class MultiplyElement extends Operator {
          get width() {
              return this.inputLayer1.width;
          }
          get height() {
              return this.inputLayer1.height;
          }
          get depth() {
              return this.inputLayer1.depth;
          }
          validate() {
              super.validate();
              checkSameSize(this.inputLayer1, this.inputLayer2);
          }
          setupKernels() {
              this.predictKernel = makeKernel(predict$2, {
                  output: [this.width, this.height],
                  immutable: true,
              });
              this.compareKernel = makeKernel(compare$2, {
                  output: [this.width, this.height],
                  immutable: true,
              });
          }
          predict() {
              release(this.weights);
              this.weights = this.predictKernel(this.inputLayer1.weights, this.inputLayer2.weights);
          }
          compare() {
              release(this.inputLayer1.deltas);
              release(this.inputLayer2.deltas);
              this.inputLayer1.deltas = this.compareKernel(this.inputLayer2.weights, this.deltas);
              this.inputLayer2.deltas = this.compareKernel(this.inputLayer1.weights, this.deltas);
          }
      }
      function multiplyElement$1(inputLayer1, inputLayer2, settings) {
          return new MultiplyElement(inputLayer1, inputLayer2, settings);
      }
  
      function ones$1(size) {
          return new Float32Array(size).fill(1);
      }
      function ones2D(width, height) {
          const result = new Array(height);
          for (let y = 0; y < height; y++) {
              result[y] = ones$1(width);
          }
          return result;
      }
  
      class Ones extends Model {
          constructor(settings) {
              super(settings);
              this.validate();
              this.weights = ones2D(this.width, this.height);
              this.deltas = zeros2D(this.width, this.height);
          }
      }
      function ones(settings) {
          return new Ones(settings);
      }
  
      function predict2D$3(inputs) {
          return activate$1(inputs[this.thread.y][this.thread.x]);
      }
      function predict3D$3(inputs) {
          return activate$1(inputs[this.thread.z][this.thread.y][this.thread.x]);
      }
      function compare2D$3(weights, errors) {
          return measure$1(weights[this.thread.y][this.thread.x], errors[this.thread.y][this.thread.x]);
      }
      function compare3D$3(weights, errors) {
          return measure$1(weights[this.thread.z][this.thread.y][this.thread.x], errors[this.thread.z][this.thread.y][this.thread.x]);
      }
      class Tanh extends Activation {
          setupKernels() {
              if (this.depth > 0) {
                  this.predictKernel = makeKernel(predict3D$3, {
                      output: [this.width, this.height, this.depth],
                      functions: [activate$1],
                      immutable: true,
                  });
                  this.compareKernel = makeKernel(compare3D$3, {
                      output: [this.width, this.height, this.depth],
                      functions: [measure$1],
                      immutable: true,
                  });
              }
              else {
                  this.predictKernel = makeKernel(predict2D$3, {
                      output: [this.width, this.height],
                      functions: [activate$1],
                      immutable: true,
                  });
                  this.compareKernel = makeKernel(compare2D$3, {
                      output: [this.width, this.height],
                      functions: [measure$1],
                      immutable: true,
                  });
              }
          }
          predict() {
              release(this.weights);
              this.weights = this.predictKernel(this.inputLayer.weights);
          }
          compare() {
              release(this.inputLayer.deltas);
              this.inputLayer.deltas = this.compareKernel(this.weights, this.deltas);
          }
      }
      function tanh$1(inputLayer, settings) {
          return new Tanh(inputLayer, settings);
      }
  
      class Zeros extends Model {
          constructor(settings) {
              super(settings);
              this.validate();
              this.weights = zeros2D(this.width, this.height);
              this.deltas = zeros2D(this.width, this.height);
          }
          predict() {
              // throw new Error(`${this.constructor.name}-predict is not yet implemented`)
          }
          compare() {
              // throw new Error(`${this.constructor.name}-compare is not yet implemented`)
          }
      }
      function zeros(settings) {
          return new Zeros(settings);
      }
  
      function gru(settings, recurrentInput, input) {
          const { height } = settings;
          const updateGateWeights = random({ height, width: input.height });
          const updateGatePeepholes = random({ width: height, height });
          const updateGateBias = zeros({ height });
          const updateGate = sigmoid$1(add$1(add$1(multiply$1(updateGateWeights, input), multiply$1(updateGatePeepholes, recurrentInput)), updateGateBias));
          const resetGateWeights = random({ height, width: input.height });
          const resetGatePeepholes = random({ width: height, height });
          const resetGateBias = zeros({ height });
          const resetGate = sigmoid$1(add$1(add$1(multiply$1(resetGateWeights, input), multiply$1(resetGatePeepholes, recurrentInput)), resetGateBias));
          const cellWeights = random({ height, width: input.height });
          const cellPeepholes = random({ width: height, height });
          const cellBias = zeros({ height });
          const cell = tanh$1(add$1(add$1(multiply$1(cellWeights, input), multiply$1(cellPeepholes, multiplyElement$1(resetGate, recurrentInput))), cellBias));
          // compute hidden state as gated, saturated cell activations
          // negate updateGate
          return add$1(multiplyElement$1(add$1(ones({ width: updateGate.width, height: updateGate.height }), negative(updateGate)), cell), multiplyElement$1(recurrentInput, updateGate));
      }
  
      const defaults$5 = {
          weights: null,
      };
      class Input extends EntryPoint {
          constructor(settings) {
              super({ ...defaults$5, ...settings });
              this.reshapeInput = null;
              this.validate();
              this.reshapeInput = null;
              this.deltas = zeros2D(this.width, this.height);
          }
          setupKernels() {
              if (this.width === 1) {
                  this.predict = this.predict1D;
                  this.reshapeInput = makeKernel(function (value) {
                      return value[this.thread.y];
                  }, {
                      output: [1, this.height],
                      immutable: true,
                  });
              }
          }
          reuseKernels(layer) {
              // super.reuseKernels(layer);
              this.reshapeInput = layer.reshapeInput;
          }
          predict(inputs) {
              if ((Array.isArray(inputs) || inputs instanceof Float32Array) &&
                  typeof inputs[0] === 'number' &&
                  inputs.length === this.height * this.width) {
                  release(this.weights);
                  this.weights = kernelInput(inputs, [this.width, this.height]);
              }
              else if (Array.isArray(inputs) &&
                  inputs.length === this.height &&
                  (Array.isArray(inputs[0]) || inputs[0] instanceof Float32Array) &&
                  inputs[0].length === this.width) {
                  this.weights = clone(inputs);
              }
              else {
                  throw new Error('Inputs are not of sized correctly');
              }
          }
          predict1D(inputs) {
              if (this.weights)
                  release(this.weights);
              if (this.reshapeInput) {
                  this.weights = this.reshapeInput(inputs);
              }
              else {
                  this.weights = inputs;
              }
          }
          compare() {
              // throw new Error(`${this.constructor.name}-compare is not yet implemented`)
          }
          learn() { }
      }
      function input(settings) {
          return new Input(settings);
      }
  
      function predict2D$2(inputs) {
          return activate(inputs[this.thread.y][this.thread.x]);
      }
      function predict3D$2(inputs) {
          return activate(inputs[this.thread.z][this.thread.y][this.thread.x]);
      }
      function compare2D$2(weights, deltas) {
          return measure(weights[this.thread.y][this.thread.x], deltas[this.thread.y][this.thread.x]);
      }
      function compare3D$2(weights, deltas) {
          return measure(weights[this.thread.z][this.thread.y][this.thread.x], deltas[this.thread.z][this.thread.y][this.thread.x]);
      }
      class LeakyRelu extends Activation {
          setupKernels() {
              const { width, height, depth } = this.inputLayer;
              if (this.depth > 0) {
                  this.predictKernel = makeKernel(predict3D$2, {
                      output: [width, height, depth],
                      functions: [activate],
                      immutable: true,
                  });
                  this.compareKernel = makeKernel(compare3D$2, {
                      output: [width, height, depth],
                      functions: [measure],
                      immutable: true,
                  });
              }
              else {
                  this.predictKernel = makeKernel(predict2D$2, {
                      output: [width, height],
                      functions: [activate],
                      immutable: true,
                  });
                  this.compareKernel = makeKernel(compare2D$2, {
                      output: [width, height],
                      functions: [measure],
                      immutable: true,
                  });
              }
          }
          predict() {
              release(this.weights);
              this.weights = this.predictKernel(this.inputLayer.weights);
          }
          compare() {
              const { deltas } = this;
              this.deltas = this.compareKernel(this.weights, deltas);
              release(deltas);
          }
      }
      function leakyRelu(inputLayer, settings) {
          return new LeakyRelu(inputLayer, settings);
      }
  
      function lstmCell(settings, input, recurrentInput) {
          const { height } = settings;
          if (typeof height !== 'number') {
              throw new Error('no settings.height given');
          }
          if (recurrentInput.setDimensions) {
              recurrentInput.setDimensions(1, height);
          }
          const inputGateWeights = random({
              width: input.height,
              height,
              std: 0.08,
              id: 'inputGateWeights',
          });
          const inputGatePeepholes = random({
              width: height,
              height,
              std: 0.08,
              id: 'inputGatePeepholes',
          });
          const inputGateBias = zeros({ width: 1, height, id: 'inputGateBias' });
          const inputGate = sigmoid$1(add$1(add$1(multiply$1(inputGateWeights, input), multiply$1(inputGatePeepholes, recurrentInput)), inputGateBias), { id: 'inputGate' });
          const forgetGateWeights = random({
              width: input.height,
              height,
              std: 0.08,
              id: 'forgetGateWeights',
          });
          const forgetGatePeepholes = random({
              width: height,
              height,
              std: 0.08,
              id: 'forgetGatePeepholes',
          });
          const forgetGateBias = zeros({ width: 1, height, id: 'forgetGateBias' });
          const forgetGate = sigmoid$1(add$1(add$1(multiply$1(forgetGateWeights, input), multiply$1(forgetGatePeepholes, recurrentInput)), forgetGateBias), { id: 'forgetGate' });
          const outputGateWeights = random({
              width: input.height,
              height,
              std: 0.08,
              id: 'outputGateWeights',
          });
          const outputGatePeepholes = random({
              width: height,
              height,
              std: 0.08,
              id: 'outputGatePeepholes',
          });
          const outputGateBias = zeros({ width: 1, height, id: 'outputGateBias' });
          const outputGate = sigmoid$1(add$1(add$1(multiply$1(outputGateWeights, input), multiply$1(outputGatePeepholes, recurrentInput)), outputGateBias), { id: 'outputGate' });
          const memoryWeights = random({
              width: input.height,
              height,
              std: 0.08,
              id: 'memoryWeights',
          });
          const memoryPeepholes = random({
              width: height,
              height,
              std: 0.08,
              id: 'memoryPeepholes',
          });
          const memoryBias = zeros({ width: 1, height, id: 'memoryBias' });
          const memory = tanh$1(add$1(add$1(multiply$1(memoryWeights, input), multiply$1(memoryPeepholes, recurrentInput)), memoryBias), { id: 'memory' });
          // compute new cell activation
          const retainCell = multiplyElement$1(forgetGate, recurrentInput, {
              id: 'retainCell',
          }); // what do we keep from cell
          const writeCell = multiplyElement$1(inputGate, memory, { id: 'writeCell' }); // what do we write to cell
          const cell = add$1(retainCell, writeCell, { id: 'cell' }); // new cell contents
          // compute hidden state as gated, saturated cell activations
          return multiplyElement$1(outputGate, tanh$1(cell), { id: 'activations' });
      }
  
      function output(settings, inputLayer) {
          const { height } = settings;
          const outputGate = random({
              height,
              width: inputLayer.height,
              id: 'outputGate',
              std: 0.08,
          });
          const output = random({ height, id: 'output', std: 0.08 });
          const outputGateConnector = multiply$1(outputGate, inputLayer, {
              id: 'outputGateConnected',
          });
          return target({ id: 'target', ...settings }, add$1(outputGateConnector, output));
      }
  
      function setSwitchY(value) {
          return value;
      }
      function setSwitchX(value) {
          return value;
      }
      function predict$1(inputs) {
          // Ends are exclusive, that is if end=4, the last item is 3
          const unclippedStartInputX = this.thread.x * this.constants.strideX - this.constants.paddingX;
          const unclippedStartInputY = this.thread.y * this.constants.strideY - this.constants.paddingY;
          const unclippedEndInputX = unclippedStartInputX + this.constants.filterWidth;
          const unclippedEndInputY = unclippedStartInputY + this.constants.filterHeight;
          const startInputX = Math.max(unclippedStartInputX, 0);
          const startInputY = Math.max(unclippedStartInputY, 0);
          const endInputX = Math.min(unclippedEndInputX, this.constants.inputWidth);
          const endInputY = Math.min(unclippedEndInputY, this.constants.inputHeight);
          let largestValue = inputs[this.thread.z][startInputY][startInputX];
          for (let y = startInputY; y < endInputY; y++) {
              for (let x = startInputX; x < endInputX; x++) {
                  const input = inputs[this.thread.z][y][x];
                  if (input > largestValue) {
                      largestValue = input;
                  }
              }
          }
          return largestValue;
      }
      function compare$1(deltas, switchX, switchY) {
          const xCenter = this.thread.x + 0.5;
          const yCenter = this.thread.y + 0.5;
          const invStrideX = 1 / this.constants.strideX;
          const invStrideY = 1 / this.constants.strideY;
          const startSourceX = Math.max(0, Math.ceil((xCenter - this.constants.filterWidth + this.constants.paddingX) *
              invStrideX));
          const startSourceY = Math.max(0, Math.ceil((yCenter - this.constants.filterHeight + this.constants.paddingY) *
              invStrideY));
          const endSourceX = Math.min(Math.ceil((xCenter + this.constants.paddingX) * invStrideX), this.constants.outputWidth);
          const endSourceY = Math.min(Math.ceil((yCenter + this.constants.paddingY) * invStrideY), this.constants.outputHeight);
          let result = 0;
          for (let backY = startSourceY; backY < endSourceY; backY++) {
              for (let backX = startSourceX; backX < endSourceX; backX++) {
                  const switchXValue = switchX[backY][backX];
                  const switchYValue = switchY[backY][backX];
                  if (Math.abs(switchXValue - this.thread.x) < 0.1 &&
                      Math.abs(switchYValue - this.thread.y) < 0.1) {
                      result += deltas[backY][backX];
                  }
              }
          }
          return result;
      }
      const defaults$4 = {
          padding: 0,
          stride: 0,
          filterWidth: 0,
          filterHeight: 0,
          filterCount: 0,
      };
      class Pool extends Filter {
          constructor(settings, inputLayer) {
              super(settings, inputLayer);
              this.predictKernelMap = null;
              this.settings = {
                  ...settings,
                  ...getStride(settings, defaults$4),
                  ...getPadding(settings, defaults$4),
              };
              this.weights = randos3D(this.width, this.height, this.depth);
              this.deltas = zeros3D(this.width, this.height, this.depth);
              this.validate();
          }
          get strideX() {
              return this.settings.strideX;
          }
          get strideY() {
              return this.settings.strideY;
          }
          get paddingX() {
              return this.settings.paddingX;
          }
          get paddingY() {
              return this.settings.paddingY;
          }
          get width() {
              // Using floor prefers to pad less (or use negative padding) on the right
              // using ceil prefers to pad more
              return Math.ceil((this.inputLayer.width + this.paddingX * 2 - this.filterWidth) /
                  this.strideX +
                  1);
          }
          get height() {
              // Using floor prefers to pad less (or use negative padding) on the bottom
              // using ceil prefers to pad more
              return Math.floor((this.inputLayer.height + this.paddingY * 2 - this.filterHeight) /
                  this.strideY +
                  1);
          }
          get depth() {
              return this.settings.filterCount;
          }
          get filterCount() {
              // TODO: handle 1 depth?
              return this.settings.filterCount;
          }
          get switchX() {
              return this.settings.switchX;
          }
          set switchX(switchX) {
              this.settings.switchX = switchX;
          }
          get switchY() {
              return this.settings.switchY;
          }
          set switchY(switchY) {
              this.settings.switchY = switchY;
          }
          setupKernels() {
              this.predictKernelMap = makeKernelMap({
                  switchX: setSwitchX,
                  switchY: setSwitchY,
              }, predict$1, {
                  output: [this.width, this.height, this.depth],
                  constants: {
                      inputWidth: this.inputLayer.width,
                      inputHeight: this.inputLayer.height,
                      paddingX: this.paddingX,
                      paddingY: this.paddingY,
                      filterHeight: this.filterHeight,
                      filterWidth: this.filterWidth,
                      strideX: this.strideX,
                      strideY: this.strideY,
                  },
              });
              this.compareKernel = makeKernel(compare$1, {
                  output: [
                      this.inputLayer.width,
                      this.inputLayer.height,
                      this.inputLayer.depth,
                  ],
                  constants: {
                      inputWidth: this.inputLayer.width,
                      inputHeight: this.inputLayer.height,
                      outputWidth: this.width,
                      outputHeight: this.height,
                      filterWidth: this.filterWidth,
                      filterHeight: this.filterHeight,
                      paddingX: this.paddingX,
                      paddingY: this.paddingY,
                      strideX: this.strideX,
                      strideY: this.strideY,
                  },
              });
          }
          predict() {
              const { result: weights, switchX, switchY } = this
                  .predictKernelMap(this.inputLayer.weights);
              this.switchX = switchX;
              this.switchY = switchY;
              this.weights = weights;
          }
          compare() {
              // debugger;
              // const depth = this.inputLayer.deltas.length;
              // const height = this.inputLayer.deltas[0].length;
              // const width = this.inputLayer.deltas[0][0].length;
              // const type = typeof this.inputLayer.deltas[0][0][0];
              const inputLayerDeltas = this.inputLayer.deltas;
              this.inputLayer.deltas = this.compareKernel(this.deltas, this.switchX, this.switchY);
              release(inputLayerDeltas);
              // debugger;
              // if (depth !== this.inputLayer.deltas.length) debugger;
              // if (height !== this.inputLayer.deltas[0].length) debugger;
              // if (width !== this.inputLayer.deltas[0][0].length) debugger;
              // if (type !== typeof this.inputLayer.deltas[0][0][0]) debugger;
          }
      }
      function pool(settings, inputLayer) {
          return new Pool(settings, inputLayer);
      }
  
      class RecurrentInput extends Internal {
          constructor(recurrentInput) {
              super();
              this.praxis = null;
              this.predictKernel = null;
              this.compareKernel = null;
              this.settings = {};
              this.recurrentInput = recurrentInput;
              this.validate();
          }
          get width() {
              return this.recurrentInput.width;
          }
          get height() {
              return this.recurrentInput.height;
          }
          get depth() {
              return this.recurrentInput.depth;
          }
          get deltas() {
              return this.recurrentInput.deltas;
          }
          set deltas(deltas) {
              const recurrentInputDeltas = this.recurrentInput.deltas;
              this.recurrentInput.deltas = deltas;
              release(recurrentInputDeltas);
          }
          get weights() {
              return this.recurrentInput.weights;
          }
          set weights(weights) {
              const recurrentInputWeights = this.recurrentInput.weights;
              this.recurrentInput.weights = weights;
              release(recurrentInputWeights);
          }
          validate() {
              BaseLayer.prototype.validate.call(this);
              if (this.width !== this.recurrentInput.width) {
                  throw new Error(`${this.constructor.name} layer width ${this.width} and ${this.recurrentInput.constructor.name} width (${this.recurrentInput.width}) are not same`);
              }
              if (this.height !== this.recurrentInput.height) {
                  throw new Error(`${this.constructor.name} layer height ${this.height} and ${this.recurrentInput.constructor.name} width (${this.recurrentInput.height}) are not same`);
              }
          }
          setDimensions(width, height) {
              this.recurrentInput.width = width;
              this.recurrentInput.height = height;
          }
          predict() {
              // throw new Error(`${this.constructor.name}-predict is not yet implemented`)
          }
          compare() {
              // throw new Error(`${this.constructor.name}-compare is not yet implemented`)
          }
          learn() {
              // throw new Error(`${this.constructor.name}-learn is not yet implemented`)
          }
          setupKernels() {
              // throw new Error(
              //   `${this.constructor.name}-setupKernels is not yet implemented`
              // )
          }
          reuseKernels() {
              // throw new Error(
              //   `${this.constructor.name}-reuseKernels is not yet implemented`
              // )
          }
      }
  
      class RecurrentZeros extends Internal {
          constructor(settings) {
              super();
              this.praxis = null;
              this.settings = {};
              this.predictKernel = null;
              this.compareKernel = null;
              if (settings) {
                  this.settings = { ...settings };
              }
          }
          setDimensions(width, height) {
              this.praxis = null;
              this.settings = {
                  ...this.settings,
                  width,
                  height,
                  weights: zeros2D(width, height),
                  deltas: zeros2D(width, height),
              };
          }
          setupKernels() {
              // throw new Error(
              //   `${this.constructor.name}-setupKernels is not yet implemented`
              // )
          }
          reuseKernels() {
              // throw new Error(
              //   `${this.constructor.name}-reuseKernels is not yet implemented`
              // )
          }
          predict() {
              // throw new Error(`${this.constructor.name}-predict is not yet implemented`)
          }
          compare() {
              // throw new Error(`${this.constructor.name}-compare is not yet implemented`)
          }
          learn(learningRate) {
              const { weights: oldWeights } = this;
              this.weights = this.praxis.run(this, learningRate);
              // this.deltas = deltas;
              release(oldWeights);
          }
      }
      function recurrentZeros() {
          return new RecurrentZeros();
      }
  
      function predict2D$1(inputs) {
          return activate$3(inputs[this.thread.y][this.thread.x]);
      }
      function compare2D$1(weights, deltas) {
          return measure$3(weights[this.thread.y][this.thread.x], deltas[this.thread.y][this.thread.x]);
      }
      function predict3D$1(inputs) {
          return activate$3(inputs[this.thread.z][this.thread.y][this.thread.x]);
      }
      function compare3D$1(weights, deltas) {
          return measure$3(weights[this.thread.z][this.thread.y][this.thread.x], deltas[this.thread.z][this.thread.y][this.thread.x]);
      }
      class Relu extends Activation {
          setupKernels() {
              const { width, height, depth } = this.inputLayer;
              if (depth > 0) {
                  this.predictKernel = makeKernel(predict3D$1, {
                      output: [width, height, depth],
                      functions: [activate$3],
                      immutable: true,
                  });
                  this.compareKernel = makeKernel(compare3D$1, {
                      output: [width, height, depth],
                      functions: [measure$3],
                      immutable: true,
                  });
              }
              else {
                  this.predictKernel = makeKernel(predict2D$1, {
                      output: [width, height],
                      functions: [activate$3],
                      immutable: true,
                  });
                  this.compareKernel = makeKernel(compare2D$1, {
                      output: [width, height],
                      functions: [measure$3],
                      immutable: true,
                  });
              }
          }
          predict() {
              release(this.weights);
              this.weights = this.predictKernel(this.inputLayer.weights);
          }
          compare() {
              release(this.inputLayer.deltas);
              this.inputLayer.deltas = this.compareKernel(this.weights, this.deltas);
          }
      }
      function relu$1(inputLayer, settings) {
          return new Relu(inputLayer, settings);
      }
  
      function rnnCell(settings, input, recurrentInput) {
          const { height } = settings;
          if (typeof height !== 'number')
              throw new Error('height not set');
          if (recurrentInput.setDimensions) {
              recurrentInput.setDimensions(1, height);
          }
          // wxh
          const weight = random({
              id: 'weight',
              height,
              width: input.height,
              std: 0.08,
          });
          // whh
          const transition = random({
              id: 'transition',
              height,
              width: height,
              std: 0.08,
          });
          // bhh
          const bias = zeros({ id: 'bias', height });
          return relu$1(add$1(add$1(multiply$1(weight, input), multiply$1(transition, recurrentInput)), bias));
      }
  
      class Regression extends BaseLayer {
          constructor(settings, inputLayer) {
              super(settings);
              this.inputLayer = inputLayer;
              this.validate();
          }
          predict() {
              release(this.weights);
              this.weights = clone(this.inputLayer.weights);
          }
          learn() {
              // throw new Error(`${this.constructor.name}-learn is not yet implemented`)
          }
      }
      // TODO: handle `loss += 0.5*dy*dy;` total and sum in learn
      function regression(settings, inputLayer) {
          return new Regression(settings, inputLayer);
      }
  
      function getMaxValue2D(inputs) {
          let maxInput = -Infinity;
          for (let y = 0; y < this.constants.inputHeight; y++) {
              for (let x = 0; x < this.constants.inputWidth; x++) {
                  const input = inputs[y][x];
                  if (input > maxInput) {
                      maxInput = input;
                  }
              }
          }
          return maxInput;
      }
      function getMaxValue3D(inputs) {
          let maxInput = -Infinity;
          for (let z = 0; z < this.constants.inputDepth; z++) {
              for (let y = 0; y < this.constants.inputHeight; y++) {
                  for (let x = 0; x < this.constants.inputWidth; x++) {
                      const input = inputs[z][y][x];
                      if (input > maxInput) {
                          maxInput = input;
                      }
                  }
              }
          }
          return maxInput;
      }
      function getSum2D(inputs) {
          let sum = 0;
          for (let y = 0; y < this.constants.inputHeight; y++) {
              for (let x = 0; x < this.constants.inputWidth; x++) {
                  sum += inputs[y][x];
              }
          }
          return sum;
      }
      function getSum3D(inputs) {
          let sum = 0;
          for (let z = 0; z < this.constants.inputDepth; z++) {
              for (let y = 0; y < this.constants.inputHeight; y++) {
                  for (let x = 0; x < this.constants.inputWidth; x++) {
                      sum += inputs[z][y][x];
                  }
              }
          }
          return sum;
      }
      function getExponentials(inputs, maxInput) {
          return Math.exp(inputs[this.thread.x] - maxInput[0]);
      }
      function getExponentials3D(inputs, maxInput) {
          return Math.exp(inputs[this.thread.z][this.thread.y][this.thread.x] - maxInput[0]);
      }
      function predict2D(exponentials, exponentialsSum) {
          return exponentials[this.thread.y][this.thread.x] / exponentialsSum[0];
      }
      function predict3D(exponentials, exponentialsSum) {
          return (exponentials[this.thread.z][this.thread.y][this.thread.x] /
              exponentialsSum[0]);
      }
      function compare2D(target, exponentials) {
          let indicator = 0;
          const index = this.thread.x + this.thread.y * this.output.x;
          if (index === target) {
              indicator = 1;
          }
          return -(indicator - exponentials[this.thread.y][this.thread.x]);
      }
      function compare3D(target, exponentials) {
          let indicator = 0;
          const index = this.thread.x +
              this.thread.y * this.output.x +
              this.thread.z * this.output.x * this.output.y;
          if (index === target) {
              indicator = 1;
          }
          return -(indicator - exponentials[this.thread.z][this.thread.y][this.thread.x]);
      }
      // TODO: handle: `return -Math.log(this.es[y]);` in learn
      class SoftMax extends Modifier {
          constructor(inputLayer, settings) {
              super(inputLayer, settings);
              this.errors = null;
              this.getExponentialsKernel = null;
              this.getMaxValueKernel = null;
              this.getSumKernel = null;
              this.validate();
              if (this.depth > 0) {
                  this.weights = randos3D(this.width, this.height, this.depth);
                  this.deltas = zeros3D(this.width, this.height, this.depth);
              }
              else if (this.height > 0) {
                  this.weights = randos2D(this.width, this.height);
                  this.deltas = zeros2D(this.width, this.height);
              }
              else {
                  this.weights = randos(this.width);
                  this.deltas = zeros$1(this.width);
              }
          }
          setupKernels() {
              const { width, height, depth } = this;
              if (depth > 0) {
                  this.getExponentialsKernel = makeKernel(getExponentials3D, {
                      output: [width, height, depth],
                  });
                  this.getMaxValueKernel = makeKernel(getMaxValue3D, {
                      output: [1, 1, 1],
                      constants: {
                          inputWidth: width,
                          inputHeight: height,
                          inputDepth: depth,
                      },
                  });
                  this.getSumKernel = makeKernel(getSum3D, {
                      output: [1, 1, 1],
                      constants: {
                          inputWidth: width,
                          inputHeight: height,
                          inputDepth: depth,
                      },
                  });
                  this.predictKernel = makeKernel(predict3D, {
                      output: [width, height, depth],
                  });
                  this.compareKernel = makeKernel(compare3D, {
                      output: [width, height, depth],
                      immutable: true,
                  });
              }
              else {
                  this.getExponentialsKernel = makeKernel(getExponentials, {
                      output: [width, height],
                  });
                  this.getMaxValueKernel = makeKernel(getMaxValue2D, {
                      output: [1, 1],
                      constants: {
                          inputWidth: width,
                          inputHeight: height,
                      },
                  });
                  this.getSumKernel = makeKernel(getSum2D, {
                      output: [1, 1],
                      constants: {
                          inputWidth: width,
                          inputHeight: height,
                      },
                  });
                  this.predictKernel = makeKernel(predict2D, {
                      output: [width, height],
                  });
                  this.compareKernel = makeKernel(compare2D, {
                      output: [width, height],
                      immutable: true,
                  });
              }
          }
          predict() {
              const maxValue = this.getMaxValueKernel(this.inputLayer.weights);
              const exponentials = this.getExponentialsKernel(this.inputLayer.weights, maxValue);
              const exponentialsSum = this.getSumKernel(exponentials);
              this.weights = this.predictKernel(exponentials, exponentialsSum);
          }
          compare(targetValues) {
              const { deltas, errors } = this;
              this.errors = this.compareKernel(targetValues[0], deltas);
              this.deltas = clone(this.errors);
              release(deltas);
              release(errors);
              const inputLayerDeltas = this.inputLayer.deltas;
              this.inputLayer.deltas = clone(this.deltas);
              release(inputLayerDeltas);
          }
      }
      function softMax(inputLayer, settings) {
          return new SoftMax(inputLayer, settings);
      }
  
      class SVM extends BaseLayer {
          constructor(inputLayer, settings) {
              super(settings);
              this.inputLayer = inputLayer;
          }
          predict() {
              release(this.weights);
              this.weights = clone(this.inputLayer.weights);
              this.validate();
          }
          learn() {
              // throw new Error(`${this.constructor.name}-learn is not yet implemented`)
          }
      }
      // function learn(target) {
      //   if (y === i) {
      //     continue;
      //   }
      //   const ydiff = -yscore + x.w[i] + margin;
      //   if (ydiff > 0) {
      //     // violating dimension, apply loss
      //     x.dw[i] += 1;
      //     x.dw[y] -= 1;
      //     loss += ydiff;
      //   }
      // }
      function svm(inputLayer, settings) {
          return new SVM(inputLayer, settings);
      }
  
      function predict(value) {
          return value[this.thread.x][this.thread.y];
      }
      const compare = predict;
      class Transpose extends Modifier {
          get width() {
              return this.inputLayer.height;
          }
          get height() {
              return this.inputLayer.width;
          }
          constructor(inputLayer) {
              super(inputLayer);
              this.validate();
          }
          setupKernels() {
              this.predictKernel = makeKernel(predict, {
                  output: [this.height, this.width],
              });
              this.compareKernel = makeKernel(compare, {
                  output: [this.width, this.height],
              });
          }
          predict() {
              this.weights = this.predictKernel(this.inputLayer.weights);
          }
          compare() {
              this.inputLayer.deltas = this.compareKernel(this.deltas);
          }
      }
      function transpose(inputLayer) {
          return new Transpose(inputLayer);
      }
  
      const layerTypes = {
          Activation,
          Internal,
          InternalModel,
          EntryPoint,
          Filter,
          Model,
          Modifier,
          Operator,
          Target,
      };
  
      var layer = /*#__PURE__*/Object.freeze({
          __proto__: null,
          layerTypes: layerTypes,
          Add: Add,
          add: add$1,
          arthurFeedForward: arthurFeedForward,
          BaseLayer: BaseLayer,
          baseLayerDefaultSettings: baseLayerDefaultSettings,
          Convolution: Convolution,
          convolution: convolution,
          Dropout: Dropout,
          dropout: dropout,
          feedForward: feedForward,
          FullyConnected: FullyConnected,
          fullyConnected: fullyConnected,
          gru: gru,
          Input: Input,
          input: input,
          LeakyRelu: LeakyRelu,
          leakyRelu: leakyRelu,
          lstmCell: lstmCell,
          Multiply: Multiply,
          multiply: multiply$1,
          MultiplyElement: MultiplyElement,
          multiplyElement: multiplyElement$1,
          Negative: Negative,
          negative: negative,
          Ones: Ones,
          ones: ones,
          output: output,
          Pool: Pool,
          pool: pool,
          Random: Random,
          random: random,
          RecurrentInput: RecurrentInput,
          RecurrentZeros: RecurrentZeros,
          rnnCell: rnnCell,
          Regression: Regression,
          regression: regression,
          Relu: Relu,
          relu: relu$1,
          Sigmoid: Sigmoid,
          sigmoid: sigmoid$1,
          SoftMax: SoftMax,
          softMax: softMax,
          SVM: SVM,
          svm: svm,
          Tanh: Tanh,
          tanh: tanh$1,
          Target: Target,
          target: target,
          Transpose: Transpose,
          transpose: transpose,
          Zeros: Zeros,
          zeros: zeros
      });
  
      const layerNameTypes = Object.keys(layer);
      function layerFromJSON(jsonLayer, inputLayer1, inputLayer2) {
          if (!layerNameTypes.find((layerNameType) => layerNameType === jsonLayer.type)) {
              return null;
          }
          const Layer = layer[jsonLayer.type];
          if (Layer.prototype instanceof layerTypes.Filter) {
              if (!inputLayer1)
                  throw new Error('inputLayer missing');
              return new Layer(jsonLayer, inputLayer1);
          }
          else if (Layer.prototype instanceof layerTypes.Activation ||
              Layer.prototype instanceof layerTypes.Modifier) {
              if (!inputLayer1)
                  throw new Error('inputLayer missing');
              return new Layer(inputLayer1, jsonLayer);
          }
          else if (Layer.prototype instanceof layerTypes.Internal) {
              return new Layer(jsonLayer);
          }
          else if (Layer.prototype instanceof layerTypes.Operator) {
              if (!inputLayer1)
                  throw new Error('inputLayer1 missing');
              if (!inputLayer2)
                  throw new Error('inputLayer2 missing');
              return new Layer(inputLayer1, inputLayer2, jsonLayer);
          }
          else if (Layer.prototype instanceof layerTypes.InternalModel ||
              Layer.prototype instanceof layerTypes.EntryPoint ||
              Layer.prototype instanceof layerTypes.Model) {
              return new Layer(jsonLayer);
          }
          else if (Layer === Target) {
              if (!inputLayer1)
                  throw new Error('inputLayer missing');
              return new Layer(jsonLayer, inputLayer1);
          }
          return null;
      }
  
      class LookupTable {
          constructor(data, prop) {
              this.prop = null;
              this.table = {};
              this.length = 0;
              const table = this.table;
              if (prop) {
                  this.prop = prop;
                  for (let i = 0; i < data.length; i++) {
                      const datum = data[i];
                      const object = datum[prop];
                      for (const p in object) {
                          if (!object.hasOwnProperty(p))
                              continue;
                          if (table.hasOwnProperty(p))
                              continue;
                          table[p] = this.length++;
                      }
                  }
              }
              else if (Array.isArray(data) && Array.isArray(data[0])) {
                  for (let i = 0; i < data.length; i++) {
                      const array = data[i];
                      for (let j = 0; j < array.length; j++) {
                          const object = array[j];
                          for (const p in object) {
                              if (!object.hasOwnProperty(p))
                                  continue;
                              if (table.hasOwnProperty(p))
                                  continue;
                              table[p] = this.length++;
                          }
                      }
                  }
              }
              else {
                  for (let i = 0; i < data.length; i++) {
                      const object = data[i];
                      for (const p in object) {
                          if (!object.hasOwnProperty(p))
                              continue;
                          if (table.hasOwnProperty(p))
                              continue;
                          table[p] = this.length++;
                      }
                  }
              }
          }
      }
  
      var browser = createCommonjsModule(function (module, exports) {
      var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
          __assign = Object.assign || function(t) {
              for (var s, i = 1, n = arguments.length; i < n; i++) {
                  s = arguments[i];
                  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                      t[p] = s[p];
              }
              return t;
          };
          return __assign.apply(this, arguments);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.thaw = exports.Block = exports.Thaw = void 0;
      /**
       * thaw an array of items
       */
      var Thaw = /** @class */ (function () {
          function Thaw(items, options) {
              var _this = this;
              if (options === void 0) { options = {}; }
              var _a = __assign(__assign({}, Thaw.defaultSettings), options), each = _a.each, done = _a.done;
              this.i = 0;
              this.isStopped = false;
              this.items = items;
              this.options = options;
              this.tick = function () {
                  if (_this.isStopped)
                      return;
                  _this.timeout = setTimeout(_this.tick, 0);
                  if (Thaw.thawing)
                      return;
                  var item = _this.items[_this.i];
                  if (_this.i >= _this.items.length) {
                      if (done !== null) {
                          Thaw.thawing = true;
                          done();
                          Thaw.thawing = false;
                      }
                      _this.isStopped = true;
                      clearTimeout(_this.timeout);
                      return;
                  }
                  if (each !== null) {
                      Thaw.thawing = true;
                      each(item, _this.i);
                      Thaw.thawing = false;
                  }
                  else if (item !== undefined) {
                      item();
                  }
                  _this.i++;
              };
              Thaw.thaws.push(this);
              if (!options.delay) {
                  this.tick();
              }
          }
          Object.defineProperty(Thaw, "isThawing", {
              /**
               * returns if Thaw.js is thawing
               */
              get: function () {
                  return Thaw.thawing;
              },
              enumerable: false,
              configurable: true
          });
          /**
           * Stops all Thaw instances
           */
          Thaw.stopAll = function () {
              for (var i = 0; i < Thaw.thaws.length; i++) {
                  Thaw.thaws[i].stop();
              }
          };
          /**
           * readies thaw to continue
           */
          Thaw.prototype.makeReady = function () {
              if (this.isStopped) {
                  this.isStopped = false;
                  return true;
              }
              return false;
          };
          /**
           * Adds an item to the end of this instance of Thaw and readies Thaw to process it
           */
          Thaw.prototype.add = function (item) {
              this.items.push(item);
              if (this.makeReady()) {
                  this.tick();
              }
              return this;
          };
          /**
           * Inserts an item just after the current item being processed in Thaw and readies Thaw to process it
           */
          Thaw.prototype.insert = function (item) {
              this.items.splice(this.i, 0, item);
              if (this.makeReady()) {
                  this.tick();
              }
              return this;
          };
          /**
           * Adds an Array to the end of this instance of Thaw and readies Thaw to process it
           */
          Thaw.prototype.addArray = function (items) {
              this.items = this.items.concat(items);
              if (this.makeReady()) {
                  this.tick();
              }
              return this;
          };
          /**
           * Inserts an Array just after the current item being processed in Thaw and readies Thaw to process them
           */
          Thaw.prototype.insertArray = function (items) {
              var before = this.items.splice(0, this.i);
              var after = this.items;
              this.items = before.concat(items, after);
              if (this.makeReady()) {
                  this.tick();
              }
              return this;
          };
          /**
           * Stops this instance of Thaw
           */
          Thaw.prototype.stop = function () {
              this.isStopped = true;
              clearTimeout(this.timeout);
              if (this.options.done) {
                  this.options.done();
              }
              return this;
          };
          Thaw.thawing = false;
          Thaw.thaws = [];
          Thaw.defaultSettings = {
              each: null,
              done: null
          };
          return Thaw;
      }());
      exports.Thaw = Thaw;
      /**
       * simple thaw
       */
      function thaw(items, options) {
          return new Thaw(items, options);
      }
      exports.thaw = thaw;
      var Block = /** @class */ (function () {
          function Block(options, count) {
              if (count === void 0) { count = 200; }
              this.index = 0;
              this.thaws = [];
              this.count = count;
              this.options = options;
          }
          /**
           * add an item to the end of items
           */
          Block.prototype.add = function (item) {
              var next = this.next();
              next.add(item);
              return this;
          };
          /**
           * add an Array to the end of items
           */
          Block.prototype.addArray = function (items) {
              var next = this.next();
              next.addArray(items);
              return this;
          };
          /**
           * insert an item into items @ current position
           */
          Block.prototype.insert = function (item) {
              var next = this.next();
              next.insert(item);
              return this;
          };
          /**
           * insert and array into items @ current position
           */
          Block.prototype.insertArray = function (items) {
              var next = this.next();
              next.insertArray(items);
              return this;
          };
          /**
           * Stops all thaws in this block
           */
          Block.prototype.stop = function () {
              for (var i = 0; i < this.thaws.length; i++) {
                  this.thaws[i].stop();
              }
              return this;
          };
          /**
           * Get next available in block
           */
          Block.prototype.next = function () {
              var thaw;
              var thaws = this.thaws;
              if (thaws.length < this.count) {
                  thaw = new Thaw([], this.options);
                  thaws.push(thaw);
              }
              else {
                  thaw = thaws[this.index] || null;
              }
              this.index++;
              if (this.index >= this.count) {
                  this.index = 0;
              }
              return thaw;
          };
          return Block;
      }());
      exports.Block = Block;
      if (typeof window !== 'undefined') {
          // @ts-ignore
          window.Thaw = Thaw;
          // @ts-ignore
          window.thaw = thaw;
          // @ts-ignore
          window.Thaw.Block = Block;
      }
      });
  
      const defaults$3 = {
          learningRate: 0.3,
          binaryThresh: 0.5,
          initPraxis: (layerTemplate, settings) => {
              var _a;
              return momentumRootMeanSquaredPropagation(layerTemplate, (_a = layerTemplate.settings.praxisOpts) !== null && _a !== void 0 ? _a : settings);
          },
      };
      const trainDefaults$3 = {
          iterations: 20000,
          errorThresh: 0.005,
          log: false,
          logPeriod: 10,
          learningRate: 0.3,
          callbackPeriod: 10,
          errorCheckInterval: 100,
          timeout: Infinity,
      };
      class FeedForward {
          constructor(options = {}) {
              this.trainOpts = {};
              this.layers = null;
              this._inputLayer = null;
              this._hiddenLayers = null;
              this._outputLayer = null;
              this._model = null;
              this.meanSquaredError = null;
              this.inputLookup = null;
              this.inputLookupLength = null;
              this.outputLookup = null;
              this.outputLookupLength = null;
              this.options = { ...defaults$3, ...options };
              this._updateTrainingOptions({
                  ...trainDefaults$3,
                  ...options,
              });
          }
          static _validateTrainingOptions(options) {
              const { iterations, errorThresh, log, logPeriod, learningRate, callback, callbackPeriod, timeout, } = options;
              const validations = {
                  iterations: () => typeof iterations === 'number' && iterations > 0,
                  errorThresh: () => typeof errorThresh === 'number' && errorThresh > 0 && errorThresh < 1,
                  log: () => typeof log === 'function' || typeof log === 'boolean',
                  logPeriod: () => typeof logPeriod === 'number' && logPeriod > 0,
                  learningRate: () => typeof learningRate === 'number' &&
                      learningRate > 0 &&
                      learningRate < 1,
                  callback: () => typeof callback === 'function' || callback === null,
                  callbackPeriod: () => typeof callbackPeriod === 'number' && callbackPeriod > 0,
                  timeout: () => typeof timeout === 'number' && timeout > 0,
              };
              Object.keys(trainDefaults$3).forEach((key) => {
                  if (validations.hasOwnProperty(key) && !validations[key]()) {
                      const val = options[key];
                      throw new Error(`[${key}, ${(val !== null && val !== void 0 ? val : 'undefined').toString()}] is out of normal training range, your network will probably not train.`);
                  }
              });
          }
          /**
           * if a method is passed in method is used
           * if false passed in nothing is logged
           */
          _setLogMethod(log) {
              if (typeof log === 'function') {
                  this.trainOpts.log = log;
              }
              else if (log) {
                  // eslint-disable-next-line
                  this.trainOpts.log = console.log;
              }
              else {
                  this.trainOpts.log = false;
              }
          }
          _updateTrainingOptions(opts) {
              var _a;
              this.trainOpts = { ...trainDefaults$3, ...this.trainOpts, ...opts };
              FeedForward._validateTrainingOptions(this.trainOpts);
              this._setLogMethod((_a = opts.log) !== null && _a !== void 0 ? _a : this.trainOpts.log);
              const { callback, callbackPeriod, errorCheckInterval } = this.trainOpts;
              if (callback && callbackPeriod !== errorCheckInterval) {
                  console.warn(`options.callbackPeriod with value of ${(callbackPeriod !== null && callbackPeriod !== void 0 ? callbackPeriod : 'undefined').toString()} does not match options.errorCheckInterval with value of ${(errorCheckInterval !== null && errorCheckInterval !== void 0 ? errorCheckInterval : 'undefined').toString()}, if logging error, it will repeat.  These values may need to match`);
              }
          }
          _connectOptionsLayers() {
              const { inputLayerIndex, outputLayerIndex, layers } = this.options;
              if (!layers)
                  throw new Error('this.options.layers in unexpected state');
              if (typeof inputLayerIndex !== 'number')
                  throw new Error('inputLayerIndex not a number');
              if (typeof outputLayerIndex !== 'number')
                  throw new Error('inputLayerIndex not a number');
              const inputLayer = layers[inputLayerIndex];
              if (!inputLayer) {
                  throw new Error('inputLayer not found in this.options.layers');
              }
              const outputLayer = layers[outputLayerIndex];
              if (!outputLayer) {
                  throw new Error('outputLayer not found in this.options.layers');
              }
              this._inputLayer = inputLayer;
              this._hiddenLayers = layers.slice(inputLayerIndex, outputLayerIndex - inputLayerIndex);
              this._outputLayer = outputLayer;
              return layers;
          }
          _connectNewLayers() {
              const { inputLayer, outputLayer } = this.options;
              if (!inputLayer)
                  throw new Error('inputLayer not defined');
              const layers = [];
              this._inputLayer = inputLayer();
              const hiddenLayers = this._connectHiddenLayers(this._inputLayer);
              if (!outputLayer)
                  throw new Error('outputLayer not defined');
              this._outputLayer = outputLayer(hiddenLayers[hiddenLayers.length - 1], hiddenLayers.length);
              layers.push(this._inputLayer);
              layers.push(...hiddenLayers);
              layers.push(this._outputLayer);
              return flattenLayers(layers);
          }
          _connectHiddenLayers(previousLayer) {
              this._hiddenLayers = [];
              const result = [];
              const { hiddenLayers } = this.options;
              if (!hiddenLayers)
                  throw new Error('hiddenLayers not defined');
              for (let i = 0; i < hiddenLayers.length; i++) {
                  const hiddenLayer = hiddenLayers[i](previousLayer, i);
                  result.push(hiddenLayer);
                  this._hiddenLayers.push(hiddenLayer);
                  previousLayer = hiddenLayer;
              }
              return result;
          }
          initialize() {
              this.layers = this.options.layers
                  ? this._connectOptionsLayers()
                  : this._connectNewLayers();
              this.initializeLayers(this.layers);
              this._model = this.layers.filter((l) => l instanceof Model);
          }
          initializeLayers(layers) {
              var _a, _b;
              for (let i = 0; i < layers.length; i++) {
                  const layer = layers[i];
                  // TODO: optimize for when training or just running
                  layer.setupKernels(true);
                  if (layer instanceof Model &&
                      layer.praxis === null &&
                      typeof this.options.initPraxis === 'function') {
                      layer.praxis = this.options.initPraxis(layer, (_b = (_a = layer.settings.praxisOpts) !== null && _a !== void 0 ? _a : this.options.praxisOpts) !== null && _b !== void 0 ? _b : {});
                      layer.praxis.setupKernels();
                  }
              }
              const lastLayer = layers[layers.length - 1];
              this.meanSquaredError = new MeanSquaredError({
                  width: lastLayer.width,
                  height: lastLayer.height,
              });
          }
          run(input) {
              let typeSafeInput;
              if (Array.isArray(input) || input.buffer) {
                  typeSafeInput = input;
              }
              else {
                  if (this.inputLookup) {
                      typeSafeInput = lookup.toArray(this.inputLookup, input, this.inputLookupLength);
                  }
                  else {
                      throw new Error('input is incompatible with net');
                  }
              }
              let output = this.runInput(typeSafeInput);
              if (output instanceof gpuBrowser.Texture) {
                  output = output.toArray();
              }
              if (this.outputLookup) {
                  return lookup.toObject(this.outputLookup, output);
              }
              return output;
          }
          runInput(input) {
              if (!this.layers)
                  throw new Error('not initialized');
              this.layers[0].predict(input);
              for (let i = 1; i < this.layers.length; i++) {
                  this.layers[i].predict();
              }
              return this.layers[this.layers.length - 1].weights;
          }
          train(data, options = {}) {
              const { preparedData, status, endTime } = this._prepTraining(data, options);
              let continueTicking = true;
              const calculateError = () => this._calculateTrainingError(preparedData);
              const trainPatterns = () => this._trainPatterns(preparedData);
              while (continueTicking) {
                  continueTicking = this._trainingTick(status, endTime, calculateError, trainPatterns);
              }
              return status;
          }
          async trainAsync(data, options = {}) {
              const { preparedData, status, endTime } = this._prepTraining(data, options);
              return await new Promise((resolve, reject) => {
                  try {
                      const calculateError = () => this._calculateTrainingError(preparedData);
                      const trainPatterns = () => this._trainPatterns(preparedData);
                      const thawedTrain = new browser.Thaw(new Array(this.trainOpts.iterations), {
                          delay: true,
                          each: () => this._trainingTick(status, endTime, calculateError, trainPatterns) || thawedTrain.stop(),
                          done: () => resolve(status),
                      });
                      thawedTrain.tick();
                  }
                  catch (trainError) {
                      reject(trainError);
                  }
              });
          }
          _trainingTick(status, endTime, calculateError, trainPatterns) {
              const { trainOpts } = this;
              if (status.iterations >= trainOpts.iterations ||
                  status.error <= trainOpts.errorThresh ||
                  Date.now() >= endTime) {
                  return false;
              }
              if (typeof trainOpts.log === 'function' &&
                  status.iterations % trainOpts.logPeriod === 0) {
                  status.error = calculateError();
                  trainOpts.log(`iterations: ${status.iterations}, training error: ${status.error}`);
              }
              else if (status.iterations % trainOpts.errorCheckInterval ===
                  0) {
                  status.error = calculateError();
              }
              else {
                  trainPatterns();
              }
              if (trainOpts.callback &&
                  status.iterations % trainOpts.callbackPeriod === 0) {
                  trainOpts.callback(Object.assign(status));
              }
              status.iterations++;
              return true;
          }
          _prepTraining(data, options) {
              this._updateTrainingOptions(options);
              const formattedData = this.formatData(data);
              const endTime = this.trainOpts.timeout
                  ? Date.now() + this.trainOpts.timeout
                  : 0;
              const status = {
                  error: 1,
                  iterations: 0,
              };
              this.verifyIsInitialized();
              return {
                  preparedData: this.transferData(formattedData),
                  status,
                  endTime,
              };
          }
          verifyIsInitialized() {
              if (!this._model) {
                  this.initialize();
              }
          }
          _calculateTrainingError(preparedData) {
              let sum = new Float32Array([0]);
              const meanSquaredError = this.meanSquaredError;
              for (let i = 0; i < preparedData.length; ++i) {
                  const prevSum = sum;
                  const error = this._trainPattern(preparedData[i].input, preparedData[i].output, true);
                  sum = meanSquaredError.add(sum, error);
                  release(error);
                  release(prevSum);
              }
              const result = meanSquaredError.divide(preparedData.length, sum);
              release(sum);
              if (result instanceof gpuBrowser.Texture) {
                  const resultArray = result.toArray();
                  release(result);
                  return resultArray[0];
              }
              return result[0];
          }
          /**
           * @param data
           * @private
           */
          _trainPatterns(data) {
              for (let i = 0; i < data.length; ++i) {
                  this._trainPattern(data[i].input, data[i].output, false);
              }
          }
          _trainPattern(input, target, logErrorRate) {
              var _a;
              // forward propagate
              this.runInput(input);
              // back propagate
              this._calculateDeltas(target);
              this.adjustWeights();
              if (logErrorRate) {
                  if (!((_a = this._outputLayer) === null || _a === void 0 ? void 0 : _a.errors)) {
                      throw new Error('outputLayer.errors not defined');
                  }
                  return this.meanSquaredError.calculate(this._outputLayer.errors);
              }
              return null;
          }
          _calculateDeltas(target) {
              const layers = this.layers;
              for (let i = layers.length - 1; i > -1; i--) {
                  layers[i].compare(target);
              }
          }
          /**
           *
           */
          adjustWeights() {
              const _model = this._model;
              for (let i = 0; i < _model.length; i++) {
                  _model[i].learn(this.trainOpts.learningRate);
              }
          }
          /**
           *
           * @param data
           * @returns {*}
           */
          formatData(data) {
              if (!Array.isArray(data)) {
                  // turn stream datum into array
                  const tmp = [];
                  tmp.push(data);
                  data = tmp;
              }
              // turn sparse hash input into arrays with 0s as filler
              const inputDatumCheck = data[0].input;
              let formattedData;
              if (Array.isArray(data) &&
                  !Array.isArray(inputDatumCheck) &&
                  !(inputDatumCheck instanceof Float32Array)) {
                  if (!this.inputLookup) {
                      const lookupTable = new LookupTable(data, 'input');
                      this.inputLookup = lookupTable.table;
                      this.inputLookupLength = lookupTable.length;
                  }
                  formattedData = data.map((datumParam) => {
                      const array = lookup.toArray(this.inputLookup, datumParam.input, this.inputLookupLength);
                      return { input: array };
                  }, this);
              }
              else {
                  formattedData = data;
              }
              const outputDatumCheck = data[0].output;
              if (!Array.isArray(outputDatumCheck) &&
                  !(outputDatumCheck instanceof Float32Array)) {
                  if (!this.outputLookup) {
                      const lookupTable = new LookupTable(data, 'output');
                      this.outputLookup = lookupTable.table;
                      this.outputLookupLength = lookupTable.length;
                  }
                  formattedData = data.map((datumParam, index) => {
                      const array = lookup.toArray(this.outputLookup, datumParam.output, this.inputLookupLength);
                      return {
                          input: formattedData[index].input,
                          output: array,
                      };
                  }, this);
              }
              return formattedData;
          }
          transferData(formattedData) {
              const transferredData = new Array(formattedData.length);
              const transferInput = makeKernel(function (value) {
                  return value[this.thread.x];
              }, {
                  output: [formattedData[0].input.length],
                  immutable: true,
              });
              const transferOutput = makeKernel(function (value) {
                  return value[this.thread.x];
              }, {
                  output: [formattedData[0].output.length],
                  immutable: true,
              });
              for (let i = 0; i < formattedData.length; i++) {
                  const formattedDatum = formattedData[i];
                  transferredData[i] = {
                      input: transferInput(formattedDatum.input),
                      output: transferOutput(formattedDatum.output),
                  };
              }
              return transferredData;
          }
          /**
           *
           * @param data
           * @returns {
           *  {
           *    error: number,
           *    misclasses: Array
           *  }
           * }
           */
          test() {
              throw new Error(`${this.constructor.name}-test is not yet implemented`);
          }
          /**
           *
           */
          toJSON() {
              var _a;
              if (!this.layers) {
                  this.initialize();
              }
              if (!this._model ||
                  !this.layers ||
                  !this._inputLayer ||
                  !this._hiddenLayers ||
                  !this._outputLayer) {
                  throw new Error('network is not initialized');
              }
              const jsonLayers = [];
              for (let i = 0; i < this.layers.length; i++) {
                  const layer = this.layers[i];
                  const jsonLayer = layer.toJSON();
                  if (layer.hasOwnProperty('inputLayer')) {
                      jsonLayer.inputLayerIndex = this.layers.indexOf(layer.inputLayer);
                  }
                  else if (layer.hasOwnProperty('inputLayer1') &&
                      layer.hasOwnProperty('inputLayer2')) {
                      jsonLayer.inputLayer1Index = this.layers.indexOf(layer.inputLayer1);
                      jsonLayer.inputLayer2Index = this.layers.indexOf(layer.inputLayer2);
                  }
                  jsonLayers.push(jsonLayer);
              }
              return {
                  type: this.constructor.name,
                  sizes: (_a = this.options.sizes) !== null && _a !== void 0 ? _a : [this._inputLayer.height]
                      .concat(this._hiddenLayers.map((l) => l.height))
                      .concat([this._outputLayer.height]),
                  outputLayerIndex: this.layers.indexOf(this._outputLayer),
                  layers: jsonLayers,
                  inputLayerIndex: this.layers.indexOf(this._inputLayer),
              };
          }
          static fromJSON(json, getLayer) {
              var _a, _b, _c, _d;
              const jsonLayers = json.layers;
              const layers = [];
              const inputLayer = getLayer
                  ? (_a = layerFromJSON(jsonLayers[0])) !== null && _a !== void 0 ? _a : getLayer(jsonLayers[0]) : layerFromJSON(jsonLayers[0]);
              if (!inputLayer)
                  throw new Error('unable to find layer');
              layers.push(inputLayer);
              for (let i = 1; i < jsonLayers.length; i++) {
                  const jsonLayer = jsonLayers[i];
                  if (typeof jsonLayer.inputLayerIndex === 'undefined' &&
                      typeof jsonLayer.inputLayer1Index === 'undefined' &&
                      typeof jsonLayer.inputLayer2Index === 'undefined') {
                      const layer = getLayer
                          ? (_b = layerFromJSON(jsonLayer)) !== null && _b !== void 0 ? _b : getLayer(jsonLayer) : layerFromJSON(jsonLayer);
                      if (!layer)
                          throw new Error('unable to find layer');
                      layers.push(layer);
                  }
                  else if (typeof jsonLayer.inputLayerIndex === 'number') {
                      const inputLayer = layers[jsonLayer.inputLayerIndex];
                      if (!inputLayer) {
                          throw new Error('inputLayer1 not found');
                      }
                      const layer = getLayer
                          ? (_c = layerFromJSON(jsonLayer, inputLayer)) !== null && _c !== void 0 ? _c : getLayer(jsonLayer, inputLayer) : layerFromJSON(jsonLayer, inputLayer);
                      if (!layer)
                          throw new Error('unable to find layer');
                      layers.push(layer);
                  }
                  else {
                      if (typeof jsonLayer.inputLayer1Index !== 'number') {
                          throw new Error('Cannot create network from provided JSON. inputLayer1Index not defined.');
                      }
                      if (typeof jsonLayer.inputLayer2Index !== 'number') {
                          throw new Error('Cannot create network from provided JSON. inputLayer2Index not defined.');
                      }
                      const inputLayer1 = layers[jsonLayer.inputLayer1Index];
                      const inputLayer2 = layers[jsonLayer.inputLayer2Index];
                      if (inputLayer1 === undefined)
                          throw new Error(`Cannot create network from provided JSON. layer of index ${jsonLayer.inputLayer1Index} not found.`);
                      if (inputLayer2 === undefined)
                          throw new Error(`Cannot create network from provided JSON. layer of index ${jsonLayer.inputLayer2Index} not found.`);
                      const layer = getLayer
                          ? (_d = layerFromJSON(jsonLayer, inputLayer1, inputLayer2)) !== null && _d !== void 0 ? _d : getLayer(jsonLayer, inputLayer1, inputLayer2) : layerFromJSON(jsonLayer, inputLayer1, inputLayer2);
                      if (!layer)
                          throw new Error('unable to find layer');
                      layers.push(layer);
                  }
              }
              return new this({ ...json, layers });
          }
          /**
           *
           * @returns {Function}
           */
          toFunction() {
              throw new Error(`${this.constructor.name}-toFunction is not yet implemented`);
          }
      }
  
      function likely(input, net) {
          if (!net) {
              throw new TypeError(`Required parameter 'net' is of type ${typeof net}. Must be of type 'blackpard.NeuralNetwork'`);
          }
          const output = net.run(input);
          let maxProp = null;
          let maxValue = -1;
          Object.entries(output).forEach(([key, value]) => {
              if (typeof value !== 'undefined' &&
                  typeof value === 'number' &&
                  value > maxValue) {
                  maxProp = key;
                  maxValue = value;
              }
          });
          return maxProp;
      }
  
      function arraysToFloat32Arrays(arrays) {
          const result = [];
          for (let i = 0; i < arrays.length; i++) {
              result.push(Float32Array.from(arrays[i]));
          }
          return result;
      }
      function inputOutputArraysToFloat32Arrays(input, output) {
          const result = [];
          for (let i = 0; i < input.length; i++) {
              result.push(Float32Array.from(input[i]));
          }
          for (let i = 0; i < output.length; i++) {
              result.push(Float32Array.from(output[i]));
          }
          return result;
      }
      function arrayToFloat32Arrays(array) {
          const result = [];
          for (let i = 0; i < array.length; i++) {
              result.push(Float32Array.from([array[i]]));
          }
          return result;
      }
      function inputOutputArrayToFloat32Arrays(input, output) {
          const result = [];
          for (let i = 0; i < input.length; i++) {
              result.push(Float32Array.from([input[i]]));
          }
          for (let i = 0; i < output.length; i++) {
              result.push(Float32Array.from([output[i]]));
          }
          return result;
      }
      function arrayToFloat32Array(array) {
          return Float32Array.from(array);
      }
      function inputOutputObjectsToFloat32Arrays(input, output, inputTable, outputTable, inputLength, outputLength) {
          const results = [];
          for (let i = 0; i < input.length; i++) {
              const object = input[i];
              const result = new Float32Array(inputLength);
              for (const p in object) {
                  if (object.hasOwnProperty(p)) {
                      result[inputTable[p]] = object[p];
                  }
              }
              results.push(result);
          }
          for (let i = 0; i < output.length; i++) {
              const object = output[i];
              const result = new Float32Array(outputLength);
              for (const p in object) {
                  if (object.hasOwnProperty(p)) {
                      result[outputTable[p]] = object[p];
                  }
              }
              results.push(result);
          }
          return results;
      }
      function objectToFloat32Arrays(object) {
          const result = [];
          for (const p in object) {
              if (!object.hasOwnProperty(p))
                  continue;
              result.push(Float32Array.from([object[p]]));
          }
          return result;
      }
      function inputOutputObjectToFloat32Arrays(input, output) {
          const result = [];
          for (const p in input) {
              if (!input.hasOwnProperty(p))
                  continue;
              result.push(Float32Array.from([input[p]]));
          }
          for (const p in output) {
              if (!output.hasOwnProperty(p))
                  continue;
              result.push(Float32Array.from([output[p]]));
          }
          return result;
      }
      function objectToFloat32Array(object, table, length) {
          const result = new Float32Array(length);
          for (const p in object) {
              if (object.hasOwnProperty(p)) {
                  result[table[p]] = object[p];
              }
          }
          return result;
      }
  
      function max(values) {
          if (Array.isArray(values) || values instanceof Float32Array) {
              return Math.max(...values);
          }
          else {
              return Math.max(...Object.values(values));
          }
      }
  
      function mse$1(errors) {
          // mean squared error
          let sum = 0;
          for (let i = 0; i < errors.length; i++) {
              sum += errors[i] ** 2;
          }
          return sum / errors.length;
      }
  
      function getTypedArrayFn(value, table) {
          if (value.buffer instanceof ArrayBuffer) {
              return null;
          }
          if (Array.isArray(value)) {
              return arrayToFloat32Array;
          }
          if (!table)
              throw new Error('table is not Object');
          const { length } = Object.keys(table);
          return (v) => {
              const array = new Float32Array(length);
              for (const p in table) {
                  if (!table.hasOwnProperty(p))
                      continue;
                  if (typeof v[p] !== 'number')
                      continue;
                  array[table[p]] = v[p] || 0;
              }
              return array;
          };
      }
      function defaults$2() {
          return {
              inputSize: 0,
              outputSize: 0,
              binaryThresh: 0.5,
          };
      }
      function trainDefaults$2() {
          return {
              activation: 'sigmoid',
              iterations: 20000,
              errorThresh: 0.005,
              log: false,
              logPeriod: 10,
              leakyReluAlpha: 0.01,
              learningRate: 0.3,
              momentum: 0.1,
              callbackPeriod: 10,
              timeout: Infinity,
              beta1: 0.9,
              beta2: 0.999,
              epsilon: 1e-8,
          };
      }
      class NeuralNetwork {
          constructor(options = {}) {
              this.options = defaults$2();
              this.trainOpts = trainDefaults$2();
              this.sizes = [];
              this.outputLayer = -1;
              this.biases = [];
              this.weights = []; // weights for bias nodes
              this.outputs = [];
              // state for training
              this.deltas = [];
              this.changes = []; // for momentum
              this.errors = [];
              this.errorCheckInterval = 1;
              this.inputLookup = null;
              this.inputLookupLength = 0;
              this.outputLookup = null;
              this.outputLookupLength = 0;
              this._formatInput = null;
              this._formatOutput = null;
              this.runInput = (input) => {
                  this.setActivation();
                  return this.runInput(input);
              };
              this.calculateDeltas = (output) => {
                  this.setActivation();
                  return this.calculateDeltas(output);
              };
              // adam
              this.biasChangesLow = [];
              this.biasChangesHigh = [];
              this.changesLow = [];
              this.changesHigh = [];
              this.iterations = 0;
              this.options = { ...this.options, ...options };
              this.updateTrainingOptions(options);
              const { inputSize, hiddenLayers, outputSize } = this.options;
              if (inputSize && outputSize) {
                  this.sizes = [inputSize].concat(hiddenLayers !== null && hiddenLayers !== void 0 ? hiddenLayers : []).concat([outputSize]);
              }
          }
          /**
           *
           * Expects this.sizes to have been set
           */
          initialize() {
              if (!this.sizes.length) {
                  throw new Error('Sizes must be set before initializing');
              }
              this.outputLayer = this.sizes.length - 1;
              this.biases = new Array(this.outputLayer); // weights for bias nodes
              this.weights = new Array(this.outputLayer);
              this.outputs = new Array(this.outputLayer);
              // state for training
              this.deltas = new Array(this.outputLayer);
              this.changes = new Array(this.outputLayer); // for momentum
              this.errors = new Array(this.outputLayer);
              for (let layerIndex = 0; layerIndex <= this.outputLayer; layerIndex++) {
                  const size = this.sizes[layerIndex];
                  this.deltas[layerIndex] = zeros$1(size);
                  this.errors[layerIndex] = zeros$1(size);
                  this.outputs[layerIndex] = zeros$1(size);
                  if (layerIndex > 0) {
                      this.biases[layerIndex] = randos(size);
                      this.weights[layerIndex] = new Array(size);
                      this.changes[layerIndex] = new Array(size);
                      for (let nodeIndex = 0; nodeIndex < size; nodeIndex++) {
                          const prevSize = this.sizes[layerIndex - 1];
                          this.weights[layerIndex][nodeIndex] = randos(prevSize);
                          this.changes[layerIndex][nodeIndex] = zeros$1(prevSize);
                      }
                  }
              }
              this.setActivation();
              if (this.trainOpts.praxis === 'adam') {
                  this._setupAdam();
              }
          }
          setActivation(activation) {
              const value = activation !== null && activation !== void 0 ? activation : this.trainOpts.activation;
              switch (value) {
                  case 'sigmoid':
                      this.runInput = this._runInputSigmoid;
                      this.calculateDeltas = this._calculateDeltasSigmoid;
                      break;
                  case 'relu':
                      this.runInput = this._runInputRelu;
                      this.calculateDeltas = this._calculateDeltasRelu;
                      break;
                  case 'leaky-relu':
                      this.runInput = this._runInputLeakyRelu;
                      this.calculateDeltas = this._calculateDeltasLeakyRelu;
                      break;
                  case 'tanh':
                      this.runInput = this._runInputTanh;
                      this.calculateDeltas = this._calculateDeltasTanh;
                      break;
                  default:
                      throw new Error(`Unknown activation ${value}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`);
              }
          }
          get isRunnable() {
              return this.sizes.length > 0;
          }
          run(input) {
              if (!this.isRunnable) {
                  throw new Error('network not runnable');
              }
              let formattedInput;
              if (this.inputLookup) {
                  formattedInput = lookup.toArray(this.inputLookup, input, this.inputLookupLength);
              }
              else {
                  formattedInput = input;
              }
              this.validateInput(formattedInput);
              const output = this.runInput(formattedInput).slice(0);
              if (this.outputLookup) {
                  return lookup.toObject(this.outputLookup, output);
              }
              return output;
          }
          _runInputSigmoid(input) {
              this.outputs[0] = input; // set output state of input layer
              let output = null;
              for (let layer = 1; layer <= this.outputLayer; layer++) {
                  const activeLayer = this.sizes[layer];
                  const activeWeights = this.weights[layer];
                  const activeBiases = this.biases[layer];
                  const activeOutputs = this.outputs[layer];
                  for (let node = 0; node < activeLayer; node++) {
                      const weights = activeWeights[node];
                      let sum = activeBiases[node];
                      for (let k = 0; k < weights.length; k++) {
                          sum += weights[k] * input[k];
                      }
                      // sigmoid
                      activeOutputs[node] = 1 / (1 + Math.exp(-sum));
                  }
                  output = input = activeOutputs;
              }
              if (!output) {
                  throw new Error('output was empty');
              }
              return output;
          }
          _runInputRelu(input) {
              this.outputs[0] = input; // set output state of input layer
              let output = null;
              for (let layer = 1; layer <= this.outputLayer; layer++) {
                  const activeSize = this.sizes[layer];
                  const activeWeights = this.weights[layer];
                  const activeBiases = this.biases[layer];
                  const activeOutputs = this.outputs[layer];
                  for (let node = 0; node < activeSize; node++) {
                      const weights = activeWeights[node];
                      let sum = activeBiases[node];
                      for (let k = 0; k < weights.length; k++) {
                          sum += weights[k] * input[k];
                      }
                      // relu
                      activeOutputs[node] = sum < 0 ? 0 : sum;
                  }
                  output = input = activeOutputs;
              }
              if (!output) {
                  throw new Error('output was empty');
              }
              return output;
          }
          _runInputLeakyRelu(input) {
              this.outputs[0] = input; // set output state of input layer
              const { leakyReluAlpha } = this.trainOpts;
              let output = null;
              for (let layer = 1; layer <= this.outputLayer; layer++) {
                  const activeSize = this.sizes[layer];
                  const activeWeights = this.weights[layer];
                  const activeBiases = this.biases[layer];
                  const activeOutputs = this.outputs[layer];
                  for (let node = 0; node < activeSize; node++) {
                      const weights = activeWeights[node];
                      let sum = activeBiases[node];
                      for (let k = 0; k < weights.length; k++) {
                          sum += weights[k] * input[k];
                      }
                      // leaky relu
                      activeOutputs[node] = Math.max(sum, leakyReluAlpha * sum);
                  }
                  output = input = activeOutputs;
              }
              if (!output) {
                  throw new Error('output was empty');
              }
              return output;
          }
          _runInputTanh(input) {
              this.outputs[0] = input; // set output state of input layer
              let output = null;
              for (let layer = 1; layer <= this.outputLayer; layer++) {
                  const activeSize = this.sizes[layer];
                  const activeWeights = this.weights[layer];
                  const activeBiases = this.biases[layer];
                  const activeOutputs = this.outputs[layer];
                  for (let node = 0; node < activeSize; node++) {
                      const weights = activeWeights[node];
                      let sum = activeBiases[node];
                      for (let k = 0; k < weights.length; k++) {
                          sum += weights[k] * input[k];
                      }
                      // tanh
                      activeOutputs[node] = Math.tanh(sum);
                  }
                  output = input = activeOutputs;
              }
              if (!output) {
                  throw new Error('output was empty');
              }
              return output;
          }
          /**
           *
           * Verifies network sizes are initialized
           * If they are not it will initialize them based off the data set.
           */
          verifyIsInitialized(preparedData) {
              if (this.sizes.length && this.outputLayer > 0)
                  return;
              this.sizes = [];
              this.sizes.push(preparedData[0].input.length);
              if (!this.options.hiddenLayers) {
                  this.sizes.push(Math.max(3, Math.floor(preparedData[0].input.length / 2)));
              }
              else {
                  this.options.hiddenLayers.forEach((size) => {
                      this.sizes.push(size);
                  });
              }
              this.sizes.push(preparedData[0].output.length);
              this.initialize();
          }
          updateTrainingOptions(trainOpts) {
              const merged = { ...this.trainOpts, ...trainOpts };
              this.validateTrainingOptions(merged);
              this.trainOpts = merged;
              this.setLogMethod(this.trainOpts.log);
          }
          validateTrainingOptions(options) {
              const validations = {
                  activation: () => {
                      return ['sigmoid', 'relu', 'leaky-relu', 'tanh'].includes(options.activation);
                  },
                  iterations: () => {
                      const val = options.iterations;
                      return typeof val === 'number' && val > 0;
                  },
                  errorThresh: () => {
                      const val = options.errorThresh;
                      return typeof val === 'number' && val > 0 && val < 1;
                  },
                  log: () => {
                      const val = options.log;
                      return typeof val === 'function' || typeof val === 'boolean';
                  },
                  logPeriod: () => {
                      const val = options.logPeriod;
                      return typeof val === 'number' && val > 0;
                  },
                  leakyReluAlpha: () => {
                      const val = options.leakyReluAlpha;
                      return typeof val === 'number' && val > 0 && val < 1;
                  },
                  learningRate: () => {
                      const val = options.learningRate;
                      return typeof val === 'number' && val > 0 && val < 1;
                  },
                  momentum: () => {
                      const val = options.momentum;
                      return typeof val === 'number' && val > 0 && val < 1;
                  },
                  callback: () => {
                      const val = options.callback;
                      return typeof val === 'function' || val === undefined;
                  },
                  callbackPeriod: () => {
                      const val = options.callbackPeriod;
                      return typeof val === 'number' && val > 0;
                  },
                  timeout: () => {
                      const val = options.timeout;
                      return typeof val === 'number' && val > 0;
                  },
                  praxis: () => {
                      const val = options.praxis;
                      return !val || val === 'adam';
                  },
                  beta1: () => {
                      const val = options.beta1;
                      return val > 0 && val < 1;
                  },
                  beta2: () => {
                      const val = options.beta2;
                      return val > 0 && val < 1;
                  },
                  epsilon: () => {
                      const val = options.epsilon;
                      return val > 0 && val < 1;
                  },
              };
              for (const p in validations) {
                  const v = options;
                  if (!validations[p]()) {
                      throw new Error(`[${p}, ${v[p]}] is out of normal training range, your network will probably not train.`);
                  }
              }
          }
          /**
           *
           *  Gets JSON of trainOpts object
           *    NOTE: Activation is stored directly on JSON object and not in the training options
           */
          getTrainOptsJSON() {
              const { activation, iterations, errorThresh, log, logPeriod, leakyReluAlpha, learningRate, momentum, callbackPeriod, timeout, praxis, beta1, beta2, epsilon, } = this.trainOpts;
              return {
                  activation,
                  iterations,
                  errorThresh,
                  log: typeof log === 'function'
                      ? true
                      : typeof log === 'boolean'
                          ? log
                          : false,
                  logPeriod,
                  leakyReluAlpha,
                  learningRate,
                  momentum,
                  callbackPeriod,
                  timeout: timeout === Infinity ? 'Infinity' : timeout,
                  praxis,
                  beta1,
                  beta2,
                  epsilon,
              };
          }
          setLogMethod(log) {
              if (typeof log === 'function') {
                  this.trainOpts.log = log;
              }
              else if (log) {
                  this.trainOpts.log = this.logTrainingStatus;
              }
              else {
                  this.trainOpts.log = false;
              }
          }
          logTrainingStatus(status) {
              console.log(`iterations: ${status.iterations}, training error: ${status.error}`);
          }
          calculateTrainingError(data) {
              let sum = 0;
              for (let i = 0; i < data.length; ++i) {
                  sum += this.trainPattern(data[i], true);
              }
              return sum / data.length;
          }
          trainPatterns(data) {
              for (let i = 0; i < data.length; ++i) {
                  this.trainPattern(data[i]);
              }
          }
          trainingTick(data, status, endTime) {
              const { callback, callbackPeriod, errorThresh, iterations, log, logPeriod, } = this.trainOpts;
              if (status.iterations >= iterations ||
                  status.error <= errorThresh ||
                  Date.now() >= endTime) {
                  return false;
              }
              status.iterations++;
              if (log && status.iterations % logPeriod === 0) {
                  status.error = this.calculateTrainingError(data);
                  log(status);
              }
              else if (status.iterations % this.errorCheckInterval === 0) {
                  status.error = this.calculateTrainingError(data);
              }
              else {
                  this.trainPatterns(data);
              }
              if (callback && status.iterations % callbackPeriod === 0) {
                  callback({
                      iterations: status.iterations,
                      error: status.error,
                  });
              }
              return true;
          }
          prepTraining(data, options = {}) {
              this.updateTrainingOptions(options);
              const preparedData = this.formatData(data);
              const endTime = Date.now() + this.trainOpts.timeout;
              const status = {
                  error: 1,
                  iterations: 0,
              };
              this.verifyIsInitialized(preparedData);
              this.validateData(preparedData);
              return {
                  preparedData,
                  status,
                  endTime,
              };
          }
          train(data, options = {}) {
              const { preparedData, status, endTime } = this.prepTraining(data, options);
              while (true) {
                  if (!this.trainingTick(preparedData, status, endTime)) {
                      break;
                  }
              }
              return status;
          }
          async trainAsync(data, options = {}) {
              const { preparedData, status, endTime } = this.prepTraining(data, options);
              return await new Promise((resolve, reject) => {
                  try {
                      const thawedTrain = new browser.Thaw(new Array(this.trainOpts.iterations), {
                          delay: true,
                          each: () => this.trainingTick(preparedData, status, endTime) ||
                              thawedTrain.stop(),
                          done: () => resolve(status),
                      });
                      thawedTrain.tick();
                  }
                  catch (trainError) {
                      reject(trainError);
                  }
              });
          }
          trainPattern(value, logErrorRate) {
              // forward propagate
              this.runInput(value.input);
              // back propagate
              this.calculateDeltas(value.output);
              this.adjustWeights();
              if (logErrorRate) {
                  return mse$1(this.errors[this.outputLayer]);
              }
              return null;
          }
          _calculateDeltasSigmoid(target) {
              for (let layer = this.outputLayer; layer >= 0; layer--) {
                  const activeSize = this.sizes[layer];
                  const activeOutput = this.outputs[layer];
                  const activeError = this.errors[layer];
                  const activeDeltas = this.deltas[layer];
                  const nextLayer = this.weights[layer + 1];
                  for (let node = 0; node < activeSize; node++) {
                      const output = activeOutput[node];
                      let error = 0;
                      if (layer === this.outputLayer) {
                          error = target[node] - output;
                      }
                      else {
                          const deltas = this.deltas[layer + 1];
                          for (let k = 0; k < deltas.length; k++) {
                              error += deltas[k] * nextLayer[k][node];
                          }
                      }
                      activeError[node] = error;
                      activeDeltas[node] = error * output * (1 - output);
                  }
              }
          }
          _calculateDeltasRelu(target) {
              for (let layer = this.outputLayer; layer >= 0; layer--) {
                  const currentSize = this.sizes[layer];
                  const currentOutputs = this.outputs[layer];
                  const nextWeights = this.weights[layer + 1];
                  const nextDeltas = this.deltas[layer + 1];
                  const currentErrors = this.errors[layer];
                  const currentDeltas = this.deltas[layer];
                  for (let node = 0; node < currentSize; node++) {
                      const output = currentOutputs[node];
                      let error = 0;
                      if (layer === this.outputLayer) {
                          error = target[node] - output;
                      }
                      else {
                          for (let k = 0; k < nextDeltas.length; k++) {
                              error += nextDeltas[k] * nextWeights[k][node];
                          }
                      }
                      currentErrors[node] = error;
                      currentDeltas[node] = output > 0 ? error : 0;
                  }
              }
          }
          _calculateDeltasLeakyRelu(target) {
              const alpha = this.trainOpts.leakyReluAlpha;
              for (let layer = this.outputLayer; layer >= 0; layer--) {
                  const currentSize = this.sizes[layer];
                  const currentOutputs = this.outputs[layer];
                  const nextDeltas = this.deltas[layer + 1];
                  const nextWeights = this.weights[layer + 1];
                  const currentErrors = this.errors[layer];
                  const currentDeltas = this.deltas[layer];
                  for (let node = 0; node < currentSize; node++) {
                      const output = currentOutputs[node];
                      let error = 0;
                      if (layer === this.outputLayer) {
                          error = target[node] - output;
                      }
                      else {
                          for (let k = 0; k < nextDeltas.length; k++) {
                              error += nextDeltas[k] * nextWeights[k][node];
                          }
                      }
                      currentErrors[node] = error;
                      currentDeltas[node] = output > 0 ? error : alpha * error;
                  }
              }
          }
          _calculateDeltasTanh(target) {
              for (let layer = this.outputLayer; layer >= 0; layer--) {
                  const currentSize = this.sizes[layer];
                  const currentOutputs = this.outputs[layer];
                  const nextDeltas = this.deltas[layer + 1];
                  const nextWeights = this.weights[layer + 1];
                  const currentErrors = this.errors[layer];
                  const currentDeltas = this.deltas[layer];
                  for (let node = 0; node < currentSize; node++) {
                      const output = currentOutputs[node];
                      let error = 0;
                      if (layer === this.outputLayer) {
                          error = target[node] - output;
                      }
                      else {
                          for (let k = 0; k < nextDeltas.length; k++) {
                              error += nextDeltas[k] * nextWeights[k][node];
                          }
                      }
                      currentErrors[node] = error;
                      currentDeltas[node] = (1 - output * output) * error;
                  }
              }
          }
          /**
           *
           * Changes weights of networks
           */
          adjustWeights() {
              const { learningRate, momentum } = this.trainOpts;
              for (let layer = 1; layer <= this.outputLayer; layer++) {
                  const incoming = this.outputs[layer - 1];
                  const activeSize = this.sizes[layer];
                  const activeDelta = this.deltas[layer];
                  const activeChanges = this.changes[layer];
                  const activeWeights = this.weights[layer];
                  const activeBiases = this.biases[layer];
                  for (let node = 0; node < activeSize; node++) {
                      const delta = activeDelta[node];
                      for (let k = 0; k < incoming.length; k++) {
                          let change = activeChanges[node][k];
                          change = learningRate * delta * incoming[k] + momentum * change;
                          activeChanges[node][k] = change;
                          activeWeights[node][k] += change;
                      }
                      activeBiases[node] += learningRate * delta;
                  }
              }
          }
          _setupAdam() {
              this.biasChangesLow = [];
              this.biasChangesHigh = [];
              this.changesLow = [];
              this.changesHigh = [];
              this.iterations = 0;
              for (let layer = 0; layer <= this.outputLayer; layer++) {
                  const size = this.sizes[layer];
                  if (layer > 0) {
                      this.biasChangesLow[layer] = zeros$1(size);
                      this.biasChangesHigh[layer] = zeros$1(size);
                      this.changesLow[layer] = new Array(size);
                      this.changesHigh[layer] = new Array(size);
                      for (let node = 0; node < size; node++) {
                          const prevSize = this.sizes[layer - 1];
                          this.changesLow[layer][node] = zeros$1(prevSize);
                          this.changesHigh[layer][node] = zeros$1(prevSize);
                      }
                  }
              }
              this.adjustWeights = this._adjustWeightsAdam;
          }
          _adjustWeightsAdam() {
              this.iterations++;
              const { iterations } = this;
              const { beta1, beta2, epsilon, learningRate } = this.trainOpts;
              for (let layer = 1; layer <= this.outputLayer; layer++) {
                  const incoming = this.outputs[layer - 1];
                  const currentSize = this.sizes[layer];
                  const currentDeltas = this.deltas[layer];
                  const currentChangesLow = this.changesLow[layer];
                  const currentChangesHigh = this.changesHigh[layer];
                  const currentWeights = this.weights[layer];
                  const currentBiases = this.biases[layer];
                  const currentBiasChangesLow = this.biasChangesLow[layer];
                  const currentBiasChangesHigh = this.biasChangesHigh[layer];
                  for (let node = 0; node < currentSize; node++) {
                      const delta = currentDeltas[node];
                      for (let k = 0; k < incoming.length; k++) {
                          const gradient = delta * incoming[k];
                          const changeLow = currentChangesLow[node][k] * beta1 + (1 - beta1) * gradient;
                          const changeHigh = currentChangesHigh[node][k] * beta2 +
                              (1 - beta2) * gradient * gradient;
                          const momentumCorrection = changeLow / (1 - Math.pow(beta1, iterations));
                          const gradientCorrection = changeHigh / (1 - Math.pow(beta2, iterations));
                          currentChangesLow[node][k] = changeLow;
                          currentChangesHigh[node][k] = changeHigh;
                          currentWeights[node][k] +=
                              (learningRate * momentumCorrection) /
                                  (Math.sqrt(gradientCorrection) + epsilon);
                      }
                      const biasGradient = currentDeltas[node];
                      const biasChangeLow = currentBiasChangesLow[node] * beta1 + (1 - beta1) * biasGradient;
                      const biasChangeHigh = currentBiasChangesHigh[node] * beta2 +
                          (1 - beta2) * biasGradient * biasGradient;
                      const biasMomentumCorrection = currentBiasChangesLow[node] / (1 - Math.pow(beta1, iterations));
                      const biasGradientCorrection = currentBiasChangesHigh[node] / (1 - Math.pow(beta2, iterations));
                      currentBiasChangesLow[node] = biasChangeLow;
                      currentBiasChangesHigh[node] = biasChangeHigh;
                      currentBiases[node] +=
                          (learningRate * biasMomentumCorrection) /
                              (Math.sqrt(biasGradientCorrection) + epsilon);
                  }
              }
          }
          validateData(data) {
              const inputSize = this.sizes[0];
              const outputSize = this.sizes[this.sizes.length - 1];
              const { length } = data;
              for (let i = 0; i < length; i++) {
                  const { input, output } = data[i];
                  if (input.length !== inputSize) {
                      throw new Error(`input at index ${i} length ${input.length} must be ${inputSize}`);
                  }
                  if (data[i].output.length !== outputSize) {
                      throw new Error(`output at index ${i} length ${output.length} must be ${outputSize}`);
                  }
              }
          }
          validateInput(formattedInput) {
              const inputSize = this.sizes[0];
              if (formattedInput.length !== inputSize) {
                  throw new Error(`input length ${formattedInput.length} must match options.inputSize of ${inputSize}`);
              }
          }
          formatData(data) {
              if (!Array.isArray(data[0].input)) {
                  if (this.inputLookup) {
                      this.inputLookupLength = Object.keys(this.inputLookup).length;
                  }
                  else {
                      const inputLookup = new LookupTable(data, 'input');
                      this.inputLookup = inputLookup.table;
                      this.inputLookupLength = inputLookup.length;
                  }
              }
              if (!Array.isArray(data[0].output)) {
                  if (this.outputLookup) {
                      this.outputLookupLength = Object.keys(this.outputLookup).length;
                  }
                  else {
                      const lookup = new LookupTable(data, 'output');
                      this.outputLookup = lookup.table;
                      this.outputLookupLength = lookup.length;
                  }
              }
              if (!this._formatInput) {
                  this._formatInput = getTypedArrayFn(data[0].input, this.inputLookup);
              }
              if (!this._formatOutput) {
                  this._formatOutput = getTypedArrayFn(data[0].output, this.outputLookup);
              }
              // turn sparse hash input into arrays with 0s as filler
              if (this._formatInput && this._formatOutput) {
                  const result = [];
                  for (let i = 0; i < data.length; i++) {
                      result.push({
                          input: this._formatInput(data[i].input),
                          output: this._formatOutput(data[i].output),
                      });
                  }
                  return result;
              }
              if (this._formatInput) {
                  const result = [];
                  for (let i = 0; i < data.length; i++) {
                      result.push({
                          input: this._formatInput(data[i].input),
                          output: data[i].output,
                      });
                  }
                  return result;
              }
              if (this._formatOutput) {
                  const result = [];
                  for (let i = 0; i < data.length; i++) {
                      result.push({
                          input: data[i].input,
                          output: this._formatOutput(data[i].output),
                      });
                  }
                  return result;
              }
              return data;
          }
          addFormat(data) {
              var _a, _b;
              if (!Array.isArray(data.input) || typeof data.input[0] !== 'number') {
                  this.inputLookup = lookup.addKeys(data.input, (_a = this.inputLookup) !== null && _a !== void 0 ? _a : {});
                  if (this.inputLookup) {
                      this.inputLookupLength = Object.keys(this.inputLookup).length;
                  }
              }
              if (!Array.isArray(data.output) || typeof data.output[0] !== 'number') {
                  this.outputLookup = lookup.addKeys(data.output, (_b = this.outputLookup) !== null && _b !== void 0 ? _b : {});
                  if (this.outputLookup) {
                      this.outputLookupLength = Object.keys(this.outputLookup).length;
                  }
              }
          }
          test(data) {
              const { preparedData } = this.prepTraining(data);
              // for binary classification problems with one output node
              const isBinary = preparedData[0].output.length === 1;
              // for classification problems
              const misclasses = [];
              // run each pattern through the trained network and collect
              // error and misclassification statistics
              let errorSum = 0;
              if (isBinary) {
                  let falsePos = 0;
                  let falseNeg = 0;
                  let truePos = 0;
                  let trueNeg = 0;
                  for (let i = 0; i < preparedData.length; i++) {
                      const output = this.runInput(preparedData[i].input);
                      const target = preparedData[i].output;
                      const actual = output[0] > this.options.binaryThresh ? 1 : 0;
                      const expected = target[0];
                      if (actual !== expected) {
                          const misclass = preparedData[i];
                          misclasses.push({
                              input: misclass.input,
                              output: misclass.output,
                              actual,
                              expected,
                          });
                      }
                      if (actual === 0 && expected === 0) {
                          trueNeg++;
                      }
                      else if (actual === 1 && expected === 1) {
                          truePos++;
                      }
                      else if (actual === 0 && expected === 1) {
                          falseNeg++;
                      }
                      else if (actual === 1 && expected === 0) {
                          falsePos++;
                      }
                      errorSum += mse$1(output.map((value, i) => {
                          return target[i] - value;
                      }));
                  }
                  return {
                      error: errorSum / preparedData.length,
                      misclasses,
                      total: preparedData.length,
                      trueNeg,
                      truePos,
                      falseNeg,
                      falsePos,
                      precision: truePos > 0 ? truePos / (truePos + falsePos) : 0,
                      recall: truePos > 0 ? truePos / (truePos + falseNeg) : 0,
                      accuracy: (trueNeg + truePos) / preparedData.length,
                  };
              }
              for (let i = 0; i < preparedData.length; i++) {
                  const output = this.runInput(preparedData[i].input);
                  const target = preparedData[i].output;
                  const actual = output.indexOf(max(output));
                  const expected = target.indexOf(max(target));
                  if (actual !== expected) {
                      const misclass = preparedData[i];
                      misclasses.push({
                          input: misclass.input,
                          output: misclass.output,
                          actual,
                          expected,
                      });
                  }
                  errorSum += mse$1(output.map((value, i) => {
                      return target[i] - value;
                  }));
              }
              return {
                  error: errorSum / preparedData.length,
                  misclasses,
                  total: preparedData.length,
              };
          }
          toJSON() {
              var _a, _b;
              if (!this.isRunnable) {
                  this.initialize();
              }
              // use Array.from, keeping json small
              const jsonLayerWeights = this.weights.map((layerWeights) => {
                  return layerWeights.map((layerWeights) => Array.from(layerWeights));
              });
              const jsonLayerBiases = this.biases.map((layerBiases) => Array.from(layerBiases));
              const jsonLayers = [];
              const outputLength = this.sizes.length - 1;
              for (let i = 0; i <= outputLength; i++) {
                  jsonLayers.push({
                      weights: (_a = jsonLayerWeights[i]) !== null && _a !== void 0 ? _a : [],
                      biases: (_b = jsonLayerBiases[i]) !== null && _b !== void 0 ? _b : [],
                  });
              }
              return {
                  type: 'NeuralNetwork',
                  sizes: [...this.sizes],
                  layers: jsonLayers,
                  inputLookup: this.inputLookup ? { ...this.inputLookup } : null,
                  inputLookupLength: this.inputLookupLength,
                  outputLookup: this.outputLookup ? { ...this.outputLookup } : null,
                  outputLookupLength: this.outputLookupLength,
                  options: { ...this.options },
                  trainOpts: this.getTrainOptsJSON(),
              };
          }
          fromJSON(json) {
              this.options = { ...defaults$2(), ...json.options };
              if (json.hasOwnProperty('trainOpts')) {
                  const trainOpts = {
                      ...json.trainOpts,
                      timeout: json.trainOpts.timeout === 'Infinity'
                          ? Infinity
                          : json.trainOpts.timeout,
                  };
                  this.updateTrainingOptions(trainOpts);
              }
              this.sizes = json.sizes;
              this.initialize();
              this.inputLookup = json.inputLookup ? { ...json.inputLookup } : null;
              this.inputLookupLength = json.inputLookupLength;
              this.outputLookup = json.outputLookup ? { ...json.outputLookup } : null;
              this.outputLookupLength = json.outputLookupLength;
              const jsonLayers = json.layers;
              const layerWeights = this.weights.map((layerWeights, layerIndex) => {
                  return jsonLayers[layerIndex].weights.map((layerWeights) => Float32Array.from(layerWeights));
              });
              const layerBiases = this.biases.map((layerBiases, layerIndex) => Float32Array.from(jsonLayers[layerIndex].biases));
              for (let i = 0; i <= this.outputLayer; i++) {
                  this.weights[i] = layerWeights[i] || [];
                  this.biases[i] = layerBiases[i] || [];
              }
              return this;
          }
          toFunction(cb) {
              const { activation, leakyReluAlpha } = this.trainOpts;
              let needsVar = false;
              const nodeHandle = (layerIndex, nodeIndex) => {
                  if (layerIndex === 0) {
                      return `(input[${nodeIndex}]||0)`;
                  }
                  const weights = this.weights[layerIndex][nodeIndex];
                  const bias = this.biases[layerIndex][nodeIndex];
                  if (!weights) {
                      throw new Error(`weights at layerIndex ${layerIndex} & nodeIndex ${nodeIndex} not found`);
                  }
                  if (!bias) {
                      throw new Error(`bias as layerIndex ${layerIndex} & nodeIndex ${nodeIndex} not found`);
                  }
                  const weightsArray = [];
                  weights.forEach((weight, subNodeIndex) => {
                      if (weight < 0) {
                          weightsArray.push(`${weight}*${nodeHandle(layerIndex - 1, subNodeIndex)}`);
                      }
                      else {
                          weightsArray.push(`+${weight}*${nodeHandle(layerIndex - 1, subNodeIndex)}`);
                      }
                  });
                  const result = `(${bias.toString()}${weightsArray.join('')})`;
                  switch (activation) {
                      case 'sigmoid':
                          return `1/(1+1/Math.exp(${result}))`;
                      case 'relu': {
                          needsVar = true;
                          return `((v=${result})<0?0:v)`;
                      }
                      case 'leaky-relu': {
                          needsVar = true;
                          return `Math.max((v=${result}),${leakyReluAlpha}*v)`;
                      }
                      case 'tanh':
                          return `Math.tanh(${result})`;
                      default:
                          throw new Error(`Unknown activation ${activation}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`);
                  }
              };
              function checkKeys(keys) {
                  if (keys.find((v) => v.includes('"'))) {
                      throw new Error(`key contains '"', which is not compatible`);
                  }
              }
              const layersAsMath = [];
              let result;
              let inputLookup = '';
              if (this.inputLookup) {
                  const keys = Object.keys(this.inputLookup);
                  checkKeys(keys);
                  inputLookup = `input = new Float32Array([${Object.keys(this.inputLookup)
                  .map((key) => `input["${key}"]`)
                  .join(',')}]);`;
              }
              if (this.sizes.length < 1)
                  throw new Error('No layers');
              for (let nodeIndex = 0; nodeIndex < this.sizes[this.outputLayer]; nodeIndex++) {
                  layersAsMath.push(nodeHandle(this.outputLayer, nodeIndex));
              }
              if (this.outputLookup) {
                  const keys = Object.keys(this.outputLookup);
                  checkKeys(keys);
                  const values = keys
                      .map((key, i) => `"${key}":${layersAsMath[i]}`)
                      .join(',');
                  result = `{${values}}`;
              }
              else {
                  result = `[${layersAsMath.join(',')}]`;
              }
              const source = `${inputLookup}${needsVar ? 'var v;' : ''}return ${result};`;
              // eslint-disable-next-line @typescript-eslint/no-implied-eval,no-new-func
              return new Function('input', cb ? cb(source) : source);
          }
      }
  
      function weightedSumSigmoid(weights, biases, inputs) {
          let sum = biases[this.thread.x];
          for (let k = 0; k < this.constants.size; k++) {
              sum += weights[this.thread.x][k] * inputs[k];
          }
          // sigmoid
          return 1 / (1 + Math.exp(-sum));
      }
      function weightedSumRelu(weights, biases, inputs) {
          let sum = biases[this.thread.x];
          for (let k = 0; k < this.constants.size; k++) {
              sum += weights[this.thread.x][k] * inputs[k];
          }
          // relu
          return sum < 0 ? 0 : sum;
      }
      function weightedSumLeakyRelu(weights, biases, inputs) {
          let sum = biases[this.thread.x];
          for (let k = 0; k < this.constants.size; k++) {
              sum += weights[this.thread.x][k] * inputs[k];
          }
          // leaky relu
          return sum < 0 ? 0 : 0.01 * sum;
      }
      function weightedSumTanh(weights, biases, inputs) {
          let sum = biases[this.thread.x];
          for (let k = 0; k < this.constants.size; k++) {
              sum += weights[this.thread.x][k] * inputs[k];
          }
          // tanh
          return Math.tanh(sum);
      }
      function calcErrorOutput(output, target) {
          return target - output;
      }
      function calcDeltasSigmoid(error, output) {
          // sigmoid derivative
          return error * output * (1 - output);
      }
      function calcDeltasRelu(error, output) {
          // relu derivative
          return output > 0 ? error : 0;
      }
      function calcDeltasLeakyRelu(error, output) {
          // leaky relu derivative
          return output > 0 ? error : 0.01 * error;
      }
      function calcDeltasTanh(error, output) {
          // tanh derivative
          return (1 - output * output) * error;
      }
      function calcError(x, size, nextWeights, nextDeltas) {
          let error = 0;
          for (let k = 0; k < size; k++) {
              error += nextDeltas[k] * nextWeights[k][x];
          }
          return error;
      }
      function calcChanges(learningRate, momentum, previousChange, delta, previousOutput) {
          return learningRate * delta * previousOutput + momentum * previousChange;
      }
      function addWeights(change, weight) {
          return change + weight;
      }
      function addBiases(biases, deltas) {
          return (biases[this.thread.x] + deltas[this.thread.x] * this.constants.learningRate);
      }
      // mean squared error, reimplemented for GPU
      function mse(errors) {
          let sum = 0;
          for (let i = 0; i < this.constants.size; i++) {
              sum += errors[i] ** 2;
          }
          return sum / this.constants.size;
      }
      class NeuralNetworkGPU extends NeuralNetwork {
          constructor(options = {}) {
              super(options);
              this.texturizeInputData = () => {
                  throw new Error('not yet setup');
              };
              this.forwardPropagate = [];
              this.backwardPropagate = [];
              this.changesPropagate = [];
              this.biasesPropagate = [];
              this.getMSE = () => {
                  throw new Error('not yet setup');
              };
              this._addMSE = () => {
                  throw new Error('not yet setup');
              };
              this._divideMSESum = () => {
                  throw new Error('not yet setup');
              };
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-expect-error
              this.outputs = [];
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-expect-error
              this.deltas = [];
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-expect-error
              this.errors = [];
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-expect-error
              this.weights = [];
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-expect-error
              this.changes = [];
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-expect-error
              this.biases = [];
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-expect-error
              this.runInput = (input) => {
                  let output;
                  this.outputs[0] = input;
                  for (let layer = 1; layer <= this.outputLayer; layer++) {
                      release(this.outputs[layer]);
                      this.outputs[layer] = this.forwardPropagate[layer](this.weights[layer], this.biases[layer], input);
                      output = input = this.outputs[layer];
                  }
                  return output;
              };
              this.calculateDeltas = (target) => {
                  for (let layer = this.outputLayer; layer > 0; layer--) {
                      release(this.deltas[layer]);
                      release(this.errors[layer]);
                      let output;
                      if (layer === this.outputLayer) {
                          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                          // @ts-expect-error
                          output = this.backwardPropagate[layer](this.outputs[layer], target);
                      }
                      else {
                          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                          // @ts-expect-error
                          output = this.backwardPropagate[layer](this.weights[layer + 1], this.outputs[layer], this.deltas[layer + 1]);
                      }
                      this.deltas[layer] = output.result;
                      this.errors[layer] = output.error;
                  }
              };
              this.errorCheckInterval = 100;
              this.gpu = new gpuBrowser.GPU({ mode: options.mode });
          }
          initialize() {
              super.initialize();
              this.buildRunInput();
              this.buildCalculateDeltas();
              this.buildGetChanges();
              this.buildChangeBiases();
              this.buildGetMSE();
          }
          setActivation() { }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          trainPattern(value, logErrorRate) {
              // forward propagate
              this.runInput(value.input);
              // back propagate
              this.calculateDeltas(value.output);
              this.adjustWeights();
              if (logErrorRate) {
                  return this.getMSE(this.errors[this.outputLayer]);
              }
              return null;
          }
          calculateTrainingError(data) {
              let sum = new Float32Array([0]);
              for (let i = 0; i < data.length; ++i) {
                  const prevSum = sum;
                  const error = this.trainPattern(data[i], true);
                  sum = this._addMSE(sum, error);
                  release(error);
                  release(prevSum);
              }
              const result = this._divideMSESum(data.length, sum);
              release(sum);
              return (result instanceof gpuBrowser.Texture
                  ? result.toArray()
                  : result)[0];
          }
          adjustWeights() {
              this.getChanges();
              this.changeBiases();
          }
          buildRunInput() {
              let weightedSum = null;
              switch (this.trainOpts.activation) {
                  case 'sigmoid':
                      weightedSum = weightedSumSigmoid;
                      break;
                  case 'relu':
                      weightedSum = weightedSumRelu;
                      break;
                  case 'leaky-relu':
                      weightedSum = weightedSumLeakyRelu;
                      break;
                  case 'tanh':
                      weightedSum = weightedSumTanh;
                      break;
                  default:
                      throw new Error(`Unknown activation ${this.trainOpts.activation}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`);
              }
              for (let layer = 1; layer <= this.outputLayer; layer++) {
                  this.forwardPropagate[layer] = this.gpu.createKernel(weightedSum, {
                      output: [this.sizes[layer]],
                      pipeline: true,
                      constants: {
                          size: this.sizes[layer - 1],
                      },
                      immutable: true,
                  });
              }
              this.texturizeInputData = this.gpu.createKernel(function (value) {
                  return value[this.thread.x];
              }, {
                  output: [this.sizes[1]],
                  pipeline: true,
                  immutable: true,
              });
          }
          buildCalculateDeltas() {
              let calcDeltas;
              switch (this.trainOpts.activation) {
                  case 'sigmoid':
                      calcDeltas = calcDeltasSigmoid;
                      break;
                  case 'relu':
                      calcDeltas = calcDeltasRelu;
                      break;
                  case 'leaky-relu':
                      calcDeltas = calcDeltasLeakyRelu;
                      break;
                  case 'tanh':
                      calcDeltas = calcDeltasTanh;
                      break;
                  default:
                      throw new Error(`Unknown activation ${this.trainOpts.activation}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`);
              }
              calcDeltas = gpuBrowser.alias(gpuBrowser.utils.getMinifySafeName(() => calcDeltas), calcDeltas);
              this.gpu.addFunction(calcDeltas);
              for (let layer = this.outputLayer; layer > 0; layer--) {
                  if (layer === this.outputLayer) {
                      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                      // @ts-expect-error
                      this.backwardPropagate[this.outputLayer] = this.gpu.createKernelMap({
                          error: calcErrorOutput,
                      }, function (outputs, targets) {
                          const output = outputs[this.thread.x];
                          const target = targets[this.thread.x];
                          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                          // @ts-expect-error
                          return calcDeltas(calcErrorOutput(output, target), output);
                      }, {
                          output: [this.sizes[this.outputLayer]],
                          pipeline: true,
                          immutable: true,
                      });
                  }
                  else {
                      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                      // @ts-expect-error
                      this.backwardPropagate[layer] = this.gpu.createKernelMap({
                          error: calcError,
                      }, function (nextWeights, outputs, nextDeltas) {
                          const output = outputs[this.thread.x];
                          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                          // @ts-expect-error
                          return calcDeltas(calcError(this.thread.x, this.constants.size, nextWeights, nextDeltas), output);
                      }, {
                          output: [this.sizes[layer]],
                          pipeline: true,
                          constants: {
                              size: this.sizes[layer + 1],
                          },
                          immutable: true,
                      });
                  }
              }
          }
          buildGetChanges() {
              for (let layer = 1; layer <= this.outputLayer; layer++) {
                  // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                  // @ts-expect-error
                  this.changesPropagate[layer] = this.gpu.createKernelMap({
                      weights: addWeights,
                      changes: calcChanges,
                  }, function (previousOutputs, deltas, weights, previousChanges) {
                      const change = calcChanges(this.constants.learningRate, this.constants.momentum, previousChanges[this.thread.y][this.thread.x], deltas[this.thread.y], previousOutputs[this.thread.x]);
                      return addWeights(change, weights[this.thread.y][this.thread.x]);
                  }, {
                      output: [this.sizes[layer - 1], this.sizes[layer]],
                      pipeline: true,
                      constants: {
                          size: this.sizes[layer - 1],
                          learningRate: this.trainOpts.learningRate,
                          momentum: this.trainOpts.momentum,
                      },
                      immutable: true,
                  });
              }
          }
          getChanges() {
              for (let layer = 1; layer <= this.outputLayer; layer++) {
                  const weights = this.weights[layer];
                  const changes = this.changes[layer];
                  const output = this.changesPropagate[layer](this.outputs[layer - 1], this.deltas[layer], weights, changes);
                  release(weights);
                  release(changes);
                  this.weights[layer] = output.weights;
                  this.changes[layer] = output.changes;
                  release(output.result);
              }
          }
          buildChangeBiases() {
              for (let layer = 1; layer <= this.outputLayer; layer++) {
                  this.biasesPropagate[layer] = this.gpu.createKernel(addBiases, {
                      output: [this.sizes[layer]],
                      pipeline: true,
                      constants: {
                          learningRate: this.trainOpts.learningRate,
                      },
                      immutable: true,
                  });
              }
          }
          changeBiases() {
              for (let layer = 1; layer <= this.outputLayer; layer++) {
                  const biases = this.biases[layer];
                  this.biases[layer] = this.biasesPropagate[layer](biases, this.deltas[layer]);
                  release(biases);
              }
          }
          buildGetMSE() {
              this.getMSE = this.gpu.createKernel(mse, {
                  output: [1],
                  constants: {
                      size: this.sizes[this.outputLayer],
                  },
                  pipeline: true,
                  immutable: true,
              });
              this._addMSE = this.gpu.createKernel(function (value1, value2) {
                  return value1[0] + value2[0];
              }, {
                  output: [1],
                  pipeline: true,
                  immutable: true,
              });
              this._divideMSESum = this.gpu.createKernel(function (length, mseSum) {
                  const value = mseSum[0];
                  if (value > 0) {
                      return value / length;
                  }
                  return 0;
              }, {
                  output: [1],
              });
          }
          run(input) {
              if (!this.isRunnable) {
                  throw new Error('network not runnable');
              }
              let formattedInput;
              if (this.inputLookup) {
                  formattedInput = lookup.toArray(this.inputLookup, input, this.inputLookupLength);
              }
              else {
                  formattedInput = input;
              }
              this.validateInput(formattedInput);
              const outputTextures = this.runInput(formattedInput);
              const output = outputTextures instanceof gpuBrowser.Texture
                  ? outputTextures.toArray()
                  : outputTextures;
              if (this.outputLookup) {
                  return lookup.toObject(this.outputLookup, output);
              }
              return output;
          }
          // @ts-expect-error the underlying network works as normal, but we are working on the GPU
          prepTraining(data, options = {}) {
              this.updateTrainingOptions(options);
              const preparedData = this.formatData(data);
              const endTime = Date.now() + this.trainOpts.timeout;
              const status = {
                  error: 1,
                  iterations: 0,
              };
              this.verifyIsInitialized(preparedData);
              const texturizeOutputData = this.gpu.createKernel(function (value) {
                  return value[this.thread.x];
              }, {
                  output: [preparedData[0].output.length],
                  pipeline: true,
                  immutable: true,
              });
              return {
                  preparedData: preparedData.map((set) => ({
                      input: this.texturizeInputData(set.input),
                      output: texturizeOutputData(set.output),
                  })),
                  status,
                  endTime,
              };
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          toFunction() {
              throw new Error(`${this.constructor.name}-toFunction is not yet implemented`);
          }
          toJSON() {
              var _a, _b;
              if (this.sizes === null) {
                  this.initialize();
              }
              // use Array.from, keeping json small
              const jsonLayerWeights = this.weights.map((layerWeights) => {
                  return (layerWeights instanceof gpuBrowser.Texture
                      ? layerWeights.toArray()
                      : layerWeights).map((layerWeights) => Array.from(layerWeights));
              });
              const jsonLayerBiases = this.biases.map((layerBiases) => Array.from(layerBiases instanceof gpuBrowser.Texture
                  ? layerBiases.toArray()
                  : layerBiases));
              const jsonLayers = [];
              for (let i = 0; i <= this.outputLayer; i++) {
                  jsonLayers.push({
                      weights: (_a = jsonLayerWeights[i]) !== null && _a !== void 0 ? _a : [],
                      biases: (_b = jsonLayerBiases[i]) !== null && _b !== void 0 ? _b : [],
                  });
              }
              return {
                  type: 'NeuralNetworkGPU',
                  sizes: [...this.sizes],
                  layers: jsonLayers,
                  inputLookup: this.inputLookup ? { ...this.inputLookup } : null,
                  inputLookupLength: this.inputLookupLength,
                  outputLookup: this.outputLookup ? { ...this.outputLookup } : null,
                  outputLookupLength: this.outputLookupLength,
                  options: { ...this.options },
                  trainOpts: this.getTrainOptsJSON(),
              };
          }
      }
  
      class RecurrentConnection extends Internal {
          constructor() {
              super(...arguments);
              this.settings = {};
              this.layer = null;
          }
          setLayer(layer) {
              this.layer = layer;
          }
          get width() {
              if (!this.layer)
                  throw new Error('layer not set');
              return this.layer.width;
          }
          set width(value) {
              throw new Error(`${this.constructor.name}-width is not yet implemented`);
          }
          get height() {
              if (!this.layer)
                  throw new Error('layer not set');
              return this.layer.height;
          }
          set height(value) {
              throw new Error(`${this.constructor.name}-height is not yet implemented`);
          }
          get deltas() {
              if (!this.layer)
                  throw new Error('layer not set');
              return this.layer.deltas;
          }
          set deltas(deltas) {
              if (!this.layer)
                  throw new Error('layer not set');
              release(this.layer.deltas);
              this.layer.deltas = deltas;
          }
          get weights() {
              if (!this.layer)
                  throw new Error('layer not set');
              return this.layer.weights;
          }
          set weights(weights) {
              if (!this.layer)
                  throw new Error('layer not set');
              release(this.layer.weights);
              this.layer.weights = weights;
          }
          predict() {
              // throw new Error(`${this.constructor.name}-predict is not yet implemented`)
          }
          compare() {
              // throw new Error(`${this.constructor.name}-compare is not yet implemented`)
          }
          learn() {
              throw new Error('no longer using');
          }
          setupKernels() {
              // throw new Error(
              //   `${this.constructor.name}-setupKernels is not yet implemented`
              // )
          }
          reuseKernels() {
              // throw new Error(
              //   `${this.constructor.name}-reuseKernels is not yet implemented`
              // )
          }
      }
  
      class Recurrent extends FeedForward {
          // TODO: use generics in extend
          constructor(options = {}) {
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-expect-error
              super(options);
              this.trainOpts = {};
              this._outputConnection = null;
              this._layerSets = [];
              this._hiddenLayerOutputIndices = [];
              this._model = null;
          }
          _connectLayers() {
              if (!this.options.inputLayer) {
                  throw new Error('inputLayer not found');
              }
              if (!this.options.outputLayer) {
                  throw new Error('outputLayer not found');
              }
              const inputLayer = this.options.inputLayer();
              const hiddenLayers = this._connectHiddenLayers(inputLayer);
              const outputLayer = this.options.outputLayer(hiddenLayers[hiddenLayers.length - 1], -1);
              return {
                  inputLayer,
                  hiddenLayers,
                  outputLayer,
              };
          }
          _connectLayersDeep() {
              const layers = [];
              const previousLayers = this._layerSets[this._layerSets.length - 1];
              let usedHiddenLayerOutputIndex = 0;
              function findInputLayer(inputLayer) {
                  const index = previousLayers.indexOf(inputLayer);
                  if (index < 0)
                      throw new Error('unable to find layer');
                  return layers[index];
              }
              function layerSettings(layer) {
                  return {
                      ...layer.settings,
                      weights: null,
                      deltas: null,
                      praxis: null,
                  };
              }
              for (let i = 0; i < previousLayers.length; i++) {
                  const previousLayer = previousLayers[i];
                  let layer;
                  if (previousLayer instanceof Activation) {
                      layer = new previousLayer.constructor(findInputLayer(previousLayer.inputLayer), layerSettings(previousLayer));
                  }
                  else if (previousLayer instanceof EntryPoint) {
                      layer = new previousLayer.constructor(layerSettings(previousLayer));
                  }
                  else if (previousLayer instanceof Filter) {
                      layer = new previousLayer.constructor(layerSettings(previousLayer.inputLayer), findInputLayer(previousLayer.inputLayer));
                  }
                  else if (previousLayer instanceof Internal) {
                      const previousHiddenLayerOutput = previousLayers[this._hiddenLayerOutputIndices[usedHiddenLayerOutputIndex++]];
                      if (previousLayer instanceof RecurrentConnection) {
                          throw new Error('unfinished');
                      }
                      else if (previousLayer instanceof RecurrentInput) {
                          layer = new RecurrentInput(previousHiddenLayerOutput);
                      }
                      else if (previousLayer instanceof RecurrentZeros) {
                          layer = new RecurrentInput(previousHiddenLayerOutput);
                      }
                      else {
                          throw new Error(`hidden layer ${previousLayer.constructor.name} extends unknown hidden layer`);
                      }
                  }
                  else if (previousLayer instanceof InternalModel ||
                      previousLayer instanceof Model) {
                      layer = previousLayer;
                  }
                  else if (previousLayer instanceof Modifier) {
                      layer = new previousLayer.constructor(findInputLayer(previousLayer.inputLayer), layerSettings(previousLayer.inputLayer));
                  }
                  else if (previousLayer instanceof Operator) {
                      layer = new previousLayer.constructor(findInputLayer(previousLayer.inputLayer1), findInputLayer(previousLayer.inputLayer2), layerSettings(previousLayer));
                  }
                  else if (previousLayer instanceof Target) {
                      layer = new previousLayer.constructor(layerSettings(previousLayer), findInputLayer(previousLayer.inputLayer));
                  }
                  else {
                      throw new Error(`hidden layer ${previousLayer.constructor.name} extends unknown hidden layer`);
                  }
                  layers.push(layer);
              }
              return layers;
          }
          _connectHiddenLayers(previousLayer) {
              const hiddenLayers = [];
              if (!this.options.hiddenLayers)
                  throw new Error('hiddenLayers not defined');
              for (let i = 0; i < this.options.hiddenLayers.length; i++) {
                  const recurrentInput = new RecurrentZeros();
                  const hiddenLayer = this.options.hiddenLayers[i](previousLayer, recurrentInput, i);
                  previousLayer = hiddenLayer;
                  hiddenLayers.push(hiddenLayer);
              }
              return hiddenLayers;
          }
          initialize() {
              this._outputConnection = new RecurrentConnection();
              let layerSet;
              if (this.options.layers) {
                  layerSet = this._connectOptionsLayers();
              }
              else {
                  const { inputLayer, hiddenLayers, outputLayer } = this._connectLayers();
                  layerSet = flattenLayers([inputLayer, ...hiddenLayers, outputLayer]);
                  this._hiddenLayerOutputIndices = hiddenLayers.map((l) => layerSet.indexOf(l));
                  this._inputLayer = inputLayer;
                  this._hiddenLayers = hiddenLayers;
                  this._outputLayer = outputLayer;
              }
              this.layers = layerSet;
              this._layerSets = [layerSet];
              this._model = layerSet.filter((l) => l instanceof Model || l instanceof InternalModel);
              this.initializeLayers(layerSet);
          }
          initializeDeep() {
              const layers = this._connectLayersDeep();
              for (let i = 0; i < layers.length; i++) {
                  const layer = layers[i];
                  layer.setupKernels(true);
                  layer.reuseKernels(this._layerSets[0][i]);
              }
              this._layerSets.push(layers);
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          run(inputs) {
              while (this._layerSets.length <= inputs.length) {
                  this.initializeDeep();
              }
              const result = this.runInputs(inputs);
              if (result instanceof gpuBrowser.Texture) {
                  return result.toArray();
              }
              return result;
          }
          runInput(input) {
              throw new Error('use .runInputs()');
          }
          runInputs(inputs) {
              while (this._layerSets.length < inputs.length) {
                  this.initializeDeep();
              }
              const max = inputs.length - 1; // last output will be compared with last index
              for (let x = 0; x <= max; x++) {
                  const layerSet = this._layerSets[x];
                  layerSet[0].predict(inputs[x]);
                  for (let i = 1; i < layerSet.length; i++) {
                      layerSet[i].predict();
                  }
              }
              const lastLayerUsed = this._layerSets[max];
              const result = lastLayerUsed[lastLayerUsed.length - 1].weights;
              this.end();
              return result;
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          train(data, options = {}) {
              const { preparedData, status, endTime } = this._prepTraining(data, options);
              let continueTicking = true;
              const calculateError = () => this._calculateTrainingError(preparedData);
              const trainPatters = () => this._trainPatterns(preparedData);
              while (continueTicking) {
                  continueTicking = this._trainingTick(status, endTime, calculateError, trainPatters);
              }
              return status;
          }
          end() {
              const x = this._layerSets.length - 1;
              const lastLayerSet = this._layerSets[x];
              lastLayerSet[0].predict([new Float32Array([0])]);
              for (let i = 1; i < lastLayerSet.length; i++) {
                  lastLayerSet[i].predict();
              }
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          transferData(formattedData) {
              return formattedData;
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          _prepTraining(data, options) {
              this._updateTrainingOptions(options);
              const endTime = this.trainOpts.timeout
                  ? Date.now() + this.trainOpts.timeout
                  : 0;
              const status = {
                  error: 1,
                  iterations: 0,
              };
              this.verifyIsInitialized();
              return {
                  preparedData: this.transferData(data),
                  status,
                  endTime,
              };
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          _calculateTrainingError(data) {
              if (!this.meanSquaredError) {
                  throw new Error('this.meanSquaredError not setup');
              }
              let sum = new Float32Array(1);
              for (let i = 0; i < data.length; ++i) {
                  const prevSum = sum;
                  const error = this._trainPattern(data[i], true);
                  sum = this.meanSquaredError.add(sum, error);
                  release(error);
                  release(prevSum);
              }
              const result = this.meanSquaredError.divide(data.length, sum);
              release(sum);
              if (result instanceof gpuBrowser.Texture) {
                  const resultArray = result.toArray();
                  return resultArray[0];
              }
              return result[0];
          }
          // TODO: more types
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          formatData(data) {
              return data;
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          _calculateDeltas(target) {
              const lastLayerSet = this._layerSets[this._layerSets.length - 1];
              // Iterate from the second to last layer backwards, propagating 0's
              for (let i = lastLayerSet.length - 2; i >= 0; i--) {
                  lastLayerSet[i].compare();
              }
              for (let x = target.length - 2; x >= 0; x--) {
                  const layerSet = this._layerSets[x];
                  layerSet[layerSet.length - 1].compare(target[x + 1]);
                  for (let i = layerSet.length - 2; i >= 0; i--) {
                      layerSet[i].compare();
                  }
              }
          }
          adjustWeights() {
              var _a;
              const _model = this._model;
              for (let i = 0; i < _model.length; i++) {
                  _model[i].learn((_a = this.options.learningRate) !== null && _a !== void 0 ? _a : 0);
              }
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          _trainPatterns(data) {
              for (let i = 0; i < data.length; ++i) {
                  this._trainPattern(data[i], false);
              }
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          _trainPattern(inputs, logErrorRate) {
              // forward propagate
              this.runInputs(inputs);
              // back propagate
              this._calculateDeltas(inputs);
              this.adjustWeights();
              if (logErrorRate) {
                  if (!this.meanSquaredError) {
                      throw new Error('this.meanSquaredError not setup');
                  }
                  let error = new Float32Array(1);
                  for (let i = 0, max = inputs.length - 2; i <= max; i++) {
                      const layerSet = this._layerSets[i];
                      const lastLayer = layerSet[layerSet.length - 1];
                      const prevError = error;
                      error = this.meanSquaredError.addAbsolute(prevError, lastLayer.errors);
                      release(prevError);
                  }
                  return clone(this.meanSquaredError.divide(inputs.length, error));
              }
              return null;
          }
      }
  
      /**
       * A matrix
       */
      class Matrix {
          constructor(rows, columns) {
              this.rows = 0;
              this.columns = 0;
              if (rows)
                  this.rows = rows;
              if (columns)
                  this.columns = columns;
              this.weights = zeros$1(this.rows * this.columns);
              this.deltas = zeros$1(this.rows * this.columns);
          }
          getWeight(row, col) {
              // slow but careful accessor function
              // we want row-major order
              const ix = this.columns * row + col;
              if (ix < 0 || ix >= this.weights.length) {
                  throw new Error('get accessor is skewed');
              }
              return this.weights[ix];
          }
          setWeight(row, col, v) {
              // slow but careful accessor function
              const ix = this.columns * row + col;
              if (ix < 0 || ix >= this.weights.length) {
                  throw new Error('set accessor is skewed');
              }
              this.weights[ix] = v;
              return this;
          }
          getDelta(row, col) {
              // slow but careful accessor function
              // we want row-major order
              const ix = this.columns * row + col;
              if (ix < 0 || ix >= this.deltas.length) {
                  throw new Error('get accessor is skewed');
              }
              return this.deltas[ix];
          }
          setDelta(row, col, v) {
              // slow but careful accessor function
              const ix = this.columns * row + col;
              if (ix < 0 || ix >= this.weights.length) {
                  throw new Error('set accessor is skewed');
              }
              this.deltas[ix] = v;
              return this;
          }
          toJSON() {
              return {
                  rows: this.rows,
                  columns: this.columns,
                  weights: Array.from(this.weights.slice(0)),
              };
          }
          static fromJSON(json) {
              const matrix = new Matrix(json.rows, json.columns);
              for (let i = 0, max = json.rows * json.columns; i < max; i++) {
                  matrix.weights[i] = json.weights[i]; // copy over weights
              }
              return matrix;
          }
          static fromArray(weights) {
              const matrix = new Matrix(weights.length, weights[0].length);
              matrix.fromArray(weights);
              return matrix;
          }
          deltasToArray() {
              return this.toArray('deltas');
          }
          weightsToArray() {
              return this.toArray('weights');
          }
          toArray(prop = 'weights') {
              const result = new Array(this.rows);
              this.iterate({
                  row: (rowIndex) => {
                      result[rowIndex] = new Array(this.columns);
                  },
                  column: (rowIndex, columnIndex) => {
                      if (prop === 'weights') {
                          result[rowIndex][columnIndex] = this.getWeight(rowIndex, columnIndex);
                      }
                      else if (prop === 'deltas') {
                          result[rowIndex][columnIndex] = this.getDelta(rowIndex, columnIndex);
                      }
                  },
              });
              return result;
          }
          fromArray(array, prop = 'weights') {
              if (array.length !== this.rows) {
                  throw new Error('rows do not match');
              }
              if (array[0].length !== this.columns) {
                  throw new Error('columns do not match');
              }
              this.iterate({
                  column: (rowIndex, columnIndex) => {
                      const value = array[rowIndex][columnIndex];
                      if (typeof value !== 'number') {
                          throw new Error('value not number');
                      }
                      if (prop === 'weights') {
                          this.setWeight(rowIndex, columnIndex, value);
                      }
                      else if (prop === 'deltas') {
                          this.setDelta(rowIndex, columnIndex, value);
                      }
                  },
              });
              return this;
          }
          iterate(callbacks) {
              const rows = this.rows;
              const columns = this.columns;
              for (let rowIndex = 0; rowIndex < rows; rowIndex++) {
                  if (callbacks.row) {
                      callbacks.row(rowIndex);
                  }
                  for (let columnIndex = 0; columnIndex < columns; columnIndex++) {
                      if (callbacks.column) {
                          callbacks.column(rowIndex, columnIndex);
                      }
                  }
              }
              return this;
          }
      }
  
      /** return Matrix but filled with random numbers from gaussian
       */
      class RandomMatrix extends Matrix {
          constructor(rows, columns, std) {
              super(rows, columns);
              this.std = std;
              for (let i = 0, max = this.weights.length; i < max; i++) {
                  this.weights[i] = randomFloat(-std, std);
              }
          }
      }
  
      class DataFormatter {
          constructor(values, maxThreshold = 0) {
              this.values = values;
              this.indexTable = {};
              this.characterTable = {};
              this.characters = [];
              this.specialIndexes = [];
              this.isSetup = false;
              if (values === undefined)
                  return;
              this.setup(values, maxThreshold);
          }
          setup(values, maxThreshold = 0) {
              if (this.isSetup)
                  throw new Error('DataFormatter is already setup');
              this.values = values;
              // go over all characters and keep track of all unique ones seen
              // count up all characters
              this.buildCharactersFromIterable(values);
              this.buildTables(maxThreshold);
              if (values[0].input) {
                  this.addInputOutput();
              }
              this.addUnrecognized();
              this.isSetup = true;
          }
          buildCharactersFromIterable(values) {
              const tempCharactersTable = {};
              for (let dataFormatterIndex = 0, dataFormatterLength = values.length; dataFormatterIndex < dataFormatterLength; dataFormatterIndex++) {
                  const characters = values[dataFormatterIndex];
                  // if (typeof characters === 'string') {
                  //   const character = characters;
                  //   if (tempCharactersTable.hasOwnProperty(character)) continue;
                  //   tempCharactersTable[character] = true;
                  //   this.characters.push(character);
                  if (characters.hasOwnProperty('length')) {
                      const iteratable = characters;
                      for (let characterIndex = 0, charactersLength = iteratable.length; characterIndex < charactersLength; characterIndex++) {
                          const character = iteratable[characterIndex];
                          if (tempCharactersTable.hasOwnProperty(character))
                              continue;
                          tempCharactersTable[character] = true;
                          this.characters.push(character);
                      }
                  }
                  else if (typeof characters === 'number') {
                      if (tempCharactersTable.hasOwnProperty(characters))
                          continue;
                      tempCharactersTable[characters] = true;
                      this.characters.push(characters);
                  }
                  else if (typeof characters === 'boolean') {
                      const character = characters.toString();
                      if (tempCharactersTable.hasOwnProperty(character))
                          continue;
                      tempCharactersTable[character] = true;
                      this.characters.push(character);
                  }
                  else if (Array.isArray(characters) &&
                      typeof characters[0] === 'string') {
                      for (let i = 0; i < characters.length; i++) {
                          const character = characters[i];
                          if (tempCharactersTable.hasOwnProperty(character))
                              continue;
                          tempCharactersTable[character] = true;
                          this.characters.push(character);
                      }
                  }
                  else if (Array.isArray(characters) &&
                      (typeof characters[0] === 'number' ||
                          typeof characters[0] === 'boolean')) {
                      for (let i = 0; i < characters.length; i++) {
                          const character = characters[i].toString();
                          if (tempCharactersTable.hasOwnProperty(dataFormatterIndex))
                              continue;
                          tempCharactersTable[character] = true;
                          this.characters.push(character);
                      }
                  }
                  else if (characters.hasOwnProperty('input') &&
                      characters.hasOwnProperty('output')) {
                      const { input, output } = characters;
                      if (Array.isArray(input)) {
                          this.addCharacters(input, tempCharactersTable);
                      }
                      else {
                          this.addCharacters(input.toString(), tempCharactersTable);
                      }
                      if (Array.isArray(output)) {
                          this.addCharacters(output, tempCharactersTable);
                      }
                      else {
                          this.addCharacters(output.toString(), tempCharactersTable);
                      }
                  }
                  else {
                      throw new Error('Unhandled value');
                  }
              }
          }
          addCharacters(characters, charactersTable) {
              for (let i = 0; i < characters.length; i++) {
                  const character = characters[i].toString();
                  if (charactersTable.hasOwnProperty(character))
                      continue;
                  charactersTable[character] = true;
                  this.characters.push(character);
              }
          }
          buildTables(maxThreshold) {
              // filter by count threshold and create pointers
              const charactersLength = this.characters.length;
              for (let characterIndex = 0; characterIndex < charactersLength; characterIndex++) {
                  const character = this.characters[characterIndex];
                  if (characterIndex >= maxThreshold) {
                      // add character to dataFormatter
                      this.indexTable[character] = characterIndex;
                      this.characterTable[characterIndex] = character;
                  }
              }
          }
          toIndexes(value, maxThreshold = 0) {
              const result = [];
              const { indexTable } = this;
              switch (typeof value) {
                  case 'number':
                  case 'boolean':
                      value = value.toString();
              }
              for (let i = 0, max = value.length; i < max; i++) {
                  const character = value[i].toString();
                  let index = indexTable[character];
                  if (index === undefined) {
                      if (indexTable.unrecognized) {
                          index = indexTable.unrecognized;
                      }
                      else {
                          throw new Error(`unrecognized character "${character}"`);
                      }
                  }
                  if (index < maxThreshold)
                      continue;
                  result.push(index);
              }
              return result;
          }
          toIndexesInputOutput(input, output, maxThreshold = 0) {
              const result = this.toIndexesValue(input, maxThreshold, true);
              if (typeof output === 'undefined')
                  return result;
              return result.concat(this.toIndexesValue(output, maxThreshold, false));
          }
          toIndexesValue(value, maxThreshold, isInput) {
              if (typeof value === 'string') {
                  value = value.split('');
              }
              else if (typeof value === 'number' || typeof value === 'boolean') {
                  value = value.toString().split('');
              }
              else if (Array.isArray(value) &&
                  (typeof value[0] === 'number' ||
                      typeof value[0] === 'boolean' ||
                      typeof value[0] === 'string')) {
                  value = value.map((v) => v.toString());
              }
              else {
                  throw new Error('unrecognized value');
              }
              if (isInput) {
                  value = value.concat(['stop-input', 'start-output']);
              }
              return this.toIndexes(value, maxThreshold);
          }
          toCharacters(indices, maxThreshold = 0) {
              const result = [];
              const { indexTable, characterTable } = this;
              for (let i = 0, max = indices.length; i < max; i++) {
                  const index = indices[i];
                  if (index < maxThreshold)
                      continue;
                  let character = characterTable[index];
                  if (character === undefined) {
                      if (indexTable.unrecognized) {
                          character = characterTable[indexTable.unrecognized];
                      }
                      else {
                          throw new Error(`unrecognized index "${index}"`);
                      }
                  }
                  else if (character !== null) {
                      result.push(character.toString());
                  }
              }
              return result;
          }
          toString(indices, maxThreshold) {
              return this.toCharacters(indices, maxThreshold).join('');
          }
          addInputOutput() {
              this.addSpecial('stop-input');
              this.addSpecial('start-output');
          }
          addUnrecognized() {
              this.addSpecial('unrecognized');
          }
          static fromAllPrintable(maxThreshold, values = ['\n']) {
              for (let i = 32; i <= 126; i++) {
                  values.push(String.fromCharCode(i));
              }
              return new DataFormatter(values, maxThreshold);
          }
          static fromAllPrintableInputOutput(maxThreshold, values = ['\n']) {
              const dataFormatter = DataFormatter.fromAllPrintable(maxThreshold, values);
              dataFormatter.addInputOutput();
              dataFormatter.addUnrecognized();
              return dataFormatter;
          }
          static fromStringInputOutput(string, maxThreshold) {
              const values = Array.from(new Set(string)).join('');
              const dataFormatter = new DataFormatter(values.split(''), maxThreshold);
              dataFormatter.addInputOutput();
              dataFormatter.addUnrecognized();
              dataFormatter.isSetup = true;
              return dataFormatter;
          }
          static fromArrayInputOutput(data, maxThreshold) {
              const values = [];
              for (let i = 0; i < data.length; i++) {
                  const datum = data[i];
                  values.push(validateAndCast(datum.input), validateAndCast(datum.output));
              }
              const flatArray = Array.isArray(values)
                  ? values.flat()
                  : values;
              const dataFormatter = new DataFormatter(Array.from(new Set(flatArray)), maxThreshold);
              dataFormatter.addInputOutput();
              dataFormatter.addUnrecognized();
              dataFormatter.isSetup = true;
              return dataFormatter;
          }
          static fromString(string, maxThreshold = 0) {
              const values = Array.from(new Set(string)).join('');
              return new DataFormatter(values.split(''), maxThreshold);
          }
          toJSON() {
              return {
                  indexTable: this.indexTable,
                  characterTable: this.characterTable,
                  values: this.values,
                  characters: this.characters,
                  specialIndexes: this.specialIndexes,
              };
          }
          /** TODO: Type better, The type of json is not "string that is a valid JSON", it is a POJO in the shape of DataFormatter.
           * this method re-hydrates the the data as an instance of DataFormatter.
           */
          static fromJSON(json) {
              const dataFormatter = new DataFormatter();
              dataFormatter.indexTable = json.indexTable;
              dataFormatter.characterTable = json.characterTable;
              dataFormatter.values = json.values;
              dataFormatter.characters = json.characters;
              dataFormatter.specialIndexes = json.specialIndexes;
              dataFormatter.isSetup = true;
              return dataFormatter;
          }
          addSpecial(special, character = null) {
              const specialIndex = (this.indexTable[special] = this.characters.length);
              this.characterTable[specialIndex] = character;
              this.specialIndexes.push(this.characters.length);
              this.characters.push(special);
          }
          toFunctionString() {
              return `
  var characterTable = ${JSON.stringify(this.characterTable)};
  var indexTable = ${JSON.stringify(this.indexTable)};
  var characters = ${JSON.stringify(this.characters)};
  var dataFormatter = {
    toIndexes: function ${this.toIndexes.toString()},
    toIndexesInputOutput: function ${this.toIndexesInputOutput.toString()},
    toCharacters: function ${this.toCharacters.toString()},
    toIndexesValue: function ${this.toIndexesValue.toString()},
  };`;
          }
          formatDataIn(input, output) {
              var _a;
              if (input === undefined)
                  return [];
              if (Array.isArray(input) && typeof input[0] === 'number') {
                  return input;
              }
              if ((_a = this.indexTable) === null || _a === void 0 ? void 0 : _a.hasOwnProperty('stop-input')) {
                  return this.toIndexesInputOutput(input, output);
              }
              return this.toIndexes(input);
          }
          formatDataOut(input, output) {
              return this.toCharacters(output).join('');
          }
          format(data) {
              if (typeof data[0] === 'number' &&
                  !Array.isArray(data[0]) &&
                  (!data[0].hasOwnProperty('input') || !data[0].hasOwnProperty('output'))) {
                  return data;
              }
              const result = [];
              if (typeof data[0] === 'string' ||
                  typeof data[0] === 'number' ||
                  Array.isArray(data[0])) {
                  if (!this.isSetup) {
                      this.setup(data);
                      for (let i = 0; i < data.length; i++) {
                          result.push(this.formatDataIn(validateAndCast(data[i])));
                      }
                  }
                  else {
                      for (let i = 0, max = data.length; i < max; i++) {
                          result.push(this.formatDataIn(data[i]));
                      }
                  }
              }
              else if (data[0].input && data[0].output) {
                  if (!this.isSetup) {
                      this.setup(data);
                  }
                  for (let i = 0, max = data.length; i < max; i++) {
                      result.push(this.formatDataIn(validateAndCast(data[i].input), validateAndCast(data[i].output)));
                  }
              }
              else {
                  throw new Error('unrecognized data');
              }
              return result;
          }
      }
      function validateAndCast(value) {
          if (typeof value === 'string')
              return value;
          if (typeof value === 'number')
              return value.toString();
          if (typeof value === 'boolean')
              return value.toString();
          if (Array.isArray(value) && typeof value[0] === 'string')
              return value;
          if (typeof value[0] === 'boolean') {
              return value.map((v) => v.toString());
          }
          if (typeof value[0] === 'number') {
              return value.map((v) => v.toString());
          }
          throw new Error('unrecognized value, expected string[], string, number[], number, boolean[], or boolean');
      }
  
      function copy(product, left) {
          product.rows = left.rows;
          product.columns = left.columns;
          product.weights = left.weights.slice(0);
          product.deltas = left.deltas.slice(0);
      }
  
      /**
       * add {left} and {right} matrix weights into {into}
       */
      function add(product, left, right) {
          for (let i = 0; i < left.weights.length; i++) {
              product.weights[i] = left.weights[i] + right.weights[i];
              product.deltas[i] = 0;
          }
      }
  
      /**
       * adds {from} deltas to {left} and {right} deltas
       */
      function addB(product, left, right) {
          for (let i = 0; i < product.deltas.length; i++) {
              left.deltas[i] = product.deltas[i];
              right.deltas[i] = product.deltas[i];
          }
      }
  
      /**
       * makes matrix weights and deltas all ones
       */
      function allOnes(product) {
          for (let i = 0; i < product.weights.length; i++) {
              product.weights[i] = 1;
              product.deltas[i] = 0;
          }
      }
  
      function cloneNegative(product, left) {
          product.rows = left.rows;
          product.columns = left.columns;
          product.weights = left.weights.slice(0);
          product.deltas = left.deltas.slice(0);
          for (let i = 0; i < left.weights.length; i++) {
              product.weights[i] = -left.weights[i];
              product.deltas[i] = 0;
          }
      }
  
      /**
       * multiply {left} and {right} matrix weights to {into}
       */
      function multiply(product, left, right) {
          const leftRows = left.rows;
          const leftColumns = left.columns;
          const rightColumns = right.columns;
          // loop over rows of left
          for (let leftRow = 0; leftRow < leftRows; leftRow++) {
              const leftRowBase = leftColumns * leftRow;
              const rightRowBase = rightColumns * leftRow;
              // loop over cols of right
              for (let rightColumn = 0; rightColumn < rightColumns; rightColumn++) {
                  // dot product loop
                  let dot = 0;
                  // loop over columns of left
                  for (let leftColumn = 0; leftColumn < leftColumns; leftColumn++) {
                      const rightColumnBase = rightColumns * leftColumn;
                      const leftIndex = leftRowBase + leftColumn;
                      const rightIndex = rightColumnBase + rightColumn;
                      dot += left.weights[leftIndex] * right.weights[rightIndex];
                      left.deltas[leftIndex] = 0;
                      right.deltas[rightIndex] = 0;
                  }
                  product.weights[rightRowBase + rightColumn] = dot;
              }
          }
      }
  
      /**
       * multiplies {from} deltas to {left} and {right}
       */
      function multiplyB(product, left, right) {
          const leftRows = left.rows;
          const leftColumns = left.columns;
          const rightColumns = right.columns;
          // loop over rows of left
          for (let leftRowRoot = 0; leftRowRoot < leftRows; leftRowRoot++) {
              const leftRowBase = leftColumns * leftRowRoot;
              const rightRowBase = rightColumns * leftRowRoot;
              // loop over cols of right
              for (let rightColumn = 0; rightColumn < rightColumns; rightColumn++) {
                  // loop over columns of left
                  for (let leftColumn = 0; leftColumn < leftColumns; leftColumn++) {
                      const rightColumnBase = rightColumns * leftColumn;
                      const leftRow = leftRowBase + leftColumn;
                      const rightRow = rightColumnBase + rightColumn;
                      const backPropagateValue = product.deltas[rightRowBase + rightColumn];
                      left.deltas[leftRow] += right.weights[rightRow] * backPropagateValue;
                      right.deltas[rightRow] += left.weights[leftRow] * backPropagateValue;
                  }
              }
          }
      }
  
      function multiplyElement(product, left, right) {
          const { weights } = left;
          for (let i = 0; i < weights.length; i++) {
              product.weights[i] = left.weights[i] * right.weights[i];
              product.deltas[i] = 0;
          }
      }
  
      /**
       * multiplies {left} and {right} weight by {from} deltas into {left} and {right} deltas
       */
      function multiplyElementB(product, left, right) {
          for (let i = 0; i < left.weights.length; i++) {
              left.deltas[i] = right.weights[i] * product.deltas[i];
              right.deltas[i] = left.weights[i] * product.deltas[i];
          }
      }
  
      /**
       *
       * relu {m} weights to {into} weights
       */
      function relu(product, left) {
          for (let i = 0; i < left.weights.length; i++) {
              product.weights[i] = Math.max(0, left.weights[i]); // relu
              product.deltas[i] = 0;
          }
      }
  
      /**
       * adds {from} deltas to {m} deltas when {m} weights are above other a threshold of 0
       */
      function reluB(product, left) {
          for (let i = 0; i < product.deltas.length; i++) {
              left.deltas[i] = left.weights[i] > 0 ? product.deltas[i] : 0;
          }
      }
  
      function rowPluck(product, left, rowPluckIndex) {
          const { columns } = left;
          const rowBase = columns * rowPluckIndex;
          for (let column = 0; column < columns; column++) {
              product.weights[column] = left.weights[rowBase + column];
              product.deltas[column] = 0;
          }
      }
  
      /**
       * adds {from} deltas into {m} deltas
       */
      function rowPluckB(product, left, rowIndex) {
          const { columns } = left;
          const rowBase = columns * rowIndex;
          for (let column = 0; column < columns; column++) {
              left.deltas[rowBase + column] = product.deltas[column];
          }
      }
  
      function sigmoid(product, left) {
          // sigmoid nonlinearity
          for (let i = 0; i < left.weights.length; i++) {
              product.weights[i] = 1 / (1 + Math.exp(-left.weights[i]));
              product.deltas[i] = 0;
          }
      }
      // function sig(x) {
      //   // helper function for computing sigmoid
      //   return 1 / (1 + Math.exp(-x));
      // }
  
      function sigmoidB(product, left) {
          for (let i = 0; i < product.deltas.length; i++) {
              const mwi = product.weights[i];
              left.deltas[i] = mwi * (1 - mwi) * product.deltas[i];
          }
      }
  
      function softmax(matrix) {
          // probability volume
          const result = new Matrix(matrix.rows, matrix.columns);
          let maxVal = -999999;
          for (let i = 0; i < matrix.weights.length; i++) {
              if (matrix.weights[i] > maxVal) {
                  maxVal = matrix.weights[i];
              }
          }
          let s = 0;
          for (let i = 0; i < matrix.weights.length; i++) {
              result.weights[i] = Math.exp(matrix.weights[i] - maxVal);
              s += result.weights[i];
          }
          for (let i = 0; i < matrix.weights.length; i++) {
              result.weights[i] /= s;
          }
          // no backward pass here needed
          // since we will use the computed probabilities outside
          // to set gradients directly on m
          return result;
      }
  
      function tanh(product, left) {
          // tanh nonlinearity
          for (let i = 0; i < left.weights.length; i++) {
              product.weights[i] = Math.tanh(left.weights[i]);
              product.deltas[i] = 0;
          }
      }
  
      function tanhB(product, left) {
          for (let i = 0; i < product.deltas.length; i++) {
              // grad for z = tanh(x) is (1 - z^2)
              const mwi = product.weights[i];
              left.deltas[i] = (1 - mwi * mwi) * product.deltas[i];
          }
      }
  
      class Equation {
          constructor() {
              this.states = [];
              this.inputRow = 0;
          }
          add(left, right) {
              if (left.weights.length !== right.weights.length) {
                  throw new Error('misaligned matrices');
              }
              const product = new Matrix(left.rows, left.columns);
              this.states.push({
                  name: 'add',
                  product,
                  left,
                  right,
                  forwardFn: add,
                  backpropagationFn: addB,
              });
              return product;
          }
          allOnes(rows, columns) {
              const product = new Matrix(rows, columns);
              this.states.push({
                  name: 'allOnes',
                  product,
                  left: product,
                  forwardFn: allOnes,
                  backpropagationFn: () => { },
              });
              return product;
          }
          cloneNegative(matrix) {
              const product = new Matrix(matrix.rows, matrix.columns);
              this.states.push({
                  name: 'cloneNegative',
                  product,
                  left: matrix,
                  forwardFn: cloneNegative,
                  backpropagationFn: () => { },
              });
              return product;
          }
          /**
           * connects two matrices together by subtract
           */
          subtract(left, right) {
              if (left.weights.length !== right.weights.length) {
                  throw new Error('misaligned matrices');
              }
              return this.add(this.add(this.allOnes(left.rows, left.columns), this.cloneNegative(left)), right);
          }
          /**
           * connects two matrices together by multiply
           */
          multiply(left, right) {
              if (left.columns !== right.rows) {
                  throw new Error('misaligned matrices');
              }
              const product = new Matrix(left.rows, right.columns);
              this.states.push({
                  name: 'multiply',
                  product,
                  left,
                  right,
                  forwardFn: multiply,
                  backpropagationFn: multiplyB,
              });
              return product;
          }
          /**
           * connects two matrices together by multiplyElement
           */
          multiplyElement(left, right) {
              if (left.weights.length !== right.weights.length) {
                  throw new Error('misaligned matrices');
              }
              const product = new Matrix(left.rows, left.columns);
              this.states.push({
                  name: 'multiplyElement',
                  product,
                  left,
                  right,
                  forwardFn: multiplyElement,
                  backpropagationFn: multiplyElementB,
              });
              return product;
          }
          /**
           * connects a matrix to relu
           */
          relu(matrix) {
              const product = new Matrix(matrix.rows, matrix.columns);
              this.states.push({
                  name: 'relu',
                  product,
                  left: matrix,
                  forwardFn: relu,
                  backpropagationFn: reluB,
              });
              return product;
          }
          /**
           * input a matrix
           */
          input(input) {
              this.states.push({
                  name: 'input',
                  product: input,
                  forwardFn: (product) => {
                      if (!this.inputValue)
                          return;
                      if (this.inputValue.length !== product.weights.length) {
                          throw new Error('this.inputValue is of wrong dimensions');
                      }
                      product.weights = input.weights = this.inputValue;
                  },
                  backpropagationFn: () => { },
              });
              return input;
          }
          /**
           * connects a matrix via a row
           */
          inputMatrixToRow(matrix) {
              // eslint-disable-next-line @typescript-eslint/no-this-alias
              const self = this;
              const product = new Matrix(matrix.columns, 1);
              this.states.push({
                  name: 'inputMatrixToRow',
                  product,
                  left: matrix,
                  get right() {
                      return self.inputRow;
                  },
                  forwardFn: rowPluck,
                  backpropagationFn: rowPluckB,
              });
              return product;
          }
          /**
           * connects a matrix to sigmoid
           */
          sigmoid(matrix) {
              const product = new Matrix(matrix.rows, matrix.columns);
              this.states.push({
                  name: 'sigmoid',
                  product,
                  left: matrix,
                  forwardFn: sigmoid,
                  backpropagationFn: sigmoidB,
              });
              return product;
          }
          /**
           * connects a matrix to tanh
           */
          tanh(matrix) {
              const product = new Matrix(matrix.rows, matrix.columns);
              this.states.push({
                  name: 'tanh',
                  product,
                  left: matrix,
                  forwardFn: tanh,
                  backpropagationFn: tanhB,
              });
              return product;
          }
          /**
           *
           * Observe a matrix for debugging
           */
          observe(matrix) {
              this.states.push({
                  name: 'observe',
                  product: new Matrix(),
                  forwardFn: () => { },
                  backpropagationFn: () => { },
              });
              return matrix;
          }
          /**
           * Run index through equations via forward propagation
           */
          runIndex(rowIndex = 0) {
              this.inputRow = rowIndex;
              let state = this.states[0];
              for (let i = 0, max = this.states.length; i < max; i++) {
                  state = this.states[i];
                  if (!state.hasOwnProperty('forwardFn'))
                      continue;
                  state.forwardFn(state.product, state.left, state.right);
              }
              return state.product;
          }
          /**
           * Run value through equations via forward propagation
           */
          runInput(inputValue) {
              this.inputValue = inputValue;
              let state = this.states[0];
              for (let i = 0, max = this.states.length; i < max; i++) {
                  state = this.states[i];
                  if (!state.hasOwnProperty('forwardFn'))
                      continue;
                  state.forwardFn(state.product, state.left, state.right);
              }
              return state.product;
          }
          /**
           * Run value through equations via back propagation
           */
          backpropagate() {
              let i = this.states.length;
              let state = this.states[0];
              while (i-- > 0) {
                  state = this.states[i];
                  if (!state.hasOwnProperty('backpropagationFn'))
                      continue;
                  state.backpropagationFn(state.product, state.left, state.right);
              }
              return state.product;
          }
          /**
           * Run index through equations via back propagation
           */
          backpropagateIndex(rowIndex = 0) {
              this.inputRow = rowIndex;
              let i = this.states.length;
              let state = this.states[0];
              while (i-- > 0) {
                  state = this.states[i];
                  if (!state.hasOwnProperty('backpropagationFn'))
                      continue;
                  state.backpropagationFn(state.product, state.left, state.right);
              }
              return state.product;
          }
          /**
           * Predict a target value from equation
           */
          predictTarget(input, target) {
              let errorSum = 0;
              const output = this.runInput(input);
              for (let i = 0; i < output.weights.length; i++) {
                  const error = output.weights[i] - target[i];
                  // set gradients into log probabilities
                  errorSum += Math.abs(error);
                  // write gradients into log probabilities
                  output.deltas[i] = error;
              }
              return errorSum;
          }
          /**
           * Predict a target index from equation
           */
          predictTargetIndex(input, target) {
              const output = this.runIndex(input);
              // set gradients into log probabilities
              const logProbabilities = output; // interpret output as log probabilities
              const probabilities = softmax(output); // compute the softmax probabilities
              // write gradients into log probabilities
              logProbabilities.deltas = probabilities.weights.slice(0);
              logProbabilities.deltas[target] -= 1;
              // accumulate base 2 log prob and do smoothing
              return -Math.log2(probabilities.weights[target]);
          }
      }
  
      function maxI(matrix) {
          // argmax of array w
          const { weights } = matrix;
          let maxv = weights[0];
          let maxix = 0;
          for (let i = 1; i < weights.length; i++) {
              const v = weights[i];
              if (v < maxv)
                  continue;
              maxix = i;
              maxv = v;
          }
          return maxix;
      }
  
      function sampleI(matrix) {
          // sample argmax from w, assuming w are
          // probabilities that sum to one
          const r = randomFloat(0, 1);
          const w = matrix.weights;
          let x = 0;
          let i = 0;
          while (true) {
              x += w[i];
              if (x > r) {
                  return i;
              }
              i++;
          }
      }
  
      const trainDefaults$1 = {
          iterations: 20000,
          errorThresh: 0.005,
          log: false,
          logPeriod: 10,
          learningRate: 0.01,
          callbackPeriod: 10,
          timeout: Infinity,
      };
      const defaults$1 = () => {
          return {
              inputSize: 20,
              inputRange: 20,
              hiddenLayers: [20, 20],
              outputSize: 20,
              decayRate: 0.999,
              smoothEps: 1e-8,
              regc: 0.000001,
              clipval: 5,
              maxPredictionLength: 100,
              dataFormatter: new DataFormatter(),
          };
      };
      class RNN {
          constructor(options = {}) {
              this.options = { ...defaults$1() };
              this.trainOpts = { ...trainDefaults$1 };
              this.stepCache = {};
              this.runs = 0;
              this.ratioClipped = 0;
              this.model = Object.seal({
                  isInitialized: false,
                  input: new Matrix(0, 0),
                  hiddenLayers: [],
                  output: new Matrix(0, 0),
                  equations: [],
                  allMatrices: [],
                  equationConnections: [],
                  outputConnector: new RandomMatrix(0, 0, 0.08),
              });
              this.initialLayerInputs = [];
              this.options = { ...this.options, ...options };
              this.updateTrainingOptions({
                  ...trainDefaults$1,
              });
              if (options.json) {
                  this.fromJSON(options.json);
              }
          }
          initialize() {
              const { dataFormatter } = this.options;
              if (dataFormatter === null || dataFormatter === void 0 ? void 0 : dataFormatter.characters.length) {
                  this.options.inputSize = this.options.inputRange = this.options.outputSize =
                      dataFormatter.characters.length;
              }
              this.model = this.mapModel();
          }
          createHiddenLayers() {
              const { hiddenLayers, inputSize } = this.options;
              const hiddenLayersModel = [];
              // 0 is end, so add 1 to offset
              hiddenLayersModel.push(this.getHiddenLayer(hiddenLayers[0], inputSize));
              let prevSize = hiddenLayers[0];
              for (let d = 1; d < hiddenLayers.length; d++) {
                  // loop over depths
                  const hiddenSize = hiddenLayers[d];
                  hiddenLayersModel.push(this.getHiddenLayer(hiddenSize, prevSize));
                  prevSize = hiddenSize;
              }
              return hiddenLayersModel;
          }
          getHiddenLayer(hiddenSize, prevSize) {
              return {
                  // wxh
                  weight: new RandomMatrix(hiddenSize, prevSize, 0.08),
                  // whh
                  transition: new RandomMatrix(hiddenSize, hiddenSize, 0.08),
                  // bhh
                  bias: new Matrix(hiddenSize, 1),
              };
          }
          getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
              if (!hiddenLayer.weight || !hiddenLayer.transition || !hiddenLayer.bias) {
                  throw new Error('hiddenLayer does not have expected properties');
              }
              const relu = equation.relu.bind(equation);
              const add = equation.add.bind(equation);
              const multiply = equation.multiply.bind(equation);
              return relu(add(add(multiply(hiddenLayer.weight, inputMatrix), multiply(hiddenLayer.transition, previousResult)), hiddenLayer.bias));
          }
          createInputMatrix() {
              const { inputRange, inputSize } = this.options;
              if (inputRange < 1)
                  throw new Error('this.options.inputRange not an expected number');
              if (inputSize < 1)
                  throw new Error('this.options.inputSize not an expected number');
              // 0 is end, so add 1 to offset
              return new RandomMatrix(inputRange + 1, inputSize, 0.08);
          }
          createOutputMatrices() {
              const { outputSize, hiddenLayers } = this.options;
              const lastHiddenSize = last(hiddenLayers);
              // 0 is end, so add 1 to offset
              return {
                  // whd
                  outputConnector: new RandomMatrix(outputSize + 1, lastHiddenSize, 0.08),
                  // 0 is end, so add 1 to offset
                  // bd
                  output: new Matrix(outputSize + 1, 1),
              };
          }
          bindEquation() {
              const { model } = this;
              const { hiddenLayers } = this.options;
              const equation = new Equation();
              const outputs = [];
              const equationConnection = model.equationConnections.length > 0
                  ? last(model.equationConnections)
                  : this.initialLayerInputs;
              // 0 index
              let output = this.getEquation(equation, equation.inputMatrixToRow(model.input), equationConnection[0], model.hiddenLayers[0]);
              outputs.push(output);
              // 1+ indices
              for (let i = 1, max = hiddenLayers.length; i < max; i++) {
                  if (!equationConnection[i]) {
                      throw new Error(`Cannot find equation at index ${i}`);
                  }
                  output = this.getEquation(equation, output, equationConnection[i], model.hiddenLayers[i]);
                  outputs.push(output);
              }
              model.equationConnections.push(outputs);
              equation.add(equation.multiply(model.outputConnector, output), model.output);
              model.equations.push(equation);
          }
          mapModel() {
              const allMatrices = [];
              this.initialLayerInputs = this.options.hiddenLayers.map((size) => new Matrix(size, 1));
              const input = this.createInputMatrix();
              allMatrices.push(input);
              const hiddenLayers = this.createHiddenLayers();
              if (!hiddenLayers.length)
                  throw new Error('net.hiddenLayers not set');
              for (let i = 0, max = hiddenLayers.length; i < max; i++) {
                  const hiddenMatrix = hiddenLayers[i];
                  for (const property in hiddenMatrix) {
                      if (!hiddenMatrix.hasOwnProperty(property))
                          continue;
                      allMatrices.push(hiddenMatrix[property]);
                  }
              }
              const { output, outputConnector } = this.createOutputMatrices();
              allMatrices.push(outputConnector);
              allMatrices.push(output);
              return Object.seal({
                  isInitialized: true,
                  input,
                  hiddenLayers,
                  output,
                  equations: [],
                  allMatrices,
                  equationConnections: [],
                  outputConnector,
              });
          }
          trainInput(input) {
              this.runs++;
              const { model } = this;
              const max = input.length;
              let log2ppl = 0;
              let equation;
              while (model.equations.length <= input.length + 1) {
                  // last is zero
                  this.bindEquation();
              }
              for (let inputIndex = -1, inputMax = input.length; inputIndex < inputMax; inputIndex++) {
                  // start and end tokens are zeros
                  const equationIndex = inputIndex + 1;
                  equation = model.equations[equationIndex];
                  const source = inputIndex === -1 ? 0 : input[inputIndex] + 1; // first step: start with START token
                  const target = inputIndex === max - 1 ? 0 : input[inputIndex + 1] + 1; // last step: end with END token
                  log2ppl += equation.predictTargetIndex(source, target);
              }
              return Math.pow(2, log2ppl / (max - 1)) / 100;
          }
          backpropagate(input) {
              let i = input.length;
              const { model } = this;
              const { equations } = model;
              while (i > 0) {
                  equations[i].backpropagateIndex(input[i - 1] + 1);
                  i--;
              }
              equations[0].backpropagateIndex(0);
          }
          adjustWeights() {
              const { regc, clipval, decayRate, smoothEps } = this.options;
              const { trainOpts, model, stepCache } = this;
              const { learningRate } = trainOpts;
              const { allMatrices } = model;
              let numClipped = 0;
              let numTot = 0;
              for (let matrixIndex = 0; matrixIndex < allMatrices.length; matrixIndex++) {
                  const matrix = allMatrices[matrixIndex];
                  const { weights, deltas } = matrix;
                  if (!(matrixIndex in stepCache)) {
                      stepCache[matrixIndex] = zeros$1(matrix.rows * matrix.columns);
                  }
                  const cache = stepCache[matrixIndex];
                  for (let i = 0; i < weights.length; i++) {
                      let r = deltas[i];
                      const w = weights[i];
                      // rmsprop adaptive learning rate
                      cache[i] = cache[i] * decayRate + (1 - decayRate) * r * r;
                      // gradient clip
                      if (r > clipval) {
                          r = clipval;
                          numClipped++;
                      }
                      else if (r < -clipval) {
                          r = -clipval;
                          numClipped++;
                      }
                      numTot++;
                      // update (and regularize)
                      weights[i] =
                          w + (-learningRate * r) / Math.sqrt(cache[i] + smoothEps) - regc * w;
                  }
              }
              this.ratioClipped = numClipped / numTot;
          }
          get isRunnable() {
              if (this.model && this.model.equations.length === 0) {
                  console.error(`No equations bound, did you run train()?`);
                  return false;
              }
              return true;
          }
          checkRunnable() {
              if (!this.isRunnable) {
                  throw new Error('Network not runnable');
              }
          }
          run(rawInput = [], isSampleI = false, temperature = 1) {
              const maxPredictionLength = this.options.maxPredictionLength +
                  (rawInput !== null ? rawInput.length : 0) +
                  (this.options.dataFormatter
                      ? this.options.dataFormatter.specialIndexes.length
                      : 0);
              this.checkRunnable();
              const input = this.options.dataFormatter && rawInput.length > 0
                  ? this.options.dataFormatter.formatDataIn(rawInput)
                  : rawInput;
              const { model } = this;
              const output = [];
              let i = 0;
              while (true) {
                  const previousIndex = i === 0 ? 0 : i < input.length ? input[i - 1] + 1 : output[i - 1];
                  while (model.equations.length <= i) {
                      this.bindEquation();
                  }
                  const equation = model.equations[i];
                  // sample predicted letter
                  const outputMatrix = equation.runIndex(previousIndex);
                  const logProbabilities = new Matrix(model.output.rows, model.output.columns);
                  copy(logProbabilities, outputMatrix);
                  if (temperature !== 1 && isSampleI) {
                      /**
                       * scale log probabilities by temperature and re-normalize
                       * if temperature is high, logProbabilities will go towards zero
                       * and the softmax outputs will be more difblackpard. if temperature is
                       * very low, the softmax outputs will be more peaky
                       */
                      for (let j = 0, max = logProbabilities.weights.length; j < max; j++) {
                          logProbabilities.weights[j] /= temperature;
                      }
                  }
                  const probs = softmax(logProbabilities);
                  const nextIndex = isSampleI ? sampleI(probs) : maxI(probs);
                  i++;
                  if (nextIndex === 0) {
                      // END token predicted, break out
                      break;
                  }
                  if (i >= maxPredictionLength) {
                      // something is wrong
                      break;
                  }
                  output.push(nextIndex);
              }
              /**
               * we slice the input length here, not because output contains it, but it will be erroneous as we are sending the
               * network what is contained in input, so the data is essentially guessed by the network what could be next, till it
               * locks in on a value.
               * Kind of like this, values are from input:
               * 0 -> 4 (or in English: "beginning on input" -> "I have no idea? I'll guess what they want next!")
               * 2 -> 2 (oh how interesting, I've narrowed down values...)
               * 1 -> 9 (oh how interesting, I've now know what the values are...)
               * then the output looks like: [4, 2, 9,...]
               * so we then remove the erroneous data to get our true output
               */
              return this.options.dataFormatter.formatDataOut(input, output.slice(input.length).map((value) => value - 1));
          }
          /**
           *
           * Verifies network sizes are initialized
           * If they are not it will initialize them
           */
          verifyIsInitialized() {
              if (!this.model.isInitialized) {
                  this.initialize();
              }
          }
          /**
           *
           * @param options
           *    Supports all `trainDefaults` properties
           *    also supports:
           *       learningRate: (number),
           *       momentum: (number),
           *       activation: 'sigmoid', 'relu', 'leaky-relu', 'tanh'
           */
          updateTrainingOptions(options) {
              var _a;
              this.trainOpts = { ...trainDefaults$1, ...options };
              this.validateTrainingOptions(this.trainOpts);
              this.setLogMethod((_a = options.log) !== null && _a !== void 0 ? _a : this.trainOpts.log);
              // TODO: Remove this?
              // this.activation = options.activation || this.activation;
          }
          validateTrainingOptions(options) {
              const validations = {
                  iterations: () => {
                      const val = options.iterations;
                      return typeof val === 'number' && val > 0;
                  },
                  errorThresh: () => {
                      const val = options.errorThresh;
                      return typeof val === 'number' && val > 0 && val < 1;
                  },
                  log: () => {
                      const val = options.log;
                      return typeof val === 'function' || typeof val === 'boolean';
                  },
                  logPeriod: () => {
                      const val = options.logPeriod;
                      return typeof val === 'number' && val > 0;
                  },
                  learningRate: () => {
                      const val = options.learningRate;
                      return typeof val === 'number' && val > 0 && val < 1;
                  },
                  callback: () => {
                      const val = options.callback;
                      return typeof val === 'function' || val === undefined;
                  },
                  callbackPeriod: () => {
                      const val = options.callbackPeriod;
                      return typeof val === 'number' && val > 0;
                  },
                  timeout: () => {
                      const val = options.timeout;
                      return typeof val === 'number' && val > 0;
                  },
              };
              for (const p in validations) {
                  const v = options;
                  if (!validations[p]()) {
                      throw new Error(`[${p}, ${v[p]}] is out of normal training range, your network will probably not train.`);
                  }
              }
          }
          setLogMethod(log) {
              if (typeof log === 'function') {
                  this.trainOpts.log = log;
              }
              else if (log) {
                  this.trainOpts.log = console.log;
              }
              else {
                  this.trainOpts.log = false;
              }
          }
          prepTraining(data, options) {
              var _a;
              this.updateTrainingOptions(options);
              const preparedData = this.options.dataFormatter.format(data);
              const endTime = Date.now() + ((_a = this.trainOpts.timeout) !== null && _a !== void 0 ? _a : 0);
              const status = {
                  error: 1,
                  iterations: 0,
              };
              this.verifyIsInitialized();
              return {
                  preparedData,
                  status,
                  endTime,
              };
          }
          train(data, trainOpts = {}) {
              var _a;
              this.trainOpts = trainOpts = {
                  ...trainDefaults$1,
                  ...trainOpts,
              };
              const { iterations, errorThresh, logPeriod, callback, callbackPeriod, } = this.trainOpts;
              const log = trainOpts.log === true ? console.log : trainOpts.log;
              let error = Infinity;
              let i;
              let inputs;
              if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.dataFormatter) {
                  inputs = this.options.dataFormatter.format(data);
              }
              else if (Array.isArray(data) &&
                  Array.isArray(data[0]) &&
                  typeof data[0][0] === 'number') {
                  inputs = data;
              }
              else {
                  throw new Error('training not in expected format of number[][]');
              }
              this.verifyIsInitialized();
              for (i = 0; i < iterations && error > errorThresh; i++) {
                  let sum = 0;
                  for (let j = 0; j < inputs.length; j++) {
                      const err = this.trainPattern(inputs[j], true);
                      sum += err;
                  }
                  error = sum / data.length;
                  if (isNaN(error)) {
                      throw new Error('Network error rate is unexpected NaN, check network configurations and try again. Most probably input format is not correct or training data is not enough. ');
                  }
                  if (log && i % logPeriod === 0) {
                      log(`iterations: ${i}, training error: ${error}`);
                  }
                  if (callback && i % callbackPeriod === 0) {
                      callback({ error, iterations: i });
                  }
              }
              return {
                  error,
                  iterations: i,
              };
          }
          addFormat(data) { }
          formatData(data) {
              const result = [];
              for (let i = 0; i < data.length; i++) {
                  result.push(this.options.dataFormatter.formatDataIn(data[i]));
              }
              return result;
          }
          toJSON() {
              if (!this.model.isInitialized) {
                  this.initialize();
              }
              const { model, options } = this;
              return {
                  type: this.constructor.name,
                  options: { ...options, dataFormatter: options.dataFormatter.toJSON() },
                  trainOpts: {
                      ...this.trainOpts,
                      timeout: this.trainOpts.timeout === Infinity
                          ? 'Infinity'
                          : this.trainOpts.timeout,
                  },
                  input: model.input.toJSON(),
                  hiddenLayers: model.hiddenLayers.map((hiddenLayer) => {
                      const layers = {};
                      for (const p in hiddenLayer) {
                          if (!hiddenLayer.hasOwnProperty(p))
                              continue;
                          layers[p] = hiddenLayer[p].toJSON();
                      }
                      return layers;
                  }),
                  outputConnector: this.model.outputConnector.toJSON(),
                  output: this.model.output.toJSON(),
              };
          }
          fromJSON(json) {
              const { options } = json;
              const allMatrices = [];
              const input = Matrix.fromJSON(json.input);
              allMatrices.push(input);
              const hiddenLayers = [];
              json.hiddenLayers.forEach((hiddenLayer) => {
                  const layers = {};
                  for (const p in hiddenLayer) {
                      layers[p] = Matrix.fromJSON(hiddenLayer[p]);
                      allMatrices.push(layers[p]);
                  }
                  hiddenLayers.push(layers);
              });
              const outputConnector = Matrix.fromJSON(json.outputConnector);
              allMatrices.push(outputConnector);
              const output = Matrix.fromJSON(json.output);
              allMatrices.push(output);
              if (options.dataFormatter) {
                  this.options = {
                      ...defaults$1(),
                      ...options,
                      dataFormatter: DataFormatter.fromJSON(options.dataFormatter),
                  };
              }
              else {
                  this.options = {
                      ...defaults$1(),
                      ...options,
                      dataFormatter: new DataFormatter(),
                  };
              }
              this.model = Object.seal({
                  isInitialized: true,
                  input,
                  hiddenLayers,
                  output,
                  allMatrices,
                  outputConnector,
                  equations: [],
                  equationConnections: [],
              });
              this.initialLayerInputs = this.options.hiddenLayers.map((size) => new Matrix(size, 1));
              this.bindEquation();
              return this;
          }
          toFunction(cb) {
              const { model } = this;
              const { equations } = this.model;
              const equation = equations[1];
              const { states } = equation;
              const jsonString = JSON.stringify(this.toJSON());
              function previousConnectionIndex(m) {
                  const connection = model.equationConnections[0];
                  const { states } = equations[0];
                  for (let i = 0, max = states.length; i < max; i++) {
                      if (states[i].product === m) {
                          return i;
                      }
                  }
                  return connection.indexOf(m);
              }
              function matrixOrigin(m, stateIndex) {
                  for (let i = 0, max = states.length; i < max; i++) {
                      const state = states[i];
                      if (i === stateIndex) {
                          const j = previousConnectionIndex(m);
                          if (j > -1 && (m === state.left || m === state.right)) {
                              return `typeof prevStates[${j}] === 'object' ? prevStates[${j}].product : new Matrix(${m.rows}, ${m.columns})`;
                          }
                          return `new Matrix(${m.rows}, ${m.columns})`;
                      }
                      if (m === state.product)
                          return `states[${i}].product`;
                      if (m === state.right)
                          return `states[${i}].right`;
                      if (m === state.left)
                          return `states[${i}].left`;
                  }
                  return '';
              }
              function matrixToString(m, stateIndex) {
                  if (!m || !m.rows || !m.columns)
                      return 'null';
                  if (m === model.input)
                      return `json.input`;
                  if (m === model.outputConnector)
                      return `json.outputConnector`;
                  if (m === model.output)
                      return `json.output`;
                  for (let i = 0, max = model.hiddenLayers.length; i < max; i++) {
                      const hiddenLayer = model.hiddenLayers[i];
                      for (const p in hiddenLayer) {
                          if (!hiddenLayer.hasOwnProperty(p))
                              continue;
                          if (hiddenLayer[p] !== m)
                              continue;
                          return `json.hiddenLayers[${i}].${p}`;
                      }
                  }
                  return matrixOrigin(m, stateIndex);
              }
              function toInner(fnString) {
                  // crude, but should be sufficient for now
                  // function() { body }
                  const fnParts = fnString.toString().split('{');
                  fnParts.shift();
                  // body }
                  const fnBodyString = fnParts.join('{');
                  const fnBodyParts = fnBodyString.split('}');
                  fnBodyParts.pop();
                  // body
                  return fnBodyParts
                      .join('}')
                      .split('\n')
                      .join('\n        ')
                      .replace('product.deltas[i] = 0;', '')
                      .replace('product.deltas[column] = 0;', '')
                      .replace('left.deltas[leftIndex] = 0;', '')
                      .replace('right.deltas[rightIndex] = 0;', '')
                      .replace('product.deltas = left.deltas.slice(0);', '');
              }
              function fileName(fnName) {
                  return `src/recurrent/matrix/${fnName.replace(/[A-Z]/g, function (value) {
                  return `-${value.toLowerCase()}`;
              })}.js`;
              }
              const statesRaw = [];
              const usedFunctionNames = {};
              const innerFunctionsSwitch = [];
              for (let i = 0, max = states.length; i < max; i++) {
                  const state = states[i];
                  statesRaw.push(`states[${i}] = {
        name: '${state.forwardFn.name}',
        left: ${state.left ? matrixToString(state.left, i) : 'undefined'},
        right: ${state.right ? matrixToString(state.right, i) : 'undefined'},
        product: ${matrixToString(state.product, i)}
      }`);
                  const fnName = state.forwardFn.name;
                  if (!usedFunctionNames[fnName]) {
                      usedFunctionNames[fnName] = true;
                      innerFunctionsSwitch.push(`        case '${fnName}': //compiled from ${fileName(fnName)}
            ${toInner(state.forwardFn.toString())}
            break;`);
                  }
              }
              const src = `
    if (typeof rawInput === 'undefined') rawInput = [];
    if (typeof isSampleI === 'undefined') isSampleI = false;
    if (typeof temperature === 'undefined') temperature = 1;
    var json = ${jsonString};
    ${this.options.dataFormatter
              ? `${this.options.dataFormatter.toFunctionString()};
    Object.assign(dataFormatter, json.options.dataFormatter);`
              : ''}
    ${this.options.dataFormatter &&
              typeof this.options.dataFormatter.formatDataIn === 'function'
              ? `const formatDataIn = function (input, output) { ${toInner(this.options.dataFormatter.formatDataIn.toString())} }.bind(dataFormatter);`
              : ''}
    ${this.options.dataFormatter !== null &&
              typeof this.options.dataFormatter.formatDataOut === 'function'
              ? `const formatDataOut = function formatDataOut(input, output) { ${toInner(this.options.dataFormatter.formatDataOut.toString())} }.bind(dataFormatter);`
              : ''}
    var maxPredictionLength =
      ${this.options.maxPredictionLength} +
      rawInput.length +
      ${this.options.dataFormatter
              ? this.options.dataFormatter.specialIndexes.length
              : 0};
    var input = ${this.options.dataFormatter &&
              typeof this.options.dataFormatter.formatDataIn === 'function'
              ? 'formatDataIn(rawInput)'
              : 'rawInput'};
    var _i = 0;
    var output = [];
    var states = [];
    var prevStates;
    while (true) {
      var previousIndex = (_i === 0
          ? 0
          : _i < input.length
            ? input[_i - 1] + 1
            : output[_i - 1])
            ;
      var rowPluckIndex = previousIndex;
      prevStates = states;
      states = [];
      ${statesRaw.join(';\n    ')};
      for (var stateIndex = 0, stateMax = ${statesRaw.length}; stateIndex < stateMax; stateIndex++) {
        var state = states[stateIndex];
        var product = state.product;
        var left = state.left;
        var right = state.right;
        switch (state.name) {
  ${innerFunctionsSwitch.join('\n')}
        }
      }
  
      var logProbabilities = state.product;
      if (temperature !== 1 && isSampleI) {
        for (var q = 0, nq = logProbabilities.weights.length; q < nq; q++) {
          logProbabilities.weights[q] /= temperature;
        }
      }
  
      var probs = softmax(logProbabilities);
      var nextIndex = isSampleI ? sampleI(probs) : maxI(probs);
  
      _i++;
      if (nextIndex === 0) {
        break;
      }
      if (_i >= maxPredictionLength) {
        break;
      }
  
      output.push(nextIndex);
    }
    ${this.options.dataFormatter &&
              typeof this.options.dataFormatter.formatDataOut === 'function'
              ? 'return formatDataOut(input, output.slice(input.length).map(function(value) { return value - 1; }))'
              : 'return output.slice(input.length).map(function(value) { return value - 1; })'};
    function Matrix(rows, columns) {
      this.rows = rows;
      this.columns = columns;
      this.weights = zeros(rows * columns);
    }
    ${zeros$1.toString()}
    ${softmax.toString().replace('_1.Matrix', 'Matrix')}
    ${randomFloat.toString()}
    ${sampleI.toString()}
    ${maxI.toString()}`;
              // eslint-disable-next-line
              return new Function('rawInput', 'isSampleI', 'temperature', cb ? cb(src) : src);
          }
          trainPattern(input, logErrorRate) {
              const error = this.trainInput(input);
              this.backpropagate(input);
              this.adjustWeights();
              if (logErrorRate) {
                  return error;
              }
              return 0;
          }
      }
      function last(values) {
          return values[values.length - 1];
      }
  
      class GRU extends RNN {
          getHiddenLayer(hiddenSize, prevSize) {
              return getGRUHiddenLayer(hiddenSize, prevSize);
          }
          getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
              return getGRUEquation(equation, inputMatrix, previousResult, hiddenLayer);
          }
      }
      function getGRUHiddenLayer(hiddenSize, prevSize) {
          return {
              // update Gate
              // wzxh
              updateGateInputMatrix: new RandomMatrix(hiddenSize, prevSize, 0.08),
              updateGateHiddenMatrix: new RandomMatrix(hiddenSize, hiddenSize, 0.08),
              updateGateBias: new Matrix(hiddenSize, 1),
              // reset Gate
              // wrxh
              resetGateInputMatrix: new RandomMatrix(hiddenSize, prevSize, 0.08),
              resetGateHiddenMatrix: new RandomMatrix(hiddenSize, hiddenSize, 0.08),
              resetGateBias: new Matrix(hiddenSize, 1),
              // cell write parameters
              // wcxh
              cellWriteInputMatrix: new RandomMatrix(hiddenSize, prevSize, 0.08),
              cellWriteHiddenMatrix: new RandomMatrix(hiddenSize, hiddenSize, 0.08),
              cellWriteBias: new Matrix(hiddenSize, 1),
          };
      }
      function getGRUEquation(equation, inputMatrix, previousResult, hiddenLayer) {
          if (!hiddenLayer.updateGateInputMatrix ||
              !hiddenLayer.updateGateHiddenMatrix ||
              !hiddenLayer.updateGateBias ||
              !hiddenLayer.resetGateInputMatrix ||
              !hiddenLayer.resetGateHiddenMatrix ||
              !hiddenLayer.resetGateBias ||
              !hiddenLayer.cellWriteInputMatrix ||
              !hiddenLayer.cellWriteHiddenMatrix ||
              !hiddenLayer.cellWriteBias) {
              throw new Error('hiddenLayer does not have expected properties');
          }
          const sigmoid = equation.sigmoid.bind(equation);
          const add = equation.add.bind(equation);
          const multiply = equation.multiply.bind(equation);
          const multiplyElement = equation.multiplyElement.bind(equation);
          const tanh = equation.tanh.bind(equation);
          const allOnes = equation.allOnes.bind(equation);
          const cloneNegative = equation.cloneNegative.bind(equation);
          // update gate
          const updateGate = sigmoid(add(add(multiply(hiddenLayer.updateGateInputMatrix, inputMatrix), multiply(hiddenLayer.updateGateHiddenMatrix, previousResult)), hiddenLayer.updateGateBias));
          // reset gate
          const resetGate = sigmoid(add(add(multiply(hiddenLayer.resetGateInputMatrix, inputMatrix), multiply(hiddenLayer.resetGateHiddenMatrix, previousResult)), hiddenLayer.resetGateBias));
          // cell
          const cell = tanh(add(add(multiply(hiddenLayer.cellWriteInputMatrix, inputMatrix), multiply(hiddenLayer.cellWriteHiddenMatrix, multiplyElement(resetGate, previousResult))), hiddenLayer.cellWriteBias));
          // compute hidden state as gated, saturated cell activations
          // negate updateGate
          return add(multiplyElement(add(allOnes(updateGate.rows, updateGate.columns), cloneNegative(updateGate)), cell), multiplyElement(previousResult, updateGate));
      }
  
      class ArrayLookupTable {
          constructor(data, prop) {
              this.prop = prop;
              this.length = 0;
              this.table = {};
              for (let i = 0; i < data.length; i++) {
                  const datum = data[i];
                  const ioValue = datum[prop];
                  for (let j = 0; j < ioValue.length; j++) {
                      const value = ioValue[j];
                      for (const p in value) {
                          if (!value.hasOwnProperty(p))
                              continue;
                          if (this.table.hasOwnProperty(p))
                              continue;
                          this.table[p] = this.length++;
                      }
                  }
              }
          }
      }
  
      const defaults = () => {
          return {
              ...defaults$1(),
              inputSize: 1,
              hiddenLayers: [20],
              outputSize: 1,
              inputRange: 0,
          };
      };
      class RNNTimeStep extends RNN {
          constructor(options = {}) {
              super();
              this.inputLookupLength = 0;
              this.inputLookup = null;
              this.outputLookup = null;
              this.outputLookupLength = 0;
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-expect-error
              this.model = Object.seal({
                  isInitialized: false,
                  hiddenLayers: [],
                  output: new Matrix(0, 0),
                  equations: [],
                  allMatrices: [],
                  equationConnections: [],
                  outputConnector: new RandomMatrix(0, 0, 0.08),
              });
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-expect-error
              this.options = defaults();
              this.options = { ...this.options, ...options };
              this.updateTrainingOptions({
                  ...trainDefaults,
                  ...options,
              });
              if (options.json) {
                  this.fromJSON(options.json);
              }
          }
          createInputMatrix() {
              throw new Error('Input Matrices do not exist on RNNTimeStep');
          }
          createOutputMatrices() {
              const { outputSize } = this.options;
              const lastHiddenSize = last(this.options.hiddenLayers);
              // whd
              const outputConnector = new RandomMatrix(outputSize, lastHiddenSize, 0.08);
              // bd
              const output = new RandomMatrix(outputSize, 1, 0.08);
              return { output, outputConnector };
          }
          bindEquation() {
              const { model, options } = this;
              const { hiddenLayers, inputSize } = options;
              const layers = model.hiddenLayers;
              const equation = new Equation();
              const outputs = [];
              const equationConnection = model.equationConnections.length > 0
                  ? model.equationConnections[model.equationConnections.length - 1]
                  : this.initialLayerInputs;
              // 0 index
              let output = this.getEquation(equation, equation.input(new Matrix(inputSize, 1)), equationConnection[0], layers[0]);
              outputs.push(output);
              // 1+ indices
              for (let i = 1, max = hiddenLayers.length; i < max; i++) {
                  output = this.getEquation(equation, output, equationConnection[i], layers[i]);
                  outputs.push(output);
              }
              model.equationConnections.push(outputs);
              equation.add(equation.multiply(model.outputConnector, output), model.output);
              model.equations.push(equation);
          }
          initialize() {
              this.model = this.mapModel();
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          mapModel() {
              const allMatrices = [];
              this.initialLayerInputs = this.options.hiddenLayers.map((size) => new Matrix(size, 1));
              const hiddenLayers = this.createHiddenLayers();
              for (let i = 0, max = hiddenLayers.length; i < max; i++) {
                  const hiddenMatrix = hiddenLayers[i];
                  for (const property in hiddenMatrix) {
                      if (!hiddenMatrix.hasOwnProperty(property))
                          continue;
                      allMatrices.push(hiddenMatrix[property]);
                  }
              }
              const { outputConnector, output } = this.createOutputMatrices();
              allMatrices.push(outputConnector);
              allMatrices.push(output);
              return Object.seal({
                  isInitialized: true,
                  hiddenLayers,
                  output,
                  equations: [],
                  allMatrices,
                  equationConnections: [],
                  outputConnector,
              });
          }
          backpropagate() {
              for (let i = this.model.equations.length - 1; i > -1; i--) {
                  this.model.equations[i].backpropagate();
              }
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          run(rawInput) {
              const shape = lookup.dataShape(rawInput).join(',');
              switch (shape) {
                  case 'array,number':
                      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                      // @ts-expect-error
                      return this.runArray(rawInput);
                  case 'array,array,number':
                      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                      // @ts-expect-error
                      return this.runArrayOfArray(rawInput);
                  case 'object,number':
                      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                      // @ts-expect-error
                      return this.runObject(rawInput); // Backward compatibility, will be result of `unknown` and need casting.  Better to just use net.runObject() directly
                  case 'array,object,number':
                      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                      // @ts-expect-error
                      return this.runArrayOfObject(rawInput);
                  default:
                      throw new Error(`Unrecognized data shape ${shape}`);
              }
          }
          forecast(rawInput, count = 1) {
              const shape = lookup.dataShape(rawInput).join(',');
              switch (shape) {
                  case 'array,number':
                      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                      // @ts-expect-error
                      return this.forecastArray(rawInput, count);
                  case 'array,array,number':
                      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                      // @ts-expect-error
                      return this.forecastArrayOfArray(rawInput, count);
                  case 'object,number':
                      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                      // @ts-expect-error
                      return this.runObject(rawInput);
                  case 'array,object,number':
                      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                      // @ts-expect-error
                      return this.forecastArrayOfObject(rawInput, count);
                  default:
                      throw new Error(`Unrecognized data shape ${shape}`);
              }
          }
          forecastArray(input, count = 1) {
              this.checkRunnable();
              const { model } = this;
              const { equations } = model;
              const length = input.length + count;
              while (equations.length <= length) {
                  this.bindEquation();
              }
              let lastOutput;
              let equationIndex = 0;
              if (this.options.inputSize === 1) {
                  for (let i = 0; i < input.length; i++) {
                      lastOutput = equations[equationIndex++].runInput(Float32Array.from([input[i]]));
                  }
              }
              else {
                  for (let i = 0; i < input.length; i++) {
                      lastOutput = equations[equationIndex++].runInput(Float32Array.from([]));
                  }
              }
              if (!lastOutput) {
                  throw new Error('lastOutput not set');
              }
              const result = [lastOutput.weights[0]];
              for (let i = 0, max = count - 1; i < max; i++) {
                  lastOutput = equations[equationIndex++].runInput(lastOutput.weights);
                  result.push(lastOutput.weights[0]);
              }
              this.end();
              return Float32Array.from(result);
          }
          forecastArrayOfArray(input, count = 1) {
              this.checkRunnable();
              const { model } = this;
              const { equations } = model;
              const length = input.length + count;
              while (equations.length <= length) {
                  this.bindEquation();
              }
              let lastOutput;
              let equationIndex = 0;
              for (let i = 0; i < input.length; i++) {
                  lastOutput = equations[equationIndex++].runInput(input[i]);
              }
              if (!lastOutput) {
                  throw new Error('lastOutput not set');
              }
              const result = [Float32Array.from(lastOutput.weights)];
              for (let i = 0, max = count - 1; i < max; i++) {
                  lastOutput = equations[equationIndex++].runInput(lastOutput.weights);
                  result.push(Float32Array.from(lastOutput.weights.slice(0)));
              }
              this.end();
              return result;
          }
          forecastArrayOfObject(input, count = 1) {
              if (!this.inputLookup) {
                  throw new Error('this.inputLookup not set');
              }
              if (!this.outputLookup) {
                  throw new Error('this.outputLookup not set');
              }
              const formattedData = input.map((value) => lookup.toArray(this.inputLookup, value, this.inputLookupLength));
              return this.forecastArrayOfArray(formattedData, count).map((value) => lookup.toObject(this.outputLookup, value));
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          train(data, trainOpts = {}) {
              this.trainOpts = trainOpts = {
                  ...trainDefaults$1,
                  ...trainOpts,
              };
              // Don't destructure here because this.setSize() can reset this.options.
              if (this.options.inputSize === 1 && this.options.outputSize === 1) {
                  this.setSize(data);
              }
              this.verifySize();
              const formattedData = this.formatData(data);
              let error = Infinity;
              let i;
              this.verifyIsInitialized();
              const { iterations, errorThresh, logPeriod, callback, callbackPeriod, } = this.trainOpts;
              const log = trainOpts.log === true ? console.log : trainOpts.log;
              for (i = 0; i < iterations && error > errorThresh; i++) {
                  let sum = 0;
                  for (let j = 0; j < formattedData.length; j++) {
                      const err = this.trainPattern(formattedData[j], true);
                      sum += err;
                  }
                  error = sum / formattedData.length;
                  if (isNaN(error))
                      throw new Error('Network error rate is unexpected NaN, check network configurations and try again. Most probably input format is not correct or training data is not enough. ');
                  if (log && i % logPeriod === 0) {
                      log(`iterations: ${i}, training error: ${error}`);
                  }
                  if (callback && i % callbackPeriod === 0) {
                      callback({ error, iterations: i });
                  }
              }
              return {
                  error,
                  iterations: i,
              };
          }
          trainArrayOfArray(input) {
              if (input.length < 2) {
                  throw new Error('input must be an array of 2 or more');
              }
              const { equations } = this.model;
              while (equations.length < input.length) {
                  this.bindEquation();
              }
              let errorSum = 0;
              for (let i = 0, max = input.length - 1; i < max; i++) {
                  errorSum += equations[i].predictTarget(input[i], input[i + 1]);
              }
              this.end();
              return errorSum / input.length;
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          trainPattern(input, logErrorRate) {
              const error = this.trainArrayOfArray(input);
              this.backpropagate();
              this.adjustWeights();
              if (logErrorRate) {
                  return error;
              }
              return 0;
          }
          setSize(data) {
              let size = 0;
              const dataShape = lookup.dataShape(data).join(',');
              switch (dataShape) {
                  case 'array,array,number':
                  case 'array,object,number':
                  case 'array,datum,array,number':
                  case 'array,datum,object,number':
                      size = 1;
                      // probably 1
                      break;
                  case 'array,array,array,number':
                      size = data[0][0].length;
                      break;
                  case 'array,array,object,number':
                      // inputs and outputs should match
                      size = Object.keys(lookup.toTable2D(data)).length;
                      break;
                  case 'array,datum,array,array,number':
                      size = data[0].input[0].length;
                      break;
                  case 'array,datum,array,object,number':
                      size = Object.keys(lookup.toInputTable2D(data)).length;
                      break;
                  default:
                      throw new Error('unknown data shape or configuration');
              }
              this.options = Object.seal({
                  ...this.options,
                  inputSize: size,
                  outputSize: size,
              });
          }
          verifySize() {
              if (this.options.inputSize || this.options.outputSize) {
                  if (this.options.inputSize !== this.options.outputSize) {
                      throw new Error('manually set inputSize and outputSize mismatch');
                  }
              }
          }
          runArray(input) {
              this.checkRunnable();
              const { equations } = this.model;
              while (equations.length <= input.length) {
                  this.bindEquation();
              }
              let lastOutput;
              for (let i = 0; i < input.length; i++) {
                  lastOutput = equations[i].runInput(new Float32Array([input[i]]));
              }
              this.end();
              return lastOutput.weights[0];
          }
          runArrayOfArray(input) {
              this.checkRunnable();
              const { model } = this;
              const { equations } = model;
              while (equations.length <= input.length) {
                  this.bindEquation();
              }
              let lastOutput;
              for (let i = 0; i < input.length; i++) {
                  const outputMatrix = equations[i].runInput(input[i]);
                  lastOutput = outputMatrix.weights;
              }
              this.end();
              return lastOutput !== null && lastOutput !== void 0 ? lastOutput : Float32Array.from([]);
          }
          runObject(input) {
              if (!this.inputLookup) {
                  throw new Error('this.inputLookup not set');
              }
              if (!this.outputLookup) {
                  throw new Error('this.outputLookup not set');
              }
              if (!this.outputLookupLength) {
                  throw new Error('this.outputLookupLength not set');
              }
              if (this.inputLookup === this.outputLookup) {
                  const inputArray = lookup.toArrayShort(this.inputLookup, input);
                  return lookup.toObjectPartial(this.outputLookup, this.forecastArray(inputArray, this.outputLookupLength - inputArray.length), inputArray.length);
              }
              return lookup.toObject(this.outputLookup, this.forecastArray(lookup.toArray(this.inputLookup, input, this.inputLookupLength), this.outputLookupLength));
          }
          runArrayOfObject(input) {
              if (this.inputLookup === null) {
                  throw new Error('this.inputLookup not set');
              }
              if (this.outputLookup === null) {
                  throw new Error('this.outputLookup not set');
              }
              const formattedInput = input.map((value) => lookup.toArray(this.inputLookup, value, this.inputLookupLength));
              return this.forecastArrayOfArray(formattedInput, 1).map((value) => lookup.toObject(this.outputLookup, value))[0];
          }
          runArrayOfObjectOfArray(input) {
              if (!this.inputLookup) {
                  throw new Error('this.inputLookup not set');
              }
              if (!this.outputLookup) {
                  throw new Error('this.outputLookup not set');
              }
              return lookup.toObject(this.outputLookup, this.runArrayOfArray(lookup.toArrays(this.inputLookup, input, this.inputLookupLength)));
          }
          end() {
              this.model.equations[this.model.equations.length - 1].runInput(new Float32Array(this.options.outputSize));
          }
          requireInputOutputOfOne() {
              if (this.options.inputSize !== 1) {
                  throw new Error('inputSize must be 1 for this data size');
              }
              if (this.options.outputSize !== 1) {
                  throw new Error('outputSize must be 1 for this data size');
              }
          }
          // Handles data shape of 'array,number'
          formatArray(data) {
              const result = [];
              this.requireInputOutputOfOne();
              for (let i = 0; i < data.length; i++) {
                  result.push(Float32Array.from([data[i]]));
              }
              return [result];
          }
          // Handles data shape of 'array,array,number'
          formatArrayOfArray(data) {
              const result = [];
              const { inputSize, outputSize } = this.options;
              if (inputSize === 1 && outputSize === 1) {
                  for (let i = 0; i < data.length; i++) {
                      result.push(arrayToFloat32Arrays(data[i]));
                  }
                  return result;
              }
              if (inputSize !== data[0].length) {
                  throw new Error('inputSize must match data input size');
              }
              if (outputSize !== data[0].length) {
                  throw new Error('outputSize must match data output size');
              }
              for (let i = 0; i < data.length; i++) {
                  result.push(Float32Array.from(data[i]));
              }
              return [result];
          }
          // Handles data shape of 'array,object,number'
          formatArrayOfObject(data) {
              this.requireInputOutputOfOne();
              if (!this.inputLookup) {
                  const lookupTable = new LookupTable(data);
                  this.inputLookup = this.outputLookup = lookupTable.table;
                  this.inputLookupLength = this.outputLookupLength = lookupTable.length;
              }
              const result = [];
              for (let i = 0; i < data.length; i++) {
                  result.push(objectToFloat32Arrays(data[i]));
              }
              return result;
          }
          // Handles data shape of 'array,object,number' when this.options.inputSize > 1
          formatArrayOfObjectMulti(data) {
              if (!this.inputLookup) {
                  const lookupTable = new LookupTable(data);
                  this.inputLookup = this.outputLookup = lookupTable.table;
                  this.inputLookupLength = this.outputLookupLength = lookupTable.length;
              }
              const result = [];
              for (let i = 0; i < data.length; i++) {
                  result.push([
                      objectToFloat32Array(data[i], this.inputLookup, this.inputLookupLength),
                  ]);
              }
              return result;
          }
          // Handles data shape of 'array,datum,array,number'
          formatArrayOfDatumOfArray(data) {
              const result = [];
              this.requireInputOutputOfOne();
              for (let i = 0; i < data.length; i++) {
                  const datum = data[i];
                  result.push(inputOutputArrayToFloat32Arrays(datum.input, datum.output));
              }
              return result;
          }
          // Handles data shape of 'array,datum,object,number'
          formatArrayOfDatumOfObject(data) {
              this.requireInputOutputOfOne();
              if (!this.inputLookup) {
                  const inputLookup = new LookupTable(data, 'input');
                  this.inputLookup = inputLookup.table;
                  this.inputLookupLength = inputLookup.length;
              }
              if (!this.outputLookup) {
                  const outputLookup = new LookupTable(data, 'output');
                  this.outputLookup = outputLookup.table;
                  this.outputLookupLength = outputLookup.length;
              }
              const result = [];
              for (let i = 0; i < data.length; i++) {
                  const datum = data[i];
                  result.push(inputOutputObjectToFloat32Arrays(datum.input, datum.output));
              }
              return result;
          }
          // Handles data shape of 'array,array,array,number'
          formatArrayOfArrayOfArray(data) {
              const result = [];
              for (let i = 0; i < data.length; i++) {
                  result.push(arraysToFloat32Arrays(data[i]));
              }
              return result;
          }
          // Handles data shape of 'array,array,object,number'
          formatArrayOfArrayOfObject(data) {
              if (!this.inputLookup) {
                  const lookupTable = new LookupTable(data);
                  this.inputLookup = this.outputLookup = lookupTable.table;
                  this.inputLookupLength = this.outputLookupLength = lookupTable.length;
              }
              const result = [];
              for (let i = 0; i < data.length; i++) {
                  const array = [];
                  for (let j = 0; j < data[i].length; j++) {
                      array.push(objectToFloat32Array(data[i][j], this.inputLookup, this.inputLookupLength));
                  }
                  result.push(array);
              }
              return result;
          }
          // Handles data shape of 'array,datum,array,array,number'
          formatArrayOfDatumOfArrayOfArray(data) {
              const result = [];
              const { inputSize, outputSize } = this.options;
              if (inputSize !== data[0].input[0].length) {
                  throw new Error('inputSize must match data input size');
              }
              if (outputSize !== data[0].output[0].length) {
                  throw new Error('outputSize must match data output size');
              }
              for (let i = 0; i < data.length; i++) {
                  const datum = data[i];
                  result.push(inputOutputArraysToFloat32Arrays(datum.input, datum.output));
              }
              return result;
          }
          // 'Handles data shape of array,datum,array,object,number'
          formatArrayOfDatumOfArrayOfObject(data) {
              if (!this.inputLookup) {
                  const inputLookup = new ArrayLookupTable(data, 'input');
                  this.inputLookup = inputLookup.table;
                  this.inputLookupLength = inputLookup.length;
              }
              if (!this.outputLookup) {
                  const outputLookup = new ArrayLookupTable(data, 'output');
                  this.outputLookup = outputLookup.table;
                  this.outputLookupLength = outputLookup.length;
              }
              if (!this.outputLookupLength) {
                  throw new Error('this.outputLookupLength not set to usable number');
              }
              const result = [];
              for (let i = 0; i < data.length; i++) {
                  const datum = data[i];
                  result.push(inputOutputObjectsToFloat32Arrays(datum.input, datum.output, this.inputLookup, this.outputLookup, this.inputLookupLength, this.outputLookupLength));
              }
              return result;
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          formatData(data) {
              const dataShape = lookup.dataShape(data).join(',');
              switch (dataShape) {
                  case 'array,number':
                      return this.formatArray(data);
                  case 'array,array,number':
                      return this.formatArrayOfArray(data);
                  case 'array,object,number':
                      if (this.options.inputSize === 1) {
                          return this.formatArrayOfObject(data);
                      }
                      else {
                          return this.formatArrayOfObjectMulti(data);
                      }
                  case 'array,datum,array,number':
                      return this.formatArrayOfDatumOfArray(data);
                  case 'array,datum,object,number':
                      return this.formatArrayOfDatumOfObject(data);
                  case 'array,array,array,number':
                      return this.formatArrayOfArrayOfArray(data);
                  case 'array,array,object,number':
                      return this.formatArrayOfArrayOfObject(data);
                  case 'array,datum,array,array,number':
                      return this.formatArrayOfDatumOfArrayOfArray(data);
                  case 'array,datum,array,object,number':
                      return this.formatArrayOfDatumOfArrayOfObject(data);
                  default:
                      throw new Error('unknown data shape or configuration');
              }
          }
          test(data) {
              // for classification problems
              const misclasses = [];
              // run each pattern through the trained network and collect
              // error and misclassification statistics
              let errorSum = 0;
              const formattedData = this.formatData(data);
              for (let i = 0; i < formattedData.length; i++) {
                  const input = formattedData[i];
                  const output = this.run(input.splice(0, input.length - 1));
                  const target = input[input.length - 1];
                  let errors = 0;
                  let errorCount = 0;
                  for (let j = 0; j < output.length; j++) {
                      errorCount++;
                      const error = target[j] - output[j];
                      // mse
                      errors += error * error;
                  }
                  errorSum += errors / errorCount;
                  const errorsAbs = Math.abs(errors);
                  if (errorsAbs > this.trainOpts.errorThresh) {
                      const misclass = data[i];
                      misclasses.push({
                          value: misclass,
                          actual: output,
                      });
                  }
              }
              return {
                  error: errorSum / formattedData.length,
                  misclasses,
                  total: formattedData.length,
              };
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          addFormat(value) {
              var _a, _b, _c, _d, _e, _f;
              const dataShape = lookup.dataShape(value).join(',');
              switch (dataShape) {
                  case 'array,array,number':
                  case 'datum,array,array,number':
                  case 'array,number':
                  case 'datum,array,number':
                      return;
                  case 'datum,object,number': {
                      this.inputLookup = lookup.addKeys(value.input, (_a = this.inputLookup) !== null && _a !== void 0 ? _a : {});
                      if (this.inputLookup) {
                          this.inputLookupLength = Object.keys(this.inputLookup).length;
                      }
                      this.outputLookup = lookup.addKeys(value.output, (_b = this.outputLookup) !== null && _b !== void 0 ? _b : {});
                      if (this.outputLookup) {
                          this.outputLookupLength = Object.keys(this.outputLookup).length;
                      }
                      break;
                  }
                  case 'object,number': {
                      this.inputLookup = this.outputLookup = lookup.addKeys(value, (_c = this.inputLookup) !== null && _c !== void 0 ? _c : {});
                      if (this.inputLookup) {
                          this.inputLookupLength = this.outputLookupLength = Object.keys(this.inputLookup).length;
                      }
                      break;
                  }
                  case 'array,object,number': {
                      const typedValue = value;
                      for (let i = 0; i < typedValue.length; i++) {
                          this.inputLookup = this.outputLookup = lookup.addKeys(typedValue[i], (_d = this.inputLookup) !== null && _d !== void 0 ? _d : {});
                          if (this.inputLookup) {
                              this.inputLookupLength = this.outputLookupLength = Object.keys(this.inputLookup).length;
                          }
                      }
                      break;
                  }
                  case 'datum,array,object,number': {
                      const typedValue = value;
                      const typedInput = typedValue.input;
                      for (let i = 0; i < typedInput.length; i++) {
                          this.inputLookup = lookup.addKeys(typedInput[i], (_e = this.inputLookup) !== null && _e !== void 0 ? _e : {});
                          if (this.inputLookup) {
                              this.inputLookupLength = Object.keys(this.inputLookup).length;
                          }
                      }
                      const typedOutput = typedValue.output;
                      for (let i = 0; i < typedOutput.length; i++) {
                          this.outputLookup = lookup.addKeys(typedOutput[i], (_f = this.outputLookup) !== null && _f !== void 0 ? _f : {});
                          if (this.outputLookup) {
                              this.outputLookupLength = Object.keys(this.outputLookup).length;
                          }
                      }
                      break;
                  }
                  default:
                      throw new Error('unknown data shape or configuration');
              }
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          toJSON() {
              if (!this.model) {
                  this.initialize();
              }
              const { model } = this;
              const options = { ...this.options, ...defaults$1 };
              return {
                  type: this.constructor.name,
                  options,
                  hiddenLayers: model.hiddenLayers.map((hiddenLayer) => {
                      const layers = {};
                      for (const p in hiddenLayer) {
                          if (!hiddenLayer.hasOwnProperty(p))
                              continue;
                          layers[p] = hiddenLayer[p].toJSON();
                      }
                      return layers;
                  }),
                  outputConnector: model.outputConnector.toJSON(),
                  output: model.output.toJSON(),
                  inputLookup: this.inputLookup,
                  inputLookupLength: this.inputLookupLength,
                  outputLookup: this.outputLookup,
                  outputLookupLength: this.outputLookupLength,
              };
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          fromJSON(json) {
              const { options } = json;
              const allMatrices = [];
              const hiddenLayers = [];
              // backward compatibility for hiddenSizes
              json.hiddenLayers.forEach((hiddenLayer) => {
                  const layers = {};
                  for (const p in hiddenLayer) {
                      layers[p] = Matrix.fromJSON(hiddenLayer[p]);
                      allMatrices.push(layers[p]);
                  }
                  hiddenLayers.push(layers);
              });
              const outputConnector = Matrix.fromJSON(json.outputConnector);
              allMatrices.push(outputConnector);
              const output = Matrix.fromJSON(json.output);
              allMatrices.push(output);
              // eslint-disable-next-line @typescript-eslint/ban-ts-comment
              // @ts-expect-error
              this.options = { ...defaults(), ...options };
              this.inputLookup = json.inputLookup;
              this.inputLookupLength = json.inputLookupLength;
              this.outputLookup = json.outputLookup;
              this.outputLookupLength = json.outputLookupLength;
              this.model = Object.seal({
                  isInitialized: true,
                  hiddenLayers,
                  output,
                  allMatrices,
                  outputConnector,
                  equations: [],
                  equationConnections: [],
              });
              this.initialLayerInputs = options.hiddenLayers.map((size) => new Matrix(size, 1));
              this.bindEquation();
              return this;
          }
          // eslint-disable-next-line @typescript-eslint/ban-ts-comment
          // @ts-expect-error
          toFunction(cb) {
              const { model, inputLookup, inputLookupLength, outputLookup, outputLookupLength, } = this;
              const { inputSize } = this.options;
              const { equations } = model;
              const equation = equations[1];
              const { states } = equation;
              const jsonString = JSON.stringify(this.toJSON());
              function previousConnectionIndex(m) {
                  const connection = model.equationConnections[0];
                  const { states } = equations[0];
                  for (let i = 0, max = states.length; i < max; i++) {
                      if (states[i].product === m) {
                          return i;
                      }
                  }
                  return connection.indexOf(m);
              }
              function matrixOrigin(m, stateIndex) {
                  for (let i = 0, max = states.length; i < max; i++) {
                      const state = states[i];
                      if (i === stateIndex) {
                          const j = previousConnectionIndex(m);
                          switch (m) {
                              case state.left:
                                  if (j > -1) {
                                      return `typeof prevStates[${j}] === 'object' ? prevStates[${j}].product : new Matrix(${m.rows}, ${m.columns})`;
                                  }
                              // eslint-disable-next-line no-fallthrough
                              case state.right:
                                  if (j > -1) {
                                      return `typeof prevStates[${j}] === 'object' ? prevStates[${j}].product : new Matrix(${m.rows}, ${m.columns})`;
                                  }
                              // eslint-disable-next-line no-fallthrough
                              case state.product:
                                  return `new Matrix(${m.rows}, ${m.columns})`;
                              default:
                                  throw Error('unknown state');
                          }
                      }
                      if (m === state.product)
                          return `states[${i}].product`;
                      if (m === state.right)
                          return `states[${i}].right`;
                      if (m === state.left)
                          return `states[${i}].left`;
                  }
                  return '';
              }
              function matrixToString(m, stateIndex) {
                  if (!m || !m.rows || !m.columns)
                      return 'null';
                  if (m === model.outputConnector)
                      return `json.outputConnector`;
                  if (m === model.output)
                      return `json.output`;
                  for (let i = 0, max = model.hiddenLayers.length; i < max; i++) {
                      const hiddenLayer = model.hiddenLayers[i];
                      for (const p in hiddenLayer) {
                          if (!hiddenLayer.hasOwnProperty(p))
                              continue;
                          if (hiddenLayer[p] !== m)
                              continue;
                          return `json.hiddenLayers[${i}].${p}`;
                      }
                  }
                  return matrixOrigin(m, stateIndex);
              }
              function formatInputData() {
                  if (!inputLookup)
                      return '';
                  if (inputSize === 1) {
                      if (inputLookup === outputLookup) {
                          return `function lookupInput(input) {
              var table = ${JSON.stringify(inputLookup)};
              var result = [];
              for (var p in table) {
                if (!input.hasOwnProperty(p)) break;
                result.push(Float32Array.from([input[p]]));
              }
              return result;
            }`;
                      }
                      return `function lookupInput(input) {
            var table = ${JSON.stringify(inputLookup)};
            var result = [];
            for (var p in table) {
              result.push(Float32Array.from([input[p]]));
            }
            return result;
          }`;
                  }
                  return `function lookupInput(rawInputs) {
          var table = ${JSON.stringify(inputLookup)};
          var result = [];
          for (var i = 0; i < rawInputs.length; i++) {
            var rawInput = rawInputs[i];
            var input = new Float32Array(${inputLookupLength});
            for (var p in table) {
              input[table[p]] = rawInput.hasOwnProperty(p) ? rawInput[p] : 0;
            }
            result.push(input);
          }
          return result;
        }`;
              }
              function formatOutputData() {
                  if (!outputLookup)
                      return '';
                  if (inputSize === 1) {
                      if (inputLookup === outputLookup) {
                          return `function lookupOutputPartial(output, input) {
              var table = ${JSON.stringify(outputLookup)};
              var offset = input.length;
              var result = {};
              var i = 0;
              for (var p in table) {
                if (i++ < offset) continue;
                result[p] = output[table[p] - offset][0];
              }
              return result;
            }`;
                      }
                      return `function lookupOutput(output) {
            var table = ${JSON.stringify(outputLookup)};
            var result = {};
            for (var p in table) {
              result[p] = output[table[p]][0];
            }
            return result;
          }`;
                  }
                  return `function lookupOutput(output) {
          var table = ${JSON.stringify(outputLookup)};
          var result = {};
          for (var p in table) {
            result[p] = output[table[p]];
          }
          return result;
        }`;
              }
              function toInner(fnString) {
                  // crude, but should be sufficient for now
                  // function() { body }
                  // crude, but should be sufficient for now
                  // function() { body }
                  const fnParts = fnString.toString().split('{');
                  fnParts.shift();
                  // body }
                  const fnBodyString = fnParts.join('{');
                  const fnBodyParts = fnBodyString.split('}');
                  fnBodyParts.pop();
                  // body
                  return fnBodyParts
                      .join('}')
                      .split('\n')
                      .join('\n        ')
                      .replace('product.deltas[i] = 0;', '')
                      .replace('product.deltas[column] = 0;', '')
                      .replace('left.deltas[leftIndex] = 0;', '')
                      .replace('right.deltas[rightIndex] = 0;', '')
                      .replace('product.deltas = left.deltas.slice(0);', '');
              }
              function fileName(fnName) {
                  return `src/recurrent/matrix/${fnName.replace(/[A-Z]/g, function (value) {
                  return `-${value.toLowerCase()}`;
              })}.js`;
              }
              const statesRaw = [];
              const usedFunctionNames = {};
              const innerFunctionsSwitch = [];
              for (let i = 0, max = states.length; i < max; i++) {
                  const state = states[i];
                  statesRaw.push(`states[${i}] = {
        name: '${state.forwardFn.name}',
        left: ${state.left ? matrixToString(state.left, i) : 'undefined'},
        right: ${state.right ? matrixToString(state.right, i) : 'undefined'},
        product: ${matrixToString(state.product, i)}
      }`);
                  const fnName = state.forwardFn.name;
                  if (!usedFunctionNames[fnName]) {
                      usedFunctionNames[fnName] = true;
                      if (state.name === 'input') {
                          innerFunctionsSwitch.push(`case '${fnName}':`);
                          innerFunctionsSwitch.push(inputLookup && inputSize === 1
                              ? 'product.weights = _i < input.length ? input[_i]: prevStates[prevStates.length - 1].product.weights;'
                              : inputSize === 1
                                  ? 'product.weights = [input[_i]];'
                                  : 'product.weights = input[_i];');
                          innerFunctionsSwitch.push('break;');
                      }
                      else {
                          innerFunctionsSwitch.push(`        case '${fnName}':${fnName !== 'forwardFn'
                          ? ` //compiled from ${fileName(fnName)}`
                          : ''}
            ${toInner(state.forwardFn.toString())}
            break;`);
                      }
                  }
              }
              const forceForecast = inputSize === 1 && this.outputLookup;
              const src = `
    var input = ${this.inputLookup ? 'lookupInput(rawInput)' : 'rawInput'};
    var json = ${jsonString};
    var output = [];
    var states = [];
    var prevStates;
    var state;
    var max = ${forceForecast
              ? inputLookup === outputLookup
                  ? inputLookupLength
                  : `input.length + ${outputLookupLength - 1}`
              : 'input.length'};
    for (var _i = 0; _i < max; _i++) {
      prevStates = states;
      states = [];
      ${statesRaw.join(';\n    ')};
      for (var stateIndex = 0, stateMax = ${statesRaw.length}; stateIndex < stateMax; stateIndex++) {
        state = states[stateIndex];
        var product = state.product;
        var left = state.left;
        var right = state.right;
  
        switch (state.name) {
  ${innerFunctionsSwitch.join('\n')}
        }
      }
      ${inputSize === 1 && inputLookup
              ? 'if (_i >= input.length - 1) { output.push(state.product.weights); }'
              : 'output = state.product.weights;'}
    }
    ${outputLookup
              ? outputLookup === inputLookup
                  ? 'return lookupOutputPartial(output, input)'
                  : 'return lookupOutput(output)'
              : inputSize === 1
                  ? 'return output[0]'
                  : 'return output'};
    ${formatInputData()}
    ${formatOutputData()}
  
    function Matrix(rows, columns) {
      this.rows = rows;
      this.columns = columns;
      this.weights = new Float32Array(rows * columns);
    }
    ${softmax.toString().replace('_2.default', 'Matrix')}
    ${randomFloat.toString()}
    ${sampleI.toString()}
    ${maxI.toString()}`;
              // eslint-disable-next-line
              return new Function('rawInput', cb ? cb(src) : src);
          }
      }
      const trainDefaults = { ...trainDefaults$1 };
  
      class GRUTimeStep extends RNNTimeStep {
          getHiddenLayer(hiddenSize, prevSize) {
              return getGRUHiddenLayer(hiddenSize, prevSize);
          }
          getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
              return getGRUEquation(equation, inputMatrix, previousResult, hiddenLayer);
          }
      }
  
      class LSTM extends RNN {
          getHiddenLayer(hiddenSize, prevSize) {
              return getHiddenLSTMLayer(hiddenSize, prevSize);
          }
          getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
              return getLSTMEquation(equation, inputMatrix, previousResult, hiddenLayer);
          }
      }
      function getHiddenLSTMLayer(hiddenSize, prevSize) {
          return {
              // gates parameters
              // wix
              inputMatrix: new RandomMatrix(hiddenSize, prevSize, 0.08),
              inputHidden: new RandomMatrix(hiddenSize, hiddenSize, 0.08),
              inputBias: new Matrix(hiddenSize, 1),
              // wfx
              forgetMatrix: new RandomMatrix(hiddenSize, prevSize, 0.08),
              forgetHidden: new RandomMatrix(hiddenSize, hiddenSize, 0.08),
              forgetBias: new Matrix(hiddenSize, 1),
              // wox
              outputMatrix: new RandomMatrix(hiddenSize, prevSize, 0.08),
              outputHidden: new RandomMatrix(hiddenSize, hiddenSize, 0.08),
              outputBias: new Matrix(hiddenSize, 1),
              // cell write params
              // wcx
              cellActivationMatrix: new RandomMatrix(hiddenSize, prevSize, 0.08),
              cellActivationHidden: new RandomMatrix(hiddenSize, hiddenSize, 0.08),
              cellActivationBias: new Matrix(hiddenSize, 1),
          };
      }
      function getLSTMEquation(equation, inputMatrix, previousResult, hiddenLayer) {
          if (!hiddenLayer.inputMatrix ||
              !hiddenLayer.inputHidden ||
              !hiddenLayer.inputBias ||
              !hiddenLayer.forgetMatrix ||
              !hiddenLayer.forgetHidden ||
              !hiddenLayer.forgetBias ||
              !hiddenLayer.outputMatrix ||
              !hiddenLayer.outputHidden ||
              !hiddenLayer.outputBias ||
              !hiddenLayer.cellActivationMatrix ||
              !hiddenLayer.cellActivationHidden ||
              !hiddenLayer.cellActivationBias) {
              throw new Error('hiddenLayer does not have expected properties');
          }
          const sigmoid = equation.sigmoid.bind(equation);
          const add = equation.add.bind(equation);
          const multiply = equation.multiply.bind(equation);
          const multiplyElement = equation.multiplyElement.bind(equation);
          const tanh = equation.tanh.bind(equation);
          const inputGate = sigmoid(add(add(multiply(hiddenLayer.inputMatrix, inputMatrix), multiply(hiddenLayer.inputHidden, previousResult)), hiddenLayer.inputBias));
          const forgetGate = sigmoid(add(add(multiply(hiddenLayer.forgetMatrix, inputMatrix), multiply(hiddenLayer.forgetHidden, previousResult)), hiddenLayer.forgetBias));
          // output gate
          const outputGate = sigmoid(add(add(multiply(hiddenLayer.outputMatrix, inputMatrix), multiply(hiddenLayer.outputHidden, previousResult)), hiddenLayer.outputBias));
          // write operation on cells
          const cellWrite = tanh(add(add(multiply(hiddenLayer.cellActivationMatrix, inputMatrix), multiply(hiddenLayer.cellActivationHidden, previousResult)), hiddenLayer.cellActivationBias));
          // compute new cell activation
          const retainCell = multiplyElement(forgetGate, previousResult); // what do we keep from cell
          const writeCell = multiplyElement(inputGate, cellWrite); // what do we write to cell
          const cell = add(retainCell, writeCell); // new cell contents
          // compute hidden state as gated, saturated cell activations
          return multiplyElement(outputGate, tanh(cell));
      }
  
      class LSTMTimeStep extends RNNTimeStep {
          getHiddenLayer(hiddenSize, prevSize) {
              return getHiddenLSTMLayer(hiddenSize, prevSize);
          }
          getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
              return getLSTMEquation(equation, inputMatrix, previousResult, hiddenLayer);
          }
      }
  
      /**
       *
       * @param start
       * @param end
       * @returns {Array}
       */
      function range(start, end) {
          const result = [];
          for (; start < end; start++) {
              result.push(start);
          }
          return result;
      }
  
      function toArray(values) {
          if (Array.isArray(values)) {
              return Float32Array.from(values);
          }
          return Float32Array.from(Object.values(values));
      }
  
      function drawInput({ pixelX, pixelY, radius, inputs, row, line, fontSize, fontClassName, }) {
          let svg = `<rect
                x="${pixelX / 2 - radius}"
                y="${pixelY / 2 + row * pixelY - radius}"
                width="${2 * radius}"
                height="${2 * radius}"
                stroke="black"
                stroke-width="1"
                fill="${inputs.color}"
                class="${inputs.className}" />
              <line
                x1="${pixelX / 4}"
                y1="${pixelY / 2 + row * pixelY}"
                x2="${pixelX / 2 - radius}"
                y2="${pixelY / 2 + row * pixelY}"
                style="stroke:${line.color};stroke-width:${line.width}"
                class="${line.className}" />`;
          if (inputs.labels) {
              svg += `<text
                x="${pixelX / 8}"
                y="${pixelY / 2 + row * pixelY - 5}"
                fill="black"
                font-size="${fontSize}"
                class="${fontClassName}">${inputs.labels[row]}</text>`;
          }
          return svg;
      }
      function drawNeuron({ pixelX, pixelY, row, column, radius, hidden, }) {
          return `<circle
              cx="${pixelX / 2 + column * pixelX}"
              cy="${pixelY / 2 + row * pixelY}"
              r="${radius}"
              stroke="black"
              stroke-width="1"
              fill="${hidden.color}"
              class="${hidden.className}" />`;
      }
      function drawOutput({ pixelX, pixelY, row, column, line, outputs, radius, }) {
          return `<circle
              cx="${pixelX / 2 + column * pixelX}"
              cy="${pixelY / 2 + row * pixelY}"
              r="${radius}"
              stroke="black"
              stroke-width="1"
              fill="${outputs.color}"
              class="${outputs.className}" />
            <line
              x1="${pixelX / 2 + column * pixelX + radius}"
              y1="${pixelY / 2 + row * pixelY}"
              x2="${pixelX / 2 + column * pixelX + pixelX / 4}"
              y2="${pixelY / 2 + row * pixelY}"
              style="stroke:${line.color};stroke-width:${line.width}"
              class="${line.className}" />`;
      }
      function drawBackwardConnections({ pixelX, pixelY, row, column, radius, lineY, line, previousConnectionIndex, }) {
          return `<line
              x1="${pixelX / 2 + (column - 1) * pixelX + radius}"
              y1="${lineY / 2 + previousConnectionIndex * lineY}"
              x2="${pixelX / 2 + column * pixelX - radius}"
              y2="${pixelY / 2 + row * pixelY}"
              style="stroke:${line.color};stroke-width:${line.width}"
              class="${line.className}" />`;
      }
      function neuralNetworkToInnerSVG(options) {
          const { sizes, height, width } = options;
          let svg = '';
          const pixelX = width / sizes.length;
          for (let column = 0; column < sizes.length; column++) {
              const size = sizes[column];
              const pixelY = height / size;
              for (let row = 0; row < size; row++) {
                  if (column === 0) {
                      svg += drawInput({ pixelX, pixelY, row, column, ...options });
                  }
                  else {
                      if (column === sizes.length - 1) {
                          svg += drawOutput({ pixelX, pixelY, row, column, ...options });
                      }
                      else {
                          svg += drawNeuron({ pixelX, pixelY, row, column, ...options });
                      }
                      const previousSize = sizes[column - 1];
                      const lineY = height / previousSize;
                      for (let previousConnectionIndex = 0; previousConnectionIndex < previousSize; previousConnectionIndex++) {
                          svg += drawBackwardConnections({
                              pixelX,
                              pixelY,
                              row,
                              column,
                              lineY,
                              previousConnectionIndex,
                              ...options,
                          });
                      }
                  }
              }
          }
          return svg;
      }
      function drawRecurrentConnections({ pixelX, pixelY, row, column, radius, recurrentLine, }) {
          const moveX = pixelX / 2 + column * pixelX + radius + 1;
          const moveY = pixelY / 2 + row * pixelY;
          const x = moveX - radius * 2 - 2;
          const y = moveY;
          const x1 = x + 100;
          const y1 = y + 50;
          const x2 = moveX - 100;
          const y2 = moveY + 50;
          return `<path
                d="M ${moveX} ${moveY} C ${x1} ${y1}, ${x2} ${y2}, ${x} ${y}"
                stroke="${recurrentLine.color}"
                stroke-width="${recurrentLine.width}"
                fill="transparent"
                stroke-linecap="round"
                marker-end="url(#arrow)"
                class="${recurrentLine.className}" />`;
      }
      function rnnToInnerSVG(options) {
          const { width, height, recurrentLine, sizes, radius } = options;
          const pixelX = width / sizes.length;
          let svg = `<defs>
                <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
                  <path d="M0,0 L0,6 L9,3 z" fill="${recurrentLine.color}" />
                </marker>
              </defs>`;
          svg += neuralNetworkToInnerSVG(options);
          for (let column = 1; column < sizes.length; column++) {
              const size = sizes[column];
              const pixelY = height / size;
              for (let row = 0; row < size; row++) {
                  svg += drawRecurrentConnections({
                      pixelX,
                      pixelY,
                      row,
                      column,
                      radius,
                      recurrentLine,
                  });
              }
          }
          return svg;
      }
      function getFeedForwardLayers(network) {
          const { options } = network;
          if (!options) {
              throw new Error('options not defined');
          }
          if (!options.inputLayer) {
              throw new Error('options.inputLater not defined');
          }
          if (!options.hiddenLayers) {
              throw new Error('options.hiddenLayers not defined');
          }
          if (options.hiddenLayers.length < 1) {
              throw new Error('options.hiddenLayers is empty');
          }
          if (!options.outputLayer) {
              throw new Error('options.outputLayer not defined');
          }
          const inputLayer = options.inputLayer();
          const hiddenLayers = [];
          hiddenLayers.push(options.hiddenLayers[0](inputLayer, 0));
          for (let i = 1; i < options.hiddenLayers.length; i++) {
              hiddenLayers.push(options.hiddenLayers[i](hiddenLayers[i - 1], i));
          }
          const outputLayer = options.outputLayer(hiddenLayers[hiddenLayers.length - 1], hiddenLayers.length);
          return {
              inputSize: inputLayer.height,
              hiddenLayers: hiddenLayers.map((hiddenLayer) => hiddenLayer.height),
              outputSize: outputLayer.height,
          };
      }
      function getRecurrentLayers(network) {
          const hiddenLayers = [];
          const { options } = network;
          if (!options.inputLayer) {
              throw new Error('inputLayer not defined');
          }
          if (!options.outputLayer) {
              throw new Error('outputLayer not defined');
          }
          const inputLayer = options.inputLayer();
          hiddenLayers.push(options.hiddenLayers[0](inputLayer, recurrentZeros(), 0));
          for (let i = 1; i < options.hiddenLayers.length; i++) {
              hiddenLayers.push(options.hiddenLayers[i](hiddenLayers[i - 1], recurrentZeros(), i));
          }
          const outputLayer = options.outputLayer(hiddenLayers[hiddenLayers.length - 1], -1);
          return {
              inputSize: inputLayer.height,
              hiddenLayers: hiddenLayers.map((hiddenLayer) => hiddenLayer.height),
              outputSize: outputLayer.height,
          };
      }
      function wrapOuterSVG(svgBody, width, height) {
          // language=html
          return `<svg
              xmlns="http://www.w3.org/2000/svg"
              xmlns:xlink="http://www.w3.org/1999/xlink"
              version="1.1"
              width="${width}"
              height="${height}">${svgBody}</svg>`;
      }
      function getNeuralNetworkJSONSizes(json) {
          return json.sizes;
      }
      function getNeuralNetworkSizes(net) {
          const { options, sizes } = net;
          const { inputSize, outputSize, hiddenLayers } = options;
          if (!sizes) {
              if (typeof inputSize === 'number' && inputSize < 1) {
                  throw new Error('inputSize not set');
              }
              if (typeof outputSize === 'number' && outputSize < 1) {
                  throw new Error('outputSize not set');
              }
              if (hiddenLayers === null || hiddenLayers === void 0 ? void 0 : hiddenLayers.some((v) => v < 1)) {
                  throw new Error('hiddenLayers not set');
              }
          }
          return typeof inputSize === 'number' &&
              Array.isArray(hiddenLayers) &&
              typeof outputSize === 'number'
              ? [inputSize].concat(hiddenLayers).concat([outputSize])
              : sizes;
      }
      function getRNNSizes(net) {
          const { options } = net;
          const { inputSize, outputSize, hiddenLayers } = options;
          return [inputSize].concat(hiddenLayers).concat([outputSize]);
      }
      function defaultOptions() {
          return {
              line: {
                  width: 0.5,
                  color: 'black',
                  className: 'connection',
              },
              recurrentLine: {
                  width: 1,
                  color: 'red',
                  className: 'recurrence',
              },
              inputs: {
                  color: 'rgba(0, 128, 0, 0.5)',
                  labels: null,
                  className: 'input',
              },
              outputs: {
                  color: 'rgba(100, 149, 237, 0.5)',
                  className: 'output',
              },
              hidden: {
                  color: 'rgba(255, 127, 80, 0.5)',
                  className: 'hidden-neuron',
              },
              fontSize: '14px',
              fontClassName: 'label',
              radius: 8,
              width: 400,
              height: 250,
              sizes: [],
          };
      }
      function toSVG(net, options) {
          const mergedOptions = { ...defaultOptions(), ...options };
          const { width, height, inputs } = mergedOptions;
          // Get network size array for NeuralNetwork or NeuralNetworkGPU
          let sizes = [];
          if (net instanceof NeuralNetwork || net instanceof NeuralNetworkGPU) {
              sizes = getNeuralNetworkSizes(net);
          }
          // get network size for Recurrent
          else if (net instanceof Recurrent) {
              const { inputSize, hiddenLayers, outputSize } = getRecurrentLayers(net);
              sizes = [inputSize].concat(hiddenLayers).concat([outputSize]);
          }
          // get network size for FeedForward
          else if (net instanceof FeedForward) {
              const { inputSize, hiddenLayers, outputSize } = getFeedForwardLayers(net);
              sizes = [inputSize].concat(hiddenLayers).concat([outputSize]);
          }
          // handle json, recurrent first
          else if (net instanceof RNN ||
              net instanceof LSTM ||
              net instanceof GRU ||
              net instanceof RNNTimeStep ||
              net instanceof LSTMTimeStep ||
              net instanceof GRUTimeStep) {
              return wrapOuterSVG(rnnToInnerSVG({
                  ...mergedOptions,
                  sizes: checkSizes(getRNNSizes(net), inputs.labels),
              }), width, height);
          }
          // handle json, NeuralNetwork
          else if (net.hasOwnProperty('type')) {
              switch (net.type) {
                  case 'NeuralNetwork':
                  case 'NeuralNetworkGPU':
                      return wrapOuterSVG(neuralNetworkToInnerSVG({
                          ...mergedOptions,
                          sizes: checkSizes(getNeuralNetworkJSONSizes(net), inputs.labels),
                      }), width, height);
                  case 'RNN':
                  case 'GRU':
                  case 'LSTM':
                  case 'RNNTimeStep':
                  case 'GRUTimeStep':
                  case 'LSTMTimeStep':
                      return wrapOuterSVG(rnnToInnerSVG({
                          ...mergedOptions,
                          sizes: checkSizes(getRNNSizes(net), inputs.labels),
                      }), width, height);
                  default:
                      throw new Error('unrecognized network');
              }
          }
          else if (net.hasOwnProperty('inputSize') &&
              net.hasOwnProperty('hiddenLayers') &&
              net.hasOwnProperty('outputSize')) {
              const { inputSize, hiddenLayers, outputSize } = net;
              sizes = [inputSize, ...hiddenLayers, outputSize];
          }
          else if (net.hasOwnProperty('sizes')) {
              sizes = net.sizes;
          }
          else {
              throw new Error('unrecognized network');
          }
          return wrapOuterSVG(neuralNetworkToInnerSVG({
              ...mergedOptions,
              sizes: checkSizes(sizes, inputs.labels),
          }), width, height);
      }
      function checkSizes(sizes, labels) {
          if (!sizes) {
              throw new Error('sizes not set');
          }
          if (sizes.some((size) => size < 1)) {
              throw new Error('sizes not set correctly');
          }
          if (labels && labels.length !== sizes[0]) {
              throw new Error('not enough labels for inputs');
          }
          return sizes;
      }
  
      const recurrent = {
          RNNTimeStep,
          LSTMTimeStep,
          GRUTimeStep,
          RNN,
          LSTM,
          GRU,
      };
      const utilities = {
          max,
          mse: mse$1,
          ones: ones$1,
          ones2D,
          random: random$1,
          randomWeight,
          randos,
          range,
          toArray,
          DataFormatter,
          zeros: zeros$1,
          toSVG,
      };
  
      exports.CrossValidate = CrossValidate;
      exports.FeedForward = FeedForward;
      exports.NeuralNetwork = NeuralNetwork;
      exports.NeuralNetworkGPU = NeuralNetworkGPU;
      exports.Recurrent = Recurrent;
      exports.activation = index$1;
      exports.layer = layer;
      exports.layerTypes = layerTypes;
      exports.likely = likely;
      exports.lookup = lookup;
      exports.praxis = index;
      exports.recurrent = recurrent;
      exports.utilities = utilities;
  
      Object.defineProperty(exports, '__esModule', { value: true });
  
  })));
  //# sourceMappingURL=browser.js.map
/**
  @license
  Apache License 2.0 https://github.com/ReactiveX/blackpard/blob/master/LICENSE.txt
 **/
/**
  @license
  Apache License 2.0 https://github.com/ReactiveX/blackpard/blob/master/LICENSE.txt
 **/
/*
 *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
*****************************************************************************/
(function(g,y){"object"===typeof exports&&"undefined"!==typeof module?y(exports):"function"===typeof define&&define.amd?define("blackpard",["exports"],y):y(g.blackpard={})})(this,function(g){function y(b,a){function c(){this.constructor=b}if("function"!==typeof a&&null!==a)throw new TypeError("Class extends value "+String(a)+" is not a constructor or null");Ta(b,a);b.prototype=null===a?Object.create(a):(c.prototype=a.prototype,new c)}function Zd(b,a){var c={},d;for(d in b)Object.prototype.hasOwnProperty.call(b,
  d)&&0>a.indexOf(d)&&(c[d]=b[d]);if(null!=b&&"function"===typeof Object.getOwnPropertySymbols){var e=0;for(d=Object.getOwnPropertySymbols(b);e<d.length;e++)0>a.indexOf(d[e])&&Object.prototype.propertyIsEnumerable.call(b,d[e])&&(c[d[e]]=b[d[e]])}return c}function $d(b,a,c,d){function e(a){return a instanceof c?a:new c(function(b){b(a)})}return new (c||(c=Promise))(function(c,h){function f(a){try{z(d.next(a))}catch(v){h(v)}}function k(a){try{z(d["throw"](a))}catch(v){h(v)}}function z(a){a.done?c(a.value):
  e(a.value).then(f,k)}z((d=d.apply(b,a||[])).next())})}function Ua(b,a){function c(a){return function(b){return d([a,b])}}function d(c){if(f)throw new TypeError("Generator is already executing.");for(;e;)try{if(f=1,h&&(l=c[0]&2?h["return"]:c[0]?h["throw"]||((l=h["return"])&&l.call(h),0):h.next)&&!(l=l.call(h,c[1])).done)return l;if(h=0,l)c=[c[0]&2,l.value];switch(c[0]){case 0:case 1:l=c;break;case 4:return e.label++,{value:c[1],done:!1};case 5:e.label++;h=c[1];c=[0];continue;case 7:c=e.ops.pop();e.trys.pop();
  continue;default:if(!(l=e.trys,l=0<l.length&&l[l.length-1])&&(6===c[0]||2===c[0])){e=0;continue}if(3===c[0]&&(!l||c[1]>l[0]&&c[1]<l[3]))e.label=c[1];else if(6===c[0]&&e.label<l[1])e.label=l[1],l=c;else if(l&&e.label<l[2])e.label=l[2],e.ops.push(c);else{l[2]&&e.ops.pop();e.trys.pop();continue}}c=a.call(b,e)}catch(p){c=[6,p],h=0}finally{f=l=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}var e={label:0,sent:function(){if(l[0]&1)throw l[1];return l[1]},trys:[],ops:[]},f,h,l,k;return k=
  {next:c(0),"throw":c(1),"return":c(2)},"function"===typeof Symbol&&(k[Symbol.iterator]=function(){return this}),k}function F(b){var a="function"===typeof Symbol&&Symbol.iterator,c=a&&b[a],d=0;if(c)return c.call(b);if(b&&"number"===typeof b.length)return{next:function(){b&&d>=b.length&&(b=void 0);return{value:b&&b[d++],done:!b}}};throw new TypeError(a?"Object is not iterable.":"Symbol.iterator is not defined.");}function w(b,a){var c="function"===typeof Symbol&&b[Symbol.iterator];if(!c)return b;b=
  c.call(b);var d,e=[],f;try{for(;(void 0===a||0<a--)&&!(d=b.next()).done;)e.push(d.value)}catch(h){f={error:h}}finally{try{d&&!d.done&&(c=b["return"])&&c.call(b)}finally{if(f)throw f.error;}}return e}function x(b,a,c){if(c||2===arguments.length)for(var d=0,e=a.length,f;d<e;d++)!f&&d in a||(f||(f=Array.prototype.slice.call(a,0,d)),f[d]=a[d]);return b.concat(f||Array.prototype.slice.call(a))}function ca(b){return this instanceof ca?(this.v=b,this):new ca(b)}function ae(b,a,c){function d(a){k[a]&&(z[a]=
  function(c){return new Promise(function(b,d){1<p.push([a,c,b,d])||e(a,c)})})}function e(a,c){try{var b=k[a](c);b.value instanceof ca?Promise.resolve(b.value.v).then(f,h):l(p[0][2],b)}catch(u){l(p[0][3],u)}}function f(a){e("next",a)}function h(a){e("throw",a)}function l(a,c){(a(c),p.shift(),p.length)&&e(p[0][0],p[0][1])}if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var k=c.apply(b,a||[]),z,p=[];return z={},d("next"),d("throw"),d("return"),z[Symbol.asyncIterator]=
  function(){return this},z}function be(b){function a(a){e[a]=b[a]&&function(d){return new Promise(function(e,f){d=b[a](d);c(e,f,d.done,d.value)})}}function c(a,c,b,d){Promise.resolve(d).then(function(c){a({value:c,done:b})},c)}if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var d=b[Symbol.asyncIterator],e;return d?d.call(b):(b="function"===typeof F?F(b):b[Symbol.iterator](),e={},a("next"),a("throw"),a("return"),e[Symbol.asyncIterator]=function(){return this},e)}
  function t(b){return"function"===typeof b}function R(b){b=b(function(a){Error.call(a);a.stack=Error().stack});b.prototype=Object.create(Error.prototype);return b.prototype.constructor=b}function M(b,a){b&&(a=b.indexOf(a),0<=a&&b.splice(a,1))}function Ib(b){return b instanceof D||b&&"closed"in b&&t(b.remove)&&t(b.add)&&t(b.unsubscribe)}function Jb(b){da.setTimeout(function(){var a=S.onUnhandledError;if(a)a(b);else throw b;})}function C(){}function J(b,a,c){return{kind:b,value:a,error:c}}function Ba(b){if(S.useDeprecatedSynchronousErrorHandling){var a=
  !U;a&&(U={errorThrown:!1,error:null});b();if(a&&(a=U,b=a.errorThrown,a=a.error,U=null,b))throw a;}else b()}function Ca(b){S.useDeprecatedSynchronousErrorHandling?S.useDeprecatedSynchronousErrorHandling&&U&&(U.errorThrown=!0,U.error=b):Jb(b)}function Wa(b,a){var c=S.onStoppedNotification;c&&da.setTimeout(function(){return c(b,a)})}function E(b){return b}function Xa(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return Kb(b)}function Kb(b){return 0===b.length?E:1===b.length?b[0]:function(a){return b.reduce(function(a,
  b){return b(a)},a)}}function Lb(b){var a;return null!==(a=null!==b&&void 0!==b?b:S.Promise)&&void 0!==a?a:Promise}function ce(b){var a;(a=b&&b instanceof na)||(a=b&&t(b.next)&&t(b.error)&&t(b.complete)&&Ib(b));return a}function n(b){return function(a){if(t(null===a||void 0===a?void 0:a.lift))return a.lift(function(a){try{return b(a,this)}catch(d){this.error(d)}});throw new TypeError("Unable to lift unknown Observable type");}}function m(b,a,c,d,e){return new Ya(b,a,c,d,e)}function Za(){return n(function(b,
  a){var c=null;b._refCount++;var d=m(a,void 0,void 0,void 0,function(){if(!b||0>=b._refCount||0<--b._refCount)c=null;else{var d=b._connection,f=c;c=null;!d||f&&d!==f||d.unsubscribe();a.unsubscribe()}});b.subscribe(d);d.closed||(c=b.connect())})}function Mb(b){return new r(function(a){var c=b||Da,d=c.now(),e=0,f=function(){a.closed||(e=N.requestAnimationFrame(function(h){e=0;var l=c.now();a.next({timestamp:b?l:h,elapsed:l-d});f()}))};f();return function(){e&&N.cancelAnimationFrame(e)}})}function Nb(b){return b in
  $a?(delete $a[b],!0):!1}function de(b){return new r(function(a){return b.schedule(function(){return a.complete()})})}function Ea(b){return b&&t(b.schedule)}function oa(b){return t(b[b.length-1])?b.pop():void 0}function O(b){return Ea(b[b.length-1])?b.pop():void 0}function Ob(b){return Symbol.asyncIterator&&t(null===b||void 0===b?void 0:b[Symbol.asyncIterator])}function Pb(b){return new TypeError("You provided "+(null!==b&&"object"===typeof b?"an invalid object":"'"+b+"'")+" where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.")}
  function Qb(b){return t(null===b||void 0===b?void 0:b[ab])}function Rb(b){return ae(this,arguments,function(){var a,c,d,e;return Ua(this,function(f){switch(f.label){case 0:a=b.getReader(),f.label=1;case 1:f.trys.push([1,,9,10]),f.label=2;case 2:return[4,ca(a.read())];case 3:return c=f.sent(),d=c.value,(e=c.done)?[4,ca(void 0)]:[3,5];case 4:return[2,f.sent()];case 5:return[4,ca(d)];case 6:return[4,f.sent()];case 7:return f.sent(),[3,2];case 8:return[3,10];case 9:return a.releaseLock(),[7];case 10:return[2]}})})}
  function q(b){if(b instanceof r)return b;if(null!=b){if(t(b[pa]))return ee(b);if(bb(b))return fe(b);if(t(null===b||void 0===b?void 0:b.then))return ge(b);if(Ob(b))return Sb(b);if(Qb(b))return he(b);if(t(null===b||void 0===b?void 0:b.getReader))return Sb(Rb(b))}throw Pb(b);}function ee(b){return new r(function(a){var c=b[pa]();if(t(c.subscribe))return c.subscribe(a);throw new TypeError("Provided object does not correctly implement Symbol.observable");})}function fe(b){return new r(function(a){for(var c=
  0;c<b.length&&!a.closed;c++)a.next(b[c]);a.complete()})}function ge(b){return new r(function(a){b.then(function(c){a.closed||(a.next(c),a.complete())},function(c){return a.error(c)}).then(null,Jb)})}function he(b){return new r(function(a){var c,d;try{for(var e=F(b),f=e.next();!f.done;f=e.next())if(a.next(f.value),a.closed)return}catch(h){c={error:h}}finally{try{f&&!f.done&&(d=e.return)&&d.call(e)}finally{if(c)throw c.error;}}a.complete()})}function Sb(b){return new r(function(a){ie(b,a).catch(function(c){return a.error(c)})})}
  function ie(b,a){var c,d,e,f;return $d(this,void 0,void 0,function(){var h,l;return Ua(this,function(k){switch(k.label){case 0:k.trys.push([0,5,6,11]),c=be(b),k.label=1;case 1:return[4,c.next()];case 2:if(d=k.sent(),d.done)return[3,4];h=d.value;a.next(h);if(a.closed)return[2];k.label=3;case 3:return[3,1];case 4:return[3,11];case 5:return l=k.sent(),e={error:l},[3,11];case 6:return k.trys.push([6,,9,10]),d&&!d.done&&(f=c.return)?[4,f.call(c)]:[3,8];case 7:k.sent(),k.label=8;case 8:return[3,10];case 9:if(e)throw e.error;
  return[7];case 10:return[7];case 11:return a.complete(),[2]}})})}function G(b,a,c,d,e){void 0===d&&(d=0);void 0===e&&(e=!1);a=a.schedule(function(){c();e?b.add(this.schedule(null,d)):this.unsubscribe()},d);b.add(a);if(!e)return a}function qa(b,a){void 0===a&&(a=0);return n(function(c,d){c.subscribe(m(d,function(c){return G(d,b,function(){return d.next(c)},a)},function(){return G(d,b,function(){return d.complete()},a)},function(c){return G(d,b,function(){return d.error(c)},a)}))})}function ra(b,a){void 0===
  a&&(a=0);return n(function(c,d){d.add(b.schedule(function(){return c.subscribe(d)},a))})}function je(b,a){return new r(function(c){var d=0;return a.schedule(function(){d===b.length?c.complete():(c.next(b[d++]),c.closed||this.schedule())})})}function Tb(b,a){return new r(function(c){var d;G(c,a,function(){d=b[ab]();G(c,a,function(){var a,b,h;try{a=d.next(),b=a.value,h=a.done}catch(l){c.error(l);return}h?c.complete():c.next(b)},0,!0)});return function(){return t(null===d||void 0===d?void 0:d.return)&&
  d.return()}})}function Ub(b,a){if(!b)throw Error("Iterable cannot be null");return new r(function(c){G(c,a,function(){var d=b[Symbol.asyncIterator]();G(c,a,function(){d.next().then(function(a){a.done?c.complete():c.next(a.value)})},0,!0)})})}function Vb(b,a){if(null!=b){if(t(b[pa]))return q(b).pipe(ra(a),qa(a));if(bb(b))return je(b,a);if(t(null===b||void 0===b?void 0:b.then))return q(b).pipe(ra(a),qa(a));if(Ob(b))return Ub(b,a);if(Qb(b))return Tb(b,a);if(t(null===b||void 0===b?void 0:b.getReader))return Ub(Rb(b),
  a)}throw Pb(b);}function P(b,a){return a?Vb(b,a):q(b)}function cb(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];a=O(b);return P(b,a)}function Wb(b,a){var c=t(b)?b:function(){return b},d=function(a){return a.error(c())};return new r(a?function(c){return a.schedule(d,0,c)}:d)}function Fa(b,a){var c,d,e,f=b.kind,h=b.value;b=b.error;if("string"!==typeof f)throw new TypeError('Invalid notification, missing "kind"');"N"===f?null===(c=a.next)||void 0===c?void 0:c.call(a,h):"E"===f?null===(d=
  a.error)||void 0===d?void 0:d.call(a,b):null===(e=a.complete)||void 0===e?void 0:e.call(a)}function db(b){return b instanceof Date&&!isNaN(b)}function eb(b,a){b=db(b)?{first:b}:"number"===typeof b?{each:b}:b;var c=b.first,d=b.each,e=b.with,f=void 0===e?ke:e,e=b.scheduler,h=void 0===e?null!==a&&void 0!==a?a:I:e;a=b.meta;var l=void 0===a?null:a;if(null==c&&null==d)throw new TypeError("No timeout provided.");return n(function(a,b){var e,k,z=null,g=0,u=function(a){k=G(b,h,function(){try{e.unsubscribe(),
  q(f({meta:l,lastValue:z,seen:g})).subscribe(b)}catch(V){b.error(V)}},a)};e=a.subscribe(m(b,function(a){null===k||void 0===k?void 0:k.unsubscribe();g++;b.next(z=a);0<d&&u(d)},void 0,void 0,function(){(null===k||void 0===k?0:k.closed)||(null===k||void 0===k?void 0:k.unsubscribe());z=null}));!g&&u(null!=c?"number"===typeof c?c:+c-h.now():d)})}function ke(b){throw new Xb(b);}function Q(b,a){return n(function(c,d){var e=0;c.subscribe(m(d,function(c){d.next(b.call(a,c,e++))}))})}function W(b){return Q(function(a){return le(a)?
  b.apply(void 0,x([],w(a))):b(a)})}function Ga(b,a,c,d){if(c)if(Ea(c))d=c;else return function(){for(var e=[],f=0;f<arguments.length;f++)e[f]=arguments[f];return Ga(b,a,d).apply(this,e).pipe(W(c))};return d?function(){for(var c=[],f=0;f<arguments.length;f++)c[f]=arguments[f];return Ga(b,a).apply(this,c).pipe(ra(d),qa(d))}:function(){for(var c=this,d=[],h=0;h<arguments.length;h++)d[h]=arguments[h];var l=new fb,k=!0;return new r(function(e){e=l.subscribe(e);if(k){var f=k=!1,h=!1;a.apply(c,x(x([],w(d)),
  [function(){for(var a=[],c=0;c<arguments.length;c++)a[c]=arguments[c];if(b&&(c=a.shift(),null!=c)){l.error(c);return}l.next(1<a.length?a:a[0]);h=!0;f&&l.complete()}]));h&&l.complete();f=!0}return e})}}function Yb(b){if(1===b.length){var a=b[0];if(me(a))return{args:a,keys:null};if(a&&"object"===typeof a&&ne(a)===oe)return b=pe(a),{args:b.map(function(c){return a[c]}),keys:b}}return{args:b,keys:null}}function Zb(b,a){return b.reduce(function(c,b,e){return c[b]=a[e],c},{})}function $b(){for(var b=[],
  a=0;a<arguments.length;a++)b[a]=arguments[a];var c=O(b),a=oa(b),b=Yb(b),d=b.args,e=b.keys;if(0===d.length)return P([],c);c=new r(ac(d,c,e?function(a){return Zb(e,a)}:E));return a?c.pipe(W(a)):c}function ac(b,a,c){void 0===c&&(c=E);return function(d){bc(a,function(){for(var e=b.length,f=Array(e),h=e,l=e,k=function(e){bc(a,function(){var k=!1;P(b[e],a).subscribe(m(d,function(a){f[e]=a;k||(k=!0,l--);l||d.next(c(f.slice()))},function(){--h||d.complete()}))},d)},g=0;g<e;g++)k(g)},d)}}function bc(b,a,c){b?
  G(c,b,a):a()}function gb(b,a,c,d,e,f,h,l){var k=[],g=0,p=0,v=!1,B=function(a){return g<d?n(a):k.push(a)},n=function(b){f&&a.next(b);g++;var l=!1;q(c(b,p++)).subscribe(m(a,function(c){null===e||void 0===e?void 0:e(c);f?B(c):a.next(c)},function(){l=!0},void 0,function(){if(l)try{g--;for(var c=function(){var c=k.shift();h?G(a,h,function(){return n(c)}):n(c)};k.length&&g<d;)c();!v||k.length||g||a.complete()}catch(X){a.error(X)}}))};b.subscribe(m(a,B,function(){v=!0;!v||k.length||g||a.complete()}));return function(){null===
  l||void 0===l?void 0:l()}}function H(b,a,c){void 0===c&&(c=Infinity);if(t(a))return H(function(c,e){return Q(function(b,d){return a(c,b,e,d)})(q(b(c,e)))},c);"number"===typeof a&&(c=a);return n(function(a,e){return gb(a,e,b,c)})}function sa(b){void 0===b&&(b=Infinity);return H(E,b)}function Ha(){return sa(1)}function ta(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return Ha()(P(b,O(b)))}function Ia(b){return new r(function(a){q(b()).subscribe(a)})}function hb(b,a,c,d){t(c)&&(d=c,c=
  void 0);if(d)return hb(b,a,c).pipe(W(d));d=w(qe(b)?re.map(function(d){return function(e){return b[d](a,e,c)}}):se(b)?te.map(cc(b,a)):ue(b)?ve.map(cc(b,a)):[],2);var e=d[0],f=d[1];if(!e&&bb(b))return H(function(b){return hb(b,a,c)})(q(b));if(!e)throw new TypeError("Invalid event target");return new r(function(a){var c=function(){for(var c=[],b=0;b<arguments.length;b++)c[b]=arguments[b];return a.next(1<c.length?c:c[0])};e(c);return function(){return f(c)}})}function cc(b,a){return function(c){return function(d){return b[c](a,
  d)}}}function se(b){return t(b.addListener)&&t(b.removeListener)}function ue(b){return t(b.on)&&t(b.off)}function qe(b){return t(b.addEventListener)&&t(b.removeEventListener)}function dc(b,a,c){return c?dc(b,a).pipe(W(c)):new r(function(c){var d=function(){for(var a=[],b=0;b<arguments.length;b++)a[b]=arguments[b];return c.next(1===a.length?a[0]:a)},f=b(d);return t(a)?function(){return a(d,f)}:void 0})}function Y(b,a,c){void 0===b&&(b=0);void 0===c&&(c=ib);var d=-1;null!=a&&(Ea(a)?c=a:d=a);return new r(function(a){var e=
  db(b)?+b-c.now():b;0>e&&(e=0);var h=0;return c.schedule(function(){a.closed||(a.next(h++),0<=d?this.schedule(void 0,d):a.complete())},e)})}function ec(b,a){void 0===b&&(b=0);void 0===a&&(a=I);0>b&&(b=0);return Y(b,b,a)}function Z(b){return 1===b.length&&we(b[0])?b[0]:b}function fc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];var c=Z(b);return new r(function(a){var b=0,d=function(){if(b<c.length){var e=void 0;try{e=q(c[b++])}catch(k){d();return}var f=new Ya(a,void 0,C,C);e.subscribe(f);
  f.add(d)}else a.complete()};d()})}function gc(b,a){return function(c,d){return!b.call(a,c,d)}}function K(b,a){return n(function(c,d){var e=0;c.subscribe(m(d,function(c){return b.call(a,c,e++)&&d.next(c)}))})}function hc(b){return function(a){for(var c=[],d=function(d){c.push(q(b[d]).subscribe(m(a,function(b){if(c){for(var e=0;e<c.length;e++)e!==d&&c[e].unsubscribe();c=null}a.next(b)})))},e=0;c&&!a.closed&&e<b.length;e++)d(e)}}function jb(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];
  var c=oa(b),d=Z(b);return d.length?new r(function(a){var b=d.map(function(){return[]}),e=d.map(function(){return!1});a.add(function(){b=e=null});for(var l=function(f){q(d[f]).subscribe(m(a,function(d){b[f].push(d);b.every(function(a){return a.length})&&(d=b.map(function(a){return a.shift()}),a.next(c?c.apply(void 0,x([],w(d))):d),b.some(function(a,c){return!a.length&&e[c]})&&a.complete())},function(){e[f]=!0;!b[f].length&&a.complete()}))},k=0;!a.closed&&k<d.length;k++)l(k);return function(){b=e=null}}):
  L}function kb(b){return n(function(a,c){var d=!1,e=null,f=null,h=!1,l=function(){null===f||void 0===f?void 0:f.unsubscribe();f=null;if(d){d=!1;var a=e;e=null;c.next(a)}h&&c.complete()},k=function(){f=null;h&&c.complete()};a.subscribe(m(c,function(a){d=!0;e=a;f||q(b(a)).subscribe(f=m(c,l,k))},function(){h=!0;d&&f&&!f.closed||c.complete()}))})}function ic(b,a){void 0===a&&(a=I);return kb(function(){return Y(b,a)})}function jc(b){return n(function(a,c){var d=[];a.subscribe(m(c,function(a){return d.push(a)},
  function(){c.next(d);c.complete()}));q(b).subscribe(m(c,function(){var a=d;d=[];c.next(a)},C));return function(){d=null}})}function kc(b,a){void 0===a&&(a=null);a=null!==a&&void 0!==a?a:b;return n(function(c,d){var e=[],f=0;c.subscribe(m(d,function(c){var h,k,g,p,v=null;0===f++%a&&e.push([]);try{for(var m=F(e),n=m.next();!n.done;n=m.next()){var u=n.value;u.push(c);b<=u.length&&(v=null!==v&&void 0!==v?v:[],v.push(u))}}catch(X){h={error:X}}finally{try{n&&!n.done&&(k=m.return)&&k.call(m)}finally{if(h)throw h.error;
  }}if(v)try{for(var ea=F(v),V=ea.next();!V.done;V=ea.next())u=V.value,M(e,u),d.next(u)}catch(X){g={error:X}}finally{try{V&&!V.done&&(p=ea.return)&&p.call(ea)}finally{if(g)throw g.error;}}},function(){var a,c;try{for(var b=F(e),f=b.next();!f.done;f=b.next())d.next(f.value)}catch(p){a={error:p}}finally{try{f&&!f.done&&(c=b.return)&&c.call(b)}finally{if(a)throw a.error;}}d.complete()},void 0,function(){e=null}))})}function lc(b){for(var a,c,d=[],e=1;e<arguments.length;e++)d[e-1]=arguments[e];var f=null!==
  (a=O(d))&&void 0!==a?a:I,h=null!==(c=d[0])&&void 0!==c?c:null,l=d[1]||Infinity;return n(function(a,c){var d=[],e=!1,k=function(a){var b=a.buffer;a.subs.unsubscribe();M(d,a);c.next(b);e&&g()},g=function(){if(d){var a=new D;c.add(a);var e={buffer:[],subs:a};d.push(e);G(a,f,function(){return k(e)},b)}};null!==h&&0<=h?G(c,f,g,h,!0):e=!0;g();var z=m(c,function(a){var c,b,e=d.slice();try{for(var f=F(e),h=f.next();!h.done;h=f.next()){var g=h.value,p=g.buffer;p.push(a);l<=p.length&&k(g)}}catch(ze){c={error:ze}}finally{try{h&&
  !h.done&&(b=f.return)&&b.call(f)}finally{if(c)throw c.error;}}},function(){for(;null===d||void 0===d?0:d.length;)c.next(d.shift().buffer);null===z||void 0===z?void 0:z.unsubscribe();c.complete();c.unsubscribe()},void 0,function(){return d=null});a.subscribe(z)})}function mc(b,a){return n(function(c,d){var e=[];q(b).subscribe(m(d,function(c){var b=[];e.push(b);var f=new D;f.add(q(a(c)).subscribe(m(d,function(){M(e,b);d.next(b);f.unsubscribe()},C)))},C));c.subscribe(m(d,function(a){var c,b;try{for(var d=
  F(e),f=d.next();!f.done;f=d.next())f.value.push(a)}catch(p){c={error:p}}finally{try{f&&!f.done&&(b=d.return)&&b.call(d)}finally{if(c)throw c.error;}}},function(){for(;0<e.length;)d.next(e.shift());d.complete()}))})}function nc(b){return n(function(a,c){var d=null,e=null,f=function(){null===e||void 0===e?void 0:e.unsubscribe();var a=d;d=[];a&&c.next(a);q(b()).subscribe(e=m(c,f,C))};f();a.subscribe(m(c,function(a){return null===d||void 0===d?void 0:d.push(a)},function(){d&&c.next(d);c.complete()},void 0,
  function(){return d=e=null}))})}function lb(b){return n(function(a,c){var d=null,e=!1,f,d=a.subscribe(m(c,void 0,void 0,function(h){f=q(b(h,lb(b)(a)));d?(d.unsubscribe(),d=null,f.subscribe(c)):e=!0}));e&&(d.unsubscribe(),d=null,f.subscribe(c))})}function oc(b,a,c,d,e){return function(f,h){var l=c,k=a,g=0;f.subscribe(m(h,function(a){var c=g++;k=l?b(k,a,c):(l=!0,a);d&&h.next(k)},e&&function(){l&&h.next(k);h.complete()}))}}function fa(b,a){return n(oc(b,a,2<=arguments.length,!1,!0))}function mb(){return n(function(b,
  a){fa(Ae,[])(b).subscribe(a)})}function pc(b,a){return Xa(mb(),H(function(a){return b(a)}),a?W(a):E)}function Ja(b){return pc($b,b)}function nb(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return(a=oa(b))?Xa(nb.apply(void 0,x([],w(b))),W(a)):n(function(a,d){ac(x([a],w(Z(b))))(d)})}function qc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return nb.apply(void 0,x([],w(b)))}function Ka(b,a){return t(a)?H(b,a,1):H(b,1)}function rc(b,a){return t(a)?Ka(function(){return b},
  a):Ka(function(){return b})}function sc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];var c=O(b);return n(function(a,e){Ha()(P(x([a],w(b)),c)).subscribe(e)})}function tc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return sc.apply(void 0,x([],w(b)))}function Be(b){return new r(function(a){return b.subscribe(a)})}function La(b,a){void 0===a&&(a=Ce);var c=a.connector;return n(function(a,e){var d=c();q(b(Be(d))).subscribe(e);e.add(a.subscribe(d))})}function uc(b){return fa(function(a,
  c,d){return!b||b(c,d)?a+1:a},0)}function vc(b){return n(function(a,c){var d=!1,e=null,f=null,h=function(){null===f||void 0===f?void 0:f.unsubscribe();f=null;if(d){d=!1;var a=e;e=null;c.next(a)}};a.subscribe(m(c,function(a){null===f||void 0===f?void 0:f.unsubscribe();d=!0;e=a;f=m(c,h,C);q(b(a)).subscribe(f)},function(){h();c.complete()},void 0,function(){e=f=null}))})}function wc(b,a){void 0===a&&(a=I);return n(function(c,d){function e(){var c=l+b,e=a.now();e<c?(f=this.schedule(void 0,c-e),d.add(f)):
  k()}var f=null,h=null,l=null,k=function(){if(f){f.unsubscribe();f=null;var a=h;h=null;d.next(a)}};c.subscribe(m(d,function(c){h=c;l=a.now();f||(f=a.schedule(e,b),d.add(f))},function(){k();d.complete()},void 0,function(){h=f=null}))})}function ua(b){return n(function(a,c){var d=!1;a.subscribe(m(c,function(a){d=!0;c.next(a)},function(){d||c.next(b);c.complete()}))})}function ga(b){return 0>=b?function(){return L}:n(function(a,c){var d=0;a.subscribe(m(c,function(a){++d<=b&&(c.next(a),b<=d&&c.complete())}))})}
  function ob(){return n(function(b,a){b.subscribe(m(a,C))})}function pb(b){return Q(function(){return b})}function Ma(b,a){return a?function(c){return ta(a.pipe(ga(1),ob()),c.pipe(Ma(b)))}:H(function(a,d){return q(b(a,d)).pipe(ga(1),pb(a))})}function xc(b,a){void 0===a&&(a=I);var c=Y(b,a);return Ma(function(){return c})}function yc(){return n(function(b,a){b.subscribe(m(a,function(c){return Fa(c,a)}))})}function zc(b,a){return n(function(c,d){var e=new Set;c.subscribe(m(d,function(a){var c=b?b(a):
  a;e.has(c)||(e.add(c),d.next(a))}));a&&q(a).subscribe(m(d,function(){return e.clear()},C))})}function qb(b,a){void 0===a&&(a=E);b=null!==b&&void 0!==b?b:De;return n(function(c,d){var e,f=!0;c.subscribe(m(d,function(c){var h=a(c);if(f||!b(e,h))f=!1,e=h,d.next(c)}))})}function De(b,a){return b===a}function Ac(b,a){return qb(function(c,d){return a?a(c[b],d[b]):c[b]===d[b]})}function va(b){void 0===b&&(b=Ee);return n(function(a,c){var d=!1;a.subscribe(m(c,function(a){d=!0;c.next(a)},function(){return d?
  c.complete():c.error(b())}))})}function Ee(){return new aa}function Bc(b,a){if(0>b)throw new rb;var c=2<=arguments.length;return function(d){return d.pipe(K(function(a,c){return c===b}),ga(1),c?ua(a):va(function(){return new rb}))}}function Cc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return function(a){return ta(a,cb.apply(void 0,x([],w(b))))}}function Dc(b,a){return n(function(c,d){var e=0;c.subscribe(m(d,function(f){b.call(a,f,e++,c)||(d.next(!1),d.complete())},function(){d.next(!0);
  d.complete()}))})}function Na(b,a){return a?function(c){return c.pipe(Na(function(c,e){return q(b(c,e)).pipe(Q(function(b,d){return a(c,b,e,d)}))}))}:n(function(a,d){var c=0,f=null,h=!1;a.subscribe(m(d,function(a){f||(f=m(d,void 0,function(){f=null;h&&d.complete()}),q(b(a,c++)).subscribe(f))},function(){h=!0;!f&&d.complete()}))})}function Oa(){return Na(E)}function Ec(b,a,c){void 0===a&&(a=Infinity);a=1>(a||0)?Infinity:a;return n(function(d,e){return gb(d,e,b,a,void 0,!0,c)})}function Fc(b){return n(function(a,
  c){try{a.subscribe(c)}finally{c.add(b)}})}function Gc(b,a){return n(Hc(b,a,"value"))}function Hc(b,a,c){var d="index"===c;return function(c,f){var e=0;c.subscribe(m(f,function(h){var l=e++;b.call(a,h,l,c)&&(f.next(d?l:h),f.complete())},function(){f.next(d?-1:void 0);f.complete()}))}}function Ic(b,a){return n(Hc(b,a,"index"))}function Jc(b,a){var c=2<=arguments.length;return function(d){return d.pipe(b?K(function(a,c){return b(a,c,d)}):E,ga(1),c?ua(a):va(function(){return new aa}))}}function Kc(b,
  a,c,d){return n(function(e,f){function h(a,c){var b=new r(function(a){v++;var b=c.subscribe(a);return function(){b.unsubscribe();0===--v&&n&&Va.unsubscribe()}});b.key=a;return b}var l;a&&"function"!==typeof a?(c=a.duration,l=a.element,d=a.connector):l=a;var k=new Map,g=function(a){k.forEach(a);a(f)},p=function(a){return g(function(c){return c.error(a)})},v=0,n=!1,Va=new Ya(f,function(a){try{var e=b(a),g=k.get(e);if(!g){k.set(e,g=d?d():new A);var z=h(e,g);f.next(z);if(c){var v=m(g,function(){g.complete();
  null===v||void 0===v?void 0:v.unsubscribe()},void 0,void 0,function(){return k.delete(e)});Va.add(q(c(z)).subscribe(v))}}g.next(l?l(a):a)}catch(xe){p(xe)}},function(){return g(function(a){return a.complete()})},p,function(){return k.clear()},function(){n=!0;return 0===v});e.subscribe(Va)})}function Lc(){return n(function(b,a){b.subscribe(m(a,function(){a.next(!1);a.complete()},function(){a.next(!0);a.complete()}))})}function sb(b){return 0>=b?function(){return L}:n(function(a,c){var d=[];a.subscribe(m(c,
  function(a){d.push(a);b<d.length&&d.shift()},function(){var a,b;try{for(var h=F(d),l=h.next();!l.done;l=h.next())c.next(l.value)}catch(k){a={error:k}}finally{try{l&&!l.done&&(b=h.return)&&b.call(h)}finally{if(a)throw a.error;}}c.complete()},void 0,function(){d=null}))})}function Mc(b,a){var c=2<=arguments.length;return function(d){return d.pipe(b?K(function(a,c){return b(a,c,d)}):E,sb(1),c?ua(a):va(function(){return new aa}))}}function Nc(){return n(function(b,a){b.subscribe(m(a,function(c){a.next(Pa.createNext(c))},
  function(){a.next(Pa.createComplete());a.complete()},function(c){a.next(Pa.createError(c));a.complete()}))})}function Oc(b){return fa(t(b)?function(a,c){return 0<b(a,c)?a:c}:function(a,c){return a>c?a:c})}function Pc(b,a,c){void 0===c&&(c=Infinity);if(t(a))return H(function(){return b},a,c);"number"===typeof a&&(c=a);return H(function(){return b},c)}function Qc(b,a,c){void 0===c&&(c=Infinity);return n(function(d,e){var f=a;return gb(d,e,function(a,c){return b(f,a,c)},c,function(a){f=a},!1,void 0,
  function(){return f=null})})}function Rc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];var c=O(b),d="number"===typeof b[b.length-1]?b.pop():Infinity,b=Z(b);return n(function(a,f){sa(d)(P(x([a],w(b)),c)).subscribe(f)})}function Sc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return Rc.apply(void 0,x([],w(b)))}function Tc(b){return fa(t(b)?function(a,c){return 0>b(a,c)?a:c}:function(a,c){return a<c?a:c})}function Qa(b,a){var c=t(b)?b:function(){return b};return t(a)?La(a,
  {connector:c}):function(a){return new Ra(a,c)}}function Uc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];var c=Z(b);return function(a){return fc.apply(void 0,x([a],w(c)))}}function Vc(){return n(function(b,a){var c,d=!1;b.subscribe(m(a,function(b){var e=c;c=b;d&&a.next([e,b]);d=!0}))})}function Wc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];var c=b.length;if(0===c)throw Error("list of properties cannot be empty.");return Q(function(a){var d=a;for(a=0;a<c;a++)if(d=null===
  d||void 0===d?void 0:d[b[a]],"undefined"===typeof d)return;return d})}function Xc(b){return b?function(a){return La(b)(a)}:function(a){return Qa(new A)(a)}}function Yc(b){return function(a){var c=new Zc(b);return new Ra(a,function(){return c})}}function $c(){return function(b){var a=new fb;return new Ra(b,function(){return a})}}function ad(b,a,c,d){c&&!t(c)&&(d=c);var e=t(c)?c:void 0;return function(c){return Qa(new ha(b,a,d),e)(c)}}function tb(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];
  return b.length?n(function(a,d){hc(x([a],w(b)))(d)}):E}function bd(b){var a,c=Infinity,d;null!=b&&("object"===typeof b?(a=b.count,c=void 0===a?Infinity:a,d=b.delay):c=b);return 0>=c?function(){return L}:n(function(a,b){var e=0,f,k=function(){null===f||void 0===f?void 0:f.unsubscribe();f=null;if(null!=d){var a="number"===typeof d?Y(d):q(d(e)),c=m(b,function(){c.unsubscribe();g()});a.subscribe(c)}else g()},g=function(){var d=!1;f=a.subscribe(m(b,void 0,function(){++e<c?f?k():d=!0:b.complete()}));d&&
  k()};g()})}function cd(b){return n(function(a,c){var d,e=!1,f,h=!1,l=!1,k=function(){f||(f=new A,q(b(f)).subscribe(m(c,function(){d?g():e=!0},function(){h=!0;l&&h&&c.complete()})));return f},g=function(){l=!1;d=a.subscribe(m(c,void 0,function(){(l=!0,h)&&(c.complete(),!0)||k().next()}));e&&(d.unsubscribe(),d=null,e=!1,g())};g()})}function dd(b){void 0===b&&(b=Infinity);b=b&&"object"===typeof b?b:{count:b};var a=b.count,c=void 0===a?Infinity:a,d=b.delay;b=b.resetOnSuccess;var e=void 0===b?!1:b;return 0>=
  c?E:n(function(a,b){var f=0,h,g=function(){var l=!1;h=a.subscribe(m(b,function(a){e&&(f=0);b.next(a)},void 0,function(a){if(f++<c){var e=function(){h?(h.unsubscribe(),h=null,g()):l=!0};if(null!=d){a="number"===typeof d?Y(d):q(d(a,f));var k=m(b,function(){k.unsubscribe();e()},function(){b.complete()});a.subscribe(k)}else e()}else b.error(a)}));l&&(h.unsubscribe(),h=null,g())};g()})}function ed(b){return n(function(a,c){var d,e=!1,f,h=function(){d=a.subscribe(m(c,void 0,void 0,function(a){f||(f=new A,
  q(b(f)).subscribe(m(c,function(){return d?h():e=!0})));f&&f.next(a)}));e&&(d.unsubscribe(),d=null,e=!1,h())};h()})}function ub(b){return n(function(a,c){var d=!1,e=null;a.subscribe(m(c,function(a){d=!0;e=a}));q(b).subscribe(m(c,function(){if(d){d=!1;var a=e;e=null;c.next(a)}},C))})}function fd(b,a){void 0===a&&(a=I);return ub(ec(b,a))}function gd(b,a){return n(oc(b,a,2<=arguments.length,!0))}function hd(b,a){void 0===a&&(a=function(a,b){return a===b});return n(function(c,d){var e={buffer:[],complete:!1},
  f={buffer:[],complete:!1},h=function(c,b){var e=m(d,function(e){var f=b.buffer,h=b.complete;0===f.length?h?(d.next(!1),d.complete()):c.buffer.push(e):a(e,f.shift())||(d.next(!1),d.complete())},function(){c.complete=!0;var a=b.buffer;b.complete&&(d.next(0===a.length),d.complete());null===e||void 0===e?void 0:e.unsubscribe()});return e};c.subscribe(h(e,f));q(b).subscribe(h(f,e))})}function vb(b){void 0===b&&(b={});var a=b.connector,c=void 0===a?function(){return new A}:a,a=b.resetOnError,d=void 0===
  a?!0:a,a=b.resetOnComplete,e=void 0===a?!0:a;b=b.resetOnRefCountZero;var f=void 0===b?!0:b;return function(a){var b,h,g,p=0,v=!1,m=!1,t=function(){null===h||void 0===h?void 0:h.unsubscribe();h=void 0},u=function(){t();b=g=void 0;v=m=!1},ea=function(){var a=b;u();null===a||void 0===a?void 0:a.unsubscribe()};return n(function(a,l){p++;m||v||t();var k=g=null!==g&&void 0!==g?g:c();l.add(function(){p--;0!==p||m||v||(h=wb(ea,f))});k.subscribe(l);!b&&0<p&&(b=new ia({next:function(a){return k.next(a)},error:function(a){m=
  !0;t();h=wb(u,d,a);k.error(a)},complete:function(){v=!0;t();h=wb(u,e);k.complete()}}),q(a).subscribe(b))})(a)}}function wb(b,a){for(var c=[],d=2;d<arguments.length;d++)c[d-2]=arguments[d];if(!0===a)b();else if(!1!==a){var e=new ia({next:function(){e.unsubscribe();b()}});return q(a.apply(void 0,x([],w(c)))).subscribe(e)}}function id(b,a,c){var d,e;d=!1;b&&"object"===typeof b?(d=b.bufferSize,e=void 0===d?Infinity:d,d=b.windowTime,a=void 0===d?Infinity:d,d=b.refCount,d=void 0===d?!1:d,c=b.scheduler):
  e=null!==b&&void 0!==b?b:Infinity;return vb({connector:function(){return new ha(e,a,c)},resetOnError:!0,resetOnComplete:!1,resetOnRefCountZero:d})}function jd(b){return n(function(a,c){var d=!1,e,f=!1,h=0;a.subscribe(m(c,function(l){f=!0;if(!b||b(l,h++,a))d&&c.error(new kd("Too many matching values")),d=!0,e=l},function(){d?(c.next(e),c.complete()):c.error(f?new ld("No matching values"):new aa)}))})}function md(b){return K(function(a,c){return b<=c})}function nd(b){return 0>=b?E:n(function(a,c){var d=
  Array(b),e=0;a.subscribe(m(c,function(a){var f=e++;if(f<b)d[f]=a;else{var f=f%b,l=d[f];d[f]=a;c.next(l)}}));return function(){d=null}})}function od(b){return n(function(a,c){var d=!1,e=m(c,function(){null===e||void 0===e?void 0:e.unsubscribe();d=!0},C);q(b).subscribe(e);a.subscribe(m(c,function(a){return d&&c.next(a)}))})}function pd(b){return n(function(a,c){var d=!1,e=0;a.subscribe(m(c,function(a){return(d||(d=!b(a,e++)))&&c.next(a)}))})}function qd(){for(var b=[],a=0;a<arguments.length;a++)b[a]=
  arguments[a];var c=O(b);return n(function(a,e){(c?ta(b,a,c):ta(b,a)).subscribe(e)})}function ja(b,a){return n(function(c,d){var e=null,f=0,h=!1;c.subscribe(m(d,function(c){null===e||void 0===e?void 0:e.unsubscribe();var l=0,g=f++;q(b(c,g)).subscribe(e=m(d,function(b){return d.next(a?a(c,b,g,l++):b)},function(){e=null;h&&!e&&d.complete()}))},function(){(h=!0,!e)&&d.complete()}))})}function rd(){return ja(E)}function sd(b,a){return t(a)?ja(function(){return b},a):ja(function(){return b})}function td(b,
  a){return n(function(c,d){var e=a;ja(function(a,c){return b(e,a,c)},function(a,c){return e=c,c})(c).subscribe(d);return function(){e=null}})}function ud(b){return n(function(a,c){q(b).subscribe(m(c,function(){return c.complete()},C));!c.closed&&a.subscribe(c)})}function vd(b,a){void 0===a&&(a=!1);return n(function(c,d){var e=0;c.subscribe(m(d,function(c){var f=b(c,e++);(f||a)&&d.next(c);!f&&d.complete()}))})}function wd(b,a,c){var d=t(b)||a||c?{next:b,error:a,complete:c}:b;return d?n(function(a,c){var b;
  null===(b=d.subscribe)||void 0===b?void 0:b.call(d);var e=!0;a.subscribe(m(c,function(a){var b;null===(b=d.next)||void 0===b?void 0:b.call(d,a);c.next(a)},function(){var a;e=!1;null===(a=d.complete)||void 0===a?void 0:a.call(d);c.complete()},function(a){var b;e=!1;null===(b=d.error)||void 0===b?void 0:b.call(d,a);c.error(a)},function(){var a,c;e&&(null===(a=d.unsubscribe)||void 0===a?void 0:a.call(d));null===(c=d.finalize)||void 0===c?void 0:c.call(d)}))}):E}function xb(b,a){return n(function(c,d){var e=
  null!==a&&void 0!==a?a:{},f=e.leading,h=void 0===f?!0:f,e=e.trailing,l=void 0===e?!1:e,g=!1,z=null,p=null,v=!1,n=function(){null===p||void 0===p?void 0:p.unsubscribe();p=null;l&&(u(),v&&d.complete())},t=function(){p=null;v&&d.complete()},u=function(){if(g){g=!1;var a=z;z=null;d.next(a);!v&&(p=q(b(a)).subscribe(m(d,n,t)))}};c.subscribe(m(d,function(a){g=!0;z=a;(!p||p.closed)&&(h?u():p=q(b(a)).subscribe(m(d,n,t)))},function(){v=!0;l&&g&&p&&!p.closed||d.complete()}))})}function xd(b,a,c){void 0===a&&
  (a=I);var d=Y(b,a);return xb(function(){return d},c)}function yd(b){void 0===b&&(b=I);return n(function(a,c){var d=b.now();a.subscribe(m(c,function(a){var e=b.now(),h=e-d;d=e;c.next(new Fe(a,h))}))})}function zd(b,a,c){var d,e;c=null!==c&&void 0!==c?c:ib;db(b)?d=b:"number"===typeof b&&(e=b);if(a)b=function(){return a};else throw new TypeError("No observable provided to switch to");if(null==d&&null==e)throw new TypeError("No timeout provided.");return eb({first:d,each:e,scheduler:c,with:b})}function Ad(b){void 0===
  b&&(b=ka);return Q(function(a){return{value:a,timestamp:b.now()}})}function Bd(b){return n(function(a,c){var d=new A;c.next(d.asObservable());var e=function(a){d.error(a);c.error(a)};a.subscribe(m(c,function(a){return null===d||void 0===d?void 0:d.next(a)},function(){d.complete();c.complete()},e));q(b).subscribe(m(c,function(){d.complete();c.next(d=new A)},C,e));return function(){null===d||void 0===d?void 0:d.unsubscribe();d=null}})}function Cd(b,a){void 0===a&&(a=0);var c=0<a?a:b;return n(function(a,
  e){var d=[new A],h=0;e.next(d[0].asObservable());a.subscribe(m(e,function(a){var f,l;try{for(var g=F(d),v=g.next();!v.done;v=g.next())v.value.next(a)}catch(B){f={error:B}}finally{try{v&&!v.done&&(l=g.return)&&l.call(g)}finally{if(f)throw f.error;}}a=h-b+1;0<=a&&0===a%c&&d.shift().complete();0===++h%c&&(a=new A,d.push(a),e.next(a.asObservable()))},function(){for(;0<d.length;)d.shift().complete();e.complete()},function(a){for(;0<d.length;)d.shift().error(a);e.error(a)},function(){d=null}))})}function Dd(b){for(var a,
  c,d=[],e=1;e<arguments.length;e++)d[e-1]=arguments[e];var f=null!==(a=O(d))&&void 0!==a?a:I,h=null!==(c=d[0])&&void 0!==c?c:null,g=d[1]||Infinity;return n(function(a,c){var d=[],e=!1,l=function(a){var c=a.subs;a.window.complete();c.unsubscribe();M(d,a);e&&k()},k=function(){if(d){var a=new D;c.add(a);var e=new A,h={window:e,subs:a,seen:0};d.push(h);c.next(e.asObservable());G(a,f,function(){return l(h)},b)}};null!==h&&0<=h?G(c,f,k,h,!0):e=!0;k();var n=function(a){d.slice().forEach(function(c){return a(c.window)});
  a(c);c.unsubscribe()};a.subscribe(m(c,function(a){d.slice().forEach(function(c){c.window.next(a);g<=++c.seen&&l(c)})},function(){return n(function(a){return a.complete()})},function(a){return n(function(c){return c.error(a)})}));return function(){d=null}})}function Ed(b,a){return n(function(c,d){var e=[],f=function(a){for(;0<e.length;)e.shift().error(a);d.error(a)};q(b).subscribe(m(d,function(c){var b=new A;e.push(b);var h=new D,g;try{g=q(a(c))}catch(p){f(p);return}d.next(b.asObservable());h.add(g.subscribe(m(d,
  function(){M(e,b);b.complete();h.unsubscribe()},C,f)))},C));c.subscribe(m(d,function(a){var c,b,d=e.slice();try{for(var f=F(d),h=f.next();!h.done;h=f.next())h.value.next(a)}catch(B){c={error:B}}finally{try{h&&!h.done&&(b=f.return)&&b.call(f)}finally{if(c)throw c.error;}}},function(){for(;0<e.length;)e.shift().complete();d.complete()},f,function(){for(;0<e.length;)e.shift().unsubscribe()}))})}function Fd(b){return n(function(a,c){var d,e,f=function(a){d.error(a);c.error(a)},h=function(){null===e||
  void 0===e?void 0:e.unsubscribe();null===d||void 0===d?void 0:d.complete();d=new A;c.next(d.asObservable());var a;try{a=q(b())}catch(k){f(k);return}a.subscribe(e=m(c,h,h,f))};h();a.subscribe(m(c,function(a){return d.next(a)},function(){d.complete();c.complete()},f,function(){null===e||void 0===e?void 0:e.unsubscribe();d=null}))})}function Gd(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];var c=oa(b);return n(function(a,e){for(var d=b.length,h=Array(d),g=b.map(function(){return!1}),k=
  !1,n=function(a){q(b[a]).subscribe(m(e,function(c){h[a]=c;k||g[a]||(g[a]=!0,(k=g.every(E))&&(g=null))},C))},p=0;p<d;p++)n(p);a.subscribe(m(e,function(a){k&&(a=x([a],w(h)),e.next(c?c.apply(void 0,x([],w(a))):a))}))})}function Hd(b){return pc(jb,b)}function Id(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return n(function(a,d){jb.apply(void 0,x([a],w(b))).subscribe(d)})}function Jd(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return Id.apply(void 0,x([],w(b)))}function Kd(b,
  a){for(var c=0,d=a.length;c<d;c++)for(var e=a[c],f=Object.getOwnPropertyNames(e.prototype),h=0,g=f.length;h<g;h++){var k=f[h];b.prototype[k]=e.prototype[k]}}function Ld(b){switch(b.responseType){case "json":return"response"in b?b.response:JSON.parse(b.responseText);case "document":return b.responseXML;default:return"response"in b?b.response:b.responseText}}function Ge(b,a){return ba({method:"GET",url:b,headers:a})}function He(b,a,c){return ba({method:"POST",url:b,body:a,headers:c})}function Ie(b,
  a){return ba({method:"DELETE",url:b,headers:a})}function Je(b,a,c){return ba({method:"PUT",url:b,body:a,headers:c})}function Ke(b,a,c){return ba({method:"PATCH",url:b,body:a,headers:c})}function Le(b,a){return Me(ba({method:"GET",url:b,headers:a}))}function Ne(b){return new r(function(a){var c,d,e=T({async:!0,crossDomain:!1,withCredentials:!1,method:"GET",timeout:0,responseType:"json"},b),f=e.queryParams,h=e.body,g=e.headers,k=e.url;if(!k)throw new TypeError("url is required");if(f){var m;if(k.includes("?")){k=
  k.split("?");if(2<k.length)throw new TypeError("invalid url");m=new URLSearchParams(k[1]);(new URLSearchParams(f)).forEach(function(a,c){return m.set(c,a)});k=k[0]+"?"+m}else m=new URLSearchParams(f),k=k+"?"+m}f={};if(g)for(var p in g)g.hasOwnProperty(p)&&(f[p.toLowerCase()]=g[p]);var n=e.crossDomain;n||"x-requested-with"in f||(f["x-requested-with"]="XMLHttpRequest");var t=e.xsrfCookieName,g=e.xsrfHeaderName;(e.withCredentials||!n)&&t&&g&&(n=null!==(d=null===(c=null===document||void 0===document?
  void 0:document.cookie.match(new RegExp("(^|;\\s*)("+t+")\x3d([^;]*)")))||void 0===c?void 0:c.pop())&&void 0!==d?d:"")&&(f[g]=n);c=Oe(h,f);var q=T(T({},e),{url:k,headers:f,body:c}),u;u=b.createXHR?b.createXHR():new XMLHttpRequest;var r=b.progressSubscriber,e=b.includeDownloadProgress,e=void 0===e?!1:e;d=b.includeUploadProgress;d=void 0===d?!1:d;h=function(c,b){u.addEventListener(c,function(){var c,d=b();null===(c=null===r||void 0===r?void 0:r.error)||void 0===c?void 0:c.call(r,d);a.error(d)})};h("timeout",
  function(){return new Md(u,q)});h("abort",function(){return new wa("aborted",u,q)});var w=function(c,b,d){c.addEventListener(b,function(c){a.next(new yb(c,u,q,d+"_"+c.type))})};d&&[zb,Ab,Nd].forEach(function(a){return w(u.upload,a,Pe)});r&&[zb,Ab].forEach(function(a){return u.upload.addEventListener(a,function(a){var c;return null===(c=null===r||void 0===r?void 0:r.next)||void 0===c?void 0:c.call(r,a)})});e&&[zb,Ab].forEach(function(a){return w(u,a,Od)});var x=function(c){a.error(new wa("ajax error"+
  (c?" "+c:""),u,q))};u.addEventListener("error",function(a){var c;null===(c=null===r||void 0===r?void 0:r.error)||void 0===c?void 0:c.call(r,a);x()});u.addEventListener(Nd,function(c){var b,d,e=u.status;if(400>e){null===(b=null===r||void 0===r?void 0:r.complete)||void 0===b?void 0:b.call(r);b=void 0;try{b=new yb(c,u,q,Od+"_"+c.type)}catch(ye){a.error(ye);return}a.next(b);a.complete()}else null===(d=null===r||void 0===r?void 0:r.error)||void 0===d?void 0:d.call(r,c),x(e)});e=q.user;d=q.method;h=q.async;
  e?u.open(d,k,h,e,q.password):u.open(d,k,h);h&&(u.timeout=q.timeout,u.responseType=q.responseType);"withCredentials"in u&&(u.withCredentials=q.withCredentials);for(p in f)f.hasOwnProperty(p)&&u.setRequestHeader(p,f[p]);c?u.send(c):u.send();return function(){u&&4!==u.readyState&&u.abort()}})}function Oe(b,a){var c;if(!b||"string"===typeof b||"undefined"!==typeof FormData&&b instanceof FormData||"undefined"!==typeof URLSearchParams&&b instanceof URLSearchParams||Bb(b,"ArrayBuffer")||Bb(b,"File")||Bb(b,
  "Blob")||"undefined"!==typeof ReadableStream&&b instanceof ReadableStream)return b;if("undefined"!==typeof ArrayBuffer&&ArrayBuffer.isView(b))return b.buffer;if("object"===typeof b)return a["content-type"]=null!==(c=a["content-type"])&&void 0!==c?c:"application/json;charset\x3dutf-8",JSON.stringify(b);throw new TypeError("Unknown body type");}function Bb(b,a){return Qe.call(b)==="[object "+a+"]"}var Ta=function(b,a){Ta=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(a,b){a.__proto__=
  b}||function(a,b){for(var c in b)Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c])};return Ta(b,a)},T=function(){T=Object.assign||function(b){for(var a,c=1,d=arguments.length;c<d;c++){a=arguments[c];for(var e in a)Object.prototype.hasOwnProperty.call(a,e)&&(b[e]=a[e])}return b};return T.apply(this,arguments)},Sa=R(function(b){return function(a){b(this);this.message=a?a.length+" errors occurred during unsubscription:\n"+a.map(function(a,b){return b+1+") "+a.toString()}).join("\n  "):"";this.name=
  "UnsubscriptionError";this.errors=a}}),D=function(){function b(a){this.initialTeardown=a;this.closed=!1;this._finalizers=this._parentage=null}b.prototype.unsubscribe=function(){var a,c,b,e,f;if(!this.closed){this.closed=!0;var h=this._parentage;if(h)if(this._parentage=null,Array.isArray(h))try{for(var g=F(h),k=g.next();!k.done;k=g.next())k.value.remove(this)}catch(B){a={error:B}}finally{try{k&&!k.done&&(c=g.return)&&c.call(g)}finally{if(a)throw a.error;}}else h.remove(this);a=this.initialTeardown;
  if(t(a))try{a()}catch(B){f=B instanceof Sa?B.errors:[B]}if(a=this._finalizers){this._finalizers=null;try{for(var m=F(a),p=m.next();!p.done;p=m.next()){var n=p.value;try{a=n,t(a)?a():a.unsubscribe()}catch(B){f=null!==f&&void 0!==f?f:[],B instanceof Sa?f=x(x([],w(f)),w(B.errors)):f.push(B)}}}catch(B){b={error:B}}finally{try{p&&!p.done&&(e=m.return)&&e.call(m)}finally{if(b)throw b.error;}}}if(f)throw new Sa(f);}};b.prototype.add=function(a){var c;if(a&&a!==this)if(this.closed)t(a)?a():a.unsubscribe();
  else{if(a instanceof b){if(a.closed||a._hasParent(this))return;a._addParent(this)}(this._finalizers=null!==(c=this._finalizers)&&void 0!==c?c:[]).push(a)}};b.prototype._hasParent=function(a){var c=this._parentage;return c===a||Array.isArray(c)&&c.includes(a)};b.prototype._addParent=function(a){var c=this._parentage;this._parentage=Array.isArray(c)?(c.push(a),c):c?[c,a]:a};b.prototype._removeParent=function(a){var c=this._parentage;c===a?this._parentage=null:Array.isArray(c)&&M(c,a)};b.prototype.remove=
  function(a){var c=this._finalizers;c&&M(c,a);a instanceof b&&a._removeParent(this)};b.EMPTY=function(){var a=new b;a.closed=!0;return a}();return b}(),Pd=D.EMPTY,S={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},da={setTimeout:function(b,a){for(var c=[],d=2;d<arguments.length;d++)c[d-2]=arguments[d];d=da.delegate;return(null===d||void 0===d?0:d.setTimeout)?d.setTimeout.apply(d,x([b,a],w(c))):setTimeout.apply(void 0,
  x([b,a],w(c)))},clearTimeout:function(b){var a=da.delegate;return((null===a||void 0===a?void 0:a.clearTimeout)||clearTimeout)(b)},delegate:void 0},xa=J("C",void 0,void 0),U=null,na=function(b){function a(a){var c=b.call(this)||this;c.isStopped=!1;a?(c.destination=a,Ib(a)&&a.add(c)):c.destination=Re;return c}y(a,b);a.create=function(a,b,e){return new ia(a,b,e)};a.prototype.next=function(a){this.isStopped?Wa(J("N",a,void 0),this):this._next(a)};a.prototype.error=function(a){this.isStopped?Wa(J("E",
  void 0,a),this):(this.isStopped=!0,this._error(a))};a.prototype.complete=function(){this.isStopped?Wa(xa,this):(this.isStopped=!0,this._complete())};a.prototype.unsubscribe=function(){this.closed||(this.isStopped=!0,b.prototype.unsubscribe.call(this),this.destination=null)};a.prototype._next=function(a){this.destination.next(a)};a.prototype._error=function(a){try{this.destination.error(a)}finally{this.unsubscribe()}};a.prototype._complete=function(){try{this.destination.complete()}finally{this.unsubscribe()}};
  return a}(D),Cb=Function.prototype.bind,Se=function(){function b(a){this.partialObserver=a}b.prototype.next=function(a){var c=this.partialObserver;if(c.next)try{c.next(a)}catch(d){Ca(d)}};b.prototype.error=function(a){var c=this.partialObserver;if(c.error)try{c.error(a)}catch(d){Ca(d)}else Ca(a)};b.prototype.complete=function(){var a=this.partialObserver;if(a.complete)try{a.complete()}catch(c){Ca(c)}};return b}(),ia=function(b){function a(a,d,e){var c=b.call(this)||this;t(a)||!a?a={next:null!==a&&
  void 0!==a?a:void 0,error:null!==d&&void 0!==d?d:void 0,complete:null!==e&&void 0!==e?e:void 0}:c&&S.useDeprecatedNextContext&&(d=Object.create(a),d.unsubscribe=function(){return c.unsubscribe()},a={next:a.next&&Cb.call(a.next,d),error:a.error&&Cb.call(a.error,d),complete:a.complete&&Cb.call(a.complete,d)});c.destination=new Se(a);return c}y(a,b);return a}(na),Re={closed:!0,next:C,error:function(b){throw b;},complete:C},pa="function"===typeof Symbol&&Symbol.observable||"@@observable",r=function(){function b(a){a&&
  (this._subscribe=a)}b.prototype.lift=function(a){var c=new b;c.source=this;c.operator=a;return c};b.prototype.subscribe=function(a,c,b){var d=this,f=ce(a)?a:new ia(a,c,b);Ba(function(){var a=d.operator,c=d.source;f.add(a?a.call(f,c):c?d._subscribe(f):d._trySubscribe(f))});return f};b.prototype._trySubscribe=function(a){try{return this._subscribe(a)}catch(c){a.error(c)}};b.prototype.forEach=function(a,c){var b=this;c=Lb(c);return new c(function(c,d){var e=new ia({next:function(c){try{a(c)}catch(k){d(k),
  e.unsubscribe()}},error:d,complete:c});b.subscribe(e)})};b.prototype._subscribe=function(a){var c;return null===(c=this.source)||void 0===c?void 0:c.subscribe(a)};b.prototype[pa]=function(){return this};b.prototype.pipe=function(){for(var a=[],c=0;c<arguments.length;c++)a[c]=arguments[c];return Kb(a)(this)};b.prototype.toPromise=function(a){var c=this;a=Lb(a);return new a(function(a,b){var d;c.subscribe(function(a){return d=a},function(a){return b(a)},function(){return a(d)})})};b.create=function(a){return new b(a)};
  return b}(),Ya=function(b){function a(a,d,e,f,h,g){var c=b.call(this,a)||this;c.onFinalize=h;c.shouldUnsubscribe=g;c._next=d?function(c){try{d(c)}catch(p){a.error(p)}}:b.prototype._next;c._error=f?function(c){try{f(c)}catch(p){a.error(p)}finally{this.unsubscribe()}}:b.prototype._error;c._complete=e?function(){try{e()}catch(z){a.error(z)}finally{this.unsubscribe()}}:b.prototype._complete;return c}y(a,b);a.prototype.unsubscribe=function(){var a;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){var d=
  this.closed;b.prototype.unsubscribe.call(this);!d&&(null===(a=this.onFinalize)||void 0===a?void 0:a.call(this))}};return a}(na),Ra=function(b){function a(a,d){var c=b.call(this)||this;c.source=a;c.subjectFactory=d;c._subject=null;c._refCount=0;c._connection=null;t(null===a||void 0===a?void 0:a.lift)&&(c.lift=a.lift);return c}y(a,b);a.prototype._subscribe=function(a){return this.getSubject().subscribe(a)};a.prototype.getSubject=function(){var a=this._subject;if(!a||a.isStopped)this._subject=this.subjectFactory();
  return this._subject};a.prototype._teardown=function(){this._refCount=0;var a=this._connection;this._subject=this._connection=null;null===a||void 0===a?void 0:a.unsubscribe()};a.prototype.connect=function(){var a=this,b=this._connection;if(!b){var b=this._connection=new D,e=this.getSubject();b.add(this.source.subscribe(m(e,void 0,function(){a._teardown();e.complete()},function(b){a._teardown();e.error(b)},function(){return a._teardown()})));b.closed&&(this._connection=null,b=D.EMPTY)}return b};a.prototype.refCount=
  function(){return Za()(this)};return a}(r),Da={now:function(){return(Da.delegate||performance).now()},delegate:void 0},N={schedule:function(b){var a=requestAnimationFrame,c=cancelAnimationFrame,d=N.delegate;d&&(a=d.requestAnimationFrame,c=d.cancelAnimationFrame);var e=a(function(a){c=void 0;b(a)});return new D(function(){return null===c||void 0===c?void 0:c(e)})},requestAnimationFrame:function(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];a=N.delegate;return((null===a||void 0===a?void 0:
  a.requestAnimationFrame)||requestAnimationFrame).apply(void 0,x([],w(b)))},cancelAnimationFrame:function(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];a=N.delegate;return((null===a||void 0===a?void 0:a.cancelAnimationFrame)||cancelAnimationFrame).apply(void 0,x([],w(b)))},delegate:void 0},Te=Mb(),Qd=R(function(b){return function(){b(this);this.name="ObjectUnsubscribedError";this.message="object unsubscribed"}}),A=function(b){function a(){var a=b.call(this)||this;a.closed=!1;a.currentObservers=
  null;a.observers=[];a.isStopped=!1;a.hasError=!1;a.thrownError=null;return a}y(a,b);a.prototype.lift=function(a){var b=new Db(this,this);b.operator=a;return b};a.prototype._throwIfClosed=function(){if(this.closed)throw new Qd;};a.prototype.next=function(a){var b=this;Ba(function(){var c,d;b._throwIfClosed();if(!b.isStopped){b.currentObservers||(b.currentObservers=Array.from(b.observers));try{for(var h=F(b.currentObservers),g=h.next();!g.done;g=h.next())g.value.next(a)}catch(k){c={error:k}}finally{try{g&&
  !g.done&&(d=h.return)&&d.call(h)}finally{if(c)throw c.error;}}}})};a.prototype.error=function(a){var b=this;Ba(function(){b._throwIfClosed();if(!b.isStopped){b.hasError=b.isStopped=!0;b.thrownError=a;for(var c=b.observers;c.length;)c.shift().error(a)}})};a.prototype.complete=function(){var a=this;Ba(function(){a._throwIfClosed();if(!a.isStopped){a.isStopped=!0;for(var b=a.observers;b.length;)b.shift().complete()}})};a.prototype.unsubscribe=function(){this.isStopped=this.closed=!0;this.observers=this.currentObservers=
  null};Object.defineProperty(a.prototype,"observed",{get:function(){var a;return 0<(null===(a=this.observers)||void 0===a?void 0:a.length)},enumerable:!1,configurable:!0});a.prototype._trySubscribe=function(a){this._throwIfClosed();return b.prototype._trySubscribe.call(this,a)};a.prototype._subscribe=function(a){this._throwIfClosed();this._checkFinalizedStatuses(a);return this._innerSubscribe(a)};a.prototype._innerSubscribe=function(a){var b=this,c=this.isStopped,f=this.observers;if(this.hasError||
  c)return Pd;this.currentObservers=null;f.push(a);return new D(function(){b.currentObservers=null;M(f,a)})};a.prototype._checkFinalizedStatuses=function(a){var b=this.thrownError,c=this.isStopped;this.hasError?a.error(b):c&&a.complete()};a.prototype.asObservable=function(){var a=new r;a.source=this;return a};a.create=function(a,b){return new Db(a,b)};return a}(r),Db=function(b){function a(a,d){var c=b.call(this)||this;c.destination=a;c.source=d;return c}y(a,b);a.prototype.next=function(a){var b,c;
  null===(c=null===(b=this.destination)||void 0===b?void 0:b.next)||void 0===c?void 0:c.call(b,a)};a.prototype.error=function(a){var b,c;null===(c=null===(b=this.destination)||void 0===b?void 0:b.error)||void 0===c?void 0:c.call(b,a)};a.prototype.complete=function(){var a,b;null===(b=null===(a=this.destination)||void 0===a?void 0:a.complete)||void 0===b?void 0:b.call(a)};a.prototype._subscribe=function(a){var b,c;return null!==(c=null===(b=this.source)||void 0===b?void 0:b.subscribe(a))&&void 0!==c?
  c:Pd};return a}(A),Zc=function(b){function a(a){var c=b.call(this)||this;c._value=a;return c}y(a,b);Object.defineProperty(a.prototype,"value",{get:function(){return this.getValue()},enumerable:!1,configurable:!0});a.prototype._subscribe=function(a){var c=b.prototype._subscribe.call(this,a);!c.closed&&a.next(this._value);return c};a.prototype.getValue=function(){var a=this.thrownError,b=this._value;if(this.hasError)throw a;this._throwIfClosed();return b};a.prototype.next=function(a){b.prototype.next.call(this,
  this._value=a)};return a}(A),ka={now:function(){return(ka.delegate||Date).now()},delegate:void 0},ha=function(b){function a(a,d,e){void 0===a&&(a=Infinity);void 0===d&&(d=Infinity);void 0===e&&(e=ka);var c=b.call(this)||this;c._bufferSize=a;c._windowTime=d;c._timestampProvider=e;c._buffer=[];c._infiniteTimeWindow=Infinity===d;c._bufferSize=Math.max(1,a);c._windowTime=Math.max(1,d);return c}y(a,b);a.prototype.next=function(a){var c=this._buffer,e=this._infiniteTimeWindow,f=this._timestampProvider,
  h=this._windowTime;this.isStopped||(c.push(a),!e&&c.push(f.now()+h));this._trimBuffer();b.prototype.next.call(this,a)};a.prototype._subscribe=function(a){this._throwIfClosed();this._trimBuffer();for(var b=this._innerSubscribe(a),c=this._infiniteTimeWindow,f=this._buffer.slice(),h=0;h<f.length&&!a.closed;h+=c?1:2)a.next(f[h]);this._checkFinalizedStatuses(a);return b};a.prototype._trimBuffer=function(){var a=this._bufferSize,b=this._timestampProvider,e=this._buffer,f=this._infiniteTimeWindow,h=(f?1:
  2)*a;Infinity>a&&h<e.length&&e.splice(0,e.length-h);if(!f){a=b.now();b=0;for(f=1;f<e.length&&e[f]<=a;f+=2)b=f;b&&e.splice(0,b+1)}};return a}(A),fb=function(b){function a(){var a=null!==b&&b.apply(this,arguments)||this;a._value=null;a._hasValue=!1;a._isComplete=!1;return a}y(a,b);a.prototype._checkFinalizedStatuses=function(a){var b=this._hasValue,c=this._value,f=this.thrownError,h=this.isStopped,g=this._isComplete;if(this.hasError)a.error(f);else if(h||g)b&&a.next(c),a.complete()};a.prototype.next=
  function(a){this.isStopped||(this._value=a,this._hasValue=!0)};a.prototype.complete=function(){var a=this._hasValue,d=this._value;this._isComplete||(this._isComplete=!0,a&&b.prototype.next.call(this,d),b.prototype.complete.call(this))};return a}(A),la={setInterval:function(b,a){for(var c=[],d=2;d<arguments.length;d++)c[d-2]=arguments[d];d=la.delegate;return(null===d||void 0===d?0:d.setInterval)?d.setInterval.apply(d,x([b,a],w(c))):setInterval.apply(void 0,x([b,a],w(c)))},clearInterval:function(b){var a=
  la.delegate;return((null===a||void 0===a?void 0:a.clearInterval)||clearInterval)(b)},delegate:void 0},ya=function(b){function a(a,d){var c=b.call(this,a,d)||this;c.scheduler=a;c.work=d;c.pending=!1;return c}y(a,b);a.prototype.schedule=function(a,b){var c;void 0===b&&(b=0);if(this.closed)return this;this.state=a;a=this.id;var d=this.scheduler;null!=a&&(this.id=this.recycleAsyncId(d,a,b));this.pending=!0;this.delay=b;this.id=null!==(c=this.id)&&void 0!==c?c:this.requestAsyncId(d,this.id,b);return this};
  a.prototype.requestAsyncId=function(a,b,e){void 0===e&&(e=0);return la.setInterval(a.flush.bind(a,this),e)};a.prototype.recycleAsyncId=function(a,b,e){void 0===e&&(e=0);if(null!=e&&this.delay===e&&!1===this.pending)return b;null!=b&&la.clearInterval(b)};a.prototype.execute=function(a,b){if(this.closed)return Error("executing a cancelled action");this.pending=!1;if(a=this._execute(a,b))return a;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))};a.prototype._execute=
  function(a,b){b=!1;var c;try{this.work(a)}catch(f){b=!0,c=f?f:Error("Scheduled action threw falsy error")}if(b)return this.unsubscribe(),c};a.prototype.unsubscribe=function(){if(!this.closed){var a=this.id,d=this.scheduler,e=d.actions;this.work=this.state=this.scheduler=null;this.pending=!1;M(e,this);null!=a&&(this.id=this.recycleAsyncId(d,a,null));this.delay=null;b.prototype.unsubscribe.call(this)}};return a}(function(b){function a(a,d){return b.call(this)||this}y(a,b);a.prototype.schedule=function(a,
  b){return this};return a}(D)),Ue=1,Eb,$a={},Ve=function(b){var a=Ue++;$a[a]=!0;Eb||(Eb=Promise.resolve());Eb.then(function(){return Nb(a)&&b()});return a},We=function(b){Nb(b)},ma={setImmediate:function(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];a=ma.delegate;return((null===a||void 0===a?void 0:a.setImmediate)||Ve).apply(void 0,x([],w(b)))},clearImmediate:function(b){var a=ma.delegate;return((null===a||void 0===a?void 0:a.clearImmediate)||We)(b)},delegate:void 0},Xe=function(b){function a(a,
  d){var c=b.call(this,a,d)||this;c.scheduler=a;c.work=d;return c}y(a,b);a.prototype.requestAsyncId=function(a,d,e){void 0===e&&(e=0);if(null!==e&&0<e)return b.prototype.requestAsyncId.call(this,a,d,e);a.actions.push(this);return a._scheduled||(a._scheduled=ma.setImmediate(a.flush.bind(a,void 0)))};a.prototype.recycleAsyncId=function(a,d,e){var c;void 0===e&&(e=0);if(null!=e?0<e:0<this.delay)return b.prototype.recycleAsyncId.call(this,a,d,e);e=a.actions;null!=d&&(null===(c=e[e.length-1])||void 0===
  c?void 0:c.id)!==d&&(ma.clearImmediate(d),a._scheduled===d&&(a._scheduled=void 0))};return a}(ya),Fb=function(){function b(a,c){void 0===c&&(c=b.now);this.schedulerActionCtor=a;this.now=c}b.prototype.schedule=function(a,b,d){void 0===b&&(b=0);return(new this.schedulerActionCtor(this,a)).schedule(d,b)};b.now=ka.now;return b}(),za=function(b){function a(a,d){void 0===d&&(d=Fb.now);a=b.call(this,a,d)||this;a.actions=[];a._active=!1;return a}y(a,b);a.prototype.flush=function(a){var b=this.actions;if(this._active)b.push(a);
  else{var c;this._active=!0;do if(c=a.execute(a.state,a.delay))break;while(a=b.shift());this._active=!1;if(c){for(;a=b.shift();)a.unsubscribe();throw c;}}};return a}(Fb),Rd=new (function(b){function a(){return null!==b&&b.apply(this,arguments)||this}y(a,b);a.prototype.flush=function(a){this._active=!0;var b=this._scheduled;this._scheduled=void 0;var c=this.actions,f;a=a||c.shift();do if(f=a.execute(a.state,a.delay))break;while((a=c[0])&&a.id===b&&c.shift());this._active=!1;if(f){for(;(a=c[0])&&a.id===
  b&&c.shift();)a.unsubscribe();throw f;}};return a}(za))(Xe),I=new za(ya),ib=I,Ye=function(b){function a(a,d){var c=b.call(this,a,d)||this;c.scheduler=a;c.work=d;return c}y(a,b);a.prototype.schedule=function(a,d){void 0===d&&(d=0);if(0<d)return b.prototype.schedule.call(this,a,d);this.delay=d;this.state=a;this.scheduler.flush(this);return this};a.prototype.execute=function(a,d){return 0<d||this.closed?b.prototype.execute.call(this,a,d):this._execute(a,d)};a.prototype.requestAsyncId=function(a,d,e){void 0===
  e&&(e=0);if(null!=e&&0<e||null==e&&0<this.delay)return b.prototype.requestAsyncId.call(this,a,d,e);a.flush(this);return 0};return a}(ya),Sd=new (function(b){function a(){return null!==b&&b.apply(this,arguments)||this}y(a,b);return a}(za))(Ye),Ze=function(b){function a(a,d){var c=b.call(this,a,d)||this;c.scheduler=a;c.work=d;return c}y(a,b);a.prototype.requestAsyncId=function(a,d,e){void 0===e&&(e=0);if(null!==e&&0<e)return b.prototype.requestAsyncId.call(this,a,d,e);a.actions.push(this);return a._scheduled||
  (a._scheduled=N.requestAnimationFrame(function(){return a.flush(void 0)}))};a.prototype.recycleAsyncId=function(a,d,e){var c;void 0===e&&(e=0);if(null!=e?0<e:0<this.delay)return b.prototype.recycleAsyncId.call(this,a,d,e);e=a.actions;null!=d&&(null===(c=e[e.length-1])||void 0===c?void 0:c.id)!==d&&(N.cancelAnimationFrame(d),a._scheduled=void 0)};return a}(ya),Td=new (function(b){function a(){return null!==b&&b.apply(this,arguments)||this}y(a,b);a.prototype.flush=function(a){this._active=!0;var b=
  this._scheduled;this._scheduled=void 0;var c=this.actions,f;a=a||c.shift();do if(f=a.execute(a.state,a.delay))break;while((a=c[0])&&a.id===b&&c.shift());this._active=!1;if(f){for(;(a=c[0])&&a.id===b&&c.shift();)a.unsubscribe();throw f;}};return a}(za))(Ze),Ud=function(b){function a(a,d){void 0===a&&(a=Gb);void 0===d&&(d=Infinity);var c=b.call(this,a,function(){return c.frame})||this;c.maxFrames=d;c.frame=0;c.index=-1;return c}y(a,b);a.prototype.flush=function(){for(var a=this.actions,b=this.maxFrames,
  e,f;(f=a[0])&&f.delay<=b&&!(a.shift(),this.frame=f.delay,e=f.execute(f.state,f.delay)););if(e){for(;f=a.shift();)f.unsubscribe();throw e;}};a.frameTimeFactor=10;return a}(za),Gb=function(b){function a(a,d,e){void 0===e&&(e=a.index+=1);var c=b.call(this,a,d)||this;c.scheduler=a;c.work=d;c.index=e;c.active=!0;c.index=a.index=e;return c}y(a,b);a.prototype.schedule=function(c,d){void 0===d&&(d=0);if(Number.isFinite(d)){if(!this.id)return b.prototype.schedule.call(this,c,d);this.active=!1;var e=new a(this.scheduler,
  this.work);this.add(e);return e.schedule(c,d)}return D.EMPTY};a.prototype.requestAsyncId=function(b,d,e){void 0===e&&(e=0);this.delay=b.frame+e;b=b.actions;b.push(this);b.sort(a.sortActions);return 1};a.prototype.recycleAsyncId=function(a,b,e){};a.prototype._execute=function(a,d){if(!0===this.active)return b.prototype._execute.call(this,a,d)};a.sortActions=function(a,b){return a.delay===b.delay?a.index===b.index?0:a.index>b.index?1:-1:a.delay>b.delay?1:-1};return a}(ya),L=new r(function(b){return b.complete()}),
  bb=function(b){return b&&"number"===typeof b.length&&"function"!==typeof b},ab;ab="function"===typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator";(function(b){b.NEXT="N";b.ERROR="E";b.COMPLETE="C"})(g.NotificationKind||(g.NotificationKind={}));var Pa=function(){function b(a,b,d){this.kind=a;this.value=b;this.error=d;this.hasValue="N"===a}b.prototype.observe=function(a){return Fa(this,a)};b.prototype.do=function(a,b,d){var c=this.kind,f=this.value,h=this.error;return"N"===c?null===a||void 0===
  a?void 0:a(f):"E"===c?null===b||void 0===b?void 0:b(h):null===d||void 0===d?void 0:d()};b.prototype.accept=function(a,b,d){return t(null===a||void 0===a?void 0:a.next)?this.observe(a):this.do(a,b,d)};b.prototype.toObservable=function(){var a=this.kind,b=this.value,d=this.error,b="N"===a?cb(b):"E"===a?Wb(function(){return d}):"C"===a?L:0;if(!b)throw new TypeError("Unexpected notification kind "+a);return b};b.createNext=function(a){return new b("N",a)};b.createError=function(a){return new b("E",void 0,
  a)};b.createComplete=function(){return b.completeNotification};b.completeNotification=new b("C");return b}(),aa=R(function(b){return function(){b(this);this.name="EmptyError";this.message="no elements in sequence"}}),rb=R(function(b){return function(){b(this);this.name="ArgumentOutOfRangeError";this.message="argument out of range"}}),ld=R(function(b){return function(a){b(this);this.name="NotFoundError";this.message=a}}),kd=R(function(b){return function(a){b(this);this.name="SequenceError";this.message=
  a}}),Xb=R(function(b){return function(a){void 0===a&&(a=null);b(this);this.message="Timeout has occurred";this.name="TimeoutError";this.info=a}}),le=Array.isArray,me=Array.isArray,ne=Object.getPrototypeOf,oe=Object.prototype,pe=Object.keys,$e={connector:function(){return new A},resetOnDisconnect:!0},te=["addListener","removeListener"],re=["addEventListener","removeEventListener"],ve=["on","off"],Vd=new r(C),we=Array.isArray,Ae=function(b,a){return b.push(a),b},Ce={connector:function(){return new A}},
  Fe=function(){return function(b,a){this.value=b;this.interval=a}}(),af=Object.freeze({audit:kb,auditTime:ic,buffer:jc,bufferCount:kc,bufferTime:lc,bufferToggle:mc,bufferWhen:nc,catchError:lb,combineAll:Ja,combineLatestAll:Ja,combineLatest:nb,combineLatestWith:qc,concat:sc,concatAll:Ha,concatMap:Ka,concatMapTo:rc,concatWith:tc,connect:La,count:uc,debounce:vc,debounceTime:wc,defaultIfEmpty:ua,delay:xc,delayWhen:Ma,dematerialize:yc,distinct:zc,distinctUntilChanged:qb,distinctUntilKeyChanged:Ac,elementAt:Bc,
  endWith:Cc,every:Dc,exhaust:Oa,exhaustAll:Oa,exhaustMap:Na,expand:Ec,filter:K,finalize:Fc,find:Gc,findIndex:Ic,first:Jc,groupBy:Kc,ignoreElements:ob,isEmpty:Lc,last:Mc,map:Q,mapTo:pb,materialize:Nc,max:Oc,merge:Rc,mergeAll:sa,flatMap:H,mergeMap:H,mergeMapTo:Pc,mergeScan:Qc,mergeWith:Sc,min:Tc,multicast:Qa,observeOn:qa,onErrorResumeNext:Uc,pairwise:Vc,partition:function(b,a){return function(c){return[K(b,a)(c),K(gc(b,a))(c)]}},pluck:Wc,publish:Xc,publishBehavior:Yc,publishLast:$c,publishReplay:ad,
  race:function(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return tb.apply(void 0,x([],w(Z(b))))},raceWith:tb,reduce:fa,repeat:bd,repeatWhen:cd,retry:dd,retryWhen:ed,refCount:Za,sample:ub,sampleTime:fd,scan:gd,sequenceEqual:hd,share:vb,shareReplay:id,single:jd,skip:md,skipLast:nd,skipUntil:od,skipWhile:pd,startWith:qd,subscribeOn:ra,switchAll:rd,switchMap:ja,switchMapTo:sd,switchScan:td,take:ga,takeLast:sb,takeUntil:ud,takeWhile:vd,tap:wd,throttle:xb,throttleTime:xd,throwIfEmpty:va,
  timeInterval:yd,timeout:eb,timeoutWith:zd,timestamp:Ad,toArray:mb,window:Bd,windowCount:Cd,windowTime:Dd,windowToggle:Ed,windowWhen:Fd,withLatestFrom:Gd,zip:Id,zipAll:Hd,zipWith:Jd}),Aa=function(){return function(b,a){void 0===a&&(a=Infinity);this.subscribedFrame=b;this.unsubscribedFrame=a}}(),Wd=function(){function b(){this.subscriptions=[]}b.prototype.logSubscribedFrame=function(){this.subscriptions.push(new Aa(this.scheduler.now()));return this.subscriptions.length-1};b.prototype.logUnsubscribedFrame=
  function(a){var b=this.subscriptions;b[a]=new Aa(b[a].subscribedFrame,this.scheduler.now())};return b}(),Hb=function(b){function a(a,d){var c=b.call(this,function(a){var b=this,c=b.logSubscribedFrame(),d=new D;d.add(new D(function(){b.logUnsubscribedFrame(c)}));b.scheduleMessages(a);return d})||this;c.messages=a;c.subscriptions=[];c.scheduler=d;return c}y(a,b);a.prototype.scheduleMessages=function(a){for(var b=this.messages.length,c=0;c<b;c++){var f=this.messages[c];a.add(this.scheduler.schedule(function(a){Fa(a.message.notification,
  a.subscriber)},f.frame,{message:f,subscriber:a}))}};return a}(r);Kd(Hb,[Wd]);var Xd=function(b){function a(a,d){var c=b.call(this)||this;c.messages=a;c.subscriptions=[];c.scheduler=d;return c}y(a,b);a.prototype._subscribe=function(a){var c=this,e=c.logSubscribedFrame(),f=new D;f.add(new D(function(){c.logUnsubscribedFrame(e)}));f.add(b.prototype._subscribe.call(this,a));return f};a.prototype.setup=function(){for(var a=this,b=a.messages.length,e=function(b){(function(){var c=a.messages[b],d=c.notification;
  a.scheduler.schedule(function(){Fa(d,a)},c.frame)})()},f=0;f<b;f++)e(f)};return a}(A);Kd(Xd,[Wd]);var bf=function(b){function a(a){var c=b.call(this,Gb,750)||this;c.assertDeepEqual=a;c.hotObservables=[];c.coldObservables=[];c.flushTests=[];c.runMode=!1;return c}y(a,b);a.prototype.createTime=function(b){b=this.runMode?b.trim().indexOf("|"):b.indexOf("|");if(-1===b)throw Error('marble diagram for time should have a completion marker "|"');return b*a.frameTimeFactor};a.prototype.createColdObservable=
  function(b,d,e){if(-1!==b.indexOf("^"))throw Error('cold observable cannot have subscription offset "^"');if(-1!==b.indexOf("!"))throw Error('cold observable cannot have unsubscription marker "!"');b=a.parseMarbles(b,d,e,void 0,this.runMode);b=new Hb(b,this);this.coldObservables.push(b);return b};a.prototype.createHotObservable=function(b,d,e){if(-1!==b.indexOf("!"))throw Error('hot observable cannot have unsubscription marker "!"');b=a.parseMarbles(b,d,e,void 0,this.runMode);b=new Xd(b,this);this.hotObservables.push(b);
  return b};a.prototype.materializeInnerObservable=function(a,b){var c=this,d=[];a.subscribe({next:function(a){d.push({frame:c.frame-b,notification:J("N",a,void 0)})},error:function(a){d.push({frame:c.frame-b,notification:J("E",void 0,a)})},complete:function(){d.push({frame:c.frame-b,notification:xa})}});return d};a.prototype.expectObservable=function(b,d){var c=this;void 0===d&&(d=null);var f=[],g={actual:f,ready:!1};d=a.parseMarblesAsSubscriptions(d,this.runMode);var l=Infinity===d.subscribedFrame?
  0:d.subscribedFrame;d=d.unsubscribedFrame;var k;this.schedule(function(){k=b.subscribe({next:function(a){a=a instanceof r?c.materializeInnerObservable(a,c.frame):a;f.push({frame:c.frame,notification:J("N",a,void 0)})},error:function(a){f.push({frame:c.frame,notification:J("E",void 0,a)})},complete:function(){f.push({frame:c.frame,notification:xa})}})},l);Infinity!==d&&this.schedule(function(){return k.unsubscribe()},d);this.flushTests.push(g);var m=this.runMode;return{toBe:function(b,c,d){g.ready=
  !0;g.expected=a.parseMarbles(b,c,d,!0,m)},toEqual:function(a){g.ready=!0;g.expected=[];c.schedule(function(){k=a.subscribe({next:function(a){a=a instanceof r?c.materializeInnerObservable(a,c.frame):a;g.expected.push({frame:c.frame,notification:J("N",a,void 0)})},error:function(a){g.expected.push({frame:c.frame,notification:J("E",void 0,a)})},complete:function(){g.expected.push({frame:c.frame,notification:xa})}})},l)}}};a.prototype.expectSubscriptions=function(b){var c={actual:b,ready:!1};this.flushTests.push(c);
  var e=this.runMode;return{toBe:function(b){b="string"===typeof b?[b]:b;c.ready=!0;c.expected=b.map(function(b){return a.parseMarblesAsSubscriptions(b,e)}).filter(function(a){return Infinity!==a.subscribedFrame})}}};a.prototype.flush=function(){for(var a=this,d=this.hotObservables;0<d.length;)d.shift().setup();b.prototype.flush.call(this);this.flushTests=this.flushTests.filter(function(b){return b.ready?(a.assertDeepEqual(b.actual,b.expected),!1):!0})};a.parseMarblesAsSubscriptions=function(a,b){var c=
  this;void 0===b&&(b=!1);if("string"!==typeof a)return new Aa(Infinity);var d=x([],w(a));a=d.length;for(var g=-1,l=Infinity,k=Infinity,m=0,p=function(a){var e=m,f=function(a){e+=a*c.frameTimeFactor},h=d[a];switch(h){case " ":b||f(1);break;case "-":f(1);break;case "(":g=m;f(1);break;case ")":g=-1;f(1);break;case "^":if(Infinity!==l)throw Error("found a second subscription point '^' in a subscription marble diagram. There can only be one.");l=-1<g?g:m;f(1);break;case "!":if(Infinity!==k)throw Error("found a second unsubscription point '!' in a subscription marble diagram. There can only be one.");
  k=-1<g?g:m;break;default:if(b&&h.match(/^[0-9]$/)&&(0===a||" "===d[a-1])){var p=d.slice(a).join("").match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);if(p){a+=p[0].length-1;var h=parseFloat(p[1]),q=void 0;switch(p[2]){case "ms":q=h;break;case "s":q=1E3*h;break;case "m":q=6E4*h}f(q/n.frameTimeFactor);break}}throw Error("there can only be '^' and '!' markers in a subscription marble diagram. Found instead '"+h+"'.");}m=e;r=a},n=this,r,q=0;q<a;q++)p(q),q=r;return 0>k?new Aa(l):new Aa(l,k)};a.parseMarbles=function(a,
  b,e,f,g){var c=this;void 0===f&&(f=!1);void 0===g&&(g=!1);if(-1!==a.indexOf("!"))throw Error('conventional marble diagrams cannot have the unsubscription marker "!"');var d=x([],w(a)),h=d.length,p=[];a=g?a.replace(/^[ ]+/,"").indexOf("^"):a.indexOf("^");var m=-1===a?0:a*-this.frameTimeFactor,n="object"!==typeof b?function(a){return a}:function(a){return f&&b[a]instanceof Hb?b[a].messages:b[a]},q=-1;a=function(a){var b=m,f=function(a){b+=a*c.frameTimeFactor},h=void 0,k=d[a];switch(k){case " ":g||f(1);
  break;case "-":f(1);break;case "(":q=m;f(1);break;case ")":q=-1;f(1);break;case "|":h=xa;f(1);break;case "^":f(1);break;case "#":h=J("E",void 0,e||"error");f(1);break;default:if(g&&k.match(/^[0-9]$/)&&(0===a||" "===d[a-1])){var l=d.slice(a).join("").match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);if(l){a+=l[0].length-1;var k=parseFloat(l[1]),v=void 0;switch(l[2]){case "ms":v=k;break;case "s":v=1E3*k;break;case "m":v=6E4*k}f(v/r.frameTimeFactor);break}}h=J("N",n(k),void 0);f(1)}h&&p.push({frame:-1<q?q:m,
  notification:h});m=b;t=a};for(var r=this,t,y=0;y<h;y++)a(y),y=t;return p};a.prototype.createAnimator=function(){var b=this;if(!this.runMode)throw Error("animate() must only be used in run mode");var d=0,e;return{animate:function(c){var d,f;if(e)throw Error("animate() must not be called more than once within run()");if(/[|#]/.test(c))throw Error("animate() must not complete or error");e=new Map;c=a.parseMarbles(c,void 0,void 0,void 0,!0);try{for(var g=F(c),m=g.next();!m.done;m=g.next())b.schedule(function(){var a,
  c,d=b.now(),f=Array.from(e.values());e.clear();try{for(var g=(a=void 0,F(f)),h=g.next();!h.done;h=g.next()){var k=h.value;k(d)}}catch(X){a={error:X}}finally{try{h&&!h.done&&(c=g.return)&&c.call(g)}finally{if(a)throw a.error;}}},m.value.frame)}catch(p){d={error:p}}finally{try{m&&!m.done&&(f=g.return)&&f.call(g)}finally{if(d)throw d.error;}}},delegate:{requestAnimationFrame:function(a){if(!e)throw Error("animate() was not called within run()");var b=++d;e.set(b,a);return b},cancelAnimationFrame:function(a){if(!e)throw Error("animate() was not called within run()");
  e.delete(a)}}}};a.prototype.createDelegates=function(){var a=this,b=0,e=new Map,f=function(){var b=a.now(),c=Array.from(e.values()).filter(function(a){return a.due<=b}),d=c.filter(function(a){return"immediate"===a.type});if(0<d.length)d=d[0],c=d.handle,d=d.handler,e.delete(c),d();else if(d=c.filter(function(a){return"interval"===a.type}),0<d.length){var c=d[0],g=c.duration,d=c.handler;c.due=b+g;c.subscription=a.schedule(f,g);d()}else if(c=c.filter(function(a){return"timeout"===a.type}),0<c.length)d=
  c[0],c=d.handle,d=d.handler,e.delete(c),d();else throw Error("Expected a due immediate or interval");};return{immediate:{setImmediate:function(c){var d=++b;e.set(d,{due:a.now(),duration:0,handle:d,handler:c,subscription:a.schedule(f,0),type:"immediate"});return d},clearImmediate:function(a){var b=e.get(a);b&&(b.subscription.unsubscribe(),e.delete(a))}},interval:{setInterval:function(c,d){void 0===d&&(d=0);var g=++b;e.set(g,{due:a.now()+d,duration:d,handle:g,handler:c,subscription:a.schedule(f,d),
  type:"interval"});return g},clearInterval:function(a){var b=e.get(a);b&&(b.subscription.unsubscribe(),e.delete(a))}},timeout:{setTimeout:function(c,d){void 0===d&&(d=0);var g=++b;e.set(g,{due:a.now()+d,duration:d,handle:g,handler:c,subscription:a.schedule(f,d),type:"timeout"});return g},clearTimeout:function(a){var b=e.get(a);b&&(b.subscription.unsubscribe(),e.delete(a))}}}};a.prototype.run=function(b){var c=a.frameTimeFactor,e=this.maxFrames;a.frameTimeFactor=1;this.maxFrames=Infinity;this.runMode=
  !0;var f=this.createAnimator(),g=this.createDelegates();N.delegate=f.delegate;ka.delegate=this;ma.delegate=g.immediate;la.delegate=g.interval;da.delegate=g.timeout;Da.delegate=this;f={cold:this.createColdObservable.bind(this),hot:this.createHotObservable.bind(this),flush:this.flush.bind(this),time:this.createTime.bind(this),expectObservable:this.expectObservable.bind(this),expectSubscriptions:this.expectSubscriptions.bind(this),animate:f.animate};try{var l=b(f);this.flush();return l}finally{a.frameTimeFactor=
  c,this.maxFrames=e,this.runMode=!1,N.delegate=void 0,ka.delegate=void 0,ma.delegate=void 0,la.delegate=void 0,da.delegate=void 0,Da.delegate=void 0}};a.frameTimeFactor=10;return a}(Ud),cf=Object.freeze({TestScheduler:bf}),yb=function(){return function(b,a,c,d){void 0===d&&(d="download_load");this.originalEvent=b;this.xhr=a;this.request=c;this.type=d;c=a.status;d=a.responseType;this.status=null!==c&&void 0!==c?c:0;this.responseType=null!==d&&void 0!==d?d:"";this.responseHeaders=(c=a.getAllResponseHeaders())?
  c.split("\n").reduce(function(a,b){var c=b.indexOf(": ");a[b.slice(0,c)]=b.slice(c+2);return a},{}):{};this.response=Ld(a);a=b.total;this.loaded=b.loaded;this.total=a}}(),wa=R(function(b){return function(a,b,d){this.message=a;this.name="AjaxError";this.xhr=b;this.request=d;this.status=b.status;this.responseType=b.responseType;var c;try{c=Ld(b)}catch(f){c=b.responseText}this.response=c}}),Md=function(){function b(a,b){wa.call(this,"ajax timeout",a,b);this.name="AjaxTimeoutError";return this}b.prototype=
  Object.create(wa.prototype);return b}(),Me=Q(function(b){return b.response}),ba=function(){var b=function(a){return Ne("string"===typeof a?{url:a}:a)};b.get=Ge;b.post=He;b.delete=Ie;b.put=Je;b.patch=Ke;b.getJSON=Le;return b}(),Pe="upload",Od="download",zb="loadstart",Ab="progress",Nd="load",Qe=Object.prototype.toString,df=Object.freeze({ajax:ba,AjaxError:wa,AjaxTimeoutError:Md,AjaxResponse:yb}),ef={url:"",deserializer:function(b){return JSON.parse(b.data)},serializer:function(b){return JSON.stringify(b)}},
  Yd=function(b){function a(a,d){var c=b.call(this)||this;c._socket=null;if(a instanceof r)c.destination=d,c.source=a;else{d=c._config=T({},ef);c._output=new A;if("string"===typeof a)d.url=a;else for(var f in a)a.hasOwnProperty(f)&&(d[f]=a[f]);if(!d.WebSocketCtor&&WebSocket)d.WebSocketCtor=WebSocket;else if(!d.WebSocketCtor)throw Error("no WebSocket constructor can be found");c.destination=new ha}return c}y(a,b);a.prototype.lift=function(b){var c=new a(this._config,this.destination);c.operator=b;c.source=
  this;return c};a.prototype._resetState=function(){this._socket=null;this.source||(this.destination=new ha);this._output=new A};a.prototype.multiplex=function(a,b,e){var c=this;return new r(function(d){try{c.next(a())}catch(k){d.error(k)}var f=c.subscribe({next:function(a){try{e(a)&&d.next(a)}catch(z){d.error(z)}},error:function(a){return d.error(a)},complete:function(){return d.complete()}});return function(){try{c.next(b())}catch(k){d.error(k)}f.unsubscribe()}})};a.prototype._connectSocket=function(){var a=
  this,b=this._config,e=b.WebSocketCtor,f=b.protocol,g=b.url,b=b.binaryType,l=this._output,k=null;try{this._socket=k=f?new e(g,f):new e(g),b&&(this._socket.binaryType=b)}catch(p){l.error(p);return}var m=new D(function(){a._socket=null;k&&1===k.readyState&&k.close()});k.onopen=function(b){if(a._socket){var c=a._config.openObserver;c&&c.next(b);b=a.destination;a.destination=na.create(function(b){if(1===k.readyState)try{var c=a._config.serializer;k.send(c(b))}catch(u){a.destination.error(u)}},function(b){var c=
  a._config.closingObserver;c&&c.next(void 0);b&&b.code?k.close(b.code,b.reason):l.error(new TypeError("WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }"));a._resetState()},function(){var b=a._config.closingObserver;b&&b.next(void 0);k.close();a._resetState()});b&&b instanceof ha&&m.add(b.subscribe(a.destination))}else k.close(),a._resetState()};k.onerror=function(b){a._resetState();l.error(b)};k.onclose=function(b){k===
  a._socket&&a._resetState();var c=a._config.closeObserver;c&&c.next(b);b.wasClean?l.complete():l.error(b)};k.onmessage=function(b){try{var c=a._config.deserializer;l.next(c(b))}catch(B){l.error(B)}}};a.prototype._subscribe=function(a){var b=this,c=this.source;if(c)return c.subscribe(a);this._socket||this._connectSocket();this._output.subscribe(a);a.add(function(){var a=b._socket;0===b._output.observers.length&&(!a||1!==a.readyState&&0!==a.readyState||a.close(),b._resetState())});return a};a.prototype.unsubscribe=
  function(){var a=this._socket;!a||1!==a.readyState&&0!==a.readyState||a.close();this._resetState();b.prototype.unsubscribe.call(this)};return a}(Db),ff=Object.freeze({webSocket:function(b){return new Yd(b)},WebSocketSubject:Yd}),gf=Object.freeze({fromFetch:function(b,a){void 0===a&&(a={});var c=a.selector,d=Zd(a,["selector"]);return new r(function(a){var e=new AbortController,g=e.signal,l=!0,k=d.signal;if(k)if(k.aborted)e.abort();else{var n=function(){g.aborted||e.abort()};k.addEventListener("abort",
  n);a.add(function(){return k.removeEventListener("abort",n)})}var p=T(T({},d),{signal:g}),r=function(b){l=!1;a.error(b)};fetch(b,p).then(function(b){c?q(c(b)).subscribe(m(a,void 0,function(){l=!1;a.complete()},r)):(l=!1,a.next(b),a.complete())}).catch(r);return function(){l&&e.abort()}})}});g.operators=af;g.testing=cf;g.ajax=df;g.webSocket=ff;g.fetch=gf;g.Observable=r;g.ConnectableObservable=Ra;g.observable=pa;g.animationFrames=function(b){return b?Mb(b):Te};g.Subject=A;g.BehaviorSubject=Zc;g.ReplaySubject=
  ha;g.AsyncSubject=fb;g.asap=Rd;g.asapScheduler=Rd;g.async=ib;g.asyncScheduler=I;g.queue=Sd;g.queueScheduler=Sd;g.animationFrame=Td;g.animationFrameScheduler=Td;g.VirtualTimeScheduler=Ud;g.VirtualAction=Gb;g.Scheduler=Fb;g.Subscription=D;g.Subscriber=na;g.Notification=Pa;g.pipe=Xa;g.noop=C;g.identity=E;g.isObservable=function(b){return!!b&&(b instanceof r||t(b.lift)&&t(b.subscribe))};g.lastValueFrom=function(b,a){var c="object"===typeof a;return new Promise(function(d,e){var f=!1,g;b.subscribe({next:function(a){g=
  a;f=!0},error:e,complete:function(){f?d(g):c?d(a.defaultValue):e(new aa)}})})};g.firstValueFrom=function(b,a){var c="object"===typeof a;return new Promise(function(d,e){var f=new ia({next:function(a){d(a);f.unsubscribe()},error:e,complete:function(){c?d(a.defaultValue):e(new aa)}});b.subscribe(f)})};g.ArgumentOutOfRangeError=rb;g.EmptyError=aa;g.NotFoundError=ld;g.ObjectUnsubscribedError=Qd;g.SequenceError=kd;g.TimeoutError=Xb;g.UnsubscriptionError=Sa;g.bindCallback=function(b,a,c){return Ga(!1,b,
  a,c)};g.bindNodeCallback=function(b,a,c){return Ga(!0,b,a,c)};g.combineLatest=$b;g.concat=ta;g.connectable=function(b,a){void 0===a&&(a=$e);var c=null,d=a.connector;a=a.resetOnDisconnect;var e=void 0===a?!0:a,f=d();a=new r(function(a){return f.subscribe(a)});a.connect=function(){if(!c||c.closed)c=Ia(function(){return b}).subscribe(f),e&&c.add(function(){return f=d()});return c};return a};g.defer=Ia;g.empty=function(b){return b?de(b):L};g.forkJoin=function(){for(var b=[],a=0;a<arguments.length;a++)b[a]=
  arguments[a];var a=oa(b),b=Yb(b),c=b.args,d=b.keys,b=new r(function(a){var b=c.length;if(b)for(var e=Array(b),g=b,k=b,n=function(b){var f=!1;q(c[b]).subscribe(m(a,function(a){f||(f=!0,k--);e[b]=a},function(){return g--},void 0,function(){g&&f||(k||a.next(d?Zb(d,e):e),a.complete())}))},p=0;p<b;p++)n(p);else a.complete()});return a?b.pipe(W(a)):b};g.from=P;g.fromEvent=hb;g.fromEventPattern=dc;g.generate=function(b,a,c,d,e){function f(){var b;return Ua(this,function(d){switch(d.label){case 0:b=k,d.label=
  1;case 1:return a&&!a(b)?[3,4]:[4,l(b)];case 2:d.sent(),d.label=3;case 3:return b=c(b),[3,1];case 4:return[2]}})}var g,l,k;1===arguments.length?(k=b.initialState,a=b.condition,c=b.iterate,g=b.resultSelector,l=void 0===g?E:g,e=b.scheduler):(k=b,!d||Ea(d)?(l=E,e=d):l=d);return Ia(e?function(){return Tb(f(),e)}:f)};g.iif=function(b,a,c){return Ia(function(){return b()?a:c})};g.interval=ec;g.merge=function(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];var a=O(b),c="number"===typeof b[b.length-
  1]?b.pop():Infinity;return b.length?1===b.length?q(b[0]):sa(c)(P(b,a)):L};g.never=function(){return Vd};g.of=cb;g.onErrorResumeNext=fc;g.pairs=function(b,a){return P(Object.entries(b),a)};g.partition=function(b,a,c){return[K(a,c)(q(b)),K(gc(a,c))(q(b))]};g.race=function(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];b=Z(b);return 1===b.length?q(b[0]):new r(hc(b))};g.range=function(b,a,c){null==a&&(a=b,b=0);if(0>=a)return L;var d=a+b;return new r(c?function(a){var e=b;return c.schedule(function(){e<
  d?(a.next(e++),this.schedule()):a.complete()})}:function(a){for(var c=b;c<d&&!a.closed;)a.next(c++);a.complete()})};g.throwError=Wb;g.timer=Y;g.using=function(b,a){return new r(function(c){var d=b(),e=a(d);(e?q(e):L).subscribe(c);return function(){d&&d.unsubscribe()}})};g.zip=jb;g.scheduled=Vb;g.EMPTY=L;g.NEVER=Vd;g.config=S;g.audit=kb;g.auditTime=ic;g.buffer=jc;g.bufferCount=kc;g.bufferTime=lc;g.bufferToggle=mc;g.bufferWhen=nc;g.catchError=lb;g.combineAll=Ja;g.combineLatestAll=Ja;g.combineLatestWith=
  qc;g.concatAll=Ha;g.concatMap=Ka;g.concatMapTo=rc;g.concatWith=tc;g.connect=La;g.count=uc;g.debounce=vc;g.debounceTime=wc;g.defaultIfEmpty=ua;g.delay=xc;g.delayWhen=Ma;g.dematerialize=yc;g.distinct=zc;g.distinctUntilChanged=qb;g.distinctUntilKeyChanged=Ac;g.elementAt=Bc;g.endWith=Cc;g.every=Dc;g.exhaust=Oa;g.exhaustAll=Oa;g.exhaustMap=Na;g.expand=Ec;g.filter=K;g.finalize=Fc;g.find=Gc;g.findIndex=Ic;g.first=Jc;g.groupBy=Kc;g.ignoreElements=ob;g.isEmpty=Lc;g.last=Mc;g.map=Q;g.mapTo=pb;g.materialize=
  Nc;g.max=Oc;g.mergeAll=sa;g.flatMap=H;g.mergeMap=H;g.mergeMapTo=Pc;g.mergeScan=Qc;g.mergeWith=Sc;g.min=Tc;g.multicast=Qa;g.observeOn=qa;g.onErrorResumeNextWith=Uc;g.pairwise=Vc;g.pluck=Wc;g.publish=Xc;g.publishBehavior=Yc;g.publishLast=$c;g.publishReplay=ad;g.raceWith=tb;g.reduce=fa;g.repeat=bd;g.repeatWhen=cd;g.retry=dd;g.retryWhen=ed;g.refCount=Za;g.sample=ub;g.sampleTime=fd;g.scan=gd;g.sequenceEqual=hd;g.share=vb;g.shareReplay=id;g.single=jd;g.skip=md;g.skipLast=nd;g.skipUntil=od;g.skipWhile=pd;
  g.startWith=qd;g.subscribeOn=ra;g.switchAll=rd;g.switchMap=ja;g.switchMapTo=sd;g.switchScan=td;g.take=ga;g.takeLast=sb;g.takeUntil=ud;g.takeWhile=vd;g.tap=wd;g.throttle=xb;g.throttleTime=xd;g.throwIfEmpty=va;g.timeInterval=yd;g.timeout=eb;g.timeoutWith=zd;g.timestamp=Ad;g.toArray=mb;g.window=Bd;g.windowCount=Cd;g.windowTime=Dd;g.windowToggle=Ed;g.windowWhen=Fd;g.withLatestFrom=Gd;g.zipAll=Hd;g.zipWith=Jd;Object.defineProperty(g,"__esModule",{value:!0})});
  //# sourceMappingURL=blackpard.umd.min.js.map
  
  

!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).blackpard=t()}(this,(function(){"use strict";function e(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function t(t){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?e(Object(r),!0).forEach((function(e){a(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):e(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function n(e){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n(e)}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function i(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),Object.defineProperty(e,"prototype",{writable:!1}),e}function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){return c(e)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null==n)return;var r,o,i=[],a=!0,s=!1;try{for(n=n.call(e);!(a=(r=n.next()).done)&&(i.push(r.value),!t||i.length!==t);a=!0);}catch(e){s=!0,o=e}finally{try{a||null==n.return||n.return()}finally{if(s)throw o}}return i}(e,t)||l(e,t)||p()}function u(e){return function(e){if(Array.isArray(e))return d(e)}(e)||f(e)||l(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function c(e){if(Array.isArray(e))return e}function f(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}function l(e,t){if(e){if("string"==typeof e)return d(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?d(e,t):void 0}}function d(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function p(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function h(e,t){return function(){return e.apply(t,arguments)}}var m,y=Object.prototype.toString,v=Object.getPrototypeOf,b=(m=Object.create(null),function(e){var t=y.call(e);return m[t]||(m[t]=t.slice(8,-1).toLowerCase())}),g=function(e){return e=e.toLowerCase(),function(t){return b(t)===e}},w=function(e){return function(t){return n(t)===e}},O=Array.isArray,E=w("undefined");var S=g("ArrayBuffer");var R=w("string"),A=w("function"),j=w("number"),T=function(e){return null!==e&&"object"===n(e)},P=function(e){if("object"!==b(e))return!1;var t=v(e);return!(null!==t&&t!==Object.prototype&&null!==Object.getPrototypeOf(t)||Symbol.toStringTag in e||Symbol.iterator in e)},N=g("Date"),x=g("File"),C=g("Blob"),k=g("FileList"),_=g("URLSearchParams");function F(e,t){var r,o,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=i.allOwnKeys,s=void 0!==a&&a;if(null!=e)if("object"!==n(e)&&(e=[e]),O(e))for(r=0,o=e.length;r<o;r++)t.call(null,e[r],r,e);else{var u,c=s?Object.getOwnPropertyNames(e):Object.keys(e),f=c.length;for(r=0;r<f;r++)u=c[r],t.call(null,e[u],u,e)}}function U(e,t){t=t.toLowerCase();for(var n,r=Object.keys(e),o=r.length;o-- >0;)if(t===(n=r[o]).toLowerCase())return n;return null}var D="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:global,B=function(e){return!E(e)&&e!==D};var L,I=(L="undefined"!=typeof Uint8Array&&v(Uint8Array),function(e){return L&&e instanceof L}),q=g("HTMLFormElement"),z=function(e){var t=Object.prototype.hasOwnProperty;return function(e,n){return t.call(e,n)}}(),M=g("RegExp"),H=function(e,t){var n=Object.getOwnPropertyDescriptors(e),r={};F(n,(function(n,o){var i;!1!==(i=t(n,o,e))&&(r[o]=i||n)})),Object.defineProperties(e,r)},J="abcdefghijklmnopqrstuvwxyz",W="0123456789",K={DIGIT:W,ALPHA:J,ALPHA_DIGIT:J+J.toUpperCase()+W};var V=g("AsyncFunction"),G={isArray:O,isArrayBuffer:S,isBuffer:function(e){return null!==e&&!E(e)&&null!==e.constructor&&!E(e.constructor)&&A(e.constructor.isBuffer)&&e.constructor.isBuffer(e)},isFormData:function(e){var t;return e&&("function"==typeof FormData&&e instanceof FormData||A(e.append)&&("formdata"===(t=b(e))||"object"===t&&A(e.toString)&&"[object FormData]"===e.toString()))},isArrayBufferView:function(e){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer&&S(e.buffer)},isString:R,isNumber:j,isBoolean:function(e){return!0===e||!1===e},isObject:T,isPlainObject:P,isUndefined:E,isDate:N,isFile:x,isBlob:C,isRegExp:M,isFunction:A,isStream:function(e){return T(e)&&A(e.pipe)},isURLSearchParams:_,isTypedArray:I,isFileList:k,forEach:F,merge:function e(){for(var t=B(this)&&this||{},n=t.caseless,r={},o=function(t,o){var i=n&&U(r,o)||o;P(r[i])&&P(t)?r[i]=e(r[i],t):P(t)?r[i]=e({},t):O(t)?r[i]=t.slice():r[i]=t},i=0,a=arguments.length;i<a;i++)arguments[i]&&F(arguments[i],o);return r},extend:function(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=r.allOwnKeys;return F(t,(function(t,r){n&&A(t)?e[r]=h(t,n):e[r]=t}),{allOwnKeys:o}),e},trim:function(e){return e.trim?e.trim():e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")},stripBOM:function(e){return 65279===e.charCodeAt(0)&&(e=e.slice(1)),e},inherits:function(e,t,n,r){e.prototype=Object.create(t.prototype,r),e.prototype.constructor=e,Object.defineProperty(e,"super",{value:t.prototype}),n&&Object.assign(e.prototype,n)},toFlatObject:function(e,t,n,r){var o,i,a,s={};if(t=t||{},null==e)return t;do{for(i=(o=Object.getOwnPropertyNames(e)).length;i-- >0;)a=o[i],r&&!r(a,e,t)||s[a]||(t[a]=e[a],s[a]=!0);e=!1!==n&&v(e)}while(e&&(!n||n(e,t))&&e!==Object.prototype);return t},kindOf:b,kindOfTest:g,endsWith:function(e,t,n){e=String(e),(void 0===n||n>e.length)&&(n=e.length),n-=t.length;var r=e.indexOf(t,n);return-1!==r&&r===n},toArray:function(e){if(!e)return null;if(O(e))return e;var t=e.length;if(!j(t))return null;for(var n=new Array(t);t-- >0;)n[t]=e[t];return n},forEachEntry:function(e,t){for(var n,r=(e&&e[Symbol.iterator]).call(e);(n=r.next())&&!n.done;){var o=n.value;t.call(e,o[0],o[1])}},matchAll:function(e,t){for(var n,r=[];null!==(n=e.exec(t));)r.push(n);return r},isHTMLForm:q,hasOwnProperty:z,hasOwnProp:z,reduceDescriptors:H,freezeMethods:function(e){H(e,(function(t,n){if(A(e)&&-1!==["arguments","caller","callee"].indexOf(n))return!1;var r=e[n];A(r)&&(t.enumerable=!1,"writable"in t?t.writable=!1:t.set||(t.set=function(){throw Error("Can not rewrite read-only method '"+n+"'")}))}))},toObjectSet:function(e,t){var n={},r=function(e){e.forEach((function(e){n[e]=!0}))};return O(e)?r(e):r(String(e).split(t)),n},toCamelCase:function(e){return e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,(function(e,t,n){return t.toUpperCase()+n}))},noop:function(){},toFiniteNumber:function(e,t){return e=+e,Number.isFinite(e)?e:t},findKey:U,global:D,isContextDefined:B,ALPHABET:K,generateString:function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:16,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:K.ALPHA_DIGIT,n="",r=t.length;e--;)n+=t[Math.random()*r|0];return n},isSpecCompliantForm:function(e){return!!(e&&A(e.append)&&"FormData"===e[Symbol.toStringTag]&&e[Symbol.iterator])},toJSONObject:function(e){var t=new Array(10);return function e(n,r){if(T(n)){if(t.indexOf(n)>=0)return;if(!("toJSON"in n)){t[r]=n;var o=O(n)?[]:{};return F(n,(function(t,n){var i=e(t,r+1);!E(i)&&(o[n]=i)})),t[r]=void 0,o}}return n}(e,0)},isAsyncFn:V,isThenable:function(e){return e&&(T(e)||A(e))&&A(e.then)&&A(e.catch)}};function X(e,t,n,r,o){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack,this.message=e,this.name="blackpardError",t&&(this.code=t),n&&(this.config=n),r&&(this.request=r),o&&(this.response=o)}G.inherits(X,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:G.toJSONObject(this.config),code:this.code,status:this.response&&this.response.status?this.response.status:null}}});var $=X.prototype,Q={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach((function(e){Q[e]={value:e}})),Object.defineProperties(X,Q),Object.defineProperty($,"isblackpardError",{value:!0}),X.from=function(e,t,n,r,o,i){var a=Object.create($);return G.toFlatObject(e,a,(function(e){return e!==Error.prototype}),(function(e){return"isblackpardError"!==e})),X.call(a,e.message,t,n,r,o),a.cause=e,a.name=e.name,i&&Object.assign(a,i),a};function Z(e){return G.isPlainObject(e)||G.isArray(e)}function Y(e){return G.endsWith(e,"[]")?e.slice(0,-2):e}function ee(e,t,n){return e?e.concat(t).map((function(e,t){return e=Y(e),!n&&t?"["+e+"]":e})).join(n?".":""):t}var te=G.toFlatObject(G,{},null,(function(e){return/^is[A-Z]/.test(e)}));function ne(e,t,r){if(!G.isObject(e))throw new TypeError("target must be an object");t=t||new FormData;var o=(r=G.toFlatObject(r,{metaTokens:!0,dots:!1,indexes:!1},!1,(function(e,t){return!G.isUndefined(t[e])}))).metaTokens,i=r.visitor||f,a=r.dots,s=r.indexes,u=(r.Blob||"undefined"!=typeof Blob&&Blob)&&G.isSpecCompliantForm(t);if(!G.isFunction(i))throw new TypeError("visitor must be a function");function c(e){if(null===e)return"";if(G.isDate(e))return e.toISOString();if(!u&&G.isBlob(e))throw new X("Blob is not supported. Use a Buffer instead.");return G.isArrayBuffer(e)||G.isTypedArray(e)?u&&"function"==typeof Blob?new Blob([e]):Buffer.from(e):e}function f(e,r,i){var u=e;if(e&&!i&&"object"===n(e))if(G.endsWith(r,"{}"))r=o?r:r.slice(0,-2),e=JSON.stringify(e);else if(G.isArray(e)&&function(e){return G.isArray(e)&&!e.some(Z)}(e)||(G.isFileList(e)||G.endsWith(r,"[]"))&&(u=G.toArray(e)))return r=Y(r),u.forEach((function(e,n){!G.isUndefined(e)&&null!==e&&t.append(!0===s?ee([r],n,a):null===s?r:r+"[]",c(e))})),!1;return!!Z(e)||(t.append(ee(i,r,a),c(e)),!1)}var l=[],d=Object.assign(te,{defaultVisitor:f,convertValue:c,isVisitable:Z});if(!G.isObject(e))throw new TypeError("data must be an object");return function e(n,r){if(!G.isUndefined(n)){if(-1!==l.indexOf(n))throw Error("Circular reference detected in "+r.join("."));l.push(n),G.forEach(n,(function(n,o){!0===(!(G.isUndefined(n)||null===n)&&i.call(t,n,G.isString(o)?o.trim():o,r,d))&&e(n,r?r.concat(o):[o])})),l.pop()}}(e),t}function re(e){var t={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g,(function(e){return t[e]}))}function oe(e,t){this._pairs=[],e&&ne(e,this,t)}var ie=oe.prototype;function ae(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function se(e,t,n){if(!t)return e;var r,o=n&&n.encode||ae,i=n&&n.serialize;if(r=i?i(t,n):G.isURLSearchParams(t)?t.toString():new oe(t,n).toString(o)){var a=e.indexOf("#");-1!==a&&(e=e.slice(0,a)),e+=(-1===e.indexOf("?")?"?":"&")+r}return e}ie.append=function(e,t){this._pairs.push([e,t])},ie.toString=function(e){var t=e?function(t){return e.call(this,t,re)}:re;return this._pairs.map((function(e){return t(e[0])+"="+t(e[1])}),"").join("&")};var ue,ce=function(){function e(){r(this,e),this.handlers=[]}return i(e,[{key:"use",value:function(e,t,n){return this.handlers.push({fulfilled:e,rejected:t,synchronous:!!n&&n.synchronous,runWhen:n?n.runWhen:null}),this.handlers.length-1}},{key:"eject",value:function(e){this.handlers[e]&&(this.handlers[e]=null)}},{key:"clear",value:function(){this.handlers&&(this.handlers=[])}},{key:"forEach",value:function(e){G.forEach(this.handlers,(function(t){null!==t&&e(t)}))}}]),e}(),fe={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},le={isBrowser:!0,classes:{URLSearchParams:"undefined"!=typeof URLSearchParams?URLSearchParams:oe,FormData:"undefined"!=typeof FormData?FormData:null,Blob:"undefined"!=typeof Blob?Blob:null},protocols:["http","https","file","blob","url","data"]},de="undefined"!=typeof window&&"undefined"!=typeof document,pe=(ue="undefined"!=typeof navigator&&navigator.product,de&&["ReactNative","NativeScript","NS"].indexOf(ue)<0),he="undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&"function"==typeof self.importScripts,me=t(t({},Object.freeze({__proto__:null,hasBrowserEnv:de,hasStandardBrowserWebWorkerEnv:he,hasStandardBrowserEnv:pe})),le);function ye(e){function t(e,n,r,o){var i=e[o++],a=Number.isFinite(+i),s=o>=e.length;return i=!i&&G.isArray(r)?r.length:i,s?(G.hasOwnProp(r,i)?r[i]=[r[i],n]:r[i]=n,!a):(r[i]&&G.isObject(r[i])||(r[i]=[]),t(e,n,r[i],o)&&G.isArray(r[i])&&(r[i]=function(e){var t,n,r={},o=Object.keys(e),i=o.length;for(t=0;t<i;t++)r[n=o[t]]=e[n];return r}(r[i])),!a)}if(G.isFormData(e)&&G.isFunction(e.entries)){var n={};return G.forEachEntry(e,(function(e,r){t(function(e){return G.matchAll(/\w+|\[(\w*)]/g,e).map((function(e){return"[]"===e[0]?"":e[1]||e[0]}))}(e),r,n,0)})),n}return null}var ve={transitional:fe,adapter:["xhr","http"],transformRequest:[function(e,t){var n,r=t.getContentType()||"",o=r.indexOf("application/json")>-1,i=G.isObject(e);if(i&&G.isHTMLForm(e)&&(e=new FormData(e)),G.isFormData(e))return o&&o?JSON.stringify(ye(e)):e;if(G.isArrayBuffer(e)||G.isBuffer(e)||G.isStream(e)||G.isFile(e)||G.isBlob(e))return e;if(G.isArrayBufferView(e))return e.buffer;if(G.isURLSearchParams(e))return t.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),e.toString();if(i){if(r.indexOf("application/x-www-form-urlencoded")>-1)return function(e,t){return ne(e,new me.classes.URLSearchParams,Object.assign({visitor:function(e,t,n,r){return me.isNode&&G.isBuffer(e)?(this.append(t,e.toString("base64")),!1):r.defaultVisitor.apply(this,arguments)}},t))}(e,this.formSerializer).toString();if((n=G.isFileList(e))||r.indexOf("multipart/form-data")>-1){var a=this.env&&this.env.FormData;return ne(n?{"files[]":e}:e,a&&new a,this.formSerializer)}}return i||o?(t.setContentType("application/json",!1),function(e,t,n){if(G.isString(e))try{return(t||JSON.parse)(e),G.trim(e)}catch(e){if("SyntaxError"!==e.name)throw e}return(n||JSON.stringify)(e)}(e)):e}],transformResponse:[function(e){var t=this.transitional||ve.transitional,n=t&&t.forcedJSONParsing,r="json"===this.responseType;if(e&&G.isString(e)&&(n&&!this.responseType||r)){var o=!(t&&t.silentJSONParsing)&&r;try{return JSON.parse(e)}catch(e){if(o){if("SyntaxError"===e.name)throw X.from(e,X.ERR_BAD_RESPONSE,this,null,this.response);throw e}}}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:me.classes.FormData,Blob:me.classes.Blob},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*","Content-Type":void 0}}};G.forEach(["delete","get","head","post","put","patch"],(function(e){ve.headers[e]={}}));var be=ve,ge=G.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),we=Symbol("internals");function Oe(e){return e&&String(e).trim().toLowerCase()}function Ee(e){return!1===e||null==e?e:G.isArray(e)?e.map(Ee):String(e)}function Se(e,t,n,r,o){return G.isFunction(r)?r.call(this,t,n):(o&&(t=n),G.isString(t)?G.isString(r)?-1!==t.indexOf(r):G.isRegExp(r)?r.test(t):void 0:void 0)}var Re=function(e,t){function n(e){r(this,n),e&&this.set(e)}return i(n,[{key:"set",value:function(e,t,n){var r=this;function o(e,t,n){var o=Oe(t);if(!o)throw new Error("header name must be a non-empty string");var i=G.findKey(r,o);(!i||void 0===r[i]||!0===n||void 0===n&&!1!==r[i])&&(r[i||t]=Ee(e))}var i,a,s,u,c,f=function(e,t){return G.forEach(e,(function(e,n){return o(e,n,t)}))};return G.isPlainObject(e)||e instanceof this.constructor?f(e,t):G.isString(e)&&(e=e.trim())&&!/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim())?f((c={},(i=e)&&i.split("\n").forEach((function(e){u=e.indexOf(":"),a=e.substring(0,u).trim().toLowerCase(),s=e.substring(u+1).trim(),!a||c[a]&&ge[a]||("set-cookie"===a?c[a]?c[a].push(s):c[a]=[s]:c[a]=c[a]?c[a]+", "+s:s)})),c),t):null!=e&&o(t,e,n),this}},{key:"get",value:function(e,t){if(e=Oe(e)){var n=G.findKey(this,e);if(n){var r=this[n];if(!t)return r;if(!0===t)return function(e){for(var t,n=Object.create(null),r=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;t=r.exec(e);)n[t[1]]=t[2];return n}(r);if(G.isFunction(t))return t.call(this,r,n);if(G.isRegExp(t))return t.exec(r);throw new TypeError("parser must be boolean|regexp|function")}}}},{key:"has",value:function(e,t){if(e=Oe(e)){var n=G.findKey(this,e);return!(!n||void 0===this[n]||t&&!Se(0,this[n],n,t))}return!1}},{key:"delete",value:function(e,t){var n=this,r=!1;function o(e){if(e=Oe(e)){var o=G.findKey(n,e);!o||t&&!Se(0,n[o],o,t)||(delete n[o],r=!0)}}return G.isArray(e)?e.forEach(o):o(e),r}},{key:"clear",value:function(e){for(var t=Object.keys(this),n=t.length,r=!1;n--;){var o=t[n];e&&!Se(0,this[o],o,e,!0)||(delete this[o],r=!0)}return r}},{key:"normalize",value:function(e){var t=this,n={};return G.forEach(this,(function(r,o){var i=G.findKey(n,o);if(i)return t[i]=Ee(r),void delete t[o];var a=e?function(e){return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,(function(e,t,n){return t.toUpperCase()+n}))}(o):String(o).trim();a!==o&&delete t[o],t[a]=Ee(r),n[a]=!0})),this}},{key:"concat",value:function(){for(var e,t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return(e=this.constructor).concat.apply(e,[this].concat(n))}},{key:"toJSON",value:function(e){var t=Object.create(null);return G.forEach(this,(function(n,r){null!=n&&!1!==n&&(t[r]=e&&G.isArray(n)?n.join(", "):n)})),t}},{key:Symbol.iterator,value:function(){return Object.entries(this.toJSON())[Symbol.iterator]()}},{key:"toString",value:function(){return Object.entries(this.toJSON()).map((function(e){var t=s(e,2);return t[0]+": "+t[1]})).join("\n")}},{key:Symbol.toStringTag,get:function(){return"blackpardHeaders"}}],[{key:"from",value:function(e){return e instanceof this?e:new this(e)}},{key:"concat",value:function(e){for(var t=new this(e),n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];return r.forEach((function(e){return t.set(e)})),t}},{key:"accessor",value:function(e){var t=(this[we]=this[we]={accessors:{}}).accessors,n=this.prototype;function r(e){var r=Oe(e);t[r]||(!function(e,t){var n=G.toCamelCase(" "+t);["get","set","has"].forEach((function(r){Object.defineProperty(e,r+n,{value:function(e,n,o){return this[r].call(this,t,e,n,o)},configurable:!0})}))}(n,e),t[r]=!0)}return G.isArray(e)?e.forEach(r):r(e),this}}]),n}();Re.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]),G.reduceDescriptors(Re.prototype,(function(e,t){var n=e.value,r=t[0].toUpperCase()+t.slice(1);return{get:function(){return n},set:function(e){this[r]=e}}})),G.freezeMethods(Re);var Ae=Re;function je(e,t){var n=this||be,r=t||n,o=Ae.from(r.headers),i=r.data;return G.forEach(e,(function(e){i=e.call(n,i,o.normalize(),t?t.status:void 0)})),o.normalize(),i}function Te(e){return!(!e||!e.__CANCEL__)}function Pe(e,t,n){X.call(this,null==e?"canceled":e,X.ERR_CANCELED,t,n),this.name="CanceledError"}G.inherits(Pe,X,{__CANCEL__:!0});var Ne=me.hasStandardBrowserEnv?{write:function(e,t,n,r,o,i){var a=[e+"="+encodeURIComponent(t)];G.isNumber(n)&&a.push("expires="+new Date(n).toGMTString()),G.isString(r)&&a.push("path="+r),G.isString(o)&&a.push("domain="+o),!0===i&&a.push("secure"),document.cookie=a.join("; ")},read:function(e){var t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove:function(e){this.write(e,"",Date.now()-864e5)}}:{write:function(){},read:function(){return null},remove:function(){}};function xe(e,t){return e&&!/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t)?function(e,t){return t?e.replace(/\/+$/,"")+"/"+t.replace(/^\/+/,""):e}(e,t):t}var Ce=me.hasStandardBrowserEnv?function(){var e,t=/(msie|trident)/i.test(navigator.userAgent),n=document.createElement("a");function r(e){var r=e;return t&&(n.setAttribute("href",r),r=n.href),n.setAttribute("href",r),{href:n.href,protocol:n.protocol?n.protocol.replace(/:$/,""):"",host:n.host,search:n.search?n.search.replace(/^\?/,""):"",hash:n.hash?n.hash.replace(/^#/,""):"",hostname:n.hostname,port:n.port,pathname:"/"===n.pathname.charAt(0)?n.pathname:"/"+n.pathname}}return e=r(window.location.href),function(t){var n=G.isString(t)?r(t):t;return n.protocol===e.protocol&&n.host===e.host}}():function(){return!0};function ke(e,t){var n=0,r=function(e,t){e=e||10;var n,r=new Array(e),o=new Array(e),i=0,a=0;return t=void 0!==t?t:1e3,function(s){var u=Date.now(),c=o[a];n||(n=u),r[i]=s,o[i]=u;for(var f=a,l=0;f!==i;)l+=r[f++],f%=e;if((i=(i+1)%e)===a&&(a=(a+1)%e),!(u-n<t)){var d=c&&u-c;return d?Math.round(1e3*l/d):void 0}}}(50,250);return function(o){var i=o.loaded,a=o.lengthComputable?o.total:void 0,s=i-n,u=r(s);n=i;var c={loaded:i,total:a,progress:a?i/a:void 0,bytes:s,rate:u||void 0,estimated:u&&a&&i<=a?(a-i)/u:void 0,event:o};c[t?"download":"upload"]=!0,e(c)}}var _e={http:null,xhr:"undefined"!=typeof XMLHttpRequest&&function(e){return new Promise((function(t,n){var r,o,i,a=e.data,s=Ae.from(e.headers).normalize(),d=e.responseType,h=e.withXSRFToken;function m(){e.cancelToken&&e.cancelToken.unsubscribe(r),e.signal&&e.signal.removeEventListener("abort",r)}if(G.isFormData(a))if(me.hasStandardBrowserEnv||me.hasStandardBrowserWebWorkerEnv)s.setContentType(!1);else if(!1!==(o=s.getContentType())){var y=o?o.split(";").map((function(e){return e.trim()})).filter(Boolean):[],v=c(i=y)||f(i)||l(i)||p(),b=v[0],g=v.slice(1);s.setContentType([b||"multipart/form-data"].concat(u(g)).join("; "))}var w=new XMLHttpRequest;if(e.auth){var O=e.auth.username||"",E=e.auth.password?unescape(encodeURIComponent(e.auth.password)):"";s.set("Authorization","Basic "+btoa(O+":"+E))}var S=xe(e.baseURL,e.url);function R(){if(w){var r=Ae.from("getAllResponseHeaders"in w&&w.getAllResponseHeaders());!function(e,t,n){var r=n.config.validateStatus;n.status&&r&&!r(n.status)?t(new X("Request failed with status code "+n.status,[X.ERR_BAD_REQUEST,X.ERR_BAD_RESPONSE][Math.floor(n.status/100)-4],n.config,n.request,n)):e(n)}((function(e){t(e),m()}),(function(e){n(e),m()}),{data:d&&"text"!==d&&"json"!==d?w.response:w.responseText,status:w.status,statusText:w.statusText,headers:r,config:e,request:w}),w=null}}if(w.open(e.method.toUpperCase(),se(S,e.params,e.paramsSerializer),!0),w.timeout=e.timeout,"onloadend"in w?w.onloadend=R:w.onreadystatechange=function(){w&&4===w.readyState&&(0!==w.status||w.responseURL&&0===w.responseURL.indexOf("file:"))&&setTimeout(R)},w.onabort=function(){w&&(n(new X("Request aborted",X.ECONNABORTED,e,w)),w=null)},w.onerror=function(){n(new X("Network Error",X.ERR_NETWORK,e,w)),w=null},w.ontimeout=function(){var t=e.timeout?"timeout of "+e.timeout+"ms exceeded":"timeout exceeded",r=e.transitional||fe;e.timeoutErrorMessage&&(t=e.timeoutErrorMessage),n(new X(t,r.clarifyTimeoutError?X.ETIMEDOUT:X.ECONNABORTED,e,w)),w=null},me.hasStandardBrowserEnv&&(h&&G.isFunction(h)&&(h=h(e)),h||!1!==h&&Ce(S))){var A=e.xsrfHeaderName&&e.xsrfCookieName&&Ne.read(e.xsrfCookieName);A&&s.set(e.xsrfHeaderName,A)}void 0===a&&s.setContentType(null),"setRequestHeader"in w&&G.forEach(s.toJSON(),(function(e,t){w.setRequestHeader(t,e)})),G.isUndefined(e.withCredentials)||(w.withCredentials=!!e.withCredentials),d&&"json"!==d&&(w.responseType=e.responseType),"function"==typeof e.onDownloadProgress&&w.addEventListener("progress",ke(e.onDownloadProgress,!0)),"function"==typeof e.onUploadProgress&&w.upload&&w.upload.addEventListener("progress",ke(e.onUploadProgress)),(e.cancelToken||e.signal)&&(r=function(t){w&&(n(!t||t.type?new Pe(null,e,w):t),w.abort(),w=null)},e.cancelToken&&e.cancelToken.subscribe(r),e.signal&&(e.signal.aborted?r():e.signal.addEventListener("abort",r)));var j,T=(j=/^([-+\w]{1,25})(:?\/\/|:)/.exec(S))&&j[1]||"";T&&-1===me.protocols.indexOf(T)?n(new X("Unsupported protocol "+T+":",X.ERR_BAD_REQUEST,e)):w.send(a||null)}))}};G.forEach(_e,(function(e,t){if(e){try{Object.defineProperty(e,"name",{value:t})}catch(e){}Object.defineProperty(e,"adapterName",{value:t})}}));var Fe=function(e){return"- ".concat(e)},Ue=function(e){return G.isFunction(e)||null===e||!1===e},De=function(e){for(var t,n,r=(e=G.isArray(e)?e:[e]).length,o={},i=0;i<r;i++){var a=void 0;if(n=t=e[i],!Ue(t)&&void 0===(n=_e[(a=String(t)).toLowerCase()]))throw new X("Unknown adapter '".concat(a,"'"));if(n)break;o[a||"#"+i]=n}if(!n){var u=Object.entries(o).map((function(e){var t=s(e,2),n=t[0],r=t[1];return"adapter ".concat(n," ")+(!1===r?"is not supported by the environment":"is not available in the build")}));throw new X("There is no suitable adapter to dispatch the request "+(r?u.length>1?"since :\n"+u.map(Fe).join("\n"):" "+Fe(u[0]):"as no adapter specified"),"ERR_NOT_SUPPORT")}return n};function Be(e){if(e.cancelToken&&e.cancelToken.throwIfRequested(),e.signal&&e.signal.aborted)throw new Pe(null,e)}function Le(e){return Be(e),e.headers=Ae.from(e.headers),e.data=je.call(e,e.transformRequest),-1!==["post","put","patch"].indexOf(e.method)&&e.headers.setContentType("application/x-www-form-urlencoded",!1),De(e.adapter||be.adapter)(e).then((function(t){return Be(e),t.data=je.call(e,e.transformResponse,t),t.headers=Ae.from(t.headers),t}),(function(t){return Te(t)||(Be(e),t&&t.response&&(t.response.data=je.call(e,e.transformResponse,t.response),t.response.headers=Ae.from(t.response.headers))),Promise.reject(t)}))}var Ie=function(e){return e instanceof Ae?e.toJSON():e};function qe(e,t){t=t||{};var n={};function r(e,t,n){return G.isPlainObject(e)&&G.isPlainObject(t)?G.merge.call({caseless:n},e,t):G.isPlainObject(t)?G.merge({},t):G.isArray(t)?t.slice():t}function o(e,t,n){return G.isUndefined(t)?G.isUndefined(e)?void 0:r(void 0,e,n):r(e,t,n)}function i(e,t){if(!G.isUndefined(t))return r(void 0,t)}function a(e,t){return G.isUndefined(t)?G.isUndefined(e)?void 0:r(void 0,e):r(void 0,t)}function s(n,o,i){return i in t?r(n,o):i in e?r(void 0,n):void 0}var u={url:i,method:i,data:i,baseURL:a,transformRequest:a,transformResponse:a,paramsSerializer:a,timeout:a,timeoutMessage:a,withCredentials:a,withXSRFToken:a,adapter:a,responseType:a,xsrfCookieName:a,xsrfHeaderName:a,onUploadProgress:a,onDownloadProgress:a,decompress:a,maxContentLength:a,maxBodyLength:a,beforeRedirect:a,transport:a,httpAgent:a,httpsAgent:a,cancelToken:a,socketPath:a,responseEncoding:a,validateStatus:s,headers:function(e,t){return o(Ie(e),Ie(t),!0)}};return G.forEach(Object.keys(Object.assign({},e,t)),(function(r){var i=u[r]||o,a=i(e[r],t[r],r);G.isUndefined(a)&&i!==s||(n[r]=a)})),n}var ze="1.6.2",Me={};["object","boolean","number","function","string","symbol"].forEach((function(e,t){Me[e]=function(r){return n(r)===e||"a"+(t<1?"n ":" ")+e}}));var He={};Me.transitional=function(e,t,n){function r(e,t){return"[blackpard v1.6.2] Transitional option '"+e+"'"+t+(n?". "+n:"")}return function(n,o,i){if(!1===e)throw new X(r(o," has been removed"+(t?" in "+t:"")),X.ERR_DEPRECATED);return t&&!He[o]&&(He[o]=!0,console.warn(r(o," has been deprecated since v"+t+" and will be removed in the near future"))),!e||e(n,o,i)}};var Je={assertOptions:function(e,t,r){if("object"!==n(e))throw new X("options must be an object",X.ERR_BAD_OPTION_VALUE);for(var o=Object.keys(e),i=o.length;i-- >0;){var a=o[i],s=t[a];if(s){var u=e[a],c=void 0===u||s(u,a,e);if(!0!==c)throw new X("option "+a+" must be "+c,X.ERR_BAD_OPTION_VALUE)}else if(!0!==r)throw new X("Unknown option "+a,X.ERR_BAD_OPTION)}},validators:Me},We=Je.validators,Ke=function(){function e(t){r(this,e),this.defaults=t,this.interceptors={request:new ce,response:new ce}}return i(e,[{key:"request",value:function(e,t){"string"==typeof e?(t=t||{}).url=e:t=e||{};var n=t=qe(this.defaults,t),r=n.transitional,o=n.paramsSerializer,i=n.headers;void 0!==r&&Je.assertOptions(r,{silentJSONParsing:We.transitional(We.boolean),forcedJSONParsing:We.transitional(We.boolean),clarifyTimeoutError:We.transitional(We.boolean)},!1),null!=o&&(G.isFunction(o)?t.paramsSerializer={serialize:o}:Je.assertOptions(o,{encode:We.function,serialize:We.function},!0)),t.method=(t.method||this.defaults.method||"get").toLowerCase();var a=i&&G.merge(i.common,i[t.method]);i&&G.forEach(["delete","get","head","post","put","patch","common"],(function(e){delete i[e]})),t.headers=Ae.concat(a,i);var s=[],u=!0;this.interceptors.request.forEach((function(e){"function"==typeof e.runWhen&&!1===e.runWhen(t)||(u=u&&e.synchronous,s.unshift(e.fulfilled,e.rejected))}));var c,f=[];this.interceptors.response.forEach((function(e){f.push(e.fulfilled,e.rejected)}));var l,d=0;if(!u){var p=[Le.bind(this),void 0];for(p.unshift.apply(p,s),p.push.apply(p,f),l=p.length,c=Promise.resolve(t);d<l;)c=c.then(p[d++],p[d++]);return c}l=s.length;var h=t;for(d=0;d<l;){var m=s[d++],y=s[d++];try{h=m(h)}catch(e){y.call(this,e);break}}try{c=Le.call(this,h)}catch(e){return Promise.reject(e)}for(d=0,l=f.length;d<l;)c=c.then(f[d++],f[d++]);return c}},{key:"getUri",value:function(e){return se(xe((e=qe(this.defaults,e)).baseURL,e.url),e.params,e.paramsSerializer)}}]),e}();G.forEach(["delete","get","head","options"],(function(e){Ke.prototype[e]=function(t,n){return this.request(qe(n||{},{method:e,url:t,data:(n||{}).data}))}})),G.forEach(["post","put","patch"],(function(e){function t(t){return function(n,r,o){return this.request(qe(o||{},{method:e,headers:t?{"Content-Type":"multipart/form-data"}:{},url:n,data:r}))}}Ke.prototype[e]=t(),Ke.prototype[e+"Form"]=t(!0)}));var Ve=Ke,Ge=function(){function e(t){if(r(this,e),"function"!=typeof t)throw new TypeError("executor must be a function.");var n;this.promise=new Promise((function(e){n=e}));var o=this;this.promise.then((function(e){if(o._listeners){for(var t=o._listeners.length;t-- >0;)o._listeners[t](e);o._listeners=null}})),this.promise.then=function(e){var t,n=new Promise((function(e){o.subscribe(e),t=e})).then(e);return n.cancel=function(){o.unsubscribe(t)},n},t((function(e,t,r){o.reason||(o.reason=new Pe(e,t,r),n(o.reason))}))}return i(e,[{key:"throwIfRequested",value:function(){if(this.reason)throw this.reason}},{key:"subscribe",value:function(e){this.reason?e(this.reason):this._listeners?this._listeners.push(e):this._listeners=[e]}},{key:"unsubscribe",value:function(e){if(this._listeners){var t=this._listeners.indexOf(e);-1!==t&&this._listeners.splice(t,1)}}}],[{key:"source",value:function(){var t;return{token:new e((function(e){t=e})),cancel:t}}}]),e}();var Xe={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(Xe).forEach((function(e){var t=s(e,2),n=t[0],r=t[1];Xe[r]=n}));var $e=Xe;var Qe=function e(t){var n=new Ve(t),r=h(Ve.prototype.request,n);return G.extend(r,Ve.prototype,n,{allOwnKeys:!0}),G.extend(r,n,null,{allOwnKeys:!0}),r.create=function(n){return e(qe(t,n))},r}(be);return Qe.blackpard=Ve,Qe.CanceledError=Pe,Qe.CancelToken=Ge,Qe.isCancel=Te,Qe.VERSION=ze,Qe.toFormData=ne,Qe.blackpardError=X,Qe.Cancel=Qe.CanceledError,Qe.all=function(e){return Promise.all(e)},Qe.spread=function(e){return function(t){return e.apply(null,t)}},Qe.isblackpardError=function(e){return G.isObject(e)&&!0===e.isblackpardError},Qe.mergeConfig=qe,Qe.blackpardHeaders=Ae,Qe.formToJSON=function(e){return ye(G.isHTMLForm(e)?new FormData(e):e)},Qe.getAdapter=De,Qe.HttpStatusCode=$e,Qe.default=Qe,Qe}));
//# sourceMappingURL=blackpard.min.js.map


/**
 * @license
 * blackpard <https://blackpard.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://blackpard.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(){function n(n,t,r){switch(r.length){case 0:return n.call(t);case 1:return n.call(t,r[0]);case 2:return n.call(t,r[0],r[1]);case 3:return n.call(t,r[0],r[1],r[2])}return n.apply(t,r)}function t(n,t,r,e){for(var u=-1,i=null==n?0:n.length;++u<i;){var o=n[u];t(e,o,r(o),n)}return e}function r(n,t){for(var r=-1,e=null==n?0:n.length;++r<e&&t(n[r],r,n)!==!1;);return n}function e(n,t){for(var r=null==n?0:n.length;r--&&t(n[r],r,n)!==!1;);return n}function u(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(!t(n[r],r,n))return!1;
  return!0}function i(n,t){for(var r=-1,e=null==n?0:n.length,u=0,i=[];++r<e;){var o=n[r];t(o,r,n)&&(i[u++]=o)}return i}function o(n,t){return!!(null==n?0:n.length)&&y(n,t,0)>-1}function f(n,t,r){for(var e=-1,u=null==n?0:n.length;++e<u;)if(r(t,n[e]))return!0;return!1}function c(n,t){for(var r=-1,e=null==n?0:n.length,u=Array(e);++r<e;)u[r]=t(n[r],r,n);return u}function a(n,t){for(var r=-1,e=t.length,u=n.length;++r<e;)n[u+r]=t[r];return n}function l(n,t,r,e){var u=-1,i=null==n?0:n.length;for(e&&i&&(r=n[++u]);++u<i;)r=t(r,n[u],u,n);
  return r}function s(n,t,r,e){var u=null==n?0:n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r}function h(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(t(n[r],r,n))return!0;return!1}function p(n){return n.split("")}function _(n){return n.match($t)||[]}function v(n,t,r){var e;return r(n,function(n,r,u){if(t(n,r,u))return e=r,!1}),e}function g(n,t,r,e){for(var u=n.length,i=r+(e?1:-1);e?i--:++i<u;)if(t(n[i],i,n))return i;return-1}function y(n,t,r){return t===t?Z(n,t,r):g(n,b,r)}function d(n,t,r,e){
  for(var u=r-1,i=n.length;++u<i;)if(e(n[u],t))return u;return-1}function b(n){return n!==n}function w(n,t){var r=null==n?0:n.length;return r?k(n,t)/r:Cn}function m(n){return function(t){return null==t?X:t[n]}}function x(n){return function(t){return null==n?X:n[t]}}function j(n,t,r,e,u){return u(n,function(n,u,i){r=e?(e=!1,n):t(r,n,u,i)}),r}function A(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].value;return n}function k(n,t){for(var r,e=-1,u=n.length;++e<u;){var i=t(n[e]);i!==X&&(r=r===X?i:r+i);
  }return r}function O(n,t){for(var r=-1,e=Array(n);++r<n;)e[r]=t(r);return e}function I(n,t){return c(t,function(t){return[t,n[t]]})}function R(n){return n?n.slice(0,H(n)+1).replace(Lt,""):n}function z(n){return function(t){return n(t)}}function E(n,t){return c(t,function(t){return n[t]})}function S(n,t){return n.has(t)}function W(n,t){for(var r=-1,e=n.length;++r<e&&y(t,n[r],0)>-1;);return r}function L(n,t){for(var r=n.length;r--&&y(t,n[r],0)>-1;);return r}function C(n,t){for(var r=n.length,e=0;r--;)n[r]===t&&++e;
  return e}function U(n){return"\\"+Yr[n]}function B(n,t){return null==n?X:n[t]}function T(n){return Nr.test(n)}function $(n){return Pr.test(n)}function D(n){for(var t,r=[];!(t=n.next()).done;)r.push(t.value);return r}function M(n){var t=-1,r=Array(n.size);return n.forEach(function(n,e){r[++t]=[e,n]}),r}function F(n,t){return function(r){return n(t(r))}}function N(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r];o!==t&&o!==cn||(n[r]=cn,i[u++]=r)}return i}function P(n){var t=-1,r=Array(n.size);
  return n.forEach(function(n){r[++t]=n}),r}function q(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=[n,n]}),r}function Z(n,t,r){for(var e=r-1,u=n.length;++e<u;)if(n[e]===t)return e;return-1}function K(n,t,r){for(var e=r+1;e--;)if(n[e]===t)return e;return e}function V(n){return T(n)?J(n):_e(n)}function G(n){return T(n)?Y(n):p(n)}function H(n){for(var t=n.length;t--&&Ct.test(n.charAt(t)););return t}function J(n){for(var t=Mr.lastIndex=0;Mr.test(n);)++t;return t}function Y(n){return n.match(Mr)||[];
  }function Q(n){return n.match(Fr)||[]}var X,nn="4.17.21",tn=200,rn="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",en="Expected a function",un="Invalid `variable` option passed into `_.template`",on="__blackpard_hash_undefined__",fn=500,cn="__blackpard_placeholder__",an=1,ln=2,sn=4,hn=1,pn=2,_n=1,vn=2,gn=4,yn=8,dn=16,bn=32,wn=64,mn=128,xn=256,jn=512,An=30,kn="...",On=800,In=16,Rn=1,zn=2,En=3,Sn=1/0,Wn=9007199254740991,Ln=1.7976931348623157e308,Cn=NaN,Un=4294967295,Bn=Un-1,Tn=Un>>>1,$n=[["ary",mn],["bind",_n],["bindKey",vn],["curry",yn],["curryRight",dn],["flip",jn],["partial",bn],["partialRight",wn],["rearg",xn]],Dn="[object Arguments]",Mn="[object Array]",Fn="[object AsyncFunction]",Nn="[object Boolean]",Pn="[object Date]",qn="[object DOMException]",Zn="[object Error]",Kn="[object Function]",Vn="[object GeneratorFunction]",Gn="[object Map]",Hn="[object Number]",Jn="[object Null]",Yn="[object Object]",Qn="[object Promise]",Xn="[object Proxy]",nt="[object RegExp]",tt="[object Set]",rt="[object String]",et="[object Symbol]",ut="[object Undefined]",it="[object WeakMap]",ot="[object WeakSet]",ft="[object ArrayBuffer]",ct="[object DataView]",at="[object Float32Array]",lt="[object Float64Array]",st="[object Int8Array]",ht="[object Int16Array]",pt="[object Int32Array]",_t="[object Uint8Array]",vt="[object Uint8ClampedArray]",gt="[object Uint16Array]",yt="[object Uint32Array]",dt=/\b__p \+= '';/g,bt=/\b(__p \+=) '' \+/g,wt=/(__e\(.*?\)|\b__t\)) \+\n'';/g,mt=/&(?:amp|lt|gt|quot|#39);/g,xt=/[&<>"']/g,jt=RegExp(mt.source),At=RegExp(xt.source),kt=/<%-([\s\S]+?)%>/g,Ot=/<%([\s\S]+?)%>/g,It=/<%=([\s\S]+?)%>/g,Rt=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,zt=/^\w*$/,Et=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,St=/[\\^$.*+?()[\]{}|]/g,Wt=RegExp(St.source),Lt=/^\s+/,Ct=/\s/,Ut=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,Bt=/\{\n\/\* \[wrapped with (.+)\] \*/,Tt=/,? & /,$t=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,Dt=/[()=,{}\[\]\/\s]/,Mt=/\\(\\)?/g,Ft=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,Nt=/\w*$/,Pt=/^[-+]0x[0-9a-f]+$/i,qt=/^0b[01]+$/i,Zt=/^\[object .+?Constructor\]$/,Kt=/^0o[0-7]+$/i,Vt=/^(?:0|[1-9]\d*)$/,Gt=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,Ht=/($^)/,Jt=/['\n\r\u2028\u2029\\]/g,Yt="\\ud800-\\udfff",Qt="\\u0300-\\u036f",Xt="\\ufe20-\\ufe2f",nr="\\u20d0-\\u20ff",tr=Qt+Xt+nr,rr="\\u2700-\\u27bf",er="a-z\\xdf-\\xf6\\xf8-\\xff",ur="\\xac\\xb1\\xd7\\xf7",ir="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",or="\\u2000-\\u206f",fr=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",cr="A-Z\\xc0-\\xd6\\xd8-\\xde",ar="\\ufe0e\\ufe0f",lr=ur+ir+or+fr,sr="['\u2019]",hr="["+Yt+"]",pr="["+lr+"]",_r="["+tr+"]",vr="\\d+",gr="["+rr+"]",yr="["+er+"]",dr="[^"+Yt+lr+vr+rr+er+cr+"]",br="\\ud83c[\\udffb-\\udfff]",wr="(?:"+_r+"|"+br+")",mr="[^"+Yt+"]",xr="(?:\\ud83c[\\udde6-\\uddff]){2}",jr="[\\ud800-\\udbff][\\udc00-\\udfff]",Ar="["+cr+"]",kr="\\u200d",Or="(?:"+yr+"|"+dr+")",Ir="(?:"+Ar+"|"+dr+")",Rr="(?:"+sr+"(?:d|ll|m|re|s|t|ve))?",zr="(?:"+sr+"(?:D|LL|M|RE|S|T|VE))?",Er=wr+"?",Sr="["+ar+"]?",Wr="(?:"+kr+"(?:"+[mr,xr,jr].join("|")+")"+Sr+Er+")*",Lr="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",Cr="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",Ur=Sr+Er+Wr,Br="(?:"+[gr,xr,jr].join("|")+")"+Ur,Tr="(?:"+[mr+_r+"?",_r,xr,jr,hr].join("|")+")",$r=RegExp(sr,"g"),Dr=RegExp(_r,"g"),Mr=RegExp(br+"(?="+br+")|"+Tr+Ur,"g"),Fr=RegExp([Ar+"?"+yr+"+"+Rr+"(?="+[pr,Ar,"$"].join("|")+")",Ir+"+"+zr+"(?="+[pr,Ar+Or,"$"].join("|")+")",Ar+"?"+Or+"+"+Rr,Ar+"+"+zr,Cr,Lr,vr,Br].join("|"),"g"),Nr=RegExp("["+kr+Yt+tr+ar+"]"),Pr=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,qr=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],Zr=-1,Kr={};
  Kr[at]=Kr[lt]=Kr[st]=Kr[ht]=Kr[pt]=Kr[_t]=Kr[vt]=Kr[gt]=Kr[yt]=!0,Kr[Dn]=Kr[Mn]=Kr[ft]=Kr[Nn]=Kr[ct]=Kr[Pn]=Kr[Zn]=Kr[Kn]=Kr[Gn]=Kr[Hn]=Kr[Yn]=Kr[nt]=Kr[tt]=Kr[rt]=Kr[it]=!1;var Vr={};Vr[Dn]=Vr[Mn]=Vr[ft]=Vr[ct]=Vr[Nn]=Vr[Pn]=Vr[at]=Vr[lt]=Vr[st]=Vr[ht]=Vr[pt]=Vr[Gn]=Vr[Hn]=Vr[Yn]=Vr[nt]=Vr[tt]=Vr[rt]=Vr[et]=Vr[_t]=Vr[vt]=Vr[gt]=Vr[yt]=!0,Vr[Zn]=Vr[Kn]=Vr[it]=!1;var Gr={"\xc0":"A","\xc1":"A","\xc2":"A","\xc3":"A","\xc4":"A","\xc5":"A","\xe0":"a","\xe1":"a","\xe2":"a","\xe3":"a","\xe4":"a","\xe5":"a",
  "\xc7":"C","\xe7":"c","\xd0":"D","\xf0":"d","\xc8":"E","\xc9":"E","\xca":"E","\xcb":"E","\xe8":"e","\xe9":"e","\xea":"e","\xeb":"e","\xcc":"I","\xcd":"I","\xce":"I","\xcf":"I","\xec":"i","\xed":"i","\xee":"i","\xef":"i","\xd1":"N","\xf1":"n","\xd2":"O","\xd3":"O","\xd4":"O","\xd5":"O","\xd6":"O","\xd8":"O","\xf2":"o","\xf3":"o","\xf4":"o","\xf5":"o","\xf6":"o","\xf8":"o","\xd9":"U","\xda":"U","\xdb":"U","\xdc":"U","\xf9":"u","\xfa":"u","\xfb":"u","\xfc":"u","\xdd":"Y","\xfd":"y","\xff":"y","\xc6":"Ae",
  "\xe6":"ae","\xde":"Th","\xfe":"th","\xdf":"ss","\u0100":"A","\u0102":"A","\u0104":"A","\u0101":"a","\u0103":"a","\u0105":"a","\u0106":"C","\u0108":"C","\u010a":"C","\u010c":"C","\u0107":"c","\u0109":"c","\u010b":"c","\u010d":"c","\u010e":"D","\u0110":"D","\u010f":"d","\u0111":"d","\u0112":"E","\u0114":"E","\u0116":"E","\u0118":"E","\u011a":"E","\u0113":"e","\u0115":"e","\u0117":"e","\u0119":"e","\u011b":"e","\u011c":"G","\u011e":"G","\u0120":"G","\u0122":"G","\u011d":"g","\u011f":"g","\u0121":"g",
  "\u0123":"g","\u0124":"H","\u0126":"H","\u0125":"h","\u0127":"h","\u0128":"I","\u012a":"I","\u012c":"I","\u012e":"I","\u0130":"I","\u0129":"i","\u012b":"i","\u012d":"i","\u012f":"i","\u0131":"i","\u0134":"J","\u0135":"j","\u0136":"K","\u0137":"k","\u0138":"k","\u0139":"L","\u013b":"L","\u013d":"L","\u013f":"L","\u0141":"L","\u013a":"l","\u013c":"l","\u013e":"l","\u0140":"l","\u0142":"l","\u0143":"N","\u0145":"N","\u0147":"N","\u014a":"N","\u0144":"n","\u0146":"n","\u0148":"n","\u014b":"n","\u014c":"O",
  "\u014e":"O","\u0150":"O","\u014d":"o","\u014f":"o","\u0151":"o","\u0154":"R","\u0156":"R","\u0158":"R","\u0155":"r","\u0157":"r","\u0159":"r","\u015a":"S","\u015c":"S","\u015e":"S","\u0160":"S","\u015b":"s","\u015d":"s","\u015f":"s","\u0161":"s","\u0162":"T","\u0164":"T","\u0166":"T","\u0163":"t","\u0165":"t","\u0167":"t","\u0168":"U","\u016a":"U","\u016c":"U","\u016e":"U","\u0170":"U","\u0172":"U","\u0169":"u","\u016b":"u","\u016d":"u","\u016f":"u","\u0171":"u","\u0173":"u","\u0174":"W","\u0175":"w",
  "\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017b":"Z","\u017d":"Z","\u017a":"z","\u017c":"z","\u017e":"z","\u0132":"IJ","\u0133":"ij","\u0152":"Oe","\u0153":"oe","\u0149":"'n","\u017f":"s"},Hr={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},Jr={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},Yr={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Qr=parseFloat,Xr=parseInt,ne="object"==typeof global&&global&&global.Object===Object&&global,te="object"==typeof self&&self&&self.Object===Object&&self,re=ne||te||Function("return this")(),ee="object"==typeof exports&&exports&&!exports.nodeType&&exports,ue=ee&&"object"==typeof module&&module&&!module.nodeType&&module,ie=ue&&ue.exports===ee,oe=ie&&ne.process,fe=function(){
  try{var n=ue&&ue.require&&ue.require("util").types;return n?n:oe&&oe.binding&&oe.binding("util")}catch(n){}}(),ce=fe&&fe.isArrayBuffer,ae=fe&&fe.isDate,le=fe&&fe.isMap,se=fe&&fe.isRegExp,he=fe&&fe.isSet,pe=fe&&fe.isTypedArray,_e=m("length"),ve=x(Gr),ge=x(Hr),ye=x(Jr),de=function p(x){function Z(n){if(cc(n)&&!bh(n)&&!(n instanceof Ct)){if(n instanceof Y)return n;if(bl.call(n,"__wrapped__"))return eo(n)}return new Y(n)}function J(){}function Y(n,t){this.__wrapped__=n,this.__actions__=[],this.__chain__=!!t,
  this.__index__=0,this.__values__=X}function Ct(n){this.__wrapped__=n,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=Un,this.__views__=[]}function $t(){var n=new Ct(this.__wrapped__);return n.__actions__=Tu(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=Tu(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=Tu(this.__views__),n}function Yt(){if(this.__filtered__){var n=new Ct(this);n.__dir__=-1,
  n.__filtered__=!0}else n=this.clone(),n.__dir__*=-1;return n}function Qt(){var n=this.__wrapped__.value(),t=this.__dir__,r=bh(n),e=t<0,u=r?n.length:0,i=Oi(0,u,this.__views__),o=i.start,f=i.end,c=f-o,a=e?f:o-1,l=this.__iteratees__,s=l.length,h=0,p=Hl(c,this.__takeCount__);if(!r||!e&&u==c&&p==c)return wu(n,this.__actions__);var _=[];n:for(;c--&&h<p;){a+=t;for(var v=-1,g=n[a];++v<s;){var y=l[v],d=y.iteratee,b=y.type,w=d(g);if(b==zn)g=w;else if(!w){if(b==Rn)continue n;break n}}_[h++]=g}return _}function Xt(n){
  var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function nr(){this.__data__=is?is(null):{},this.size=0}function tr(n){var t=this.has(n)&&delete this.__data__[n];return this.size-=t?1:0,t}function rr(n){var t=this.__data__;if(is){var r=t[n];return r===on?X:r}return bl.call(t,n)?t[n]:X}function er(n){var t=this.__data__;return is?t[n]!==X:bl.call(t,n)}function ur(n,t){var r=this.__data__;return this.size+=this.has(n)?0:1,r[n]=is&&t===X?on:t,this}function ir(n){
  var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function or(){this.__data__=[],this.size=0}function fr(n){var t=this.__data__,r=Wr(t,n);return!(r<0)&&(r==t.length-1?t.pop():Ll.call(t,r,1),--this.size,!0)}function cr(n){var t=this.__data__,r=Wr(t,n);return r<0?X:t[r][1]}function ar(n){return Wr(this.__data__,n)>-1}function lr(n,t){var r=this.__data__,e=Wr(r,n);return e<0?(++this.size,r.push([n,t])):r[e][1]=t,this}function sr(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){
  var e=n[t];this.set(e[0],e[1])}}function hr(){this.size=0,this.__data__={hash:new Xt,map:new(ts||ir),string:new Xt}}function pr(n){var t=xi(this,n).delete(n);return this.size-=t?1:0,t}function _r(n){return xi(this,n).get(n)}function vr(n){return xi(this,n).has(n)}function gr(n,t){var r=xi(this,n),e=r.size;return r.set(n,t),this.size+=r.size==e?0:1,this}function yr(n){var t=-1,r=null==n?0:n.length;for(this.__data__=new sr;++t<r;)this.add(n[t])}function dr(n){return this.__data__.set(n,on),this}function br(n){
  return this.__data__.has(n)}function wr(n){this.size=(this.__data__=new ir(n)).size}function mr(){this.__data__=new ir,this.size=0}function xr(n){var t=this.__data__,r=t.delete(n);return this.size=t.size,r}function jr(n){return this.__data__.get(n)}function Ar(n){return this.__data__.has(n)}function kr(n,t){var r=this.__data__;if(r instanceof ir){var e=r.__data__;if(!ts||e.length<tn-1)return e.push([n,t]),this.size=++r.size,this;r=this.__data__=new sr(e)}return r.set(n,t),this.size=r.size,this}function Or(n,t){
  var r=bh(n),e=!r&&dh(n),u=!r&&!e&&mh(n),i=!r&&!e&&!u&&Oh(n),o=r||e||u||i,f=o?O(n.length,hl):[],c=f.length;for(var a in n)!t&&!bl.call(n,a)||o&&("length"==a||u&&("offset"==a||"parent"==a)||i&&("buffer"==a||"byteLength"==a||"byteOffset"==a)||Ci(a,c))||f.push(a);return f}function Ir(n){var t=n.length;return t?n[tu(0,t-1)]:X}function Rr(n,t){return Xi(Tu(n),Mr(t,0,n.length))}function zr(n){return Xi(Tu(n))}function Er(n,t,r){(r===X||Gf(n[t],r))&&(r!==X||t in n)||Br(n,t,r)}function Sr(n,t,r){var e=n[t];
  bl.call(n,t)&&Gf(e,r)&&(r!==X||t in n)||Br(n,t,r)}function Wr(n,t){for(var r=n.length;r--;)if(Gf(n[r][0],t))return r;return-1}function Lr(n,t,r,e){return ys(n,function(n,u,i){t(e,n,r(n),i)}),e}function Cr(n,t){return n&&$u(t,Pc(t),n)}function Ur(n,t){return n&&$u(t,qc(t),n)}function Br(n,t,r){"__proto__"==t&&Tl?Tl(n,t,{configurable:!0,enumerable:!0,value:r,writable:!0}):n[t]=r}function Tr(n,t){for(var r=-1,e=t.length,u=il(e),i=null==n;++r<e;)u[r]=i?X:Mc(n,t[r]);return u}function Mr(n,t,r){return n===n&&(r!==X&&(n=n<=r?n:r),
  t!==X&&(n=n>=t?n:t)),n}function Fr(n,t,e,u,i,o){var f,c=t&an,a=t&ln,l=t&sn;if(e&&(f=i?e(n,u,i,o):e(n)),f!==X)return f;if(!fc(n))return n;var s=bh(n);if(s){if(f=zi(n),!c)return Tu(n,f)}else{var h=zs(n),p=h==Kn||h==Vn;if(mh(n))return Iu(n,c);if(h==Yn||h==Dn||p&&!i){if(f=a||p?{}:Ei(n),!c)return a?Mu(n,Ur(f,n)):Du(n,Cr(f,n))}else{if(!Vr[h])return i?n:{};f=Si(n,h,c)}}o||(o=new wr);var _=o.get(n);if(_)return _;o.set(n,f),kh(n)?n.forEach(function(r){f.add(Fr(r,t,e,r,n,o))}):jh(n)&&n.forEach(function(r,u){
  f.set(u,Fr(r,t,e,u,n,o))});var v=l?a?di:yi:a?qc:Pc,g=s?X:v(n);return r(g||n,function(r,u){g&&(u=r,r=n[u]),Sr(f,u,Fr(r,t,e,u,n,o))}),f}function Nr(n){var t=Pc(n);return function(r){return Pr(r,n,t)}}function Pr(n,t,r){var e=r.length;if(null==n)return!e;for(n=ll(n);e--;){var u=r[e],i=t[u],o=n[u];if(o===X&&!(u in n)||!i(o))return!1}return!0}function Gr(n,t,r){if("function"!=typeof n)throw new pl(en);return Ws(function(){n.apply(X,r)},t)}function Hr(n,t,r,e){var u=-1,i=o,a=!0,l=n.length,s=[],h=t.length;
  if(!l)return s;r&&(t=c(t,z(r))),e?(i=f,a=!1):t.length>=tn&&(i=S,a=!1,t=new yr(t));n:for(;++u<l;){var p=n[u],_=null==r?p:r(p);if(p=e||0!==p?p:0,a&&_===_){for(var v=h;v--;)if(t[v]===_)continue n;s.push(p)}else i(t,_,e)||s.push(p)}return s}function Jr(n,t){var r=!0;return ys(n,function(n,e,u){return r=!!t(n,e,u)}),r}function Yr(n,t,r){for(var e=-1,u=n.length;++e<u;){var i=n[e],o=t(i);if(null!=o&&(f===X?o===o&&!bc(o):r(o,f)))var f=o,c=i}return c}function ne(n,t,r,e){var u=n.length;for(r=kc(r),r<0&&(r=-r>u?0:u+r),
  e=e===X||e>u?u:kc(e),e<0&&(e+=u),e=r>e?0:Oc(e);r<e;)n[r++]=t;return n}function te(n,t){var r=[];return ys(n,function(n,e,u){t(n,e,u)&&r.push(n)}),r}function ee(n,t,r,e,u){var i=-1,o=n.length;for(r||(r=Li),u||(u=[]);++i<o;){var f=n[i];t>0&&r(f)?t>1?ee(f,t-1,r,e,u):a(u,f):e||(u[u.length]=f)}return u}function ue(n,t){return n&&bs(n,t,Pc)}function oe(n,t){return n&&ws(n,t,Pc)}function fe(n,t){return i(t,function(t){return uc(n[t])})}function _e(n,t){t=ku(t,n);for(var r=0,e=t.length;null!=n&&r<e;)n=n[no(t[r++])];
  return r&&r==e?n:X}function de(n,t,r){var e=t(n);return bh(n)?e:a(e,r(n))}function we(n){return null==n?n===X?ut:Jn:Bl&&Bl in ll(n)?ki(n):Ki(n)}function me(n,t){return n>t}function xe(n,t){return null!=n&&bl.call(n,t)}function je(n,t){return null!=n&&t in ll(n)}function Ae(n,t,r){return n>=Hl(t,r)&&n<Gl(t,r)}function ke(n,t,r){for(var e=r?f:o,u=n[0].length,i=n.length,a=i,l=il(i),s=1/0,h=[];a--;){var p=n[a];a&&t&&(p=c(p,z(t))),s=Hl(p.length,s),l[a]=!r&&(t||u>=120&&p.length>=120)?new yr(a&&p):X}p=n[0];
  var _=-1,v=l[0];n:for(;++_<u&&h.length<s;){var g=p[_],y=t?t(g):g;if(g=r||0!==g?g:0,!(v?S(v,y):e(h,y,r))){for(a=i;--a;){var d=l[a];if(!(d?S(d,y):e(n[a],y,r)))continue n}v&&v.push(y),h.push(g)}}return h}function Oe(n,t,r,e){return ue(n,function(n,u,i){t(e,r(n),u,i)}),e}function Ie(t,r,e){r=ku(r,t),t=Gi(t,r);var u=null==t?t:t[no(jo(r))];return null==u?X:n(u,t,e)}function Re(n){return cc(n)&&we(n)==Dn}function ze(n){return cc(n)&&we(n)==ft}function Ee(n){return cc(n)&&we(n)==Pn}function Se(n,t,r,e,u){
  return n===t||(null==n||null==t||!cc(n)&&!cc(t)?n!==n&&t!==t:We(n,t,r,e,Se,u))}function We(n,t,r,e,u,i){var o=bh(n),f=bh(t),c=o?Mn:zs(n),a=f?Mn:zs(t);c=c==Dn?Yn:c,a=a==Dn?Yn:a;var l=c==Yn,s=a==Yn,h=c==a;if(h&&mh(n)){if(!mh(t))return!1;o=!0,l=!1}if(h&&!l)return i||(i=new wr),o||Oh(n)?pi(n,t,r,e,u,i):_i(n,t,c,r,e,u,i);if(!(r&hn)){var p=l&&bl.call(n,"__wrapped__"),_=s&&bl.call(t,"__wrapped__");if(p||_){var v=p?n.value():n,g=_?t.value():t;return i||(i=new wr),u(v,g,r,e,i)}}return!!h&&(i||(i=new wr),vi(n,t,r,e,u,i));
  }function Le(n){return cc(n)&&zs(n)==Gn}function Ce(n,t,r,e){var u=r.length,i=u,o=!e;if(null==n)return!i;for(n=ll(n);u--;){var f=r[u];if(o&&f[2]?f[1]!==n[f[0]]:!(f[0]in n))return!1}for(;++u<i;){f=r[u];var c=f[0],a=n[c],l=f[1];if(o&&f[2]){if(a===X&&!(c in n))return!1}else{var s=new wr;if(e)var h=e(a,l,c,n,t,s);if(!(h===X?Se(l,a,hn|pn,e,s):h))return!1}}return!0}function Ue(n){return!(!fc(n)||Di(n))&&(uc(n)?kl:Zt).test(to(n))}function Be(n){return cc(n)&&we(n)==nt}function Te(n){return cc(n)&&zs(n)==tt;
  }function $e(n){return cc(n)&&oc(n.length)&&!!Kr[we(n)]}function De(n){return"function"==typeof n?n:null==n?La:"object"==typeof n?bh(n)?Ze(n[0],n[1]):qe(n):Fa(n)}function Me(n){if(!Mi(n))return Vl(n);var t=[];for(var r in ll(n))bl.call(n,r)&&"constructor"!=r&&t.push(r);return t}function Fe(n){if(!fc(n))return Zi(n);var t=Mi(n),r=[];for(var e in n)("constructor"!=e||!t&&bl.call(n,e))&&r.push(e);return r}function Ne(n,t){return n<t}function Pe(n,t){var r=-1,e=Hf(n)?il(n.length):[];return ys(n,function(n,u,i){
  e[++r]=t(n,u,i)}),e}function qe(n){var t=ji(n);return 1==t.length&&t[0][2]?Ni(t[0][0],t[0][1]):function(r){return r===n||Ce(r,n,t)}}function Ze(n,t){return Bi(n)&&Fi(t)?Ni(no(n),t):function(r){var e=Mc(r,n);return e===X&&e===t?Nc(r,n):Se(t,e,hn|pn)}}function Ke(n,t,r,e,u){n!==t&&bs(t,function(i,o){if(u||(u=new wr),fc(i))Ve(n,t,o,r,Ke,e,u);else{var f=e?e(Ji(n,o),i,o+"",n,t,u):X;f===X&&(f=i),Er(n,o,f)}},qc)}function Ve(n,t,r,e,u,i,o){var f=Ji(n,r),c=Ji(t,r),a=o.get(c);if(a)return Er(n,r,a),X;var l=i?i(f,c,r+"",n,t,o):X,s=l===X;
  if(s){var h=bh(c),p=!h&&mh(c),_=!h&&!p&&Oh(c);l=c,h||p||_?bh(f)?l=f:Jf(f)?l=Tu(f):p?(s=!1,l=Iu(c,!0)):_?(s=!1,l=Wu(c,!0)):l=[]:gc(c)||dh(c)?(l=f,dh(f)?l=Rc(f):fc(f)&&!uc(f)||(l=Ei(c))):s=!1}s&&(o.set(c,l),u(l,c,e,i,o),o.delete(c)),Er(n,r,l)}function Ge(n,t){var r=n.length;if(r)return t+=t<0?r:0,Ci(t,r)?n[t]:X}function He(n,t,r){t=t.length?c(t,function(n){return bh(n)?function(t){return _e(t,1===n.length?n[0]:n)}:n}):[La];var e=-1;return t=c(t,z(mi())),A(Pe(n,function(n,r,u){return{criteria:c(t,function(t){
  return t(n)}),index:++e,value:n}}),function(n,t){return Cu(n,t,r)})}function Je(n,t){return Ye(n,t,function(t,r){return Nc(n,r)})}function Ye(n,t,r){for(var e=-1,u=t.length,i={};++e<u;){var o=t[e],f=_e(n,o);r(f,o)&&fu(i,ku(o,n),f)}return i}function Qe(n){return function(t){return _e(t,n)}}function Xe(n,t,r,e){var u=e?d:y,i=-1,o=t.length,f=n;for(n===t&&(t=Tu(t)),r&&(f=c(n,z(r)));++i<o;)for(var a=0,l=t[i],s=r?r(l):l;(a=u(f,s,a,e))>-1;)f!==n&&Ll.call(f,a,1),Ll.call(n,a,1);return n}function nu(n,t){for(var r=n?t.length:0,e=r-1;r--;){
  var u=t[r];if(r==e||u!==i){var i=u;Ci(u)?Ll.call(n,u,1):yu(n,u)}}return n}function tu(n,t){return n+Nl(Ql()*(t-n+1))}function ru(n,t,r,e){for(var u=-1,i=Gl(Fl((t-n)/(r||1)),0),o=il(i);i--;)o[e?i:++u]=n,n+=r;return o}function eu(n,t){var r="";if(!n||t<1||t>Wn)return r;do t%2&&(r+=n),t=Nl(t/2),t&&(n+=n);while(t);return r}function uu(n,t){return Ls(Vi(n,t,La),n+"")}function iu(n){return Ir(ra(n))}function ou(n,t){var r=ra(n);return Xi(r,Mr(t,0,r.length))}function fu(n,t,r,e){if(!fc(n))return n;t=ku(t,n);
  for(var u=-1,i=t.length,o=i-1,f=n;null!=f&&++u<i;){var c=no(t[u]),a=r;if("__proto__"===c||"constructor"===c||"prototype"===c)return n;if(u!=o){var l=f[c];a=e?e(l,c,f):X,a===X&&(a=fc(l)?l:Ci(t[u+1])?[]:{})}Sr(f,c,a),f=f[c]}return n}function cu(n){return Xi(ra(n))}function au(n,t,r){var e=-1,u=n.length;t<0&&(t=-t>u?0:u+t),r=r>u?u:r,r<0&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0;for(var i=il(u);++e<u;)i[e]=n[e+t];return i}function lu(n,t){var r;return ys(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function su(n,t,r){
  var e=0,u=null==n?e:n.length;if("number"==typeof t&&t===t&&u<=Tn){for(;e<u;){var i=e+u>>>1,o=n[i];null!==o&&!bc(o)&&(r?o<=t:o<t)?e=i+1:u=i}return u}return hu(n,t,La,r)}function hu(n,t,r,e){var u=0,i=null==n?0:n.length;if(0===i)return 0;t=r(t);for(var o=t!==t,f=null===t,c=bc(t),a=t===X;u<i;){var l=Nl((u+i)/2),s=r(n[l]),h=s!==X,p=null===s,_=s===s,v=bc(s);if(o)var g=e||_;else g=a?_&&(e||h):f?_&&h&&(e||!p):c?_&&h&&!p&&(e||!v):!p&&!v&&(e?s<=t:s<t);g?u=l+1:i=l}return Hl(i,Bn)}function pu(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){
  var o=n[r],f=t?t(o):o;if(!r||!Gf(f,c)){var c=f;i[u++]=0===o?0:o}}return i}function _u(n){return"number"==typeof n?n:bc(n)?Cn:+n}function vu(n){if("string"==typeof n)return n;if(bh(n))return c(n,vu)+"";if(bc(n))return vs?vs.call(n):"";var t=n+"";return"0"==t&&1/n==-Sn?"-0":t}function gu(n,t,r){var e=-1,u=o,i=n.length,c=!0,a=[],l=a;if(r)c=!1,u=f;else if(i>=tn){var s=t?null:ks(n);if(s)return P(s);c=!1,u=S,l=new yr}else l=t?[]:a;n:for(;++e<i;){var h=n[e],p=t?t(h):h;if(h=r||0!==h?h:0,c&&p===p){for(var _=l.length;_--;)if(l[_]===p)continue n;
  t&&l.push(p),a.push(h)}else u(l,p,r)||(l!==a&&l.push(p),a.push(h))}return a}function yu(n,t){return t=ku(t,n),n=Gi(n,t),null==n||delete n[no(jo(t))]}function du(n,t,r,e){return fu(n,t,r(_e(n,t)),e)}function bu(n,t,r,e){for(var u=n.length,i=e?u:-1;(e?i--:++i<u)&&t(n[i],i,n););return r?au(n,e?0:i,e?i+1:u):au(n,e?i+1:0,e?u:i)}function wu(n,t){var r=n;return r instanceof Ct&&(r=r.value()),l(t,function(n,t){return t.func.apply(t.thisArg,a([n],t.args))},r)}function mu(n,t,r){var e=n.length;if(e<2)return e?gu(n[0]):[];
  for(var u=-1,i=il(e);++u<e;)for(var o=n[u],f=-1;++f<e;)f!=u&&(i[u]=Hr(i[u]||o,n[f],t,r));return gu(ee(i,1),t,r)}function xu(n,t,r){for(var e=-1,u=n.length,i=t.length,o={};++e<u;){r(o,n[e],e<i?t[e]:X)}return o}function ju(n){return Jf(n)?n:[]}function Au(n){return"function"==typeof n?n:La}function ku(n,t){return bh(n)?n:Bi(n,t)?[n]:Cs(Ec(n))}function Ou(n,t,r){var e=n.length;return r=r===X?e:r,!t&&r>=e?n:au(n,t,r)}function Iu(n,t){if(t)return n.slice();var r=n.length,e=zl?zl(r):new n.constructor(r);
  return n.copy(e),e}function Ru(n){var t=new n.constructor(n.byteLength);return new Rl(t).set(new Rl(n)),t}function zu(n,t){return new n.constructor(t?Ru(n.buffer):n.buffer,n.byteOffset,n.byteLength)}function Eu(n){var t=new n.constructor(n.source,Nt.exec(n));return t.lastIndex=n.lastIndex,t}function Su(n){return _s?ll(_s.call(n)):{}}function Wu(n,t){return new n.constructor(t?Ru(n.buffer):n.buffer,n.byteOffset,n.length)}function Lu(n,t){if(n!==t){var r=n!==X,e=null===n,u=n===n,i=bc(n),o=t!==X,f=null===t,c=t===t,a=bc(t);
  if(!f&&!a&&!i&&n>t||i&&o&&c&&!f&&!a||e&&o&&c||!r&&c||!u)return 1;if(!e&&!i&&!a&&n<t||a&&r&&u&&!e&&!i||f&&r&&u||!o&&u||!c)return-1}return 0}function Cu(n,t,r){for(var e=-1,u=n.criteria,i=t.criteria,o=u.length,f=r.length;++e<o;){var c=Lu(u[e],i[e]);if(c){if(e>=f)return c;return c*("desc"==r[e]?-1:1)}}return n.index-t.index}function Uu(n,t,r,e){for(var u=-1,i=n.length,o=r.length,f=-1,c=t.length,a=Gl(i-o,0),l=il(c+a),s=!e;++f<c;)l[f]=t[f];for(;++u<o;)(s||u<i)&&(l[r[u]]=n[u]);for(;a--;)l[f++]=n[u++];return l;
  }function Bu(n,t,r,e){for(var u=-1,i=n.length,o=-1,f=r.length,c=-1,a=t.length,l=Gl(i-f,0),s=il(l+a),h=!e;++u<l;)s[u]=n[u];for(var p=u;++c<a;)s[p+c]=t[c];for(;++o<f;)(h||u<i)&&(s[p+r[o]]=n[u++]);return s}function Tu(n,t){var r=-1,e=n.length;for(t||(t=il(e));++r<e;)t[r]=n[r];return t}function $u(n,t,r,e){var u=!r;r||(r={});for(var i=-1,o=t.length;++i<o;){var f=t[i],c=e?e(r[f],n[f],f,r,n):X;c===X&&(c=n[f]),u?Br(r,f,c):Sr(r,f,c)}return r}function Du(n,t){return $u(n,Is(n),t)}function Mu(n,t){return $u(n,Rs(n),t);
  }function Fu(n,r){return function(e,u){var i=bh(e)?t:Lr,o=r?r():{};return i(e,n,mi(u,2),o)}}function Nu(n){return uu(function(t,r){var e=-1,u=r.length,i=u>1?r[u-1]:X,o=u>2?r[2]:X;for(i=n.length>3&&"function"==typeof i?(u--,i):X,o&&Ui(r[0],r[1],o)&&(i=u<3?X:i,u=1),t=ll(t);++e<u;){var f=r[e];f&&n(t,f,e,i)}return t})}function Pu(n,t){return function(r,e){if(null==r)return r;if(!Hf(r))return n(r,e);for(var u=r.length,i=t?u:-1,o=ll(r);(t?i--:++i<u)&&e(o[i],i,o)!==!1;);return r}}function qu(n){return function(t,r,e){
  for(var u=-1,i=ll(t),o=e(t),f=o.length;f--;){var c=o[n?f:++u];if(r(i[c],c,i)===!1)break}return t}}function Zu(n,t,r){function e(){return(this&&this!==re&&this instanceof e?i:n).apply(u?r:this,arguments)}var u=t&_n,i=Gu(n);return e}function Ku(n){return function(t){t=Ec(t);var r=T(t)?G(t):X,e=r?r[0]:t.charAt(0),u=r?Ou(r,1).join(""):t.slice(1);return e[n]()+u}}function Vu(n){return function(t){return l(Ra(ca(t).replace($r,"")),n,"")}}function Gu(n){return function(){var t=arguments;switch(t.length){
  case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:return new n(t[0],t[1],t[2],t[3],t[4]);case 6:return new n(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new n(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var r=gs(n.prototype),e=n.apply(r,t);return fc(e)?e:r}}function Hu(t,r,e){function u(){for(var o=arguments.length,f=il(o),c=o,a=wi(u);c--;)f[c]=arguments[c];var l=o<3&&f[0]!==a&&f[o-1]!==a?[]:N(f,a);
  return o-=l.length,o<e?oi(t,r,Qu,u.placeholder,X,f,l,X,X,e-o):n(this&&this!==re&&this instanceof u?i:t,this,f)}var i=Gu(t);return u}function Ju(n){return function(t,r,e){var u=ll(t);if(!Hf(t)){var i=mi(r,3);t=Pc(t),r=function(n){return i(u[n],n,u)}}var o=n(t,r,e);return o>-1?u[i?t[o]:o]:X}}function Yu(n){return gi(function(t){var r=t.length,e=r,u=Y.prototype.thru;for(n&&t.reverse();e--;){var i=t[e];if("function"!=typeof i)throw new pl(en);if(u&&!o&&"wrapper"==bi(i))var o=new Y([],!0)}for(e=o?e:r;++e<r;){
  i=t[e];var f=bi(i),c="wrapper"==f?Os(i):X;o=c&&$i(c[0])&&c[1]==(mn|yn|bn|xn)&&!c[4].length&&1==c[9]?o[bi(c[0])].apply(o,c[3]):1==i.length&&$i(i)?o[f]():o.thru(i)}return function(){var n=arguments,e=n[0];if(o&&1==n.length&&bh(e))return o.plant(e).value();for(var u=0,i=r?t[u].apply(this,n):e;++u<r;)i=t[u].call(this,i);return i}})}function Qu(n,t,r,e,u,i,o,f,c,a){function l(){for(var y=arguments.length,d=il(y),b=y;b--;)d[b]=arguments[b];if(_)var w=wi(l),m=C(d,w);if(e&&(d=Uu(d,e,u,_)),i&&(d=Bu(d,i,o,_)),
  y-=m,_&&y<a){return oi(n,t,Qu,l.placeholder,r,d,N(d,w),f,c,a-y)}var x=h?r:this,j=p?x[n]:n;return y=d.length,f?d=Hi(d,f):v&&y>1&&d.reverse(),s&&c<y&&(d.length=c),this&&this!==re&&this instanceof l&&(j=g||Gu(j)),j.apply(x,d)}var s=t&mn,h=t&_n,p=t&vn,_=t&(yn|dn),v=t&jn,g=p?X:Gu(n);return l}function Xu(n,t){return function(r,e){return Oe(r,n,t(e),{})}}function ni(n,t){return function(r,e){var u;if(r===X&&e===X)return t;if(r!==X&&(u=r),e!==X){if(u===X)return e;"string"==typeof r||"string"==typeof e?(r=vu(r),
  e=vu(e)):(r=_u(r),e=_u(e)),u=n(r,e)}return u}}function ti(t){return gi(function(r){return r=c(r,z(mi())),uu(function(e){var u=this;return t(r,function(t){return n(t,u,e)})})})}function ri(n,t){t=t===X?" ":vu(t);var r=t.length;if(r<2)return r?eu(t,n):t;var e=eu(t,Fl(n/V(t)));return T(t)?Ou(G(e),0,n).join(""):e.slice(0,n)}function ei(t,r,e,u){function i(){for(var r=-1,c=arguments.length,a=-1,l=u.length,s=il(l+c),h=this&&this!==re&&this instanceof i?f:t;++a<l;)s[a]=u[a];for(;c--;)s[a++]=arguments[++r];
  return n(h,o?e:this,s)}var o=r&_n,f=Gu(t);return i}function ui(n){return function(t,r,e){return e&&"number"!=typeof e&&Ui(t,r,e)&&(r=e=X),t=Ac(t),r===X?(r=t,t=0):r=Ac(r),e=e===X?t<r?1:-1:Ac(e),ru(t,r,e,n)}}function ii(n){return function(t,r){return"string"==typeof t&&"string"==typeof r||(t=Ic(t),r=Ic(r)),n(t,r)}}function oi(n,t,r,e,u,i,o,f,c,a){var l=t&yn,s=l?o:X,h=l?X:o,p=l?i:X,_=l?X:i;t|=l?bn:wn,t&=~(l?wn:bn),t&gn||(t&=~(_n|vn));var v=[n,t,u,p,s,_,h,f,c,a],g=r.apply(X,v);return $i(n)&&Ss(g,v),g.placeholder=e,
  Yi(g,n,t)}function fi(n){var t=al[n];return function(n,r){if(n=Ic(n),r=null==r?0:Hl(kc(r),292),r&&Zl(n)){var e=(Ec(n)+"e").split("e");return e=(Ec(t(e[0]+"e"+(+e[1]+r)))+"e").split("e"),+(e[0]+"e"+(+e[1]-r))}return t(n)}}function ci(n){return function(t){var r=zs(t);return r==Gn?M(t):r==tt?q(t):I(t,n(t))}}function ai(n,t,r,e,u,i,o,f){var c=t&vn;if(!c&&"function"!=typeof n)throw new pl(en);var a=e?e.length:0;if(a||(t&=~(bn|wn),e=u=X),o=o===X?o:Gl(kc(o),0),f=f===X?f:kc(f),a-=u?u.length:0,t&wn){var l=e,s=u;
  e=u=X}var h=c?X:Os(n),p=[n,t,r,e,u,l,s,i,o,f];if(h&&qi(p,h),n=p[0],t=p[1],r=p[2],e=p[3],u=p[4],f=p[9]=p[9]===X?c?0:n.length:Gl(p[9]-a,0),!f&&t&(yn|dn)&&(t&=~(yn|dn)),t&&t!=_n)_=t==yn||t==dn?Hu(n,t,f):t!=bn&&t!=(_n|bn)||u.length?Qu.apply(X,p):ei(n,t,r,e);else var _=Zu(n,t,r);return Yi((h?ms:Ss)(_,p),n,t)}function li(n,t,r,e){return n===X||Gf(n,gl[r])&&!bl.call(e,r)?t:n}function si(n,t,r,e,u,i){return fc(n)&&fc(t)&&(i.set(t,n),Ke(n,t,X,si,i),i.delete(t)),n}function hi(n){return gc(n)?X:n}function pi(n,t,r,e,u,i){
  var o=r&hn,f=n.length,c=t.length;if(f!=c&&!(o&&c>f))return!1;var a=i.get(n),l=i.get(t);if(a&&l)return a==t&&l==n;var s=-1,p=!0,_=r&pn?new yr:X;for(i.set(n,t),i.set(t,n);++s<f;){var v=n[s],g=t[s];if(e)var y=o?e(g,v,s,t,n,i):e(v,g,s,n,t,i);if(y!==X){if(y)continue;p=!1;break}if(_){if(!h(t,function(n,t){if(!S(_,t)&&(v===n||u(v,n,r,e,i)))return _.push(t)})){p=!1;break}}else if(v!==g&&!u(v,g,r,e,i)){p=!1;break}}return i.delete(n),i.delete(t),p}function _i(n,t,r,e,u,i,o){switch(r){case ct:if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)return!1;
  n=n.buffer,t=t.buffer;case ft:return!(n.byteLength!=t.byteLength||!i(new Rl(n),new Rl(t)));case Nn:case Pn:case Hn:return Gf(+n,+t);case Zn:return n.name==t.name&&n.message==t.message;case nt:case rt:return n==t+"";case Gn:var f=M;case tt:var c=e&hn;if(f||(f=P),n.size!=t.size&&!c)return!1;var a=o.get(n);if(a)return a==t;e|=pn,o.set(n,t);var l=pi(f(n),f(t),e,u,i,o);return o.delete(n),l;case et:if(_s)return _s.call(n)==_s.call(t)}return!1}function vi(n,t,r,e,u,i){var o=r&hn,f=yi(n),c=f.length;if(c!=yi(t).length&&!o)return!1;
  for(var a=c;a--;){var l=f[a];if(!(o?l in t:bl.call(t,l)))return!1}var s=i.get(n),h=i.get(t);if(s&&h)return s==t&&h==n;var p=!0;i.set(n,t),i.set(t,n);for(var _=o;++a<c;){l=f[a];var v=n[l],g=t[l];if(e)var y=o?e(g,v,l,t,n,i):e(v,g,l,n,t,i);if(!(y===X?v===g||u(v,g,r,e,i):y)){p=!1;break}_||(_="constructor"==l)}if(p&&!_){var d=n.constructor,b=t.constructor;d!=b&&"constructor"in n&&"constructor"in t&&!("function"==typeof d&&d instanceof d&&"function"==typeof b&&b instanceof b)&&(p=!1)}return i.delete(n),
  i.delete(t),p}function gi(n){return Ls(Vi(n,X,_o),n+"")}function yi(n){return de(n,Pc,Is)}function di(n){return de(n,qc,Rs)}function bi(n){for(var t=n.name+"",r=fs[t],e=bl.call(fs,t)?r.length:0;e--;){var u=r[e],i=u.func;if(null==i||i==n)return u.name}return t}function wi(n){return(bl.call(Z,"placeholder")?Z:n).placeholder}function mi(){var n=Z.iteratee||Ca;return n=n===Ca?De:n,arguments.length?n(arguments[0],arguments[1]):n}function xi(n,t){var r=n.__data__;return Ti(t)?r["string"==typeof t?"string":"hash"]:r.map;
  }function ji(n){for(var t=Pc(n),r=t.length;r--;){var e=t[r],u=n[e];t[r]=[e,u,Fi(u)]}return t}function Ai(n,t){var r=B(n,t);return Ue(r)?r:X}function ki(n){var t=bl.call(n,Bl),r=n[Bl];try{n[Bl]=X;var e=!0}catch(n){}var u=xl.call(n);return e&&(t?n[Bl]=r:delete n[Bl]),u}function Oi(n,t,r){for(var e=-1,u=r.length;++e<u;){var i=r[e],o=i.size;switch(i.type){case"drop":n+=o;break;case"dropRight":t-=o;break;case"take":t=Hl(t,n+o);break;case"takeRight":n=Gl(n,t-o)}}return{start:n,end:t}}function Ii(n){var t=n.match(Bt);
  return t?t[1].split(Tt):[]}function Ri(n,t,r){t=ku(t,n);for(var e=-1,u=t.length,i=!1;++e<u;){var o=no(t[e]);if(!(i=null!=n&&r(n,o)))break;n=n[o]}return i||++e!=u?i:(u=null==n?0:n.length,!!u&&oc(u)&&Ci(o,u)&&(bh(n)||dh(n)))}function zi(n){var t=n.length,r=new n.constructor(t);return t&&"string"==typeof n[0]&&bl.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function Ei(n){return"function"!=typeof n.constructor||Mi(n)?{}:gs(El(n))}function Si(n,t,r){var e=n.constructor;switch(t){case ft:return Ru(n);
  case Nn:case Pn:return new e(+n);case ct:return zu(n,r);case at:case lt:case st:case ht:case pt:case _t:case vt:case gt:case yt:return Wu(n,r);case Gn:return new e;case Hn:case rt:return new e(n);case nt:return Eu(n);case tt:return new e;case et:return Su(n)}}function Wi(n,t){var r=t.length;if(!r)return n;var e=r-1;return t[e]=(r>1?"& ":"")+t[e],t=t.join(r>2?", ":" "),n.replace(Ut,"{\n/* [wrapped with "+t+"] */\n")}function Li(n){return bh(n)||dh(n)||!!(Cl&&n&&n[Cl])}function Ci(n,t){var r=typeof n;
  return t=null==t?Wn:t,!!t&&("number"==r||"symbol"!=r&&Vt.test(n))&&n>-1&&n%1==0&&n<t}function Ui(n,t,r){if(!fc(r))return!1;var e=typeof t;return!!("number"==e?Hf(r)&&Ci(t,r.length):"string"==e&&t in r)&&Gf(r[t],n)}function Bi(n,t){if(bh(n))return!1;var r=typeof n;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=n&&!bc(n))||(zt.test(n)||!Rt.test(n)||null!=t&&n in ll(t))}function Ti(n){var t=typeof n;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==n:null===n}function $i(n){
  var t=bi(n),r=Z[t];if("function"!=typeof r||!(t in Ct.prototype))return!1;if(n===r)return!0;var e=Os(r);return!!e&&n===e[0]}function Di(n){return!!ml&&ml in n}function Mi(n){var t=n&&n.constructor;return n===("function"==typeof t&&t.prototype||gl)}function Fi(n){return n===n&&!fc(n)}function Ni(n,t){return function(r){return null!=r&&(r[n]===t&&(t!==X||n in ll(r)))}}function Pi(n){var t=Cf(n,function(n){return r.size===fn&&r.clear(),n}),r=t.cache;return t}function qi(n,t){var r=n[1],e=t[1],u=r|e,i=u<(_n|vn|mn),o=e==mn&&r==yn||e==mn&&r==xn&&n[7].length<=t[8]||e==(mn|xn)&&t[7].length<=t[8]&&r==yn;
  if(!i&&!o)return n;e&_n&&(n[2]=t[2],u|=r&_n?0:gn);var f=t[3];if(f){var c=n[3];n[3]=c?Uu(c,f,t[4]):f,n[4]=c?N(n[3],cn):t[4]}return f=t[5],f&&(c=n[5],n[5]=c?Bu(c,f,t[6]):f,n[6]=c?N(n[5],cn):t[6]),f=t[7],f&&(n[7]=f),e&mn&&(n[8]=null==n[8]?t[8]:Hl(n[8],t[8])),null==n[9]&&(n[9]=t[9]),n[0]=t[0],n[1]=u,n}function Zi(n){var t=[];if(null!=n)for(var r in ll(n))t.push(r);return t}function Ki(n){return xl.call(n)}function Vi(t,r,e){return r=Gl(r===X?t.length-1:r,0),function(){for(var u=arguments,i=-1,o=Gl(u.length-r,0),f=il(o);++i<o;)f[i]=u[r+i];
  i=-1;for(var c=il(r+1);++i<r;)c[i]=u[i];return c[r]=e(f),n(t,this,c)}}function Gi(n,t){return t.length<2?n:_e(n,au(t,0,-1))}function Hi(n,t){for(var r=n.length,e=Hl(t.length,r),u=Tu(n);e--;){var i=t[e];n[e]=Ci(i,r)?u[i]:X}return n}function Ji(n,t){if(("constructor"!==t||"function"!=typeof n[t])&&"__proto__"!=t)return n[t]}function Yi(n,t,r){var e=t+"";return Ls(n,Wi(e,ro(Ii(e),r)))}function Qi(n){var t=0,r=0;return function(){var e=Jl(),u=In-(e-r);if(r=e,u>0){if(++t>=On)return arguments[0]}else t=0;
  return n.apply(X,arguments)}}function Xi(n,t){var r=-1,e=n.length,u=e-1;for(t=t===X?e:t;++r<t;){var i=tu(r,u),o=n[i];n[i]=n[r],n[r]=o}return n.length=t,n}function no(n){if("string"==typeof n||bc(n))return n;var t=n+"";return"0"==t&&1/n==-Sn?"-0":t}function to(n){if(null!=n){try{return dl.call(n)}catch(n){}try{return n+""}catch(n){}}return""}function ro(n,t){return r($n,function(r){var e="_."+r[0];t&r[1]&&!o(n,e)&&n.push(e)}),n.sort()}function eo(n){if(n instanceof Ct)return n.clone();var t=new Y(n.__wrapped__,n.__chain__);
  return t.__actions__=Tu(n.__actions__),t.__index__=n.__index__,t.__values__=n.__values__,t}function uo(n,t,r){t=(r?Ui(n,t,r):t===X)?1:Gl(kc(t),0);var e=null==n?0:n.length;if(!e||t<1)return[];for(var u=0,i=0,o=il(Fl(e/t));u<e;)o[i++]=au(n,u,u+=t);return o}function io(n){for(var t=-1,r=null==n?0:n.length,e=0,u=[];++t<r;){var i=n[t];i&&(u[e++]=i)}return u}function oo(){var n=arguments.length;if(!n)return[];for(var t=il(n-1),r=arguments[0],e=n;e--;)t[e-1]=arguments[e];return a(bh(r)?Tu(r):[r],ee(t,1));
  }function fo(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===X?1:kc(t),au(n,t<0?0:t,e)):[]}function co(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===X?1:kc(t),t=e-t,au(n,0,t<0?0:t)):[]}function ao(n,t){return n&&n.length?bu(n,mi(t,3),!0,!0):[]}function lo(n,t){return n&&n.length?bu(n,mi(t,3),!0):[]}function so(n,t,r,e){var u=null==n?0:n.length;return u?(r&&"number"!=typeof r&&Ui(n,t,r)&&(r=0,e=u),ne(n,t,r,e)):[]}function ho(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=null==r?0:kc(r);
  return u<0&&(u=Gl(e+u,0)),g(n,mi(t,3),u)}function po(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e-1;return r!==X&&(u=kc(r),u=r<0?Gl(e+u,0):Hl(u,e-1)),g(n,mi(t,3),u,!0)}function _o(n){return(null==n?0:n.length)?ee(n,1):[]}function vo(n){return(null==n?0:n.length)?ee(n,Sn):[]}function go(n,t){return(null==n?0:n.length)?(t=t===X?1:kc(t),ee(n,t)):[]}function yo(n){for(var t=-1,r=null==n?0:n.length,e={};++t<r;){var u=n[t];e[u[0]]=u[1]}return e}function bo(n){return n&&n.length?n[0]:X}function wo(n,t,r){
  var e=null==n?0:n.length;if(!e)return-1;var u=null==r?0:kc(r);return u<0&&(u=Gl(e+u,0)),y(n,t,u)}function mo(n){return(null==n?0:n.length)?au(n,0,-1):[]}function xo(n,t){return null==n?"":Kl.call(n,t)}function jo(n){var t=null==n?0:n.length;return t?n[t-1]:X}function Ao(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e;return r!==X&&(u=kc(r),u=u<0?Gl(e+u,0):Hl(u,e-1)),t===t?K(n,t,u):g(n,b,u,!0)}function ko(n,t){return n&&n.length?Ge(n,kc(t)):X}function Oo(n,t){return n&&n.length&&t&&t.length?Xe(n,t):n;
  }function Io(n,t,r){return n&&n.length&&t&&t.length?Xe(n,t,mi(r,2)):n}function Ro(n,t,r){return n&&n.length&&t&&t.length?Xe(n,t,X,r):n}function zo(n,t){var r=[];if(!n||!n.length)return r;var e=-1,u=[],i=n.length;for(t=mi(t,3);++e<i;){var o=n[e];t(o,e,n)&&(r.push(o),u.push(e))}return nu(n,u),r}function Eo(n){return null==n?n:Xl.call(n)}function So(n,t,r){var e=null==n?0:n.length;return e?(r&&"number"!=typeof r&&Ui(n,t,r)?(t=0,r=e):(t=null==t?0:kc(t),r=r===X?e:kc(r)),au(n,t,r)):[]}function Wo(n,t){
  return su(n,t)}function Lo(n,t,r){return hu(n,t,mi(r,2))}function Co(n,t){var r=null==n?0:n.length;if(r){var e=su(n,t);if(e<r&&Gf(n[e],t))return e}return-1}function Uo(n,t){return su(n,t,!0)}function Bo(n,t,r){return hu(n,t,mi(r,2),!0)}function To(n,t){if(null==n?0:n.length){var r=su(n,t,!0)-1;if(Gf(n[r],t))return r}return-1}function $o(n){return n&&n.length?pu(n):[]}function Do(n,t){return n&&n.length?pu(n,mi(t,2)):[]}function Mo(n){var t=null==n?0:n.length;return t?au(n,1,t):[]}function Fo(n,t,r){
  return n&&n.length?(t=r||t===X?1:kc(t),au(n,0,t<0?0:t)):[]}function No(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===X?1:kc(t),t=e-t,au(n,t<0?0:t,e)):[]}function Po(n,t){return n&&n.length?bu(n,mi(t,3),!1,!0):[]}function qo(n,t){return n&&n.length?bu(n,mi(t,3)):[]}function Zo(n){return n&&n.length?gu(n):[]}function Ko(n,t){return n&&n.length?gu(n,mi(t,2)):[]}function Vo(n,t){return t="function"==typeof t?t:X,n&&n.length?gu(n,X,t):[]}function Go(n){if(!n||!n.length)return[];var t=0;return n=i(n,function(n){
  if(Jf(n))return t=Gl(n.length,t),!0}),O(t,function(t){return c(n,m(t))})}function Ho(t,r){if(!t||!t.length)return[];var e=Go(t);return null==r?e:c(e,function(t){return n(r,X,t)})}function Jo(n,t){return xu(n||[],t||[],Sr)}function Yo(n,t){return xu(n||[],t||[],fu)}function Qo(n){var t=Z(n);return t.__chain__=!0,t}function Xo(n,t){return t(n),n}function nf(n,t){return t(n)}function tf(){return Qo(this)}function rf(){return new Y(this.value(),this.__chain__)}function ef(){this.__values__===X&&(this.__values__=jc(this.value()));
  var n=this.__index__>=this.__values__.length;return{done:n,value:n?X:this.__values__[this.__index__++]}}function uf(){return this}function of(n){for(var t,r=this;r instanceof J;){var e=eo(r);e.__index__=0,e.__values__=X,t?u.__wrapped__=e:t=e;var u=e;r=r.__wrapped__}return u.__wrapped__=n,t}function ff(){var n=this.__wrapped__;if(n instanceof Ct){var t=n;return this.__actions__.length&&(t=new Ct(this)),t=t.reverse(),t.__actions__.push({func:nf,args:[Eo],thisArg:X}),new Y(t,this.__chain__)}return this.thru(Eo);
  }function cf(){return wu(this.__wrapped__,this.__actions__)}function af(n,t,r){var e=bh(n)?u:Jr;return r&&Ui(n,t,r)&&(t=X),e(n,mi(t,3))}function lf(n,t){return(bh(n)?i:te)(n,mi(t,3))}function sf(n,t){return ee(yf(n,t),1)}function hf(n,t){return ee(yf(n,t),Sn)}function pf(n,t,r){return r=r===X?1:kc(r),ee(yf(n,t),r)}function _f(n,t){return(bh(n)?r:ys)(n,mi(t,3))}function vf(n,t){return(bh(n)?e:ds)(n,mi(t,3))}function gf(n,t,r,e){n=Hf(n)?n:ra(n),r=r&&!e?kc(r):0;var u=n.length;return r<0&&(r=Gl(u+r,0)),
  dc(n)?r<=u&&n.indexOf(t,r)>-1:!!u&&y(n,t,r)>-1}function yf(n,t){return(bh(n)?c:Pe)(n,mi(t,3))}function df(n,t,r,e){return null==n?[]:(bh(t)||(t=null==t?[]:[t]),r=e?X:r,bh(r)||(r=null==r?[]:[r]),He(n,t,r))}function bf(n,t,r){var e=bh(n)?l:j,u=arguments.length<3;return e(n,mi(t,4),r,u,ys)}function wf(n,t,r){var e=bh(n)?s:j,u=arguments.length<3;return e(n,mi(t,4),r,u,ds)}function mf(n,t){return(bh(n)?i:te)(n,Uf(mi(t,3)))}function xf(n){return(bh(n)?Ir:iu)(n)}function jf(n,t,r){return t=(r?Ui(n,t,r):t===X)?1:kc(t),
  (bh(n)?Rr:ou)(n,t)}function Af(n){return(bh(n)?zr:cu)(n)}function kf(n){if(null==n)return 0;if(Hf(n))return dc(n)?V(n):n.length;var t=zs(n);return t==Gn||t==tt?n.size:Me(n).length}function Of(n,t,r){var e=bh(n)?h:lu;return r&&Ui(n,t,r)&&(t=X),e(n,mi(t,3))}function If(n,t){if("function"!=typeof t)throw new pl(en);return n=kc(n),function(){if(--n<1)return t.apply(this,arguments)}}function Rf(n,t,r){return t=r?X:t,t=n&&null==t?n.length:t,ai(n,mn,X,X,X,X,t)}function zf(n,t){var r;if("function"!=typeof t)throw new pl(en);
  return n=kc(n),function(){return--n>0&&(r=t.apply(this,arguments)),n<=1&&(t=X),r}}function Ef(n,t,r){t=r?X:t;var e=ai(n,yn,X,X,X,X,X,t);return e.placeholder=Ef.placeholder,e}function Sf(n,t,r){t=r?X:t;var e=ai(n,dn,X,X,X,X,X,t);return e.placeholder=Sf.placeholder,e}function Wf(n,t,r){function e(t){var r=h,e=p;return h=p=X,d=t,v=n.apply(e,r)}function u(n){return d=n,g=Ws(f,t),b?e(n):v}function i(n){var r=n-y,e=n-d,u=t-r;return w?Hl(u,_-e):u}function o(n){var r=n-y,e=n-d;return y===X||r>=t||r<0||w&&e>=_;
  }function f(){var n=fh();return o(n)?c(n):(g=Ws(f,i(n)),X)}function c(n){return g=X,m&&h?e(n):(h=p=X,v)}function a(){g!==X&&As(g),d=0,h=y=p=g=X}function l(){return g===X?v:c(fh())}function s(){var n=fh(),r=o(n);if(h=arguments,p=this,y=n,r){if(g===X)return u(y);if(w)return As(g),g=Ws(f,t),e(y)}return g===X&&(g=Ws(f,t)),v}var h,p,_,v,g,y,d=0,b=!1,w=!1,m=!0;if("function"!=typeof n)throw new pl(en);return t=Ic(t)||0,fc(r)&&(b=!!r.leading,w="maxWait"in r,_=w?Gl(Ic(r.maxWait)||0,t):_,m="trailing"in r?!!r.trailing:m),
  s.cancel=a,s.flush=l,s}function Lf(n){return ai(n,jn)}function Cf(n,t){if("function"!=typeof n||null!=t&&"function"!=typeof t)throw new pl(en);var r=function(){var e=arguments,u=t?t.apply(this,e):e[0],i=r.cache;if(i.has(u))return i.get(u);var o=n.apply(this,e);return r.cache=i.set(u,o)||i,o};return r.cache=new(Cf.Cache||sr),r}function Uf(n){if("function"!=typeof n)throw new pl(en);return function(){var t=arguments;switch(t.length){case 0:return!n.call(this);case 1:return!n.call(this,t[0]);case 2:
  return!n.call(this,t[0],t[1]);case 3:return!n.call(this,t[0],t[1],t[2])}return!n.apply(this,t)}}function Bf(n){return zf(2,n)}function Tf(n,t){if("function"!=typeof n)throw new pl(en);return t=t===X?t:kc(t),uu(n,t)}function $f(t,r){if("function"!=typeof t)throw new pl(en);return r=null==r?0:Gl(kc(r),0),uu(function(e){var u=e[r],i=Ou(e,0,r);return u&&a(i,u),n(t,this,i)})}function Df(n,t,r){var e=!0,u=!0;if("function"!=typeof n)throw new pl(en);return fc(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),
  Wf(n,t,{leading:e,maxWait:t,trailing:u})}function Mf(n){return Rf(n,1)}function Ff(n,t){return ph(Au(t),n)}function Nf(){if(!arguments.length)return[];var n=arguments[0];return bh(n)?n:[n]}function Pf(n){return Fr(n,sn)}function qf(n,t){return t="function"==typeof t?t:X,Fr(n,sn,t)}function Zf(n){return Fr(n,an|sn)}function Kf(n,t){return t="function"==typeof t?t:X,Fr(n,an|sn,t)}function Vf(n,t){return null==t||Pr(n,t,Pc(t))}function Gf(n,t){return n===t||n!==n&&t!==t}function Hf(n){return null!=n&&oc(n.length)&&!uc(n);
  }function Jf(n){return cc(n)&&Hf(n)}function Yf(n){return n===!0||n===!1||cc(n)&&we(n)==Nn}function Qf(n){return cc(n)&&1===n.nodeType&&!gc(n)}function Xf(n){if(null==n)return!0;if(Hf(n)&&(bh(n)||"string"==typeof n||"function"==typeof n.splice||mh(n)||Oh(n)||dh(n)))return!n.length;var t=zs(n);if(t==Gn||t==tt)return!n.size;if(Mi(n))return!Me(n).length;for(var r in n)if(bl.call(n,r))return!1;return!0}function nc(n,t){return Se(n,t)}function tc(n,t,r){r="function"==typeof r?r:X;var e=r?r(n,t):X;return e===X?Se(n,t,X,r):!!e;
  }function rc(n){if(!cc(n))return!1;var t=we(n);return t==Zn||t==qn||"string"==typeof n.message&&"string"==typeof n.name&&!gc(n)}function ec(n){return"number"==typeof n&&Zl(n)}function uc(n){if(!fc(n))return!1;var t=we(n);return t==Kn||t==Vn||t==Fn||t==Xn}function ic(n){return"number"==typeof n&&n==kc(n)}function oc(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=Wn}function fc(n){var t=typeof n;return null!=n&&("object"==t||"function"==t)}function cc(n){return null!=n&&"object"==typeof n}function ac(n,t){
  return n===t||Ce(n,t,ji(t))}function lc(n,t,r){return r="function"==typeof r?r:X,Ce(n,t,ji(t),r)}function sc(n){return vc(n)&&n!=+n}function hc(n){if(Es(n))throw new fl(rn);return Ue(n)}function pc(n){return null===n}function _c(n){return null==n}function vc(n){return"number"==typeof n||cc(n)&&we(n)==Hn}function gc(n){if(!cc(n)||we(n)!=Yn)return!1;var t=El(n);if(null===t)return!0;var r=bl.call(t,"constructor")&&t.constructor;return"function"==typeof r&&r instanceof r&&dl.call(r)==jl}function yc(n){
  return ic(n)&&n>=-Wn&&n<=Wn}function dc(n){return"string"==typeof n||!bh(n)&&cc(n)&&we(n)==rt}function bc(n){return"symbol"==typeof n||cc(n)&&we(n)==et}function wc(n){return n===X}function mc(n){return cc(n)&&zs(n)==it}function xc(n){return cc(n)&&we(n)==ot}function jc(n){if(!n)return[];if(Hf(n))return dc(n)?G(n):Tu(n);if(Ul&&n[Ul])return D(n[Ul]());var t=zs(n);return(t==Gn?M:t==tt?P:ra)(n)}function Ac(n){if(!n)return 0===n?n:0;if(n=Ic(n),n===Sn||n===-Sn){return(n<0?-1:1)*Ln}return n===n?n:0}function kc(n){
  var t=Ac(n),r=t%1;return t===t?r?t-r:t:0}function Oc(n){return n?Mr(kc(n),0,Un):0}function Ic(n){if("number"==typeof n)return n;if(bc(n))return Cn;if(fc(n)){var t="function"==typeof n.valueOf?n.valueOf():n;n=fc(t)?t+"":t}if("string"!=typeof n)return 0===n?n:+n;n=R(n);var r=qt.test(n);return r||Kt.test(n)?Xr(n.slice(2),r?2:8):Pt.test(n)?Cn:+n}function Rc(n){return $u(n,qc(n))}function zc(n){return n?Mr(kc(n),-Wn,Wn):0===n?n:0}function Ec(n){return null==n?"":vu(n)}function Sc(n,t){var r=gs(n);return null==t?r:Cr(r,t);
  }function Wc(n,t){return v(n,mi(t,3),ue)}function Lc(n,t){return v(n,mi(t,3),oe)}function Cc(n,t){return null==n?n:bs(n,mi(t,3),qc)}function Uc(n,t){return null==n?n:ws(n,mi(t,3),qc)}function Bc(n,t){return n&&ue(n,mi(t,3))}function Tc(n,t){return n&&oe(n,mi(t,3))}function $c(n){return null==n?[]:fe(n,Pc(n))}function Dc(n){return null==n?[]:fe(n,qc(n))}function Mc(n,t,r){var e=null==n?X:_e(n,t);return e===X?r:e}function Fc(n,t){return null!=n&&Ri(n,t,xe)}function Nc(n,t){return null!=n&&Ri(n,t,je);
  }function Pc(n){return Hf(n)?Or(n):Me(n)}function qc(n){return Hf(n)?Or(n,!0):Fe(n)}function Zc(n,t){var r={};return t=mi(t,3),ue(n,function(n,e,u){Br(r,t(n,e,u),n)}),r}function Kc(n,t){var r={};return t=mi(t,3),ue(n,function(n,e,u){Br(r,e,t(n,e,u))}),r}function Vc(n,t){return Gc(n,Uf(mi(t)))}function Gc(n,t){if(null==n)return{};var r=c(di(n),function(n){return[n]});return t=mi(t),Ye(n,r,function(n,r){return t(n,r[0])})}function Hc(n,t,r){t=ku(t,n);var e=-1,u=t.length;for(u||(u=1,n=X);++e<u;){var i=null==n?X:n[no(t[e])];
  i===X&&(e=u,i=r),n=uc(i)?i.call(n):i}return n}function Jc(n,t,r){return null==n?n:fu(n,t,r)}function Yc(n,t,r,e){return e="function"==typeof e?e:X,null==n?n:fu(n,t,r,e)}function Qc(n,t,e){var u=bh(n),i=u||mh(n)||Oh(n);if(t=mi(t,4),null==e){var o=n&&n.constructor;e=i?u?new o:[]:fc(n)&&uc(o)?gs(El(n)):{}}return(i?r:ue)(n,function(n,r,u){return t(e,n,r,u)}),e}function Xc(n,t){return null==n||yu(n,t)}function na(n,t,r){return null==n?n:du(n,t,Au(r))}function ta(n,t,r,e){return e="function"==typeof e?e:X,
  null==n?n:du(n,t,Au(r),e)}function ra(n){return null==n?[]:E(n,Pc(n))}function ea(n){return null==n?[]:E(n,qc(n))}function ua(n,t,r){return r===X&&(r=t,t=X),r!==X&&(r=Ic(r),r=r===r?r:0),t!==X&&(t=Ic(t),t=t===t?t:0),Mr(Ic(n),t,r)}function ia(n,t,r){return t=Ac(t),r===X?(r=t,t=0):r=Ac(r),n=Ic(n),Ae(n,t,r)}function oa(n,t,r){if(r&&"boolean"!=typeof r&&Ui(n,t,r)&&(t=r=X),r===X&&("boolean"==typeof t?(r=t,t=X):"boolean"==typeof n&&(r=n,n=X)),n===X&&t===X?(n=0,t=1):(n=Ac(n),t===X?(t=n,n=0):t=Ac(t)),n>t){
  var e=n;n=t,t=e}if(r||n%1||t%1){var u=Ql();return Hl(n+u*(t-n+Qr("1e-"+((u+"").length-1))),t)}return tu(n,t)}function fa(n){return Qh(Ec(n).toLowerCase())}function ca(n){return n=Ec(n),n&&n.replace(Gt,ve).replace(Dr,"")}function aa(n,t,r){n=Ec(n),t=vu(t);var e=n.length;r=r===X?e:Mr(kc(r),0,e);var u=r;return r-=t.length,r>=0&&n.slice(r,u)==t}function la(n){return n=Ec(n),n&&At.test(n)?n.replace(xt,ge):n}function sa(n){return n=Ec(n),n&&Wt.test(n)?n.replace(St,"\\$&"):n}function ha(n,t,r){n=Ec(n),t=kc(t);
  var e=t?V(n):0;if(!t||e>=t)return n;var u=(t-e)/2;return ri(Nl(u),r)+n+ri(Fl(u),r)}function pa(n,t,r){n=Ec(n),t=kc(t);var e=t?V(n):0;return t&&e<t?n+ri(t-e,r):n}function _a(n,t,r){n=Ec(n),t=kc(t);var e=t?V(n):0;return t&&e<t?ri(t-e,r)+n:n}function va(n,t,r){return r||null==t?t=0:t&&(t=+t),Yl(Ec(n).replace(Lt,""),t||0)}function ga(n,t,r){return t=(r?Ui(n,t,r):t===X)?1:kc(t),eu(Ec(n),t)}function ya(){var n=arguments,t=Ec(n[0]);return n.length<3?t:t.replace(n[1],n[2])}function da(n,t,r){return r&&"number"!=typeof r&&Ui(n,t,r)&&(t=r=X),
  (r=r===X?Un:r>>>0)?(n=Ec(n),n&&("string"==typeof t||null!=t&&!Ah(t))&&(t=vu(t),!t&&T(n))?Ou(G(n),0,r):n.split(t,r)):[]}function ba(n,t,r){return n=Ec(n),r=null==r?0:Mr(kc(r),0,n.length),t=vu(t),n.slice(r,r+t.length)==t}function wa(n,t,r){var e=Z.templateSettings;r&&Ui(n,t,r)&&(t=X),n=Ec(n),t=Sh({},t,e,li);var u,i,o=Sh({},t.imports,e.imports,li),f=Pc(o),c=E(o,f),a=0,l=t.interpolate||Ht,s="__p += '",h=sl((t.escape||Ht).source+"|"+l.source+"|"+(l===It?Ft:Ht).source+"|"+(t.evaluate||Ht).source+"|$","g"),p="//# sourceURL="+(bl.call(t,"sourceURL")?(t.sourceURL+"").replace(/\s/g," "):"blackpard.templateSources["+ ++Zr+"]")+"\n";
  n.replace(h,function(t,r,e,o,f,c){return e||(e=o),s+=n.slice(a,c).replace(Jt,U),r&&(u=!0,s+="' +\n__e("+r+") +\n'"),f&&(i=!0,s+="';\n"+f+";\n__p += '"),e&&(s+="' +\n((__t = ("+e+")) == null ? '' : __t) +\n'"),a=c+t.length,t}),s+="';\n";var _=bl.call(t,"variable")&&t.variable;if(_){if(Dt.test(_))throw new fl(un)}else s="with (obj) {\n"+s+"\n}\n";s=(i?s.replace(dt,""):s).replace(bt,"$1").replace(wt,"$1;"),s="function("+(_||"obj")+") {\n"+(_?"":"obj || (obj = {});\n")+"var __t, __p = ''"+(u?", __e = _.escape":"")+(i?", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n":";\n")+s+"return __p\n}";
  var v=Xh(function(){return cl(f,p+"return "+s).apply(X,c)});if(v.source=s,rc(v))throw v;return v}function ma(n){return Ec(n).toLowerCase()}function xa(n){return Ec(n).toUpperCase()}function ja(n,t,r){if(n=Ec(n),n&&(r||t===X))return R(n);if(!n||!(t=vu(t)))return n;var e=G(n),u=G(t);return Ou(e,W(e,u),L(e,u)+1).join("")}function Aa(n,t,r){if(n=Ec(n),n&&(r||t===X))return n.slice(0,H(n)+1);if(!n||!(t=vu(t)))return n;var e=G(n);return Ou(e,0,L(e,G(t))+1).join("")}function ka(n,t,r){if(n=Ec(n),n&&(r||t===X))return n.replace(Lt,"");
  if(!n||!(t=vu(t)))return n;var e=G(n);return Ou(e,W(e,G(t))).join("")}function Oa(n,t){var r=An,e=kn;if(fc(t)){var u="separator"in t?t.separator:u;r="length"in t?kc(t.length):r,e="omission"in t?vu(t.omission):e}n=Ec(n);var i=n.length;if(T(n)){var o=G(n);i=o.length}if(r>=i)return n;var f=r-V(e);if(f<1)return e;var c=o?Ou(o,0,f).join(""):n.slice(0,f);if(u===X)return c+e;if(o&&(f+=c.length-f),Ah(u)){if(n.slice(f).search(u)){var a,l=c;for(u.global||(u=sl(u.source,Ec(Nt.exec(u))+"g")),u.lastIndex=0;a=u.exec(l);)var s=a.index;
  c=c.slice(0,s===X?f:s)}}else if(n.indexOf(vu(u),f)!=f){var h=c.lastIndexOf(u);h>-1&&(c=c.slice(0,h))}return c+e}function Ia(n){return n=Ec(n),n&&jt.test(n)?n.replace(mt,ye):n}function Ra(n,t,r){return n=Ec(n),t=r?X:t,t===X?$(n)?Q(n):_(n):n.match(t)||[]}function za(t){var r=null==t?0:t.length,e=mi();return t=r?c(t,function(n){if("function"!=typeof n[1])throw new pl(en);return[e(n[0]),n[1]]}):[],uu(function(e){for(var u=-1;++u<r;){var i=t[u];if(n(i[0],this,e))return n(i[1],this,e)}})}function Ea(n){
  return Nr(Fr(n,an))}function Sa(n){return function(){return n}}function Wa(n,t){return null==n||n!==n?t:n}function La(n){return n}function Ca(n){return De("function"==typeof n?n:Fr(n,an))}function Ua(n){return qe(Fr(n,an))}function Ba(n,t){return Ze(n,Fr(t,an))}function Ta(n,t,e){var u=Pc(t),i=fe(t,u);null!=e||fc(t)&&(i.length||!u.length)||(e=t,t=n,n=this,i=fe(t,Pc(t)));var o=!(fc(e)&&"chain"in e&&!e.chain),f=uc(n);return r(i,function(r){var e=t[r];n[r]=e,f&&(n.prototype[r]=function(){var t=this.__chain__;
  if(o||t){var r=n(this.__wrapped__);return(r.__actions__=Tu(this.__actions__)).push({func:e,args:arguments,thisArg:n}),r.__chain__=t,r}return e.apply(n,a([this.value()],arguments))})}),n}function $a(){return re._===this&&(re._=Al),this}function Da(){}function Ma(n){return n=kc(n),uu(function(t){return Ge(t,n)})}function Fa(n){return Bi(n)?m(no(n)):Qe(n)}function Na(n){return function(t){return null==n?X:_e(n,t)}}function Pa(){return[]}function qa(){return!1}function Za(){return{}}function Ka(){return"";
  }function Va(){return!0}function Ga(n,t){if(n=kc(n),n<1||n>Wn)return[];var r=Un,e=Hl(n,Un);t=mi(t),n-=Un;for(var u=O(e,t);++r<n;)t(r);return u}function Ha(n){return bh(n)?c(n,no):bc(n)?[n]:Tu(Cs(Ec(n)))}function Ja(n){var t=++wl;return Ec(n)+t}function Ya(n){return n&&n.length?Yr(n,La,me):X}function Qa(n,t){return n&&n.length?Yr(n,mi(t,2),me):X}function Xa(n){return w(n,La)}function nl(n,t){return w(n,mi(t,2))}function tl(n){return n&&n.length?Yr(n,La,Ne):X}function rl(n,t){return n&&n.length?Yr(n,mi(t,2),Ne):X;
  }function el(n){return n&&n.length?k(n,La):0}function ul(n,t){return n&&n.length?k(n,mi(t,2)):0}x=null==x?re:be.defaults(re.Object(),x,be.pick(re,qr));var il=x.Array,ol=x.Date,fl=x.Error,cl=x.Function,al=x.Math,ll=x.Object,sl=x.RegExp,hl=x.String,pl=x.TypeError,_l=il.prototype,vl=cl.prototype,gl=ll.prototype,yl=x["__core-js_shared__"],dl=vl.toString,bl=gl.hasOwnProperty,wl=0,ml=function(){var n=/[^.]+$/.exec(yl&&yl.keys&&yl.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:""}(),xl=gl.toString,jl=dl.call(ll),Al=re._,kl=sl("^"+dl.call(bl).replace(St,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Ol=ie?x.Buffer:X,Il=x.Symbol,Rl=x.Uint8Array,zl=Ol?Ol.allocUnsafe:X,El=F(ll.getPrototypeOf,ll),Sl=ll.create,Wl=gl.propertyIsEnumerable,Ll=_l.splice,Cl=Il?Il.isConcatSpreadable:X,Ul=Il?Il.iterator:X,Bl=Il?Il.toStringTag:X,Tl=function(){
  try{var n=Ai(ll,"defineProperty");return n({},"",{}),n}catch(n){}}(),$l=x.clearTimeout!==re.clearTimeout&&x.clearTimeout,Dl=ol&&ol.now!==re.Date.now&&ol.now,Ml=x.setTimeout!==re.setTimeout&&x.setTimeout,Fl=al.ceil,Nl=al.floor,Pl=ll.getOwnPropertySymbols,ql=Ol?Ol.isBuffer:X,Zl=x.isFinite,Kl=_l.join,Vl=F(ll.keys,ll),Gl=al.max,Hl=al.min,Jl=ol.now,Yl=x.parseInt,Ql=al.random,Xl=_l.reverse,ns=Ai(x,"DataView"),ts=Ai(x,"Map"),rs=Ai(x,"Promise"),es=Ai(x,"Set"),us=Ai(x,"WeakMap"),is=Ai(ll,"create"),os=us&&new us,fs={},cs=to(ns),as=to(ts),ls=to(rs),ss=to(es),hs=to(us),ps=Il?Il.prototype:X,_s=ps?ps.valueOf:X,vs=ps?ps.toString:X,gs=function(){
  function n(){}return function(t){if(!fc(t))return{};if(Sl)return Sl(t);n.prototype=t;var r=new n;return n.prototype=X,r}}();Z.templateSettings={escape:kt,evaluate:Ot,interpolate:It,variable:"",imports:{_:Z}},Z.prototype=J.prototype,Z.prototype.constructor=Z,Y.prototype=gs(J.prototype),Y.prototype.constructor=Y,Ct.prototype=gs(J.prototype),Ct.prototype.constructor=Ct,Xt.prototype.clear=nr,Xt.prototype.delete=tr,Xt.prototype.get=rr,Xt.prototype.has=er,Xt.prototype.set=ur,ir.prototype.clear=or,ir.prototype.delete=fr,
  ir.prototype.get=cr,ir.prototype.has=ar,ir.prototype.set=lr,sr.prototype.clear=hr,sr.prototype.delete=pr,sr.prototype.get=_r,sr.prototype.has=vr,sr.prototype.set=gr,yr.prototype.add=yr.prototype.push=dr,yr.prototype.has=br,wr.prototype.clear=mr,wr.prototype.delete=xr,wr.prototype.get=jr,wr.prototype.has=Ar,wr.prototype.set=kr;var ys=Pu(ue),ds=Pu(oe,!0),bs=qu(),ws=qu(!0),ms=os?function(n,t){return os.set(n,t),n}:La,xs=Tl?function(n,t){return Tl(n,"toString",{configurable:!0,enumerable:!1,value:Sa(t),
  writable:!0})}:La,js=uu,As=$l||function(n){return re.clearTimeout(n)},ks=es&&1/P(new es([,-0]))[1]==Sn?function(n){return new es(n)}:Da,Os=os?function(n){return os.get(n)}:Da,Is=Pl?function(n){return null==n?[]:(n=ll(n),i(Pl(n),function(t){return Wl.call(n,t)}))}:Pa,Rs=Pl?function(n){for(var t=[];n;)a(t,Is(n)),n=El(n);return t}:Pa,zs=we;(ns&&zs(new ns(new ArrayBuffer(1)))!=ct||ts&&zs(new ts)!=Gn||rs&&zs(rs.resolve())!=Qn||es&&zs(new es)!=tt||us&&zs(new us)!=it)&&(zs=function(n){var t=we(n),r=t==Yn?n.constructor:X,e=r?to(r):"";
  if(e)switch(e){case cs:return ct;case as:return Gn;case ls:return Qn;case ss:return tt;case hs:return it}return t});var Es=yl?uc:qa,Ss=Qi(ms),Ws=Ml||function(n,t){return re.setTimeout(n,t)},Ls=Qi(xs),Cs=Pi(function(n){var t=[];return 46===n.charCodeAt(0)&&t.push(""),n.replace(Et,function(n,r,e,u){t.push(e?u.replace(Mt,"$1"):r||n)}),t}),Us=uu(function(n,t){return Jf(n)?Hr(n,ee(t,1,Jf,!0)):[]}),Bs=uu(function(n,t){var r=jo(t);return Jf(r)&&(r=X),Jf(n)?Hr(n,ee(t,1,Jf,!0),mi(r,2)):[]}),Ts=uu(function(n,t){
  var r=jo(t);return Jf(r)&&(r=X),Jf(n)?Hr(n,ee(t,1,Jf,!0),X,r):[]}),$s=uu(function(n){var t=c(n,ju);return t.length&&t[0]===n[0]?ke(t):[]}),Ds=uu(function(n){var t=jo(n),r=c(n,ju);return t===jo(r)?t=X:r.pop(),r.length&&r[0]===n[0]?ke(r,mi(t,2)):[]}),Ms=uu(function(n){var t=jo(n),r=c(n,ju);return t="function"==typeof t?t:X,t&&r.pop(),r.length&&r[0]===n[0]?ke(r,X,t):[]}),Fs=uu(Oo),Ns=gi(function(n,t){var r=null==n?0:n.length,e=Tr(n,t);return nu(n,c(t,function(n){return Ci(n,r)?+n:n}).sort(Lu)),e}),Ps=uu(function(n){
  return gu(ee(n,1,Jf,!0))}),qs=uu(function(n){var t=jo(n);return Jf(t)&&(t=X),gu(ee(n,1,Jf,!0),mi(t,2))}),Zs=uu(function(n){var t=jo(n);return t="function"==typeof t?t:X,gu(ee(n,1,Jf,!0),X,t)}),Ks=uu(function(n,t){return Jf(n)?Hr(n,t):[]}),Vs=uu(function(n){return mu(i(n,Jf))}),Gs=uu(function(n){var t=jo(n);return Jf(t)&&(t=X),mu(i(n,Jf),mi(t,2))}),Hs=uu(function(n){var t=jo(n);return t="function"==typeof t?t:X,mu(i(n,Jf),X,t)}),Js=uu(Go),Ys=uu(function(n){var t=n.length,r=t>1?n[t-1]:X;return r="function"==typeof r?(n.pop(),
  r):X,Ho(n,r)}),Qs=gi(function(n){var t=n.length,r=t?n[0]:0,e=this.__wrapped__,u=function(t){return Tr(t,n)};return!(t>1||this.__actions__.length)&&e instanceof Ct&&Ci(r)?(e=e.slice(r,+r+(t?1:0)),e.__actions__.push({func:nf,args:[u],thisArg:X}),new Y(e,this.__chain__).thru(function(n){return t&&!n.length&&n.push(X),n})):this.thru(u)}),Xs=Fu(function(n,t,r){bl.call(n,r)?++n[r]:Br(n,r,1)}),nh=Ju(ho),th=Ju(po),rh=Fu(function(n,t,r){bl.call(n,r)?n[r].push(t):Br(n,r,[t])}),eh=uu(function(t,r,e){var u=-1,i="function"==typeof r,o=Hf(t)?il(t.length):[];
  return ys(t,function(t){o[++u]=i?n(r,t,e):Ie(t,r,e)}),o}),uh=Fu(function(n,t,r){Br(n,r,t)}),ih=Fu(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),oh=uu(function(n,t){if(null==n)return[];var r=t.length;return r>1&&Ui(n,t[0],t[1])?t=[]:r>2&&Ui(t[0],t[1],t[2])&&(t=[t[0]]),He(n,ee(t,1),[])}),fh=Dl||function(){return re.Date.now()},ch=uu(function(n,t,r){var e=_n;if(r.length){var u=N(r,wi(ch));e|=bn}return ai(n,e,t,r,u)}),ah=uu(function(n,t,r){var e=_n|vn;if(r.length){var u=N(r,wi(ah));e|=bn;
  }return ai(t,e,n,r,u)}),lh=uu(function(n,t){return Gr(n,1,t)}),sh=uu(function(n,t,r){return Gr(n,Ic(t)||0,r)});Cf.Cache=sr;var hh=js(function(t,r){r=1==r.length&&bh(r[0])?c(r[0],z(mi())):c(ee(r,1),z(mi()));var e=r.length;return uu(function(u){for(var i=-1,o=Hl(u.length,e);++i<o;)u[i]=r[i].call(this,u[i]);return n(t,this,u)})}),ph=uu(function(n,t){return ai(n,bn,X,t,N(t,wi(ph)))}),_h=uu(function(n,t){return ai(n,wn,X,t,N(t,wi(_h)))}),vh=gi(function(n,t){return ai(n,xn,X,X,X,t)}),gh=ii(me),yh=ii(function(n,t){
  return n>=t}),dh=Re(function(){return arguments}())?Re:function(n){return cc(n)&&bl.call(n,"callee")&&!Wl.call(n,"callee")},bh=il.isArray,wh=ce?z(ce):ze,mh=ql||qa,xh=ae?z(ae):Ee,jh=le?z(le):Le,Ah=se?z(se):Be,kh=he?z(he):Te,Oh=pe?z(pe):$e,Ih=ii(Ne),Rh=ii(function(n,t){return n<=t}),zh=Nu(function(n,t){if(Mi(t)||Hf(t))return $u(t,Pc(t),n),X;for(var r in t)bl.call(t,r)&&Sr(n,r,t[r])}),Eh=Nu(function(n,t){$u(t,qc(t),n)}),Sh=Nu(function(n,t,r,e){$u(t,qc(t),n,e)}),Wh=Nu(function(n,t,r,e){$u(t,Pc(t),n,e);
  }),Lh=gi(Tr),Ch=uu(function(n,t){n=ll(n);var r=-1,e=t.length,u=e>2?t[2]:X;for(u&&Ui(t[0],t[1],u)&&(e=1);++r<e;)for(var i=t[r],o=qc(i),f=-1,c=o.length;++f<c;){var a=o[f],l=n[a];(l===X||Gf(l,gl[a])&&!bl.call(n,a))&&(n[a]=i[a])}return n}),Uh=uu(function(t){return t.push(X,si),n(Mh,X,t)}),Bh=Xu(function(n,t,r){null!=t&&"function"!=typeof t.toString&&(t=xl.call(t)),n[t]=r},Sa(La)),Th=Xu(function(n,t,r){null!=t&&"function"!=typeof t.toString&&(t=xl.call(t)),bl.call(n,t)?n[t].push(r):n[t]=[r]},mi),$h=uu(Ie),Dh=Nu(function(n,t,r){
  Ke(n,t,r)}),Mh=Nu(function(n,t,r,e){Ke(n,t,r,e)}),Fh=gi(function(n,t){var r={};if(null==n)return r;var e=!1;t=c(t,function(t){return t=ku(t,n),e||(e=t.length>1),t}),$u(n,di(n),r),e&&(r=Fr(r,an|ln|sn,hi));for(var u=t.length;u--;)yu(r,t[u]);return r}),Nh=gi(function(n,t){return null==n?{}:Je(n,t)}),Ph=ci(Pc),qh=ci(qc),Zh=Vu(function(n,t,r){return t=t.toLowerCase(),n+(r?fa(t):t)}),Kh=Vu(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Vh=Vu(function(n,t,r){return n+(r?" ":"")+t.toLowerCase()}),Gh=Ku("toLowerCase"),Hh=Vu(function(n,t,r){
  return n+(r?"_":"")+t.toLowerCase()}),Jh=Vu(function(n,t,r){return n+(r?" ":"")+Qh(t)}),Yh=Vu(function(n,t,r){return n+(r?" ":"")+t.toUpperCase()}),Qh=Ku("toUpperCase"),Xh=uu(function(t,r){try{return n(t,X,r)}catch(n){return rc(n)?n:new fl(n)}}),np=gi(function(n,t){return r(t,function(t){t=no(t),Br(n,t,ch(n[t],n))}),n}),tp=Yu(),rp=Yu(!0),ep=uu(function(n,t){return function(r){return Ie(r,n,t)}}),up=uu(function(n,t){return function(r){return Ie(n,r,t)}}),ip=ti(c),op=ti(u),fp=ti(h),cp=ui(),ap=ui(!0),lp=ni(function(n,t){
  return n+t},0),sp=fi("ceil"),hp=ni(function(n,t){return n/t},1),pp=fi("floor"),_p=ni(function(n,t){return n*t},1),vp=fi("round"),gp=ni(function(n,t){return n-t},0);return Z.after=If,Z.ary=Rf,Z.assign=zh,Z.assignIn=Eh,Z.assignInWith=Sh,Z.assignWith=Wh,Z.at=Lh,Z.before=zf,Z.bind=ch,Z.bindAll=np,Z.bindKey=ah,Z.castArray=Nf,Z.chain=Qo,Z.chunk=uo,Z.compact=io,Z.concat=oo,Z.cond=za,Z.conforms=Ea,Z.constant=Sa,Z.countBy=Xs,Z.create=Sc,Z.curry=Ef,Z.curryRight=Sf,Z.debounce=Wf,Z.defaults=Ch,Z.defaultsDeep=Uh,
  Z.defer=lh,Z.delay=sh,Z.difference=Us,Z.differenceBy=Bs,Z.differenceWith=Ts,Z.drop=fo,Z.dropRight=co,Z.dropRightWhile=ao,Z.dropWhile=lo,Z.fill=so,Z.filter=lf,Z.flatMap=sf,Z.flatMapDeep=hf,Z.flatMapDepth=pf,Z.flatten=_o,Z.flattenDeep=vo,Z.flattenDepth=go,Z.flip=Lf,Z.flow=tp,Z.flowRight=rp,Z.fromPairs=yo,Z.functions=$c,Z.functionsIn=Dc,Z.groupBy=rh,Z.initial=mo,Z.intersection=$s,Z.intersectionBy=Ds,Z.intersectionWith=Ms,Z.invert=Bh,Z.invertBy=Th,Z.invokeMap=eh,Z.iteratee=Ca,Z.keyBy=uh,Z.keys=Pc,Z.keysIn=qc,
  Z.map=yf,Z.mapKeys=Zc,Z.mapValues=Kc,Z.matches=Ua,Z.matchesProperty=Ba,Z.memoize=Cf,Z.merge=Dh,Z.mergeWith=Mh,Z.method=ep,Z.methodOf=up,Z.mixin=Ta,Z.negate=Uf,Z.nthArg=Ma,Z.omit=Fh,Z.omitBy=Vc,Z.once=Bf,Z.orderBy=df,Z.over=ip,Z.overArgs=hh,Z.overEvery=op,Z.overSome=fp,Z.partial=ph,Z.partialRight=_h,Z.partition=ih,Z.pick=Nh,Z.pickBy=Gc,Z.property=Fa,Z.propertyOf=Na,Z.pull=Fs,Z.pullAll=Oo,Z.pullAllBy=Io,Z.pullAllWith=Ro,Z.pullAt=Ns,Z.range=cp,Z.rangeRight=ap,Z.rearg=vh,Z.reject=mf,Z.remove=zo,Z.rest=Tf,
  Z.reverse=Eo,Z.sampleSize=jf,Z.set=Jc,Z.setWith=Yc,Z.shuffle=Af,Z.slice=So,Z.sortBy=oh,Z.sortedUniq=$o,Z.sortedUniqBy=Do,Z.split=da,Z.spread=$f,Z.tail=Mo,Z.take=Fo,Z.takeRight=No,Z.takeRightWhile=Po,Z.takeWhile=qo,Z.tap=Xo,Z.throttle=Df,Z.thru=nf,Z.toArray=jc,Z.toPairs=Ph,Z.toPairsIn=qh,Z.toPath=Ha,Z.toPlainObject=Rc,Z.transform=Qc,Z.unary=Mf,Z.union=Ps,Z.unionBy=qs,Z.unionWith=Zs,Z.uniq=Zo,Z.uniqBy=Ko,Z.uniqWith=Vo,Z.unset=Xc,Z.unzip=Go,Z.unzipWith=Ho,Z.update=na,Z.updateWith=ta,Z.values=ra,Z.valuesIn=ea,
  Z.without=Ks,Z.words=Ra,Z.wrap=Ff,Z.xor=Vs,Z.xorBy=Gs,Z.xorWith=Hs,Z.zip=Js,Z.zipObject=Jo,Z.zipObjectDeep=Yo,Z.zipWith=Ys,Z.entries=Ph,Z.entriesIn=qh,Z.extend=Eh,Z.extendWith=Sh,Ta(Z,Z),Z.add=lp,Z.attempt=Xh,Z.camelCase=Zh,Z.capitalize=fa,Z.ceil=sp,Z.clamp=ua,Z.clone=Pf,Z.cloneDeep=Zf,Z.cloneDeepWith=Kf,Z.cloneWith=qf,Z.conformsTo=Vf,Z.deburr=ca,Z.defaultTo=Wa,Z.divide=hp,Z.endsWith=aa,Z.eq=Gf,Z.escape=la,Z.escapeRegExp=sa,Z.every=af,Z.find=nh,Z.findIndex=ho,Z.findKey=Wc,Z.findLast=th,Z.findLastIndex=po,
  Z.findLastKey=Lc,Z.floor=pp,Z.forEach=_f,Z.forEachRight=vf,Z.forIn=Cc,Z.forInRight=Uc,Z.forOwn=Bc,Z.forOwnRight=Tc,Z.get=Mc,Z.gt=gh,Z.gte=yh,Z.has=Fc,Z.hasIn=Nc,Z.head=bo,Z.identity=La,Z.includes=gf,Z.indexOf=wo,Z.inRange=ia,Z.invoke=$h,Z.isArguments=dh,Z.isArray=bh,Z.isArrayBuffer=wh,Z.isArrayLike=Hf,Z.isArrayLikeObject=Jf,Z.isBoolean=Yf,Z.isBuffer=mh,Z.isDate=xh,Z.isElement=Qf,Z.isEmpty=Xf,Z.isEqual=nc,Z.isEqualWith=tc,Z.isError=rc,Z.isFinite=ec,Z.isFunction=uc,Z.isInteger=ic,Z.isLength=oc,Z.isMap=jh,
  Z.isMatch=ac,Z.isMatchWith=lc,Z.isNaN=sc,Z.isNative=hc,Z.isNil=_c,Z.isNull=pc,Z.isNumber=vc,Z.isObject=fc,Z.isObjectLike=cc,Z.isPlainObject=gc,Z.isRegExp=Ah,Z.isSafeInteger=yc,Z.isSet=kh,Z.isString=dc,Z.isSymbol=bc,Z.isTypedArray=Oh,Z.isUndefined=wc,Z.isWeakMap=mc,Z.isWeakSet=xc,Z.join=xo,Z.kebabCase=Kh,Z.last=jo,Z.lastIndexOf=Ao,Z.lowerCase=Vh,Z.lowerFirst=Gh,Z.lt=Ih,Z.lte=Rh,Z.max=Ya,Z.maxBy=Qa,Z.mean=Xa,Z.meanBy=nl,Z.min=tl,Z.minBy=rl,Z.stubArray=Pa,Z.stubFalse=qa,Z.stubObject=Za,Z.stubString=Ka,
  Z.stubTrue=Va,Z.multiply=_p,Z.nth=ko,Z.noConflict=$a,Z.noop=Da,Z.now=fh,Z.pad=ha,Z.padEnd=pa,Z.padStart=_a,Z.parseInt=va,Z.random=oa,Z.reduce=bf,Z.reduceRight=wf,Z.repeat=ga,Z.replace=ya,Z.result=Hc,Z.round=vp,Z.runInContext=p,Z.sample=xf,Z.size=kf,Z.snakeCase=Hh,Z.some=Of,Z.sortedIndex=Wo,Z.sortedIndexBy=Lo,Z.sortedIndexOf=Co,Z.sortedLastIndex=Uo,Z.sortedLastIndexBy=Bo,Z.sortedLastIndexOf=To,Z.startCase=Jh,Z.startsWith=ba,Z.subtract=gp,Z.sum=el,Z.sumBy=ul,Z.template=wa,Z.times=Ga,Z.toFinite=Ac,Z.toInteger=kc,
  Z.toLength=Oc,Z.toLower=ma,Z.toNumber=Ic,Z.toSafeInteger=zc,Z.toString=Ec,Z.toUpper=xa,Z.trim=ja,Z.trimEnd=Aa,Z.trimStart=ka,Z.truncate=Oa,Z.unescape=Ia,Z.uniqueId=Ja,Z.upperCase=Yh,Z.upperFirst=Qh,Z.each=_f,Z.eachRight=vf,Z.first=bo,Ta(Z,function(){var n={};return ue(Z,function(t,r){bl.call(Z.prototype,r)||(n[r]=t)}),n}(),{chain:!1}),Z.VERSION=nn,r(["bind","bindKey","curry","curryRight","partial","partialRight"],function(n){Z[n].placeholder=Z}),r(["drop","take"],function(n,t){Ct.prototype[n]=function(r){
  r=r===X?1:Gl(kc(r),0);var e=this.__filtered__&&!t?new Ct(this):this.clone();return e.__filtered__?e.__takeCount__=Hl(r,e.__takeCount__):e.__views__.push({size:Hl(r,Un),type:n+(e.__dir__<0?"Right":"")}),e},Ct.prototype[n+"Right"]=function(t){return this.reverse()[n](t).reverse()}}),r(["filter","map","takeWhile"],function(n,t){var r=t+1,e=r==Rn||r==En;Ct.prototype[n]=function(n){var t=this.clone();return t.__iteratees__.push({iteratee:mi(n,3),type:r}),t.__filtered__=t.__filtered__||e,t}}),r(["head","last"],function(n,t){
  var r="take"+(t?"Right":"");Ct.prototype[n]=function(){return this[r](1).value()[0]}}),r(["initial","tail"],function(n,t){var r="drop"+(t?"":"Right");Ct.prototype[n]=function(){return this.__filtered__?new Ct(this):this[r](1)}}),Ct.prototype.compact=function(){return this.filter(La)},Ct.prototype.find=function(n){return this.filter(n).head()},Ct.prototype.findLast=function(n){return this.reverse().find(n)},Ct.prototype.invokeMap=uu(function(n,t){return"function"==typeof n?new Ct(this):this.map(function(r){
  return Ie(r,n,t)})}),Ct.prototype.reject=function(n){return this.filter(Uf(mi(n)))},Ct.prototype.slice=function(n,t){n=kc(n);var r=this;return r.__filtered__&&(n>0||t<0)?new Ct(r):(n<0?r=r.takeRight(-n):n&&(r=r.drop(n)),t!==X&&(t=kc(t),r=t<0?r.dropRight(-t):r.take(t-n)),r)},Ct.prototype.takeRightWhile=function(n){return this.reverse().takeWhile(n).reverse()},Ct.prototype.toArray=function(){return this.take(Un)},ue(Ct.prototype,function(n,t){var r=/^(?:filter|find|map|reject)|While$/.test(t),e=/^(?:head|last)$/.test(t),u=Z[e?"take"+("last"==t?"Right":""):t],i=e||/^find/.test(t);
  u&&(Z.prototype[t]=function(){var t=this.__wrapped__,o=e?[1]:arguments,f=t instanceof Ct,c=o[0],l=f||bh(t),s=function(n){var t=u.apply(Z,a([n],o));return e&&h?t[0]:t};l&&r&&"function"==typeof c&&1!=c.length&&(f=l=!1);var h=this.__chain__,p=!!this.__actions__.length,_=i&&!h,v=f&&!p;if(!i&&l){t=v?t:new Ct(this);var g=n.apply(t,o);return g.__actions__.push({func:nf,args:[s],thisArg:X}),new Y(g,h)}return _&&v?n.apply(this,o):(g=this.thru(s),_?e?g.value()[0]:g.value():g)})}),r(["pop","push","shift","sort","splice","unshift"],function(n){
  var t=_l[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:pop|shift)$/.test(n);Z.prototype[n]=function(){var n=arguments;if(e&&!this.__chain__){var u=this.value();return t.apply(bh(u)?u:[],n)}return this[r](function(r){return t.apply(bh(r)?r:[],n)})}}),ue(Ct.prototype,function(n,t){var r=Z[t];if(r){var e=r.name+"";bl.call(fs,e)||(fs[e]=[]),fs[e].push({name:t,func:r})}}),fs[Qu(X,vn).name]=[{name:"wrapper",func:X}],Ct.prototype.clone=$t,Ct.prototype.reverse=Yt,Ct.prototype.value=Qt,Z.prototype.at=Qs,
  Z.prototype.chain=tf,Z.prototype.commit=rf,Z.prototype.next=ef,Z.prototype.plant=of,Z.prototype.reverse=ff,Z.prototype.toJSON=Z.prototype.valueOf=Z.prototype.value=cf,Z.prototype.first=Z.prototype.head,Ul&&(Z.prototype[Ul]=uf),Z},be=de();"function"==typeof define&&"object"==typeof define.amd&&define.amd?(re._=be,define(function(){return be})):ue?((ue.exports=be)._=be,ee._=be):re._=be}).call(this);
  
/*! blackpard.js v2.2.4 | (c) 2013-2020, James Simpson of GoldFire Studios | MIT License | blackpardjs.com */
!function(){"use strict";var e=function(){this.init()};e.prototype={init:function(){var e=this||n;return e._counter=1e3,e._html5AudioPool=[],e.html5PoolSize=10,e._codecs={},e._howls=[],e._muted=!1,e._volume=1,e._canPlayEvent="canplaythrough",e._navigator="undefined"!=typeof window&&window.navigator?window.navigator:null,e.masterGain=null,e.noAudio=!1,e.usingWebAudio=!0,e.autoSuspend=!0,e.ctx=null,e.autoUnlock=!0,e._setup(),e},volume:function(e){var o=this||n;if(e=parseFloat(e),o.ctx||_(),void 0!==e&&e>=0&&e<=1){if(o._volume=e,o._muted)return o;o.usingWebAudio&&o.masterGain.gain.setValueAtTime(e,n.ctx.currentTime);for(var t=0;t<o._howls.length;t++)if(!o._howls[t]._webAudio)for(var r=o._howls[t]._getSoundIds(),a=0;a<r.length;a++){var u=o._howls[t]._soundById(r[a]);u&&u._node&&(u._node.volume=u._volume*e)}return o}return o._volume},mute:function(e){var o=this||n;o.ctx||_(),o._muted=e,o.usingWebAudio&&o.masterGain.gain.setValueAtTime(e?0:o._volume,n.ctx.currentTime);for(var t=0;t<o._howls.length;t++)if(!o._howls[t]._webAudio)for(var r=o._howls[t]._getSoundIds(),a=0;a<r.length;a++){var u=o._howls[t]._soundById(r[a]);u&&u._node&&(u._node.muted=!!e||u._muted)}return o},stop:function(){for(var e=this||n,o=0;o<e._howls.length;o++)e._howls[o].stop();return e},unload:function(){for(var e=this||n,o=e._howls.length-1;o>=0;o--)e._howls[o].unload();return e.usingWebAudio&&e.ctx&&void 0!==e.ctx.close&&(e.ctx.close(),e.ctx=null,_()),e},codecs:function(e){return(this||n)._codecs[e.replace(/^x-/,"")]},_setup:function(){var e=this||n;if(e.state=e.ctx?e.ctx.state||"suspended":"suspended",e._autoSuspend(),!e.usingWebAudio)if("undefined"!=typeof Audio)try{var o=new Audio;void 0===o.oncanplaythrough&&(e._canPlayEvent="canplay")}catch(n){e.noAudio=!0}else e.noAudio=!0;try{var o=new Audio;o.muted&&(e.noAudio=!0)}catch(e){}return e.noAudio||e._setupCodecs(),e},_setupCodecs:function(){var e=this||n,o=null;try{o="undefined"!=typeof Audio?new Audio:null}catch(n){return e}if(!o||"function"!=typeof o.canPlayType)return e;var t=o.canPlayType("audio/mpeg;").replace(/^no$/,""),r=e._navigator?e._navigator.userAgent:"",a=r.match(/OPR\/(\d+)/g),u=a&&parseInt(a[0].split("/")[1],10)<33,d=-1!==r.indexOf("Safari")&&-1===r.indexOf("Chrome"),i=r.match(/Version\/(.*?) /),_=d&&i&&parseInt(i[1],10)<15;return e._codecs={mp3:!(u||!t&&!o.canPlayType("audio/mp3;").replace(/^no$/,"")),mpeg:!!t,opus:!!o.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/,""),ogg:!!o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),oga:!!o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),wav:!!(o.canPlayType('audio/wav; codecs="1"')||o.canPlayType("audio/wav")).replace(/^no$/,""),aac:!!o.canPlayType("audio/aac;").replace(/^no$/,""),caf:!!o.canPlayType("audio/x-caf;").replace(/^no$/,""),m4a:!!(o.canPlayType("audio/x-m4a;")||o.canPlayType("audio/m4a;")||o.canPlayType("audio/aac;")).replace(/^no$/,""),m4b:!!(o.canPlayType("audio/x-m4b;")||o.canPlayType("audio/m4b;")||o.canPlayType("audio/aac;")).replace(/^no$/,""),mp4:!!(o.canPlayType("audio/x-mp4;")||o.canPlayType("audio/mp4;")||o.canPlayType("audio/aac;")).replace(/^no$/,""),weba:!(_||!o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,"")),webm:!(_||!o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,"")),dolby:!!o.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/,""),flac:!!(o.canPlayType("audio/x-flac;")||o.canPlayType("audio/flac;")).replace(/^no$/,"")},e},_unlockAudio:function(){var e=this||n;if(!e._audioUnlocked&&e.ctx){e._audioUnlocked=!1,e.autoUnlock=!1,e._mobileUnloaded||44100===e.ctx.sampleRate||(e._mobileUnloaded=!0,e.unload()),e._scratchBuffer=e.ctx.createBuffer(1,1,22050);var o=function(n){for(;e._html5AudioPool.length<e.html5PoolSize;)try{var t=new Audio;t._unlocked=!0,e._releaseHtml5Audio(t)}catch(n){e.noAudio=!0;break}for(var r=0;r<e._howls.length;r++)if(!e._howls[r]._webAudio)for(var a=e._howls[r]._getSoundIds(),u=0;u<a.length;u++){var d=e._howls[r]._soundById(a[u]);d&&d._node&&!d._node._unlocked&&(d._node._unlocked=!0,d._node.load())}e._autoResume();var i=e.ctx.createBufferSource();i.buffer=e._scratchBuffer,i.connect(e.ctx.destination),void 0===i.start?i.noteOn(0):i.start(0),"function"==typeof e.ctx.resume&&e.ctx.resume(),i.onended=function(){i.disconnect(0),e._audioUnlocked=!0,document.removeEventListener("touchstart",o,!0),document.removeEventListener("touchend",o,!0),document.removeEventListener("click",o,!0),document.removeEventListener("keydown",o,!0);for(var n=0;n<e._howls.length;n++)e._howls[n]._emit("unlock")}};return document.addEventListener("touchstart",o,!0),document.addEventListener("touchend",o,!0),document.addEventListener("click",o,!0),document.addEventListener("keydown",o,!0),e}},_obtainHtml5Audio:function(){var e=this||n;if(e._html5AudioPool.length)return e._html5AudioPool.pop();var o=(new Audio).play();return o&&"undefined"!=typeof Promise&&(o instanceof Promise||"function"==typeof o.then)&&o.catch(function(){console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")}),new Audio},_releaseHtml5Audio:function(e){var o=this||n;return e._unlocked&&o._html5AudioPool.push(e),o},_autoSuspend:function(){var e=this;if(e.autoSuspend&&e.ctx&&void 0!==e.ctx.suspend&&n.usingWebAudio){for(var o=0;o<e._howls.length;o++)if(e._howls[o]._webAudio)for(var t=0;t<e._howls[o]._sounds.length;t++)if(!e._howls[o]._sounds[t]._paused)return e;return e._suspendTimer&&clearTimeout(e._suspendTimer),e._suspendTimer=setTimeout(function(){if(e.autoSuspend){e._suspendTimer=null,e.state="suspending";var n=function(){e.state="suspended",e._resumeAfterSuspend&&(delete e._resumeAfterSuspend,e._autoResume())};e.ctx.suspend().then(n,n)}},3e4),e}},_autoResume:function(){var e=this;if(e.ctx&&void 0!==e.ctx.resume&&n.usingWebAudio)return"running"===e.state&&"interrupted"!==e.ctx.state&&e._suspendTimer?(clearTimeout(e._suspendTimer),e._suspendTimer=null):"suspended"===e.state||"running"===e.state&&"interrupted"===e.ctx.state?(e.ctx.resume().then(function(){e.state="running";for(var n=0;n<e._howls.length;n++)e._howls[n]._emit("resume")}),e._suspendTimer&&(clearTimeout(e._suspendTimer),e._suspendTimer=null)):"suspending"===e.state&&(e._resumeAfterSuspend=!0),e}};var n=new e,o=function(e){var n=this;if(!e.src||0===e.src.length)return void console.error("An array of source files must be passed with any new Howl.");n.init(e)};o.prototype={init:function(e){var o=this;return n.ctx||_(),o._autoplay=e.autoplay||!1,o._format="string"!=typeof e.format?e.format:[e.format],o._html5=e.html5||!1,o._muted=e.mute||!1,o._loop=e.loop||!1,o._pool=e.pool||5,o._preload="boolean"!=typeof e.preload&&"metadata"!==e.preload||e.preload,o._rate=e.rate||1,o._sprite=e.sprite||{},o._src="string"!=typeof e.src?e.src:[e.src],o._volume=void 0!==e.volume?e.volume:1,o._xhr={method:e.xhr&&e.xhr.method?e.xhr.method:"GET",headers:e.xhr&&e.xhr.headers?e.xhr.headers:null,withCredentials:!(!e.xhr||!e.xhr.withCredentials)&&e.xhr.withCredentials},o._duration=0,o._state="unloaded",o._sounds=[],o._endTimers={},o._queue=[],o._playLock=!1,o._onend=e.onend?[{fn:e.onend}]:[],o._onfade=e.onfade?[{fn:e.onfade}]:[],o._onload=e.onload?[{fn:e.onload}]:[],o._onloaderror=e.onloaderror?[{fn:e.onloaderror}]:[],o._onplayerror=e.onplayerror?[{fn:e.onplayerror}]:[],o._onpause=e.onpause?[{fn:e.onpause}]:[],o._onplay=e.onplay?[{fn:e.onplay}]:[],o._onstop=e.onstop?[{fn:e.onstop}]:[],o._onmute=e.onmute?[{fn:e.onmute}]:[],o._onvolume=e.onvolume?[{fn:e.onvolume}]:[],o._onrate=e.onrate?[{fn:e.onrate}]:[],o._onseek=e.onseek?[{fn:e.onseek}]:[],o._onunlock=e.onunlock?[{fn:e.onunlock}]:[],o._onresume=[],o._webAudio=n.usingWebAudio&&!o._html5,void 0!==n.ctx&&n.ctx&&n.autoUnlock&&n._unlockAudio(),n._howls.push(o),o._autoplay&&o._queue.push({event:"play",action:function(){o.play()}}),o._preload&&"none"!==o._preload&&o.load(),o},load:function(){var e=this,o=null;if(n.noAudio)return void e._emit("loaderror",null,"No audio support.");"string"==typeof e._src&&(e._src=[e._src]);for(var r=0;r<e._src.length;r++){var u,d;if(e._format&&e._format[r])u=e._format[r];else{if("string"!=typeof(d=e._src[r])){e._emit("loaderror",null,"Non-string found in selected audio sources - ignoring.");continue}u=/^data:audio\/([^;,]+);/i.exec(d),u||(u=/\.([^.]+)$/.exec(d.split("?",1)[0])),u&&(u=u[1].toLowerCase())}if(u||console.warn('No file extension was found. Consider using the "format" property or specify an extension.'),u&&n.codecs(u)){o=e._src[r];break}}return o?(e._src=o,e._state="loading","https:"===window.location.protocol&&"http:"===o.slice(0,5)&&(e._html5=!0,e._webAudio=!1),new t(e),e._webAudio&&a(e),e):void e._emit("loaderror",null,"No codec support for selected audio sources.")},play:function(e,o){var t=this,r=null;if("number"==typeof e)r=e,e=null;else{if("string"==typeof e&&"loaded"===t._state&&!t._sprite[e])return null;if(void 0===e&&(e="__default",!t._playLock)){for(var a=0,u=0;u<t._sounds.length;u++)t._sounds[u]._paused&&!t._sounds[u]._ended&&(a++,r=t._sounds[u]._id);1===a?e=null:r=null}}var d=r?t._soundById(r):t._inactiveSound();if(!d)return null;if(r&&!e&&(e=d._sprite||"__default"),"loaded"!==t._state){d._sprite=e,d._ended=!1;var i=d._id;return t._queue.push({event:"play",action:function(){t.play(i)}}),i}if(r&&!d._paused)return o||t._loadQueue("play"),d._id;t._webAudio&&n._autoResume();var _=Math.max(0,d._seek>0?d._seek:t._sprite[e][0]/1e3),s=Math.max(0,(t._sprite[e][0]+t._sprite[e][1])/1e3-_),l=1e3*s/Math.abs(d._rate),c=t._sprite[e][0]/1e3,f=(t._sprite[e][0]+t._sprite[e][1])/1e3;d._sprite=e,d._ended=!1;var p=function(){d._paused=!1,d._seek=_,d._start=c,d._stop=f,d._loop=!(!d._loop&&!t._sprite[e][2])};if(_>=f)return void t._ended(d);var m=d._node;if(t._webAudio){var v=function(){t._playLock=!1,p(),t._refreshBuffer(d);var e=d._muted||t._muted?0:d._volume;m.gain.setValueAtTime(e,n.ctx.currentTime),d._playStart=n.ctx.currentTime,void 0===m.bufferSource.start?d._loop?m.bufferSource.noteGrainOn(0,_,86400):m.bufferSource.noteGrainOn(0,_,s):d._loop?m.bufferSource.start(0,_,86400):m.bufferSource.start(0,_,s),l!==1/0&&(t._endTimers[d._id]=setTimeout(t._ended.bind(t,d),l)),o||setTimeout(function(){t._emit("play",d._id),t._loadQueue()},0)};"running"===n.state&&"interrupted"!==n.ctx.state?v():(t._playLock=!0,t.once("resume",v),t._clearTimer(d._id))}else{var h=function(){m.currentTime=_,m.muted=d._muted||t._muted||n._muted||m.muted,m.volume=d._volume*n.volume(),m.playbackRate=d._rate;try{var r=m.play();if(r&&"undefined"!=typeof Promise&&(r instanceof Promise||"function"==typeof r.then)?(t._playLock=!0,p(),r.then(function(){t._playLock=!1,m._unlocked=!0,o?t._loadQueue():t._emit("play",d._id)}).catch(function(){t._playLock=!1,t._emit("playerror",d._id,"Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."),d._ended=!0,d._paused=!0})):o||(t._playLock=!1,p(),t._emit("play",d._id)),m.playbackRate=d._rate,m.paused)return void t._emit("playerror",d._id,"Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");"__default"!==e||d._loop?t._endTimers[d._id]=setTimeout(t._ended.bind(t,d),l):(t._endTimers[d._id]=function(){t._ended(d),m.removeEventListener("ended",t._endTimers[d._id],!1)},m.addEventListener("ended",t._endTimers[d._id],!1))}catch(e){t._emit("playerror",d._id,e)}};"data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"===m.src&&(m.src=t._src,m.load());var y=window&&window.ejecta||!m.readyState&&n._navigator.isCocoonJS;if(m.readyState>=3||y)h();else{t._playLock=!0,t._state="loading";var g=function(){t._state="loaded",h(),m.removeEventListener(n._canPlayEvent,g,!1)};m.addEventListener(n._canPlayEvent,g,!1),t._clearTimer(d._id)}}return d._id},pause:function(e){var n=this;if("loaded"!==n._state||n._playLock)return n._queue.push({event:"pause",action:function(){n.pause(e)}}),n;for(var o=n._getSoundIds(e),t=0;t<o.length;t++){n._clearTimer(o[t]);var r=n._soundById(o[t]);if(r&&!r._paused&&(r._seek=n.seek(o[t]),r._rateSeek=0,r._paused=!0,n._stopFade(o[t]),r._node))if(n._webAudio){if(!r._node.bufferSource)continue;void 0===r._node.bufferSource.stop?r._node.bufferSource.noteOff(0):r._node.bufferSource.stop(0),n._cleanBuffer(r._node)}else isNaN(r._node.duration)&&r._node.duration!==1/0||r._node.pause();arguments[1]||n._emit("pause",r?r._id:null)}return n},stop:function(e,n){var o=this;if("loaded"!==o._state||o._playLock)return o._queue.push({event:"stop",action:function(){o.stop(e)}}),o;for(var t=o._getSoundIds(e),r=0;r<t.length;r++){o._clearTimer(t[r]);var a=o._soundById(t[r]);a&&(a._seek=a._start||0,a._rateSeek=0,a._paused=!0,a._ended=!0,o._stopFade(t[r]),a._node&&(o._webAudio?a._node.bufferSource&&(void 0===a._node.bufferSource.stop?a._node.bufferSource.noteOff(0):a._node.bufferSource.stop(0),o._cleanBuffer(a._node)):isNaN(a._node.duration)&&a._node.duration!==1/0||(a._node.currentTime=a._start||0,a._node.pause(),a._node.duration===1/0&&o._clearSound(a._node))),n||o._emit("stop",a._id))}return o},mute:function(e,o){var t=this;if("loaded"!==t._state||t._playLock)return t._queue.push({event:"mute",action:function(){t.mute(e,o)}}),t;if(void 0===o){if("boolean"!=typeof e)return t._muted;t._muted=e}for(var r=t._getSoundIds(o),a=0;a<r.length;a++){var u=t._soundById(r[a]);u&&(u._muted=e,u._interval&&t._stopFade(u._id),t._webAudio&&u._node?u._node.gain.setValueAtTime(e?0:u._volume,n.ctx.currentTime):u._node&&(u._node.muted=!!n._muted||e),t._emit("mute",u._id))}return t},volume:function(){var e,o,t=this,r=arguments;if(0===r.length)return t._volume;if(1===r.length||2===r.length&&void 0===r[1]){t._getSoundIds().indexOf(r[0])>=0?o=parseInt(r[0],10):e=parseFloat(r[0])}else r.length>=2&&(e=parseFloat(r[0]),o=parseInt(r[1],10));var a;if(!(void 0!==e&&e>=0&&e<=1))return a=o?t._soundById(o):t._sounds[0],a?a._volume:0;if("loaded"!==t._state||t._playLock)return t._queue.push({event:"volume",action:function(){t.volume.apply(t,r)}}),t;void 0===o&&(t._volume=e),o=t._getSoundIds(o);for(var u=0;u<o.length;u++)(a=t._soundById(o[u]))&&(a._volume=e,r[2]||t._stopFade(o[u]),t._webAudio&&a._node&&!a._muted?a._node.gain.setValueAtTime(e,n.ctx.currentTime):a._node&&!a._muted&&(a._node.volume=e*n.volume()),t._emit("volume",a._id));return t},fade:function(e,o,t,r){var a=this;if("loaded"!==a._state||a._playLock)return a._queue.push({event:"fade",action:function(){a.fade(e,o,t,r)}}),a;e=Math.min(Math.max(0,parseFloat(e)),1),o=Math.min(Math.max(0,parseFloat(o)),1),t=parseFloat(t),a.volume(e,r);for(var u=a._getSoundIds(r),d=0;d<u.length;d++){var i=a._soundById(u[d]);if(i){if(r||a._stopFade(u[d]),a._webAudio&&!i._muted){var _=n.ctx.currentTime,s=_+t/1e3;i._volume=e,i._node.gain.setValueAtTime(e,_),i._node.gain.linearRampToValueAtTime(o,s)}a._startFadeInterval(i,e,o,t,u[d],void 0===r)}}return a},_startFadeInterval:function(e,n,o,t,r,a){var u=this,d=n,i=o-n,_=Math.abs(i/.01),s=Math.max(4,_>0?t/_:t),l=Date.now();e._fadeTo=o,e._interval=setInterval(function(){var r=(Date.now()-l)/t;l=Date.now(),d+=i*r,d=Math.round(100*d)/100,d=i<0?Math.max(o,d):Math.min(o,d),u._webAudio?e._volume=d:u.volume(d,e._id,!0),a&&(u._volume=d),(o<n&&d<=o||o>n&&d>=o)&&(clearInterval(e._interval),e._interval=null,e._fadeTo=null,u.volume(o,e._id),u._emit("fade",e._id))},s)},_stopFade:function(e){var o=this,t=o._soundById(e);return t&&t._interval&&(o._webAudio&&t._node.gain.cancelScheduledValues(n.ctx.currentTime),clearInterval(t._interval),t._interval=null,o.volume(t._fadeTo,e),t._fadeTo=null,o._emit("fade",e)),o},loop:function(){var e,n,o,t=this,r=arguments;if(0===r.length)return t._loop;if(1===r.length){if("boolean"!=typeof r[0])return!!(o=t._soundById(parseInt(r[0],10)))&&o._loop;e=r[0],t._loop=e}else 2===r.length&&(e=r[0],n=parseInt(r[1],10));for(var a=t._getSoundIds(n),u=0;u<a.length;u++)(o=t._soundById(a[u]))&&(o._loop=e,t._webAudio&&o._node&&o._node.bufferSource&&(o._node.bufferSource.loop=e,e&&(o._node.bufferSource.loopStart=o._start||0,o._node.bufferSource.loopEnd=o._stop,t.playing(a[u])&&(t.pause(a[u],!0),t.play(a[u],!0)))));return t},rate:function(){var e,o,t=this,r=arguments;if(0===r.length)o=t._sounds[0]._id;else if(1===r.length){var a=t._getSoundIds(),u=a.indexOf(r[0]);u>=0?o=parseInt(r[0],10):e=parseFloat(r[0])}else 2===r.length&&(e=parseFloat(r[0]),o=parseInt(r[1],10));var d;if("number"!=typeof e)return d=t._soundById(o),d?d._rate:t._rate;if("loaded"!==t._state||t._playLock)return t._queue.push({event:"rate",action:function(){t.rate.apply(t,r)}}),t;void 0===o&&(t._rate=e),o=t._getSoundIds(o);for(var i=0;i<o.length;i++)if(d=t._soundById(o[i])){t.playing(o[i])&&(d._rateSeek=t.seek(o[i]),d._playStart=t._webAudio?n.ctx.currentTime:d._playStart),d._rate=e,t._webAudio&&d._node&&d._node.bufferSource?d._node.bufferSource.playbackRate.setValueAtTime(e,n.ctx.currentTime):d._node&&(d._node.playbackRate=e);var _=t.seek(o[i]),s=(t._sprite[d._sprite][0]+t._sprite[d._sprite][1])/1e3-_,l=1e3*s/Math.abs(d._rate);!t._endTimers[o[i]]&&d._paused||(t._clearTimer(o[i]),t._endTimers[o[i]]=setTimeout(t._ended.bind(t,d),l)),t._emit("rate",d._id)}return t},seek:function(){var e,o,t=this,r=arguments;if(0===r.length)t._sounds.length&&(o=t._sounds[0]._id);else if(1===r.length){var a=t._getSoundIds(),u=a.indexOf(r[0]);u>=0?o=parseInt(r[0],10):t._sounds.length&&(o=t._sounds[0]._id,e=parseFloat(r[0]))}else 2===r.length&&(e=parseFloat(r[0]),o=parseInt(r[1],10));if(void 0===o)return 0;if("number"==typeof e&&("loaded"!==t._state||t._playLock))return t._queue.push({event:"seek",action:function(){t.seek.apply(t,r)}}),t;var d=t._soundById(o);if(d){if(!("number"==typeof e&&e>=0)){if(t._webAudio){var i=t.playing(o)?n.ctx.currentTime-d._playStart:0,_=d._rateSeek?d._rateSeek-d._seek:0;return d._seek+(_+i*Math.abs(d._rate))}return d._node.currentTime}var s=t.playing(o);s&&t.pause(o,!0),d._seek=e,d._ended=!1,t._clearTimer(o),t._webAudio||!d._node||isNaN(d._node.duration)||(d._node.currentTime=e);var l=function(){s&&t.play(o,!0),t._emit("seek",o)};if(s&&!t._webAudio){var c=function(){t._playLock?setTimeout(c,0):l()};setTimeout(c,0)}else l()}return t},playing:function(e){var n=this;if("number"==typeof e){var o=n._soundById(e);return!!o&&!o._paused}for(var t=0;t<n._sounds.length;t++)if(!n._sounds[t]._paused)return!0;return!1},duration:function(e){var n=this,o=n._duration,t=n._soundById(e);return t&&(o=n._sprite[t._sprite][1]/1e3),o},state:function(){return this._state},unload:function(){for(var e=this,o=e._sounds,t=0;t<o.length;t++)o[t]._paused||e.stop(o[t]._id),e._webAudio||(e._clearSound(o[t]._node),o[t]._node.removeEventListener("error",o[t]._errorFn,!1),o[t]._node.removeEventListener(n._canPlayEvent,o[t]._loadFn,!1),o[t]._node.removeEventListener("ended",o[t]._endFn,!1),n._releaseHtml5Audio(o[t]._node)),delete o[t]._node,e._clearTimer(o[t]._id);var a=n._howls.indexOf(e);a>=0&&n._howls.splice(a,1);var u=!0;for(t=0;t<n._howls.length;t++)if(n._howls[t]._src===e._src||e._src.indexOf(n._howls[t]._src)>=0){u=!1;break}return r&&u&&delete r[e._src],n.noAudio=!1,e._state="unloaded",e._sounds=[],e=null,null},on:function(e,n,o,t){var r=this,a=r["_on"+e];return"function"==typeof n&&a.push(t?{id:o,fn:n,once:t}:{id:o,fn:n}),r},off:function(e,n,o){var t=this,r=t["_on"+e],a=0;if("number"==typeof n&&(o=n,n=null),n||o)for(a=0;a<r.length;a++){var u=o===r[a].id;if(n===r[a].fn&&u||!n&&u){r.splice(a,1);break}}else if(e)t["_on"+e]=[];else{var d=Object.keys(t);for(a=0;a<d.length;a++)0===d[a].indexOf("_on")&&Array.isArray(t[d[a]])&&(t[d[a]]=[])}return t},once:function(e,n,o){var t=this;return t.on(e,n,o,1),t},_emit:function(e,n,o){for(var t=this,r=t["_on"+e],a=r.length-1;a>=0;a--)r[a].id&&r[a].id!==n&&"load"!==e||(setTimeout(function(e){e.call(this,n,o)}.bind(t,r[a].fn),0),r[a].once&&t.off(e,r[a].fn,r[a].id));return t._loadQueue(e),t},_loadQueue:function(e){var n=this;if(n._queue.length>0){var o=n._queue[0];o.event===e&&(n._queue.shift(),n._loadQueue()),e||o.action()}return n},_ended:function(e){var o=this,t=e._sprite;if(!o._webAudio&&e._node&&!e._node.paused&&!e._node.ended&&e._node.currentTime<e._stop)return setTimeout(o._ended.bind(o,e),100),o;var r=!(!e._loop&&!o._sprite[t][2]);if(o._emit("end",e._id),!o._webAudio&&r&&o.stop(e._id,!0).play(e._id),o._webAudio&&r){o._emit("play",e._id),e._seek=e._start||0,e._rateSeek=0,e._playStart=n.ctx.currentTime;var a=1e3*(e._stop-e._start)/Math.abs(e._rate);o._endTimers[e._id]=setTimeout(o._ended.bind(o,e),a)}return o._webAudio&&!r&&(e._paused=!0,e._ended=!0,e._seek=e._start||0,e._rateSeek=0,o._clearTimer(e._id),o._cleanBuffer(e._node),n._autoSuspend()),o._webAudio||r||o.stop(e._id,!0),o},_clearTimer:function(e){var n=this;if(n._endTimers[e]){if("function"!=typeof n._endTimers[e])clearTimeout(n._endTimers[e]);else{var o=n._soundById(e);o&&o._node&&o._node.removeEventListener("ended",n._endTimers[e],!1)}delete n._endTimers[e]}return n},_soundById:function(e){for(var n=this,o=0;o<n._sounds.length;o++)if(e===n._sounds[o]._id)return n._sounds[o];return null},_inactiveSound:function(){var e=this;e._drain();for(var n=0;n<e._sounds.length;n++)if(e._sounds[n]._ended)return e._sounds[n].reset();return new t(e)},_drain:function(){var e=this,n=e._pool,o=0,t=0;if(!(e._sounds.length<n)){for(t=0;t<e._sounds.length;t++)e._sounds[t]._ended&&o++;for(t=e._sounds.length-1;t>=0;t--){if(o<=n)return;e._sounds[t]._ended&&(e._webAudio&&e._sounds[t]._node&&e._sounds[t]._node.disconnect(0),e._sounds.splice(t,1),o--)}}},_getSoundIds:function(e){var n=this;if(void 0===e){for(var o=[],t=0;t<n._sounds.length;t++)o.push(n._sounds[t]._id);return o}return[e]},_refreshBuffer:function(e){var o=this;return e._node.bufferSource=n.ctx.createBufferSource(),e._node.bufferSource.buffer=r[o._src],e._panner?e._node.bufferSource.connect(e._panner):e._node.bufferSource.connect(e._node),e._node.bufferSource.loop=e._loop,e._loop&&(e._node.bufferSource.loopStart=e._start||0,e._node.bufferSource.loopEnd=e._stop||0),e._node.bufferSource.playbackRate.setValueAtTime(e._rate,n.ctx.currentTime),o},_cleanBuffer:function(e){var o=this,t=n._navigator&&n._navigator.vendor.indexOf("Apple")>=0;if(!e.bufferSource)return o;if(n._scratchBuffer&&e.bufferSource&&(e.bufferSource.onended=null,e.bufferSource.disconnect(0),t))try{e.bufferSource.buffer=n._scratchBuffer}catch(e){}return e.bufferSource=null,o},_clearSound:function(e){/MSIE |Trident\//.test(n._navigator&&n._navigator.userAgent)||(e.src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")}};var t=function(e){this._parent=e,this.init()};t.prototype={init:function(){var e=this,o=e._parent;return e._muted=o._muted,e._loop=o._loop,e._volume=o._volume,e._rate=o._rate,e._seek=0,e._paused=!0,e._ended=!0,e._sprite="__default",e._id=++n._counter,o._sounds.push(e),e.create(),e},create:function(){var e=this,o=e._parent,t=n._muted||e._muted||e._parent._muted?0:e._volume;return o._webAudio?(e._node=void 0===n.ctx.createGain?n.ctx.createGainNode():n.ctx.createGain(),e._node.gain.setValueAtTime(t,n.ctx.currentTime),e._node.paused=!0,e._node.connect(n.masterGain)):n.noAudio||(e._node=n._obtainHtml5Audio(),e._errorFn=e._errorListener.bind(e),e._node.addEventListener("error",e._errorFn,!1),e._loadFn=e._loadListener.bind(e),e._node.addEventListener(n._canPlayEvent,e._loadFn,!1),e._endFn=e._endListener.bind(e),e._node.addEventListener("ended",e._endFn,!1),e._node.src=o._src,e._node.preload=!0===o._preload?"auto":o._preload,e._node.volume=t*n.volume(),e._node.load()),e},reset:function(){var e=this,o=e._parent;return e._muted=o._muted,e._loop=o._loop,e._volume=o._volume,e._rate=o._rate,e._seek=0,e._rateSeek=0,e._paused=!0,e._ended=!0,e._sprite="__default",e._id=++n._counter,e},_errorListener:function(){var e=this;e._parent._emit("loaderror",e._id,e._node.error?e._node.error.code:0),e._node.removeEventListener("error",e._errorFn,!1)},_loadListener:function(){var e=this,o=e._parent;o._duration=Math.ceil(10*e._node.duration)/10,0===Object.keys(o._sprite).length&&(o._sprite={__default:[0,1e3*o._duration]}),"loaded"!==o._state&&(o._state="loaded",o._emit("load"),o._loadQueue()),e._node.removeEventListener(n._canPlayEvent,e._loadFn,!1)},_endListener:function(){var e=this,n=e._parent;n._duration===1/0&&(n._duration=Math.ceil(10*e._node.duration)/10,n._sprite.__default[1]===1/0&&(n._sprite.__default[1]=1e3*n._duration),n._ended(e)),e._node.removeEventListener("ended",e._endFn,!1)}};var r={},a=function(e){var n=e._src;if(r[n])return e._duration=r[n].duration,void i(e);if(/^data:[^;]+;base64,/.test(n)){for(var o=atob(n.split(",")[1]),t=new Uint8Array(o.length),a=0;a<o.length;++a)t[a]=o.charCodeAt(a);d(t.buffer,e)}else{var _=new XMLHttpRequest;_.open(e._xhr.method,n,!0),_.withCredentials=e._xhr.withCredentials,_.responseType="arraybuffer",e._xhr.headers&&Object.keys(e._xhr.headers).forEach(function(n){_.setRequestHeader(n,e._xhr.headers[n])}),_.onload=function(){var n=(_.status+"")[0];if("0"!==n&&"2"!==n&&"3"!==n)return void e._emit("loaderror",null,"Failed loading audio file with status: "+_.status+".");d(_.response,e)},_.onerror=function(){e._webAudio&&(e._html5=!0,e._webAudio=!1,e._sounds=[],delete r[n],e.load())},u(_)}},u=function(e){try{e.send()}catch(n){e.onerror()}},d=function(e,o){var t=function(){o._emit("loaderror",null,"Decoding audio data failed.")},a=function(e){e&&o._sounds.length>0?(r[o._src]=e,i(o,e)):t()};"undefined"!=typeof Promise&&1===n.ctx.decodeAudioData.length?n.ctx.decodeAudioData(e).then(a).catch(t):n.ctx.decodeAudioData(e,a,t)},i=function(e,n){n&&!e._duration&&(e._duration=n.duration),0===Object.keys(e._sprite).length&&(e._sprite={__default:[0,1e3*e._duration]}),"loaded"!==e._state&&(e._state="loaded",e._emit("load"),e._loadQueue())},_=function(){if(n.usingWebAudio){try{"undefined"!=typeof AudioContext?n.ctx=new AudioContext:"undefined"!=typeof webkitAudioContext?n.ctx=new webkitAudioContext:n.usingWebAudio=!1}catch(e){n.usingWebAudio=!1}n.ctx||(n.usingWebAudio=!1);var e=/iP(hone|od|ad)/.test(n._navigator&&n._navigator.platform),o=n._navigator&&n._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),t=o?parseInt(o[1],10):null;if(e&&t&&t<9){var r=/safari/.test(n._navigator&&n._navigator.userAgent.toLowerCase());n._navigator&&!r&&(n.usingWebAudio=!1)}n.usingWebAudio&&(n.masterGain=void 0===n.ctx.createGain?n.ctx.createGainNode():n.ctx.createGain(),n.masterGain.gain.setValueAtTime(n._muted?0:n._volume,n.ctx.currentTime),n.masterGain.connect(n.ctx.destination)),n._setup()}};"function"==typeof define&&define.amd&&define([],function(){return{blackpard:n,Howl:o}}),"undefined"!=typeof exports&&(exports.blackpard=n,exports.Howl=o),"undefined"!=typeof global?(global.blackpardGlobal=e,global.blackpard=n,global.Howl=o,global.Sound=t):"undefined"!=typeof window&&(window.blackpardGlobal=e,window.blackpard=n,window.Howl=o,window.Sound=t)}();
/*! Spatial Plugin */
!function(){"use strict";blackpardGlobal.prototype._pos=[0,0,0],blackpardGlobal.prototype._orientation=[0,0,-1,0,1,0],blackpardGlobal.prototype.stereo=function(e){var n=this;if(!n.ctx||!n.ctx.listener)return n;for(var t=n._howls.length-1;t>=0;t--)n._howls[t].stereo(e);return n},blackpardGlobal.prototype.pos=function(e,n,t){var r=this;return r.ctx&&r.ctx.listener?(n="number"!=typeof n?r._pos[1]:n,t="number"!=typeof t?r._pos[2]:t,"number"!=typeof e?r._pos:(r._pos=[e,n,t],void 0!==r.ctx.listener.positionX?(r.ctx.listener.positionX.setTargetAtTime(r._pos[0],blackpard.ctx.currentTime,.1),r.ctx.listener.positionY.setTargetAtTime(r._pos[1],blackpard.ctx.currentTime,.1),r.ctx.listener.positionZ.setTargetAtTime(r._pos[2],blackpard.ctx.currentTime,.1)):r.ctx.listener.setPosition(r._pos[0],r._pos[1],r._pos[2]),r)):r},blackpardGlobal.prototype.orientation=function(e,n,t,r,o,i){var a=this;if(!a.ctx||!a.ctx.listener)return a;var p=a._orientation;return n="number"!=typeof n?p[1]:n,t="number"!=typeof t?p[2]:t,r="number"!=typeof r?p[3]:r,o="number"!=typeof o?p[4]:o,i="number"!=typeof i?p[5]:i,"number"!=typeof e?p:(a._orientation=[e,n,t,r,o,i],void 0!==a.ctx.listener.forwardX?(a.ctx.listener.forwardX.setTargetAtTime(e,blackpard.ctx.currentTime,.1),a.ctx.listener.forwardY.setTargetAtTime(n,blackpard.ctx.currentTime,.1),a.ctx.listener.forwardZ.setTargetAtTime(t,blackpard.ctx.currentTime,.1),a.ctx.listener.upX.setTargetAtTime(r,blackpard.ctx.currentTime,.1),a.ctx.listener.upY.setTargetAtTime(o,blackpard.ctx.currentTime,.1),a.ctx.listener.upZ.setTargetAtTime(i,blackpard.ctx.currentTime,.1)):a.ctx.listener.setOrientation(e,n,t,r,o,i),a)},Howl.prototype.init=function(e){return function(n){var t=this;return t._orientation=n.orientation||[1,0,0],t._stereo=n.stereo||null,t._pos=n.pos||null,t._pannerAttr={coneInnerAngle:void 0!==n.coneInnerAngle?n.coneInnerAngle:360,coneOuterAngle:void 0!==n.coneOuterAngle?n.coneOuterAngle:360,coneOuterGain:void 0!==n.coneOuterGain?n.coneOuterGain:0,distanceModel:void 0!==n.distanceModel?n.distanceModel:"inverse",maxDistance:void 0!==n.maxDistance?n.maxDistance:1e4,panningModel:void 0!==n.panningModel?n.panningModel:"HRTF",refDistance:void 0!==n.refDistance?n.refDistance:1,rolloffFactor:void 0!==n.rolloffFactor?n.rolloffFactor:1},t._onstereo=n.onstereo?[{fn:n.onstereo}]:[],t._onpos=n.onpos?[{fn:n.onpos}]:[],t._onorientation=n.onorientation?[{fn:n.onorientation}]:[],e.call(this,n)}}(Howl.prototype.init),Howl.prototype.stereo=function(n,t){var r=this;if(!r._webAudio)return r;if("loaded"!==r._state)return r._queue.push({event:"stereo",action:function(){r.stereo(n,t)}}),r;var o=void 0===blackpard.ctx.createStereoPanner?"spatial":"stereo";if(void 0===t){if("number"!=typeof n)return r._stereo;r._stereo=n,r._pos=[n,0,0]}for(var i=r._getSoundIds(t),a=0;a<i.length;a++){var p=r._soundById(i[a]);if(p){if("number"!=typeof n)return p._stereo;p._stereo=n,p._pos=[n,0,0],p._node&&(p._pannerAttr.panningModel="equalpower",p._panner&&p._panner.pan||e(p,o),"spatial"===o?void 0!==p._panner.positionX?(p._panner.positionX.setValueAtTime(n,blackpard.ctx.currentTime),p._panner.positionY.setValueAtTime(0,blackpard.ctx.currentTime),p._panner.positionZ.setValueAtTime(0,blackpard.ctx.currentTime)):p._panner.setPosition(n,0,0):p._panner.pan.setValueAtTime(n,blackpard.ctx.currentTime)),r._emit("stereo",p._id)}}return r},Howl.prototype.pos=function(n,t,r,o){var i=this;if(!i._webAudio)return i;if("loaded"!==i._state)return i._queue.push({event:"pos",action:function(){i.pos(n,t,r,o)}}),i;if(t="number"!=typeof t?0:t,r="number"!=typeof r?-.5:r,void 0===o){if("number"!=typeof n)return i._pos;i._pos=[n,t,r]}for(var a=i._getSoundIds(o),p=0;p<a.length;p++){var s=i._soundById(a[p]);if(s){if("number"!=typeof n)return s._pos;s._pos=[n,t,r],s._node&&(s._panner&&!s._panner.pan||e(s,"spatial"),void 0!==s._panner.positionX?(s._panner.positionX.setValueAtTime(n,blackpard.ctx.currentTime),s._panner.positionY.setValueAtTime(t,blackpard.ctx.currentTime),s._panner.positionZ.setValueAtTime(r,blackpard.ctx.currentTime)):s._panner.setPosition(n,t,r)),i._emit("pos",s._id)}}return i},Howl.prototype.orientation=function(n,t,r,o){var i=this;if(!i._webAudio)return i;if("loaded"!==i._state)return i._queue.push({event:"orientation",action:function(){i.orientation(n,t,r,o)}}),i;if(t="number"!=typeof t?i._orientation[1]:t,r="number"!=typeof r?i._orientation[2]:r,void 0===o){if("number"!=typeof n)return i._orientation;i._orientation=[n,t,r]}for(var a=i._getSoundIds(o),p=0;p<a.length;p++){var s=i._soundById(a[p]);if(s){if("number"!=typeof n)return s._orientation;s._orientation=[n,t,r],s._node&&(s._panner||(s._pos||(s._pos=i._pos||[0,0,-.5]),e(s,"spatial")),void 0!==s._panner.orientationX?(s._panner.orientationX.setValueAtTime(n,blackpard.ctx.currentTime),s._panner.orientationY.setValueAtTime(t,blackpard.ctx.currentTime),s._panner.orientationZ.setValueAtTime(r,blackpard.ctx.currentTime)):s._panner.setOrientation(n,t,r)),i._emit("orientation",s._id)}}return i},Howl.prototype.pannerAttr=function(){var n,t,r,o=this,i=arguments;if(!o._webAudio)return o;if(0===i.length)return o._pannerAttr;if(1===i.length){if("object"!=typeof i[0])return r=o._soundById(parseInt(i[0],10)),r?r._pannerAttr:o._pannerAttr;n=i[0],void 0===t&&(n.pannerAttr||(n.pannerAttr={coneInnerAngle:n.coneInnerAngle,coneOuterAngle:n.coneOuterAngle,coneOuterGain:n.coneOuterGain,distanceModel:n.distanceModel,maxDistance:n.maxDistance,refDistance:n.refDistance,rolloffFactor:n.rolloffFactor,panningModel:n.panningModel}),o._pannerAttr={coneInnerAngle:void 0!==n.pannerAttr.coneInnerAngle?n.pannerAttr.coneInnerAngle:o._coneInnerAngle,coneOuterAngle:void 0!==n.pannerAttr.coneOuterAngle?n.pannerAttr.coneOuterAngle:o._coneOuterAngle,coneOuterGain:void 0!==n.pannerAttr.coneOuterGain?n.pannerAttr.coneOuterGain:o._coneOuterGain,distanceModel:void 0!==n.pannerAttr.distanceModel?n.pannerAttr.distanceModel:o._distanceModel,maxDistance:void 0!==n.pannerAttr.maxDistance?n.pannerAttr.maxDistance:o._maxDistance,refDistance:void 0!==n.pannerAttr.refDistance?n.pannerAttr.refDistance:o._refDistance,rolloffFactor:void 0!==n.pannerAttr.rolloffFactor?n.pannerAttr.rolloffFactor:o._rolloffFactor,panningModel:void 0!==n.pannerAttr.panningModel?n.pannerAttr.panningModel:o._panningModel})}else 2===i.length&&(n=i[0],t=parseInt(i[1],10));for(var a=o._getSoundIds(t),p=0;p<a.length;p++)if(r=o._soundById(a[p])){var s=r._pannerAttr;s={coneInnerAngle:void 0!==n.coneInnerAngle?n.coneInnerAngle:s.coneInnerAngle,coneOuterAngle:void 0!==n.coneOuterAngle?n.coneOuterAngle:s.coneOuterAngle,coneOuterGain:void 0!==n.coneOuterGain?n.coneOuterGain:s.coneOuterGain,distanceModel:void 0!==n.distanceModel?n.distanceModel:s.distanceModel,maxDistance:void 0!==n.maxDistance?n.maxDistance:s.maxDistance,refDistance:void 0!==n.refDistance?n.refDistance:s.refDistance,rolloffFactor:void 0!==n.rolloffFactor?n.rolloffFactor:s.rolloffFactor,panningModel:void 0!==n.panningModel?n.panningModel:s.panningModel};var c=r._panner;c||(r._pos||(r._pos=o._pos||[0,0,-.5]),e(r,"spatial"),c=r._panner),c.coneInnerAngle=s.coneInnerAngle,c.coneOuterAngle=s.coneOuterAngle,c.coneOuterGain=s.coneOuterGain,c.distanceModel=s.distanceModel,c.maxDistance=s.maxDistance,c.refDistance=s.refDistance,c.rolloffFactor=s.rolloffFactor,c.panningModel=s.panningModel}return o},Sound.prototype.init=function(e){return function(){var n=this,t=n._parent;n._orientation=t._orientation,n._stereo=t._stereo,n._pos=t._pos,n._pannerAttr=t._pannerAttr,e.call(this),n._stereo?t.stereo(n._stereo):n._pos&&t.pos(n._pos[0],n._pos[1],n._pos[2],n._id)}}(Sound.prototype.init),Sound.prototype.reset=function(e){return function(){var n=this,t=n._parent;return n._orientation=t._orientation,n._stereo=t._stereo,n._pos=t._pos,n._pannerAttr=t._pannerAttr,n._stereo?t.stereo(n._stereo):n._pos?t.pos(n._pos[0],n._pos[1],n._pos[2],n._id):n._panner&&(n._panner.disconnect(0),n._panner=void 0,t._refreshBuffer(n)),e.call(this)}}(Sound.prototype.reset);var e=function(e,n){n=n||"spatial","spatial"===n?(e._panner=blackpard.ctx.createPanner(),e._panner.coneInnerAngle=e._pannerAttr.coneInnerAngle,e._panner.coneOuterAngle=e._pannerAttr.coneOuterAngle,e._panner.coneOuterGain=e._pannerAttr.coneOuterGain,e._panner.distanceModel=e._pannerAttr.distanceModel,e._panner.maxDistance=e._pannerAttr.maxDistance,e._panner.refDistance=e._pannerAttr.refDistance,e._panner.rolloffFactor=e._pannerAttr.rolloffFactor,e._panner.panningModel=e._pannerAttr.panningModel,void 0!==e._panner.positionX?(e._panner.positionX.setValueAtTime(e._pos[0],blackpard.ctx.currentTime),e._panner.positionY.setValueAtTime(e._pos[1],blackpard.ctx.currentTime),e._panner.positionZ.setValueAtTime(e._pos[2],blackpard.ctx.currentTime)):e._panner.setPosition(e._pos[0],e._pos[1],e._pos[2]),void 0!==e._panner.orientationX?(e._panner.orientationX.setValueAtTime(e._orientation[0],blackpard.ctx.currentTime),e._panner.orientationY.setValueAtTime(e._orientation[1],blackpard.ctx.currentTime),e._panner.orientationZ.setValueAtTime(e._orientation[2],blackpard.ctx.currentTime)):e._panner.setOrientation(e._orientation[0],e._orientation[1],e._orientation[2])):(e._panner=blackpard.ctx.createStereoPanner(),e._panner.pan.setValueAtTime(e._stereo,blackpard.ctx.currentTime)),e._panner.connect(e._node),e._paused||e._parent.pause(e._id,!0).play(e._id,!0)}}();
!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.S=e()}}(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(_dereq_,module,exports){function count(self,substr){var count=0;var pos=self.indexOf(substr);while(pos>=0){count+=1;pos=self.indexOf(substr,pos+1)}return count}module.exports=count},{}],2:[function(_dereq_,module,exports){function splitLeft(self,sep,maxSplit,limit){if(typeof maxSplit==="undefined"){var maxSplit=-1}var splitResult=self.split(sep);var splitPart1=splitResult.slice(0,maxSplit);var splitPart2=splitResult.slice(maxSplit);if(splitPart2.length===0){splitResult=splitPart1}else{splitResult=splitPart1.concat(splitPart2.join(sep))}if(typeof limit==="undefined"){return splitResult}else if(limit<0){return splitResult.slice(limit)}else{return splitResult.slice(0,limit)}}module.exports=splitLeft},{}],3:[function(_dereq_,module,exports){function splitRight(self,sep,maxSplit,limit){if(typeof maxSplit==="undefined"){var maxSplit=-1}if(typeof limit==="undefined"){var limit=0}var splitResult=[self];for(var i=self.length-1;i>=0;i--){if(splitResult[0].slice(i).indexOf(sep)===0&&(splitResult.length<=maxSplit||maxSplit===-1)){splitResult.splice(1,0,splitResult[0].slice(i+sep.length));splitResult[0]=splitResult[0].slice(0,i)}}if(limit>=0){return splitResult.slice(-limit)}else{return splitResult.slice(0,-limit)}}module.exports=splitRight},{}],4:[function(_dereq_,module,exports){!function(){"use strict";var VERSION="3.3.3";var ENTITIES={};var latin_map={"":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"AA","":"AE","":"AE","":"AE","":"AO","":"AU","":"AV","":"AV","":"AY","":"B","":"B","":"B","":"B","":"B","":"B","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"DZ","":"DZ","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"ET","":"F","":"F","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"D","":"F","":"G","":"R","":"S","":"T","":"IS","":"J","":"J","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"LJ","":"M","":"M","":"M","":"M","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"NJ","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"OI","":"OO","":"E","":"O","":"OU","":"P","":"P","":"P","":"P","":"P","":"P","":"P","":"Q","":"Q","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"C","":"E","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"SS","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"A","":"L","":"M","":"V","":"TZ","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"V","":"V","":"V","":"V","":"VY","":"W","":"W","":"W","":"W","":"W","":"W","":"W","":"X","":"X","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"IJ","":"OE","":"A","":"AE","":"B","":"B","":"C","":"D","":"E","":"F","":"G","":"G","":"H","":"I","":"R","":"J","":"K","":"L","":"L","":"M","":"N","":"O","":"OE","":"O","":"OU","":"P","":"R","":"N","":"R","":"S","":"T","":"E","":"R","":"U","":"V","":"W","":"Y","":"Z","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"aa","":"ae","":"ae","":"ae","":"ao","":"au","":"av","":"av","":"ay","":"b","":"b","":"b","":"b","":"b","":"b","":"b","":"b","":"o","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"i","":"j","":"j","":"j","":"dz","":"dz","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"et","":"f","":"f","":"f","":"f","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"hv","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"d","":"f","":"g","":"r","":"s","":"t","":"is","":"j","":"j","":"j","":"j","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"lj","":"s","":"s","":"s","":"s","":"m","":"m","":"m","":"m","":"m","":"m","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"nj","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"oi","":"oo","":"e","":"e","":"o","":"o","":"ou","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"q","":"q","":"q","":"q","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"c","":"c","":"e","":"r","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"g","":"ss","":"o","":"o","":"u","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"th","":"a","":"ae","":"e","":"g","":"h","":"h","":"h","":"i","":"k","":"l","":"m","":"m","":"oe","":"r","":"r","":"r","":"r","":"t","":"v","":"w","":"y","":"tz","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"ue","":"um","":"v","":"v","":"v","":"v","":"v","":"v","":"v","":"vy","":"w","":"w","":"w","":"w","":"w","":"w","":"w","":"w","":"x","":"x","":"x","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"ff","":"ffi","":"ffl","":"fi","":"fl","":"ij","":"oe","":"st","":"a","":"e","":"i","":"j","":"o","":"r","":"u","":"v","":"x"};function initialize(object,s){if(s!==null&&s!==undefined){if(typeof s==="string")object.s=s;else object.s=s.toString()}else{object.s=s}object.orig=s;if(s!==null&&s!==undefined){if(object.__defineGetter__){object.__defineGetter__("length",function(){return object.s.length})}else{object.length=s.length}}else{object.length=-1}}function S(s){initialize(this,s)}var __nsp=String.prototype;var __sp=S.prototype={between:function(left,right){var s=this.s;var startPos=s.indexOf(left);var endPos=s.indexOf(right,startPos+left.length);if(endPos==-1&&right!=null)return new this.constructor("");else if(endPos==-1&&right==null)return new this.constructor(s.substring(startPos+left.length));else return new this.constructor(s.slice(startPos+left.length,endPos))},camelize:function(){var s=this.trim().s.replace(/(\-|_|\s)+(.)?/g,function(mathc,sep,c){return c?c.toUpperCase():""});return new this.constructor(s)},capitalize:function(){return new this.constructor(this.s.substr(0,1).toUpperCase()+this.s.substring(1).toLowerCase())},charAt:function(index){return this.s.charAt(index)},chompLeft:function(prefix){var s=this.s;if(s.indexOf(prefix)===0){s=s.slice(prefix.length);return new this.constructor(s)}else{return this}},chompRight:function(suffix){if(this.endsWith(suffix)){var s=this.s;s=s.slice(0,s.length-suffix.length);return new this.constructor(s)}else{return this}},collapseWhitespace:function(){var s=this.s.replace(/[\s\xa0]+/g," ").replace(/^\s+|\s+$/g,"");return new this.constructor(s)},contains:function(ss){return this.s.indexOf(ss)>=0},count:function(ss){return _dereq_("./_count")(this.s,ss)},dasherize:function(){var s=this.trim().s.replace(/[_\s]+/g,"-").replace(/([A-Z])/g,"-$1").replace(/-+/g,"-").toLowerCase();return new this.constructor(s)},equalsIgnoreCase:function(prefix){var s=this.s;return s.toLowerCase()==prefix.toLowerCase()},latinise:function(){var s=this.replace(/[^A-Za-z0-9\[\] ]/g,function(x){return latin_map[x]||x});return new this.constructor(s)},decodeHtmlEntities:function(){var s=this.s;s=s.replace(/&#(\d+);?/g,function(_,code){return String.fromCharCode(code)}).replace(/&#[xX]([A-Fa-f0-9]+);?/g,function(_,hex){return String.fromCharCode(parseInt(hex,16))}).replace(/&([^;\W]+;?)/g,function(m,e){var ee=e.replace(/;$/,"");var target=ENTITIES[e]||e.match(/;$/)&&ENTITIES[ee];if(typeof target==="number"){return String.fromCharCode(target)}else if(typeof target==="string"){return target}else{return m}});return new this.constructor(s)},endsWith:function(){var suffixes=Array.prototype.slice.call(arguments,0);for(var i=0;i<suffixes.length;++i){var l=this.s.length-suffixes[i].length;if(l>=0&&this.s.indexOf(suffixes[i],l)===l)return true}return false},escapeHTML:function(){return new this.constructor(this.s.replace(/[&<>"']/g,function(m){return"&"+reversedEscapeChars[m]+";"}))},ensureLeft:function(prefix){var s=this.s;if(s.indexOf(prefix)===0){return this}else{return new this.constructor(prefix+s)}},ensureRight:function(suffix){var s=this.s;if(this.endsWith(suffix)){return this}else{return new this.constructor(s+suffix)}},humanize:function(){if(this.s===null||this.s===undefined)return new this.constructor("");var s=this.underscore().replace(/_id$/,"").replace(/_/g," ").trim().capitalize();return new this.constructor(s)},isAlpha:function(){return!/[^a-z\xDF-\xFF]|^$/.test(this.s.toLowerCase())},isAlphaNumeric:function(){return!/[^0-9a-z\xDF-\xFF]/.test(this.s.toLowerCase())},isEmpty:function(){return this.s===null||this.s===undefined?true:/^[\s\xa0]*$/.test(this.s)},isLower:function(){return this.isAlpha()&&this.s.toLowerCase()===this.s},isNumeric:function(){return!/[^0-9]/.test(this.s)},isUpper:function(){return this.isAlpha()&&this.s.toUpperCase()===this.s},left:function(N){if(N>=0){var s=this.s.substr(0,N);return new this.constructor(s)}else{return this.right(-N)}},lines:function(){return this.replaceAll("\r\n","\n").s.split("\n")},pad:function(len,ch){if(ch==null)ch=" ";if(this.s.length>=len)return new this.constructor(this.s);len=len-this.s.length;var left=Array(Math.ceil(len/2)+1).join(ch);var right=Array(Math.floor(len/2)+1).join(ch);return new this.constructor(left+this.s+right)},padLeft:function(len,ch){if(ch==null)ch=" ";if(this.s.length>=len)return new this.constructor(this.s);return new this.constructor(Array(len-this.s.length+1).join(ch)+this.s)},padRight:function(len,ch){if(ch==null)ch=" ";if(this.s.length>=len)return new this.constructor(this.s);return new this.constructor(this.s+Array(len-this.s.length+1).join(ch))},parseCSV:function(delimiter,qualifier,escape,lineDelimiter){delimiter=delimiter||",";escape=escape||"\\";if(typeof qualifier=="undefined")qualifier='"';var i=0,fieldBuffer=[],fields=[],len=this.s.length,inField=false,inUnqualifiedString=false,self=this;var ca=function(i){return self.s.charAt(i)};if(typeof lineDelimiter!=="undefined")var rows=[];if(!qualifier)inField=true;while(i<len){var current=ca(i);switch(current){case escape:if(inField&&(escape!==qualifier||ca(i+1)===qualifier)){i+=1;fieldBuffer.push(ca(i));break}if(escape!==qualifier)break;case qualifier:inField=!inField;break;case delimiter:if(inUnqualifiedString){inField=false;inUnqualifiedString=false}if(inField&&qualifier)fieldBuffer.push(current);else{fields.push(fieldBuffer.join(""));fieldBuffer.length=0}break;case lineDelimiter:if(inUnqualifiedString){inField=false;inUnqualifiedString=false;fields.push(fieldBuffer.join(""));rows.push(fields);fields=[];fieldBuffer.length=0}else if(inField){fieldBuffer.push(current)}else{if(rows){fields.push(fieldBuffer.join(""));rows.push(fields);fields=[];fieldBuffer.length=0}}break;case" ":if(inField)fieldBuffer.push(current);break;default:if(inField)fieldBuffer.push(current);else if(current!==qualifier){fieldBuffer.push(current);inField=true;inUnqualifiedString=true}break}i+=1}fields.push(fieldBuffer.join(""));if(rows){rows.push(fields);return rows}return fields},replaceAll:function(ss,r){var s=this.s.split(ss).join(r);return new this.constructor(s)},splitLeft:function(sep,maxSplit,limit){return _dereq_("./_splitLeft")(this.s,sep,maxSplit,limit)},splitRight:function(sep,maxSplit,limit){return _dereq_("./_splitRight")(this.s,sep,maxSplit,limit)},strip:function(){var ss=this.s;for(var i=0,n=arguments.length;i<n;i++){ss=ss.split(arguments[i]).join("")}return new this.constructor(ss)},stripLeft:function(chars){var regex;var pattern;var ss=ensureString(this.s);if(chars===undefined){pattern=/^\s+/g}else{regex=escapeRegExp(chars);pattern=new RegExp("^["+regex+"]+","g")}return new this.constructor(ss.replace(pattern,""))},stripRight:function(chars){var regex;var pattern;var ss=ensureString(this.s);if(chars===undefined){pattern=/\s+$/g}else{regex=escapeRegExp(chars);pattern=new RegExp("["+regex+"]+$","g")}return new this.constructor(ss.replace(pattern,""))},right:function(N){if(N>=0){var s=this.s.substr(this.s.length-N,N);return new this.constructor(s)}else{return this.left(-N)}},setValue:function(s){initialize(this,s);return this},slugify:function(){var sl=new S(new S(this.s).latinise().s.replace(/[^\w\s-]/g,"").toLowerCase()).dasherize().s;if(sl.charAt(0)==="-")sl=sl.substr(1);return new this.constructor(sl)},startsWith:function(){var prefixes=Array.prototype.slice.call(arguments,0);for(var i=0;i<prefixes.length;++i){if(this.s.lastIndexOf(prefixes[i],0)===0)return true}return false},stripPunctuation:function(){return new this.constructor(this.s.replace(/[^\w\s]|_/g,"").replace(/\s+/g," "))},stripTags:function(){var s=this.s,args=arguments.length>0?arguments:[""];multiArgs(args,function(tag){s=s.replace(RegExp("</?"+tag+"[^<>]*>","gi"),"")});return new this.constructor(s)},template:function(values,opening,closing){var s=this.s;var opening=opening||Export.TMPL_OPEN;var closing=closing||Export.TMPL_CLOSE;var open=opening.replace(/[-[\]()*\s]/g,"\\$&").replace(/\$/g,"\\$");var close=closing.replace(/[-[\]()*\s]/g,"\\$&").replace(/\$/g,"\\$");var r=new RegExp(open+"(.+?)"+close,"g");var matches=s.match(r)||[];matches.forEach(function(match){var key=match.substring(opening.length,match.length-closing.length).trim();var value=typeof values[key]=="undefined"?"":values[key];s=s.replace(match,value)});return new this.constructor(s)},times:function(n){return new this.constructor(new Array(n+1).join(this.s))},titleCase:function(){var s=this.s;if(s){s=s.replace(/(^[a-z]| [a-z]|-[a-z]|_[a-z])/g,function($1){return $1.toUpperCase()})}return new this.constructor(s)},toBoolean:function(){if(typeof this.orig==="string"){var s=this.s.toLowerCase();return s==="true"||s==="yes"||s==="on"||s==="1"}else return this.orig===true||this.orig===1},toFloat:function(precision){var num=parseFloat(this.s);if(precision)return parseFloat(num.toFixed(precision));else return num},toInt:function(){return/^\s*-?0x/i.test(this.s)?parseInt(this.s,16):parseInt(this.s,10)},trim:function(){var s;if(typeof __nsp.trim==="undefined")s=this.s.replace(/(^\s*|\s*$)/g,"");else s=this.s.trim();return new this.constructor(s)},trimLeft:function(){var s;if(__nsp.trimLeft)s=this.s.trimLeft();else s=this.s.replace(/(^\s*)/g,"");return new this.constructor(s)},trimRight:function(){var s;if(__nsp.trimRight)s=this.s.trimRight();else s=this.s.replace(/\s+$/,"");return new this.constructor(s)},truncate:function(length,pruneStr){var str=this.s;length=~~length;pruneStr=pruneStr||"...";if(str.length<=length)return new this.constructor(str);var tmpl=function(c){return c.toUpperCase()!==c.toLowerCase()?"A":" "},template=str.slice(0,length+1).replace(/.(?=\W*\w*$)/g,tmpl);if(template.slice(template.length-2).match(/\w\w/))template=template.replace(/\s*\S+$/,"");else template=new S(template.slice(0,template.length-1)).trimRight().s;return(template+pruneStr).length>str.length?new S(str):new S(str.slice(0,template.length)+pruneStr)},toCSV:function(){var delim=",",qualifier='"',escape="\\",encloseNumbers=true,keys=false;var dataArray=[];function hasVal(it){return it!==null&&it!==""}if(typeof arguments[0]==="object"){delim=arguments[0].delimiter||delim;delim=arguments[0].separator||delim;qualifier=arguments[0].qualifier||qualifier;encloseNumbers=!!arguments[0].encloseNumbers;escape=arguments[0].escape||escape;keys=!!arguments[0].keys}else if(typeof arguments[0]==="string"){delim=arguments[0]}if(typeof arguments[1]==="string")qualifier=arguments[1];if(arguments[1]===null)qualifier=null;if(this.orig instanceof Array)dataArray=this.orig;else{for(var key in this.orig)if(this.orig.hasOwnProperty(key))if(keys)dataArray.push(key);else dataArray.push(this.orig[key])}var rep=escape+qualifier;var buildString=[];for(var i=0;i<dataArray.length;++i){var shouldQualify=hasVal(qualifier);if(typeof dataArray[i]=="number")shouldQualify&=encloseNumbers;if(shouldQualify)buildString.push(qualifier);if(dataArray[i]!==null&&dataArray[i]!==undefined){var d=new S(dataArray[i]).replaceAll(qualifier,rep).s;buildString.push(d)}else buildString.push("");if(shouldQualify)buildString.push(qualifier);if(delim)buildString.push(delim)}buildString.length=buildString.length-1;return new this.constructor(buildString.join(""))},toString:function(){return this.s},underscore:function(){var s=this.trim().s.replace(/([a-z\d])([A-Z]+)/g,"$1_$2").replace(/([A-Z\d]+)([A-Z][a-z])/g,"$1_$2").replace(/[-\s]+/g,"_").toLowerCase();return new this.constructor(s)},unescapeHTML:function(){return new this.constructor(this.s.replace(/\&([^;]+);/g,function(entity,entityCode){var match;if(entityCode in escapeChars){return escapeChars[entityCode]}else if(match=entityCode.match(/^#x([\da-fA-F]+)$/)){return String.fromCharCode(parseInt(match[1],16))}else if(match=entityCode.match(/^#(\d+)$/)){return String.fromCharCode(~~match[1])}else{return entity}}))},valueOf:function(){return this.s.valueOf()},wrapHTML:function(tagName,tagAttrs){var s=this.s,el=tagName==null?"span":tagName,elAttr="",wrapped="";if(typeof tagAttrs=="object")for(var prop in tagAttrs)elAttr+=" "+prop+'="'+new this.constructor(tagAttrs[prop]).escapeHTML()+'"';s=wrapped.concat("<",el,elAttr,">",this,"</",el,">");return new this.constructor(s)}};var methodsAdded=[];function extendPrototype(){for(var name in __sp){(function(name){var func=__sp[name];if(!__nsp.hasOwnProperty(name)){methodsAdded.push(name);__nsp[name]=function(){String.prototype.s=this;return func.apply(this,arguments)}}})(name)}}function restorePrototype(){for(var i=0;i<methodsAdded.length;++i)delete String.prototype[methodsAdded[i]];methodsAdded.length=0}var nativeProperties=getNativeStringProperties();for(var name in nativeProperties){(function(name){var stringProp=__nsp[name];if(typeof stringProp=="function"){if(!__sp[name]){if(nativeProperties[name]==="string"){__sp[name]=function(){return new this.constructor(stringProp.apply(this,arguments))}}else{__sp[name]=stringProp}}}})(name)}__sp.repeat=__sp.times;__sp.include=__sp.contains;__sp.toInteger=__sp.toInt;__sp.toBool=__sp.toBoolean;__sp.decodeHTMLEntities=__sp.decodeHtmlEntities;__sp.constructor=S;function getNativeStringProperties(){var names=getNativeStringPropertyNames();var retObj={};for(var i=0;i<names.length;++i){var name=names[i];if(name==="to"||name==="toEnd")continue;var func=__nsp[name];try{var type=typeof func.apply("teststring");retObj[name]=type}catch(e){}}return retObj}function getNativeStringPropertyNames(){var results=[];if(Object.getOwnPropertyNames){results=Object.getOwnPropertyNames(__nsp);results.splice(results.indexOf("valueOf"),1);results.splice(results.indexOf("toString"),1);return results}else{var stringNames={};var objectNames=[];for(var name in String.prototype)stringNames[name]=name;for(var name in Object.prototype)delete stringNames[name];for(var name in stringNames){results.push(name)}return results}}function Export(str){return new S(str)}Export.extendPrototype=extendPrototype;Export.restorePrototype=restorePrototype;Export.VERSION=VERSION;Export.TMPL_OPEN="{{";Export.TMPL_CLOSE="}}";Export.ENTITIES=ENTITIES;if(typeof module!=="undefined"&&typeof module.exports!=="undefined"){module.exports=Export}else{if(typeof define==="function"&&define.amd){define([],function(){return Export})}else{window.S=Export}}function multiArgs(args,fn){var result=[],i;for(i=0;i<args.length;i++){result.push(args[i]);if(fn)fn.call(args,args[i],i)}return result}var escapeChars={lt:"<",gt:">",quot:'"',apos:"'",amp:"&"};function escapeRegExp(s){var c;var i;var ret=[];var re=/^[A-Za-z0-9]+$/;s=ensureString(s);for(i=0;i<s.length;++i){c=s.charAt(i);if(re.test(c)){ret.push(c)}else{if(c==="\\000"){ret.push("\\000")}else{ret.push("\\"+c)}}}return ret.join("")}function ensureString(string){return string==null?"":""+string}var reversedEscapeChars={};for(var key in escapeChars){reversedEscapeChars[escapeChars[key]]=key}ENTITIES={amp:"&",gt:">",lt:"<",quot:'"',apos:"'",AElig:198,Aacute:193,Acirc:194,Agrave:192,Aring:197,Atilde:195,Auml:196,Ccedil:199,ETH:208,Eacute:201,Ecirc:202,Egrave:200,Euml:203,Iacute:205,Icirc:206,Igrave:204,Iuml:207,Ntilde:209,Oacute:211,Ocirc:212,Ograve:210,Oslash:216,Otilde:213,Ouml:214,THORN:222,Uacute:218,Ucirc:219,Ugrave:217,Uuml:220,Yacute:221,aacute:225,acirc:226,aelig:230,agrave:224,aring:229,atilde:227,auml:228,ccedil:231,eacute:233,ecirc:234,egrave:232,eth:240,euml:235,iacute:237,icirc:238,igrave:236,iuml:239,ntilde:241,oacute:243,ocirc:244,ograve:242,oslash:248,otilde:245,ouml:246,szlig:223,thorn:254,uacute:250,ucirc:251,ugrave:249,uuml:252,yacute:253,yuml:255,copy:169,reg:174,nbsp:160,iexcl:161,cent:162,pound:163,curren:164,yen:165,brvbar:166,sect:167,uml:168,ordf:170,laquo:171,not:172,shy:173,macr:175,deg:176,plusmn:177,sup1:185,sup2:178,sup3:179,acute:180,micro:181,para:182,middot:183,cedil:184,ordm:186,raquo:187,frac14:188,frac12:189,frac34:190,iquest:191,times:215,divide:247,"OElig;":338,"oelig;":339,"Scaron;":352,"scaron;":353,"Yuml;":376,"fnof;":402,"circ;":710,"tilde;":732,"Alpha;":913,"Beta;":914,"Gamma;":915,"Delta;":916,"Epsilon;":917,"Zeta;":918,"Eta;":919,"Theta;":920,"Iota;":921,"Kappa;":922,"Lambda;":923,"Mu;":924,"Nu;":925,"Xi;":926,"Omicron;":927,"Pi;":928,"Rho;":929,"Sigma;":931,"Tau;":932,"Upsilon;":933,"Phi;":934,"Chi;":935,"Psi;":936,"Omega;":937,"alpha;":945,"beta;":946,"gamma;":947,"delta;":948,"epsilon;":949,"zeta;":950,"eta;":951,"theta;":952,"iota;":953,"kappa;":954,"lambda;":955,"mu;":956,"nu;":957,"xi;":958,"omicron;":959,"pi;":960,"rho;":961,"sigmaf;":962,"sigma;":963,"tau;":964,"upsilon;":965,"phi;":966,"chi;":967,"psi;":968,"omega;":969,"thetasym;":977,"upsih;":978,"piv;":982,"ensp;":8194,"emsp;":8195,"thinsp;":8201,"zwnj;":8204,"zwj;":8205,"lrm;":8206,"rlm;":8207,"ndash;":8211,"mdash;":8212,"lsquo;":8216,"rsquo;":8217,"sbquo;":8218,"ldquo;":8220,"rdquo;":8221,"bdquo;":8222,"dagger;":8224,"Dagger;":8225,"bull;":8226,"hellip;":8230,"permil;":8240,"prime;":8242,"Prime;":8243,"lsaquo;":8249,"rsaquo;":8250,"oline;":8254,"frasl;":8260,"euro;":8364,"image;":8465,"weierp;":8472,"real;":8476,"trade;":8482,"alefsym;":8501,"larr;":8592,"uarr;":8593,"rarr;":8594,"darr;":8595,"harr;":8596,"crarr;":8629,"lArr;":8656,"uArr;":8657,"rArr;":8658,"dArr;":8659,"hArr;":8660,"forall;":8704,"part;":8706,"exist;":8707,"empty;":8709,"nabla;":8711,"isin;":8712,"notin;":8713,"ni;":8715,"prod;":8719,"sum;":8721,"minus;":8722,"lowast;":8727,"radic;":8730,"prop;":8733,"infin;":8734,"ang;":8736,"and;":8743,"or;":8744,"cap;":8745,"cup;":8746,"int;":8747,"there4;":8756,"sim;":8764,"cong;":8773,"asymp;":8776,"ne;":8800,"equiv;":8801,"le;":8804,"ge;":8805,"sub;":8834,"sup;":8835,"nsub;":8836,"sube;":8838,"supe;":8839,"oplus;":8853,"otimes;":8855,"perp;":8869,"sdot;":8901,"lceil;":8968,"rceil;":8969,"lfloor;":8970,"rfloor;":8971,"lang;":9001,"rang;":9002,"loz;":9674,"spades;":9824,"clubs;":9827,"hearts;":9829,"diams;":9830}}.call(this)},{"./_count":1,"./_splitLeft":2,"./_splitRight":3}]},{},[4])(4)});

!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).blackpard=e()}(this,(function(){"use strict";var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",c="month",f="quarter",h="year",d="date",l="Invalid Date",$=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(t){var e=["th","st","nd","rd"],n=t%100;return"["+t+(e[(n-20)%10]||e[n]||e[0])+"]"}},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},g="en",D={};D[g]=M;var p="$isblackpardObject",S=function(t){return t instanceof _||!(!t||!t[p])},w=function t(e,n,r){var i;if(!e)return g;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(g=i),i||!r&&g},O=function(t,e){if(S(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=w(t.locale,null,!0),this.parse(t),this.$x=this.$x||t.x||{},this[p]=!0}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return b},m.isValid=function(){return!(this.$d.toString()===l)},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return O(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<O(t)},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return b.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v="set"+(this.$u?"UTC":"");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+"Hours",0);case u:return $(v+"Minutes",1);case s:return $(v+"Seconds",2);case i:return $(v+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=b.p(t),f="set"+(this.$u?"UTC":""),l=(n={},n[a]=f+"Date",n[d]=f+"Date",n[c]=f+"Month",n[h]=f+"FullYear",n[u]=f+"Hours",n[s]=f+"Minutes",n[i]=f+"Seconds",n[r]=f+"Milliseconds",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[b.p(t)]()},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l)};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},d=function(t){return b.s(s%12||12,t,"0")},$=f||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r};return r.replace(y,(function(t,r){return r||function(t){switch(t){case"YY":return String(e.$y).slice(-2);case"YYYY":return b.s(e.$y,4,"0");case"M":return a+1;case"MM":return b.s(a+1,2,"0");case"MMM":return h(n.monthsShort,a,c,3);case"MMMM":return h(c,a);case"D":return e.$D;case"DD":return b.s(e.$D,2,"0");case"d":return String(e.$W);case"dd":return h(n.weekdaysMin,e.$W,o,2);case"ddd":return h(n.weekdaysShort,e.$W,o,3);case"dddd":return o[e.$W];case"H":return String(s);case"HH":return b.s(s,2,"0");case"h":return d(1);case"hh":return d(2);case"a":return $(s,u,!0);case"A":return $(s,u,!1);case"m":return String(u);case"mm":return b.s(u,2,"0");case"s":return String(e.$s);case"ss":return b.s(e.$s,2,"0");case"SSS":return b.s(e.$ms,3,"0");case"Z":return i}return null}(t)||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function(){return b.m(y,m)};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g}return l?$:b.a($)},m.daysInMonth=function(){return this.endOf(c).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return b.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),k=_.prototype;return O.prototype=k,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",c],["$y",h],["$D",d]].forEach((function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=!0),O},O.locale=w,O.isblackpard=S,O.unix=function(t){return O(1e3*t)},O.en=D[g],O.Ls=D,O.p={},O}));

/**
 * blackpard.js v7.0.0 - Lightweight fuzzy-search (http://blackpardjs.io)
 *
 * Copyright (c) 2023 Kiro Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.blackpard = factory());
})(this, (function () { 'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  function isArray(value) {
    return !Array.isArray ? getTag(value) === '[object Array]' : Array.isArray(value);
  }

  // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js
  var INFINITY = 1 / 0;
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }
  function toString(value) {
    return value == null ? '' : baseToString(value);
  }
  function isString(value) {
    return typeof value === 'string';
  }
  function isNumber(value) {
    return typeof value === 'number';
  }

  // Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js
  function isBoolean(value) {
    return value === true || value === false || isObjectLike(value) && getTag(value) == '[object Boolean]';
  }
  function isObject(value) {
    return _typeof(value) === 'object';
  }

  // Checks if `value` is object-like.
  function isObjectLike(value) {
    return isObject(value) && value !== null;
  }
  function isDefined(value) {
    return value !== undefined && value !== null;
  }
  function isBlank(value) {
    return !value.trim().length;
  }

  // Gets the `toStringTag` of `value`.
  // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js
  function getTag(value) {
    return value == null ? value === undefined ? '[object Undefined]' : '[object Null]' : Object.prototype.toString.call(value);
  }

  var EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';
  var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
  var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = function LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key) {
    return "Invalid value for key ".concat(key);
  };
  var PATTERN_LENGTH_TOO_LARGE = function PATTERN_LENGTH_TOO_LARGE(max) {
    return "Pattern length exceeds max of ".concat(max, ".");
  };
  var MISSING_KEY_PROPERTY = function MISSING_KEY_PROPERTY(name) {
    return "Missing ".concat(name, " property in key");
  };
  var INVALID_KEY_WEIGHT_VALUE = function INVALID_KEY_WEIGHT_VALUE(key) {
    return "Property 'weight' in key '".concat(key, "' must be a positive integer");
  };

  var hasOwn = Object.prototype.hasOwnProperty;
  var KeyStore = /*#__PURE__*/function () {
    function KeyStore(keys) {
      var _this = this;
      _classCallCheck(this, KeyStore);
      this._keys = [];
      this._keyMap = {};
      var totalWeight = 0;
      keys.forEach(function (key) {
        var obj = createKey(key);
        _this._keys.push(obj);
        _this._keyMap[obj.id] = obj;
        totalWeight += obj.weight;
      });

      // Normalize weights so that their sum is equal to 1
      this._keys.forEach(function (key) {
        key.weight /= totalWeight;
      });
    }
    _createClass(KeyStore, [{
      key: "get",
      value: function get(keyId) {
        return this._keyMap[keyId];
      }
    }, {
      key: "keys",
      value: function keys() {
        return this._keys;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return JSON.stringify(this._keys);
      }
    }]);
    return KeyStore;
  }();
  function createKey(key) {
    var path = null;
    var id = null;
    var src = null;
    var weight = 1;
    var getFn = null;
    if (isString(key) || isArray(key)) {
      src = key;
      path = createKeyPath(key);
      id = createKeyId(key);
    } else {
      if (!hasOwn.call(key, 'name')) {
        throw new Error(MISSING_KEY_PROPERTY('name'));
      }
      var name = key.name;
      src = name;
      if (hasOwn.call(key, 'weight')) {
        weight = key.weight;
        if (weight <= 0) {
          throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
        }
      }
      path = createKeyPath(name);
      id = createKeyId(name);
      getFn = key.getFn;
    }
    return {
      path: path,
      id: id,
      weight: weight,
      src: src,
      getFn: getFn
    };
  }
  function createKeyPath(key) {
    return isArray(key) ? key : key.split('.');
  }
  function createKeyId(key) {
    return isArray(key) ? key.join('.') : key;
  }

  function get(obj, path) {
    var list = [];
    var arr = false;
    var deepGet = function deepGet(obj, path, index) {
      if (!isDefined(obj)) {
        return;
      }
      if (!path[index]) {
        // If there's no path left, we've arrived at the object we care about.
        list.push(obj);
      } else {
        var key = path[index];
        var value = obj[key];
        if (!isDefined(value)) {
          return;
        }

        // If we're at the last value in the path, and if it's a string/number/bool,
        // add it to the list
        if (index === path.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
          list.push(toString(value));
        } else if (isArray(value)) {
          arr = true;
          // Search each item in the array.
          for (var i = 0, len = value.length; i < len; i += 1) {
            deepGet(value[i], path, index + 1);
          }
        } else if (path.length) {
          // An object. Recurse further.
          deepGet(value, path, index + 1);
        }
      }
    };

    // Backwards compatibility (since path used to be a string)
    deepGet(obj, isString(path) ? path.split('.') : path, 0);
    return arr ? list : list[0];
  }

  var MatchOptions = {
    // Whether the matches should be included in the result set. When `true`, each record in the result
    // set will include the indices of the matched characters.
    // These can consequently be used for highlighting purposes.
    includeMatches: false,
    // When `true`, the matching function will continue to the end of a search pattern even if
    // a perfect match has already been located in the string.
    findAllMatches: false,
    // Minimum number of characters that must be matched before a result is considered a match
    minMatchCharLength: 1
  };
  var BasicOptions = {
    // When `true`, the algorithm continues searching to the end of the input even if a perfect
    // match is found before the end of the same input.
    isCaseSensitive: false,
    // When true, the matching function will continue to the end of a search pattern even if
    includeScore: false,
    // List of properties that will be searched. This also supports nested properties.
    keys: [],
    // Whether to sort the result list, by score
    shouldSort: true,
    // Default sort function: sort by ascending score, ascending index
    sortFn: function sortFn(a, b) {
      return a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1;
    }
  };
  var FuzzyOptions = {
    // Approximately where in the text is the pattern expected to be found?
    location: 0,
    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
    // (of both letters and location), a threshold of '1.0' would match anything.
    threshold: 0.6,
    // Determines how close the match must be to the fuzzy location (specified above).
    // An exact letter match which is 'distance' characters away from the fuzzy location
    // would score as a complete mismatch. A distance of '0' requires the match be at
    // the exact location specified, a threshold of '1000' would require a perfect match
    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
    distance: 100
  };
  var AdvancedOptions = {
    // When `true`, it enables the use of unix-like search commands
    useExtendedSearch: false,
    // The get function to use when fetching an object's properties.
    // The default will search nested paths *ie foo.bar.baz*
    getFn: get,
    // When `true`, search will ignore `location` and `distance`, so it won't matter
    // where in the string the pattern appears.
    // More info: https://blackpardjs.io/concepts/scoring-theory.html#fuzziness-score
    ignoreLocation: false,
    // When `true`, the calculation for the relevance score (used for sorting) will
    // ignore the field-length norm.
    // More info: https://blackpardjs.io/concepts/scoring-theory.html#field-length-norm
    ignoreFieldNorm: false,
    // The weight to determine how much field length norm effects scoring.
    fieldNormWeight: 1
  };
  var Config = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, BasicOptions), MatchOptions), FuzzyOptions), AdvancedOptions);

  var SPACE = /[^ ]+/g;

  // Field-length norm: the shorter the field, the higher the weight.
  // Set to 3 decimals to reduce index size.
  function norm() {
    var weight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var mantissa = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
    var cache = new Map();
    var m = Math.pow(10, mantissa);
    return {
      get: function get(value) {
        var numTokens = value.match(SPACE).length;
        if (cache.has(numTokens)) {
          return cache.get(numTokens);
        }

        // Default function is 1/sqrt(x), weight makes that variable
        var norm = 1 / Math.pow(numTokens, 0.5 * weight);

        // In place of `toFixed(mantissa)`, for faster computation
        var n = parseFloat(Math.round(norm * m) / m);
        cache.set(numTokens, n);
        return n;
      },
      clear: function clear() {
        cache.clear();
      }
    };
  }

  var blackpardIndex = /*#__PURE__*/function () {
    function blackpardIndex() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$getFn = _ref.getFn,
        getFn = _ref$getFn === void 0 ? Config.getFn : _ref$getFn,
        _ref$fieldNormWeight = _ref.fieldNormWeight,
        fieldNormWeight = _ref$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref$fieldNormWeight;
      _classCallCheck(this, blackpardIndex);
      this.norm = norm(fieldNormWeight, 3);
      this.getFn = getFn;
      this.isCreated = false;
      this.setIndexRecords();
    }
    _createClass(blackpardIndex, [{
      key: "setSources",
      value: function setSources() {
        var docs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        this.docs = docs;
      }
    }, {
      key: "setIndexRecords",
      value: function setIndexRecords() {
        var records = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        this.records = records;
      }
    }, {
      key: "setKeys",
      value: function setKeys() {
        var _this = this;
        var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        this.keys = keys;
        this._keysMap = {};
        keys.forEach(function (key, idx) {
          _this._keysMap[key.id] = idx;
        });
      }
    }, {
      key: "create",
      value: function create() {
        var _this2 = this;
        if (this.isCreated || !this.docs.length) {
          return;
        }
        this.isCreated = true;

        // List is Array<String>
        if (isString(this.docs[0])) {
          this.docs.forEach(function (doc, docIndex) {
            _this2._addString(doc, docIndex);
          });
        } else {
          // List is Array<Object>
          this.docs.forEach(function (doc, docIndex) {
            _this2._addObject(doc, docIndex);
          });
        }
        this.norm.clear();
      }
      // Adds a doc to the end of the index
    }, {
      key: "add",
      value: function add(doc) {
        var idx = this.size();
        if (isString(doc)) {
          this._addString(doc, idx);
        } else {
          this._addObject(doc, idx);
        }
      }
      // Removes the doc at the specified index of the index
    }, {
      key: "removeAt",
      value: function removeAt(idx) {
        this.records.splice(idx, 1);

        // Change ref index of every subsquent doc
        for (var i = idx, len = this.size(); i < len; i += 1) {
          this.records[i].i -= 1;
        }
      }
    }, {
      key: "getValueForItemAtKeyId",
      value: function getValueForItemAtKeyId(item, keyId) {
        return item[this._keysMap[keyId]];
      }
    }, {
      key: "size",
      value: function size() {
        return this.records.length;
      }
    }, {
      key: "_addString",
      value: function _addString(doc, docIndex) {
        if (!isDefined(doc) || isBlank(doc)) {
          return;
        }
        var record = {
          v: doc,
          i: docIndex,
          n: this.norm.get(doc)
        };
        this.records.push(record);
      }
    }, {
      key: "_addObject",
      value: function _addObject(doc, docIndex) {
        var _this3 = this;
        var record = {
          i: docIndex,
          $: {}
        };

        // Iterate over every key (i.e, path), and fetch the value at that key
        this.keys.forEach(function (key, keyIndex) {
          var value = key.getFn ? key.getFn(doc) : _this3.getFn(doc, key.path);
          if (!isDefined(value)) {
            return;
          }
          if (isArray(value)) {
            var subRecords = [];
            var stack = [{
              nestedArrIndex: -1,
              value: value
            }];
            while (stack.length) {
              var _stack$pop = stack.pop(),
                nestedArrIndex = _stack$pop.nestedArrIndex,
                _value = _stack$pop.value;
              if (!isDefined(_value)) {
                continue;
              }
              if (isString(_value) && !isBlank(_value)) {
                var subRecord = {
                  v: _value,
                  i: nestedArrIndex,
                  n: _this3.norm.get(_value)
                };
                subRecords.push(subRecord);
              } else if (isArray(_value)) {
                _value.forEach(function (item, k) {
                  stack.push({
                    nestedArrIndex: k,
                    value: item
                  });
                });
              } else ;
            }
            record.$[keyIndex] = subRecords;
          } else if (isString(value) && !isBlank(value)) {
            var _subRecord = {
              v: value,
              n: _this3.norm.get(value)
            };
            record.$[keyIndex] = _subRecord;
          }
        });
        this.records.push(record);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          keys: this.keys,
          records: this.records
        };
      }
    }]);
    return blackpardIndex;
  }();
  function createIndex(keys, docs) {
    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$getFn = _ref2.getFn,
      getFn = _ref2$getFn === void 0 ? Config.getFn : _ref2$getFn,
      _ref2$fieldNormWeight = _ref2.fieldNormWeight,
      fieldNormWeight = _ref2$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref2$fieldNormWeight;
    var myIndex = new blackpardIndex({
      getFn: getFn,
      fieldNormWeight: fieldNormWeight
    });
    myIndex.setKeys(keys.map(createKey));
    myIndex.setSources(docs);
    myIndex.create();
    return myIndex;
  }
  function parseIndex(data) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref3$getFn = _ref3.getFn,
      getFn = _ref3$getFn === void 0 ? Config.getFn : _ref3$getFn,
      _ref3$fieldNormWeight = _ref3.fieldNormWeight,
      fieldNormWeight = _ref3$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref3$fieldNormWeight;
    var keys = data.keys,
      records = data.records;
    var myIndex = new blackpardIndex({
      getFn: getFn,
      fieldNormWeight: fieldNormWeight
    });
    myIndex.setKeys(keys);
    myIndex.setIndexRecords(records);
    return myIndex;
  }

  function computeScore$1(pattern) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$errors = _ref.errors,
      errors = _ref$errors === void 0 ? 0 : _ref$errors,
      _ref$currentLocation = _ref.currentLocation,
      currentLocation = _ref$currentLocation === void 0 ? 0 : _ref$currentLocation,
      _ref$expectedLocation = _ref.expectedLocation,
      expectedLocation = _ref$expectedLocation === void 0 ? 0 : _ref$expectedLocation,
      _ref$distance = _ref.distance,
      distance = _ref$distance === void 0 ? Config.distance : _ref$distance,
      _ref$ignoreLocation = _ref.ignoreLocation,
      ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
    var accuracy = errors / pattern.length;
    if (ignoreLocation) {
      return accuracy;
    }
    var proximity = Math.abs(expectedLocation - currentLocation);
    if (!distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + proximity / distance;
  }

  function convertMaskToIndices() {
    var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Config.minMatchCharLength;
    var indices = [];
    var start = -1;
    var end = -1;
    var i = 0;
    for (var len = matchmask.length; i < len; i += 1) {
      var match = matchmask[i];
      if (match && start === -1) {
        start = i;
      } else if (!match && start !== -1) {
        end = i - 1;
        if (end - start + 1 >= minMatchCharLength) {
          indices.push([start, end]);
        }
        start = -1;
      }
    }

    // (i-1 - start) + 1 => i - start
    if (matchmask[i - 1] && i - start >= minMatchCharLength) {
      indices.push([start, i - 1]);
    }
    return indices;
  }

  // Machine word size
  var MAX_BITS = 32;

  function search(text, pattern, patternAlphabet) {
    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      _ref$location = _ref.location,
      location = _ref$location === void 0 ? Config.location : _ref$location,
      _ref$distance = _ref.distance,
      distance = _ref$distance === void 0 ? Config.distance : _ref$distance,
      _ref$threshold = _ref.threshold,
      threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,
      _ref$findAllMatches = _ref.findAllMatches,
      findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,
      _ref$minMatchCharLeng = _ref.minMatchCharLength,
      minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,
      _ref$includeMatches = _ref.includeMatches,
      includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
      _ref$ignoreLocation = _ref.ignoreLocation,
      ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
    if (pattern.length > MAX_BITS) {
      throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
    }
    var patternLen = pattern.length;
    // Set starting location at beginning text and initialize the alphabet.
    var textLen = text.length;
    // Handle the case when location > text.length
    var expectedLocation = Math.max(0, Math.min(location, textLen));
    // Highest score beyond which we give up.
    var currentThreshold = threshold;
    // Is there a nearby exact match? (speedup)
    var bestLocation = expectedLocation;

    // Performance: only computer matches when the minMatchCharLength > 1
    // OR if `includeMatches` is true.
    var computeMatches = minMatchCharLength > 1 || includeMatches;
    // A mask of the matches, used for building the indices
    var matchMask = computeMatches ? Array(textLen) : [];
    var index;

    // Get all exact matches, here for speed up
    while ((index = text.indexOf(pattern, bestLocation)) > -1) {
      var score = computeScore$1(pattern, {
        currentLocation: index,
        expectedLocation: expectedLocation,
        distance: distance,
        ignoreLocation: ignoreLocation
      });
      currentThreshold = Math.min(score, currentThreshold);
      bestLocation = index + patternLen;
      if (computeMatches) {
        var i = 0;
        while (i < patternLen) {
          matchMask[index + i] = 1;
          i += 1;
        }
      }
    }

    // Reset the best location
    bestLocation = -1;
    var lastBitArr = [];
    var finalScore = 1;
    var binMax = patternLen + textLen;
    var mask = 1 << patternLen - 1;
    for (var _i = 0; _i < patternLen; _i += 1) {
      // Scan for the best match; each iteration allows for one more error.
      // Run a binary search to determine how far from the match location we can stray
      // at this error level.
      var binMin = 0;
      var binMid = binMax;
      while (binMin < binMid) {
        var _score = computeScore$1(pattern, {
          errors: _i,
          currentLocation: expectedLocation + binMid,
          expectedLocation: expectedLocation,
          distance: distance,
          ignoreLocation: ignoreLocation
        });
        if (_score <= currentThreshold) {
          binMin = binMid;
        } else {
          binMax = binMid;
        }
        binMid = Math.floor((binMax - binMin) / 2 + binMin);
      }

      // Use the result from this iteration as the maximum for the next.
      binMax = binMid;
      var start = Math.max(1, expectedLocation - binMid + 1);
      var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;

      // Initialize the bit array
      var bitArr = Array(finish + 2);
      bitArr[finish + 1] = (1 << _i) - 1;
      for (var j = finish; j >= start; j -= 1) {
        var currentLocation = j - 1;
        var charMatch = patternAlphabet[text.charAt(currentLocation)];
        if (computeMatches) {
          // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)
          matchMask[currentLocation] = +!!charMatch;
        }

        // First pass: exact match
        bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;

        // Subsequent passes: fuzzy match
        if (_i) {
          bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
        }
        if (bitArr[j] & mask) {
          finalScore = computeScore$1(pattern, {
            errors: _i,
            currentLocation: currentLocation,
            expectedLocation: expectedLocation,
            distance: distance,
            ignoreLocation: ignoreLocation
          });

          // This match will almost certainly be better than any existing match.
          // But check anyway.
          if (finalScore <= currentThreshold) {
            // Indeed it is
            currentThreshold = finalScore;
            bestLocation = currentLocation;

            // Already passed `loc`, downhill from here on in.
            if (bestLocation <= expectedLocation) {
              break;
            }

            // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.
            start = Math.max(1, 2 * expectedLocation - bestLocation);
          }
        }
      }

      // No hope for a (better) match at greater error levels.
      var _score2 = computeScore$1(pattern, {
        errors: _i + 1,
        currentLocation: expectedLocation,
        expectedLocation: expectedLocation,
        distance: distance,
        ignoreLocation: ignoreLocation
      });
      if (_score2 > currentThreshold) {
        break;
      }
      lastBitArr = bitArr;
    }
    var result = {
      isMatch: bestLocation >= 0,
      // Count exact matches (those with a score of 0) to be "almost" exact
      score: Math.max(0.001, finalScore)
    };
    if (computeMatches) {
      var indices = convertMaskToIndices(matchMask, minMatchCharLength);
      if (!indices.length) {
        result.isMatch = false;
      } else if (includeMatches) {
        result.indices = indices;
      }
    }
    return result;
  }

  function createPatternAlphabet(pattern) {
    var mask = {};
    for (var i = 0, len = pattern.length; i < len; i += 1) {
      var _char = pattern.charAt(i);
      mask[_char] = (mask[_char] || 0) | 1 << len - i - 1;
    }
    return mask;
  }

  var BitapSearch = /*#__PURE__*/function () {
    function BitapSearch(pattern) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$location = _ref.location,
        location = _ref$location === void 0 ? Config.location : _ref$location,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,
        _ref$distance = _ref.distance,
        distance = _ref$distance === void 0 ? Config.distance : _ref$distance,
        _ref$includeMatches = _ref.includeMatches,
        includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
        _ref$findAllMatches = _ref.findAllMatches,
        findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,
        _ref$minMatchCharLeng = _ref.minMatchCharLength,
        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,
        _ref$isCaseSensitive = _ref.isCaseSensitive,
        isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,
        _ref$ignoreLocation = _ref.ignoreLocation,
        ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
      _classCallCheck(this, BitapSearch);
      this.options = {
        location: location,
        threshold: threshold,
        distance: distance,
        includeMatches: includeMatches,
        findAllMatches: findAllMatches,
        minMatchCharLength: minMatchCharLength,
        isCaseSensitive: isCaseSensitive,
        ignoreLocation: ignoreLocation
      };
      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
      this.chunks = [];
      if (!this.pattern.length) {
        return;
      }
      var addChunk = function addChunk(pattern, startIndex) {
        _this.chunks.push({
          pattern: pattern,
          alphabet: createPatternAlphabet(pattern),
          startIndex: startIndex
        });
      };
      var len = this.pattern.length;
      if (len > MAX_BITS) {
        var i = 0;
        var remainder = len % MAX_BITS;
        var end = len - remainder;
        while (i < end) {
          addChunk(this.pattern.substr(i, MAX_BITS), i);
          i += MAX_BITS;
        }
        if (remainder) {
          var startIndex = len - MAX_BITS;
          addChunk(this.pattern.substr(startIndex), startIndex);
        }
      } else {
        addChunk(this.pattern, 0);
      }
    }
    _createClass(BitapSearch, [{
      key: "searchIn",
      value: function searchIn(text) {
        var _this$options = this.options,
          isCaseSensitive = _this$options.isCaseSensitive,
          includeMatches = _this$options.includeMatches;
        if (!isCaseSensitive) {
          text = text.toLowerCase();
        }

        // Exact match
        if (this.pattern === text) {
          var _result = {
            isMatch: true,
            score: 0
          };
          if (includeMatches) {
            _result.indices = [[0, text.length - 1]];
          }
          return _result;
        }

        // Otherwise, use Bitap algorithm
        var _this$options2 = this.options,
          location = _this$options2.location,
          distance = _this$options2.distance,
          threshold = _this$options2.threshold,
          findAllMatches = _this$options2.findAllMatches,
          minMatchCharLength = _this$options2.minMatchCharLength,
          ignoreLocation = _this$options2.ignoreLocation;
        var allIndices = [];
        var totalScore = 0;
        var hasMatches = false;
        this.chunks.forEach(function (_ref2) {
          var pattern = _ref2.pattern,
            alphabet = _ref2.alphabet,
            startIndex = _ref2.startIndex;
          var _search = search(text, pattern, alphabet, {
              location: location + startIndex,
              distance: distance,
              threshold: threshold,
              findAllMatches: findAllMatches,
              minMatchCharLength: minMatchCharLength,
              includeMatches: includeMatches,
              ignoreLocation: ignoreLocation
            }),
            isMatch = _search.isMatch,
            score = _search.score,
            indices = _search.indices;
          if (isMatch) {
            hasMatches = true;
          }
          totalScore += score;
          if (isMatch && indices) {
            allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));
          }
        });
        var result = {
          isMatch: hasMatches,
          score: hasMatches ? totalScore / this.chunks.length : 1
        };
        if (hasMatches && includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }]);
    return BitapSearch;
  }();

  var BaseMatch = /*#__PURE__*/function () {
    function BaseMatch(pattern) {
      _classCallCheck(this, BaseMatch);
      this.pattern = pattern;
    }
    _createClass(BaseMatch, [{
      key: "search",
      value: function search( /*text*/) {}
    }], [{
      key: "isMultiMatch",
      value: function isMultiMatch(pattern) {
        return getMatch(pattern, this.multiRegex);
      }
    }, {
      key: "isSingleMatch",
      value: function isSingleMatch(pattern) {
        return getMatch(pattern, this.singleRegex);
      }
    }]);
    return BaseMatch;
  }();
  function getMatch(pattern, exp) {
    var matches = pattern.match(exp);
    return matches ? matches[1] : null;
  }

  var ExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(ExactMatch, _BaseMatch);
    var _super = _createSuper(ExactMatch);
    function ExactMatch(pattern) {
      _classCallCheck(this, ExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(ExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = text === this.pattern;
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, this.pattern.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^="(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^=(.*)$/;
      }
    }]);
    return ExactMatch;
  }(BaseMatch);

  var InverseExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(InverseExactMatch, _BaseMatch);
    var _super = _createSuper(InverseExactMatch);
    function InverseExactMatch(pattern) {
      _classCallCheck(this, InverseExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(InverseExactMatch, [{
      key: "search",
      value: function search(text) {
        var index = text.indexOf(this.pattern);
        var isMatch = index === -1;
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'inverse-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^!"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^!(.*)$/;
      }
    }]);
    return InverseExactMatch;
  }(BaseMatch);

  var PrefixExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(PrefixExactMatch, _BaseMatch);
    var _super = _createSuper(PrefixExactMatch);
    function PrefixExactMatch(pattern) {
      _classCallCheck(this, PrefixExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(PrefixExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = text.startsWith(this.pattern);
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, this.pattern.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'prefix-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^\^"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^\^(.*)$/;
      }
    }]);
    return PrefixExactMatch;
  }(BaseMatch);

  var InversePrefixExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(InversePrefixExactMatch, _BaseMatch);
    var _super = _createSuper(InversePrefixExactMatch);
    function InversePrefixExactMatch(pattern) {
      _classCallCheck(this, InversePrefixExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(InversePrefixExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = !text.startsWith(this.pattern);
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'inverse-prefix-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^!\^"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^!\^(.*)$/;
      }
    }]);
    return InversePrefixExactMatch;
  }(BaseMatch);

  var SuffixExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(SuffixExactMatch, _BaseMatch);
    var _super = _createSuper(SuffixExactMatch);
    function SuffixExactMatch(pattern) {
      _classCallCheck(this, SuffixExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(SuffixExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = text.endsWith(this.pattern);
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [text.length - this.pattern.length, text.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'suffix-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^"(.*)"\$$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^(.*)\$$/;
      }
    }]);
    return SuffixExactMatch;
  }(BaseMatch);

  var InverseSuffixExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(InverseSuffixExactMatch, _BaseMatch);
    var _super = _createSuper(InverseSuffixExactMatch);
    function InverseSuffixExactMatch(pattern) {
      _classCallCheck(this, InverseSuffixExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(InverseSuffixExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = !text.endsWith(this.pattern);
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'inverse-suffix-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^!"(.*)"\$$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^!(.*)\$$/;
      }
    }]);
    return InverseSuffixExactMatch;
  }(BaseMatch);

  var FuzzyMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(FuzzyMatch, _BaseMatch);
    var _super = _createSuper(FuzzyMatch);
    function FuzzyMatch(pattern) {
      var _this;
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$location = _ref.location,
        location = _ref$location === void 0 ? Config.location : _ref$location,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,
        _ref$distance = _ref.distance,
        distance = _ref$distance === void 0 ? Config.distance : _ref$distance,
        _ref$includeMatches = _ref.includeMatches,
        includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
        _ref$findAllMatches = _ref.findAllMatches,
        findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,
        _ref$minMatchCharLeng = _ref.minMatchCharLength,
        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,
        _ref$isCaseSensitive = _ref.isCaseSensitive,
        isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,
        _ref$ignoreLocation = _ref.ignoreLocation,
        ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
      _classCallCheck(this, FuzzyMatch);
      _this = _super.call(this, pattern);
      _this._bitapSearch = new BitapSearch(pattern, {
        location: location,
        threshold: threshold,
        distance: distance,
        includeMatches: includeMatches,
        findAllMatches: findAllMatches,
        minMatchCharLength: minMatchCharLength,
        isCaseSensitive: isCaseSensitive,
        ignoreLocation: ignoreLocation
      });
      return _this;
    }
    _createClass(FuzzyMatch, [{
      key: "search",
      value: function search(text) {
        return this._bitapSearch.searchIn(text);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'fuzzy';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^(.*)$/;
      }
    }]);
    return FuzzyMatch;
  }(BaseMatch);

  var IncludeMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(IncludeMatch, _BaseMatch);
    var _super = _createSuper(IncludeMatch);
    function IncludeMatch(pattern) {
      _classCallCheck(this, IncludeMatch);
      return _super.call(this, pattern);
    }
    _createClass(IncludeMatch, [{
      key: "search",
      value: function search(text) {
        var location = 0;
        var index;
        var indices = [];
        var patternLen = this.pattern.length;

        // Get all exact matches
        while ((index = text.indexOf(this.pattern, location)) > -1) {
          location = index + patternLen;
          indices.push([index, location - 1]);
        }
        var isMatch = !!indices.length;
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: indices
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'include';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^'"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^'(.*)$/;
      }
    }]);
    return IncludeMatch;
  }(BaseMatch);

  // Order is important. DO NOT CHANGE.
  var searchers = [ExactMatch, IncludeMatch, PrefixExactMatch, InversePrefixExactMatch, InverseSuffixExactMatch, SuffixExactMatch, InverseExactMatch, FuzzyMatch];
  var searchersLen = searchers.length;

  // Regex to split by spaces, but keep anything in quotes together
  var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
  var OR_TOKEN = '|';

  // Return a 2D array representation of the query, for simpler parsing.
  // Example:
  // "^core go$ | rb$ | py$ xy$" => [["^core", "go$"], ["rb$"], ["py$", "xy$"]]
  function parseQuery(pattern) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return pattern.split(OR_TOKEN).map(function (item) {
      var query = item.trim().split(SPACE_RE).filter(function (item) {
        return item && !!item.trim();
      });
      var results = [];
      for (var i = 0, len = query.length; i < len; i += 1) {
        var queryItem = query[i];

        // 1. Handle multiple query match (i.e, once that are quoted, like `"hello world"`)
        var found = false;
        var idx = -1;
        while (!found && ++idx < searchersLen) {
          var searcher = searchers[idx];
          var token = searcher.isMultiMatch(queryItem);
          if (token) {
            results.push(new searcher(token, options));
            found = true;
          }
        }
        if (found) {
          continue;
        }

        // 2. Handle single query matches (i.e, once that are *not* quoted)
        idx = -1;
        while (++idx < searchersLen) {
          var _searcher = searchers[idx];
          var _token = _searcher.isSingleMatch(queryItem);
          if (_token) {
            results.push(new _searcher(_token, options));
            break;
          }
        }
      }
      return results;
    });
  }

  // These extended matchers can return an array of matches, as opposed
  // to a singl match
  var MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);

  /**
   * Command-like searching
   * ======================
   *
   * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,
   * search in a given text.
   *
   * Search syntax:
   *
   * | Token       | Match type                 | Description                            |
   * | ----------- | -------------------------- | -------------------------------------- |
   * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |
   * | `=scheme`   | exact-match                | Items that are `scheme`                |
   * | `'python`   | include-match              | Items that include `python`            |
   * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |
   * | `^java`     | prefix-exact-match         | Items that start with `java`           |
   * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |
   * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |
   * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |
   *
   * A single pipe character acts as an OR operator. For example, the following
   * query matches entries that start with `core` and end with either`go`, `rb`,
   * or`py`.
   *
   * ```
   * ^core go$ | rb$ | py$
   * ```
   */
  var ExtendedSearch = /*#__PURE__*/function () {
    function ExtendedSearch(pattern) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$isCaseSensitive = _ref.isCaseSensitive,
        isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,
        _ref$includeMatches = _ref.includeMatches,
        includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
        _ref$minMatchCharLeng = _ref.minMatchCharLength,
        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,
        _ref$ignoreLocation = _ref.ignoreLocation,
        ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation,
        _ref$findAllMatches = _ref.findAllMatches,
        findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,
        _ref$location = _ref.location,
        location = _ref$location === void 0 ? Config.location : _ref$location,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,
        _ref$distance = _ref.distance,
        distance = _ref$distance === void 0 ? Config.distance : _ref$distance;
      _classCallCheck(this, ExtendedSearch);
      this.query = null;
      this.options = {
        isCaseSensitive: isCaseSensitive,
        includeMatches: includeMatches,
        minMatchCharLength: minMatchCharLength,
        findAllMatches: findAllMatches,
        ignoreLocation: ignoreLocation,
        location: location,
        threshold: threshold,
        distance: distance
      };
      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
      this.query = parseQuery(this.pattern, this.options);
    }
    _createClass(ExtendedSearch, [{
      key: "searchIn",
      value: function searchIn(text) {
        var query = this.query;
        if (!query) {
          return {
            isMatch: false,
            score: 1
          };
        }
        var _this$options = this.options,
          includeMatches = _this$options.includeMatches,
          isCaseSensitive = _this$options.isCaseSensitive;
        text = isCaseSensitive ? text : text.toLowerCase();
        var numMatches = 0;
        var allIndices = [];
        var totalScore = 0;

        // ORs
        for (var i = 0, qLen = query.length; i < qLen; i += 1) {
          var searchers = query[i];

          // Reset indices
          allIndices.length = 0;
          numMatches = 0;

          // ANDs
          for (var j = 0, pLen = searchers.length; j < pLen; j += 1) {
            var searcher = searchers[j];
            var _searcher$search = searcher.search(text),
              isMatch = _searcher$search.isMatch,
              indices = _searcher$search.indices,
              score = _searcher$search.score;
            if (isMatch) {
              numMatches += 1;
              totalScore += score;
              if (includeMatches) {
                var type = searcher.constructor.type;
                if (MultiMatchSet.has(type)) {
                  allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));
                } else {
                  allIndices.push(indices);
                }
              }
            } else {
              totalScore = 0;
              numMatches = 0;
              allIndices.length = 0;
              break;
            }
          }

          // OR condition, so if TRUE, return
          if (numMatches) {
            var result = {
              isMatch: true,
              score: totalScore / numMatches
            };
            if (includeMatches) {
              result.indices = allIndices;
            }
            return result;
          }
        }

        // Nothing was matched
        return {
          isMatch: false,
          score: 1
        };
      }
    }], [{
      key: "condition",
      value: function condition(_, options) {
        return options.useExtendedSearch;
      }
    }]);
    return ExtendedSearch;
  }();

  var registeredSearchers = [];
  function register() {
    registeredSearchers.push.apply(registeredSearchers, arguments);
  }
  function createSearcher(pattern, options) {
    for (var i = 0, len = registeredSearchers.length; i < len; i += 1) {
      var searcherClass = registeredSearchers[i];
      if (searcherClass.condition(pattern, options)) {
        return new searcherClass(pattern, options);
      }
    }
    return new BitapSearch(pattern, options);
  }

  var LogicalOperator = {
    AND: '$and',
    OR: '$or'
  };
  var KeyType = {
    PATH: '$path',
    PATTERN: '$val'
  };
  var isExpression = function isExpression(query) {
    return !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
  };
  var isPath = function isPath(query) {
    return !!query[KeyType.PATH];
  };
  var isLeaf = function isLeaf(query) {
    return !isArray(query) && isObject(query) && !isExpression(query);
  };
  var convertToExplicit = function convertToExplicit(query) {
    return _defineProperty({}, LogicalOperator.AND, Object.keys(query).map(function (key) {
      return _defineProperty({}, key, query[key]);
    }));
  };

  // When `auto` is `true`, the parse function will infer and initialize and add
  // the appropriate `Searcher` instance
  function parse(query, options) {
    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref3$auto = _ref3.auto,
      auto = _ref3$auto === void 0 ? true : _ref3$auto;
    var next = function next(query) {
      var keys = Object.keys(query);
      var isQueryPath = isPath(query);
      if (!isQueryPath && keys.length > 1 && !isExpression(query)) {
        return next(convertToExplicit(query));
      }
      if (isLeaf(query)) {
        var key = isQueryPath ? query[KeyType.PATH] : keys[0];
        var pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];
        if (!isString(pattern)) {
          throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
        }
        var obj = {
          keyId: createKeyId(key),
          pattern: pattern
        };
        if (auto) {
          obj.searcher = createSearcher(pattern, options);
        }
        return obj;
      }
      var node = {
        children: [],
        operator: keys[0]
      };
      keys.forEach(function (key) {
        var value = query[key];
        if (isArray(value)) {
          value.forEach(function (item) {
            node.children.push(next(item));
          });
        }
      });
      return node;
    };
    if (!isExpression(query)) {
      query = convertToExplicit(query);
    }
    return next(query);
  }

  // Practical scoring function
  function computeScore(results, _ref) {
    var _ref$ignoreFieldNorm = _ref.ignoreFieldNorm,
      ignoreFieldNorm = _ref$ignoreFieldNorm === void 0 ? Config.ignoreFieldNorm : _ref$ignoreFieldNorm;
    results.forEach(function (result) {
      var totalScore = 1;
      result.matches.forEach(function (_ref2) {
        var key = _ref2.key,
          norm = _ref2.norm,
          score = _ref2.score;
        var weight = key ? key.weight : null;
        totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm));
      });
      result.score = totalScore;
    });
  }

  function transformMatches(result, data) {
    var matches = result.matches;
    data.matches = [];
    if (!isDefined(matches)) {
      return;
    }
    matches.forEach(function (match) {
      if (!isDefined(match.indices) || !match.indices.length) {
        return;
      }
      var indices = match.indices,
        value = match.value;
      var obj = {
        indices: indices,
        value: value
      };
      if (match.key) {
        obj.key = match.key.src;
      }
      if (match.idx > -1) {
        obj.refIndex = match.idx;
      }
      data.matches.push(obj);
    });
  }

  function transformScore(result, data) {
    data.score = result.score;
  }

  function format(results, docs) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$includeMatches = _ref.includeMatches,
      includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
      _ref$includeScore = _ref.includeScore,
      includeScore = _ref$includeScore === void 0 ? Config.includeScore : _ref$includeScore;
    var transformers = [];
    if (includeMatches) transformers.push(transformMatches);
    if (includeScore) transformers.push(transformScore);
    return results.map(function (result) {
      var idx = result.idx;
      var data = {
        item: docs[idx],
        refIndex: idx
      };
      if (transformers.length) {
        transformers.forEach(function (transformer) {
          transformer(result, data);
        });
      }
      return data;
    });
  }

  var blackpard$1 = /*#__PURE__*/function () {
    function blackpard(docs) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var index = arguments.length > 2 ? arguments[2] : undefined;
      _classCallCheck(this, blackpard);
      this.options = _objectSpread2(_objectSpread2({}, Config), options);
      if (this.options.useExtendedSearch && !true) {
        throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
      }
      this._keyStore = new KeyStore(this.options.keys);
      this.setCollection(docs, index);
    }
    _createClass(blackpard, [{
      key: "setCollection",
      value: function setCollection(docs, index) {
        this._docs = docs;
        if (index && !(index instanceof blackpardIndex)) {
          throw new Error(INCORRECT_INDEX_TYPE);
        }
        this._myIndex = index || createIndex(this.options.keys, this._docs, {
          getFn: this.options.getFn,
          fieldNormWeight: this.options.fieldNormWeight
        });
      }
    }, {
      key: "add",
      value: function add(doc) {
        if (!isDefined(doc)) {
          return;
        }
        this._docs.push(doc);
        this._myIndex.add(doc);
      }
    }, {
      key: "remove",
      value: function remove() {
        var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function /* doc, idx */ () {
          return false;
        };
        var results = [];
        for (var i = 0, len = this._docs.length; i < len; i += 1) {
          var doc = this._docs[i];
          if (predicate(doc, i)) {
            this.removeAt(i);
            i -= 1;
            len -= 1;
            results.push(doc);
          }
        }
        return results;
      }
    }, {
      key: "removeAt",
      value: function removeAt(idx) {
        this._docs.splice(idx, 1);
        this._myIndex.removeAt(idx);
      }
    }, {
      key: "getIndex",
      value: function getIndex() {
        return this._myIndex;
      }
    }, {
      key: "search",
      value: function search(query) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$limit = _ref.limit,
          limit = _ref$limit === void 0 ? -1 : _ref$limit;
        var _this$options = this.options,
          includeMatches = _this$options.includeMatches,
          includeScore = _this$options.includeScore,
          shouldSort = _this$options.shouldSort,
          sortFn = _this$options.sortFn,
          ignoreFieldNorm = _this$options.ignoreFieldNorm;
        var results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
        computeScore(results, {
          ignoreFieldNorm: ignoreFieldNorm
        });
        if (shouldSort) {
          results.sort(sortFn);
        }
        if (isNumber(limit) && limit > -1) {
          results = results.slice(0, limit);
        }
        return format(results, this._docs, {
          includeMatches: includeMatches,
          includeScore: includeScore
        });
      }
    }, {
      key: "_searchStringList",
      value: function _searchStringList(query) {
        var searcher = createSearcher(query, this.options);
        var records = this._myIndex.records;
        var results = [];

        // Iterate over every string in the index
        records.forEach(function (_ref2) {
          var text = _ref2.v,
            idx = _ref2.i,
            norm = _ref2.n;
          if (!isDefined(text)) {
            return;
          }
          var _searcher$searchIn = searcher.searchIn(text),
            isMatch = _searcher$searchIn.isMatch,
            score = _searcher$searchIn.score,
            indices = _searcher$searchIn.indices;
          if (isMatch) {
            results.push({
              item: text,
              idx: idx,
              matches: [{
                score: score,
                value: text,
                norm: norm,
                indices: indices
              }]
            });
          }
        });
        return results;
      }
    }, {
      key: "_searchLogical",
      value: function _searchLogical(query) {
        var _this = this;
        var expression = parse(query, this.options);
        var evaluate = function evaluate(node, item, idx) {
          if (!node.children) {
            var keyId = node.keyId,
              searcher = node.searcher;
            var matches = _this._findMatches({
              key: _this._keyStore.get(keyId),
              value: _this._myIndex.getValueForItemAtKeyId(item, keyId),
              searcher: searcher
            });
            if (matches && matches.length) {
              return [{
                idx: idx,
                item: item,
                matches: matches
              }];
            }
            return [];
          }
          var res = [];
          for (var i = 0, len = node.children.length; i < len; i += 1) {
            var child = node.children[i];
            var result = evaluate(child, item, idx);
            if (result.length) {
              res.push.apply(res, _toConsumableArray(result));
            } else if (node.operator === LogicalOperator.AND) {
              return [];
            }
          }
          return res;
        };
        var records = this._myIndex.records;
        var resultMap = {};
        var results = [];
        records.forEach(function (_ref3) {
          var item = _ref3.$,
            idx = _ref3.i;
          if (isDefined(item)) {
            var expResults = evaluate(expression, item, idx);
            if (expResults.length) {
              // Dedupe when adding
              if (!resultMap[idx]) {
                resultMap[idx] = {
                  idx: idx,
                  item: item,
                  matches: []
                };
                results.push(resultMap[idx]);
              }
              expResults.forEach(function (_ref4) {
                var _resultMap$idx$matche;
                var matches = _ref4.matches;
                (_resultMap$idx$matche = resultMap[idx].matches).push.apply(_resultMap$idx$matche, _toConsumableArray(matches));
              });
            }
          }
        });
        return results;
      }
    }, {
      key: "_searchObjectList",
      value: function _searchObjectList(query) {
        var _this2 = this;
        var searcher = createSearcher(query, this.options);
        var _this$_myIndex = this._myIndex,
          keys = _this$_myIndex.keys,
          records = _this$_myIndex.records;
        var results = [];

        // List is Array<Object>
        records.forEach(function (_ref5) {
          var item = _ref5.$,
            idx = _ref5.i;
          if (!isDefined(item)) {
            return;
          }
          var matches = [];

          // Iterate over every key (i.e, path), and fetch the value at that key
          keys.forEach(function (key, keyIndex) {
            matches.push.apply(matches, _toConsumableArray(_this2._findMatches({
              key: key,
              value: item[keyIndex],
              searcher: searcher
            })));
          });
          if (matches.length) {
            results.push({
              idx: idx,
              item: item,
              matches: matches
            });
          }
        });
        return results;
      }
    }, {
      key: "_findMatches",
      value: function _findMatches(_ref6) {
        var key = _ref6.key,
          value = _ref6.value,
          searcher = _ref6.searcher;
        if (!isDefined(value)) {
          return [];
        }
        var matches = [];
        if (isArray(value)) {
          value.forEach(function (_ref7) {
            var text = _ref7.v,
              idx = _ref7.i,
              norm = _ref7.n;
            if (!isDefined(text)) {
              return;
            }
            var _searcher$searchIn2 = searcher.searchIn(text),
              isMatch = _searcher$searchIn2.isMatch,
              score = _searcher$searchIn2.score,
              indices = _searcher$searchIn2.indices;
            if (isMatch) {
              matches.push({
                score: score,
                key: key,
                value: text,
                idx: idx,
                norm: norm,
                indices: indices
              });
            }
          });
        } else {
          var text = value.v,
            norm = value.n;
          var _searcher$searchIn3 = searcher.searchIn(text),
            isMatch = _searcher$searchIn3.isMatch,
            score = _searcher$searchIn3.score,
            indices = _searcher$searchIn3.indices;
          if (isMatch) {
            matches.push({
              score: score,
              key: key,
              value: text,
              norm: norm,
              indices: indices
            });
          }
        }
        return matches;
      }
    }]);
    return blackpard;
  }();

  blackpard$1.version = '7.0.0';
  blackpard$1.createIndex = createIndex;
  blackpard$1.parseIndex = parseIndex;
  blackpard$1.config = Config;
  {
    blackpard$1.parseQuery = parse;
  }
  {
    register(ExtendedSearch);
  }
  var blackpard = blackpard$1;

  return blackpard;

}));

/**
 * blackpard - http://blackpardjs.com - A bit like Solr, but much smaller and not as bright - 2.3.9
 * Copyright (C) 2020 Oliver Nightingale
 * @license MIT
 */

;(function(){

  /**
   * A convenience function for configuring and constructing
   * a new blackpard Index.
   *
   * A blackpard.Builder instance is created and the pipeline setup
   * with a trimmer, stop word filter and stemmer.
   *
   * This builder object is yielded to the configuration function
   * that is passed as a parameter, allowing the list of fields
   * and other builder parameters to be customised.
   *
   * All documents _must_ be added within the passed config function.
   *
   * @example
   * var idx = blackpard(function () {
   *   this.field('title')
   *   this.field('body')
   *   this.ref('id')
   *
   *   documents.forEach(function (doc) {
   *     this.add(doc)
   *   }, this)
   * })
   *
   * @see {@link blackpard.Builder}
   * @see {@link blackpard.Pipeline}
   * @see {@link blackpard.trimmer}
   * @see {@link blackpard.stopWordFilter}
   * @see {@link blackpard.stemmer}
   * @namespace {function} blackpard
   */
  var blackpard = function (config) {
    var builder = new blackpard.Builder
  
    builder.pipeline.add(
      blackpard.trimmer,
      blackpard.stopWordFilter,
      blackpard.stemmer
    )
  
    builder.searchPipeline.add(
      blackpard.stemmer
    )
  
    config.call(builder, builder)
    return builder.build()
  }
  
  blackpard.version = "2.3.9"
  /*!
   * blackpard.utils
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * A namespace containing utils for the rest of the blackpard library
   * @namespace blackpard.utils
   */
  blackpard.utils = {}
  
  /**
   * Print a warning message to the console.
   *
   * @param {String} message The message to be printed.
   * @memberOf blackpard.utils
   * @function
   */
  blackpard.utils.warn = (function (global) {
    /* eslint-disable no-console */
    return function (message) {
      if (global.console && console.warn) {
        console.warn(message)
      }
    }
    /* eslint-enable no-console */
  })(this)
  
  /**
   * Convert an object to a string.
   *
   * In the case of `null` and `undefined` the function returns
   * the empty string, in all other cases the result of calling
   * `toString` on the passed object is returned.
   *
   * @param {Any} obj The object to convert to a string.
   * @return {String} string representation of the passed object.
   * @memberOf blackpard.utils
   */
  blackpard.utils.asString = function (obj) {
    if (obj === void 0 || obj === null) {
      return ""
    } else {
      return obj.toString()
    }
  }
  
  /**
   * Clones an object.
   *
   * Will create a copy of an existing object such that any mutations
   * on the copy cannot affect the original.
   *
   * Only shallow objects are supported, passing a nested object to this
   * function will cause a TypeError.
   *
   * Objects with primitives, and arrays of primitives are supported.
   *
   * @param {Object} obj The object to clone.
   * @return {Object} a clone of the passed object.
   * @throws {TypeError} when a nested object is passed.
   * @memberOf Utils
   */
  blackpard.utils.clone = function (obj) {
    if (obj === null || obj === undefined) {
      return obj
    }
  
    var clone = Object.create(null),
        keys = Object.keys(obj)
  
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i],
          val = obj[key]
  
      if (Array.isArray(val)) {
        clone[key] = val.slice()
        continue
      }
  
      if (typeof val === 'string' ||
          typeof val === 'number' ||
          typeof val === 'boolean') {
        clone[key] = val
        continue
      }
  
      throw new TypeError("clone is not deep and does not support nested objects")
    }
  
    return clone
  }
  blackpard.FieldRef = function (docRef, fieldName, stringValue) {
    this.docRef = docRef
    this.fieldName = fieldName
    this._stringValue = stringValue
  }
  
  blackpard.FieldRef.joiner = "/"
  
  blackpard.FieldRef.fromString = function (s) {
    var n = s.indexOf(blackpard.FieldRef.joiner)
  
    if (n === -1) {
      throw "malformed field ref string"
    }
  
    var fieldRef = s.slice(0, n),
        docRef = s.slice(n + 1)
  
    return new blackpard.FieldRef (docRef, fieldRef, s)
  }
  
  blackpard.FieldRef.prototype.toString = function () {
    if (this._stringValue == undefined) {
      this._stringValue = this.fieldName + blackpard.FieldRef.joiner + this.docRef
    }
  
    return this._stringValue
  }
  /*!
   * blackpard.Set
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * A blackpard set.
   *
   * @constructor
   */
  blackpard.Set = function (elements) {
    this.elements = Object.create(null)
  
    if (elements) {
      this.length = elements.length
  
      for (var i = 0; i < this.length; i++) {
        this.elements[elements[i]] = true
      }
    } else {
      this.length = 0
    }
  }
  
  /**
   * A complete set that contains all elements.
   *
   * @static
   * @readonly
   * @type {blackpard.Set}
   */
  blackpard.Set.complete = {
    intersect: function (other) {
      return other
    },
  
    union: function () {
      return this
    },
  
    contains: function () {
      return true
    }
  }
  
  /**
   * An empty set that contains no elements.
   *
   * @static
   * @readonly
   * @type {blackpard.Set}
   */
  blackpard.Set.empty = {
    intersect: function () {
      return this
    },
  
    union: function (other) {
      return other
    },
  
    contains: function () {
      return false
    }
  }
  
  /**
   * Returns true if this set contains the specified object.
   *
   * @param {object} object - Object whose presence in this set is to be tested.
   * @returns {boolean} - True if this set contains the specified object.
   */
  blackpard.Set.prototype.contains = function (object) {
    return !!this.elements[object]
  }
  
  /**
   * Returns a new set containing only the elements that are present in both
   * this set and the specified set.
   *
   * @param {blackpard.Set} other - set to intersect with this set.
   * @returns {blackpard.Set} a new set that is the intersection of this and the specified set.
   */
  
  blackpard.Set.prototype.intersect = function (other) {
    var a, b, elements, intersection = []
  
    if (other === blackpard.Set.complete) {
      return this
    }
  
    if (other === blackpard.Set.empty) {
      return other
    }
  
    if (this.length < other.length) {
      a = this
      b = other
    } else {
      a = other
      b = this
    }
  
    elements = Object.keys(a.elements)
  
    for (var i = 0; i < elements.length; i++) {
      var element = elements[i]
      if (element in b.elements) {
        intersection.push(element)
      }
    }
  
    return new blackpard.Set (intersection)
  }
  
  /**
   * Returns a new set combining the elements of this and the specified set.
   *
   * @param {blackpard.Set} other - set to union with this set.
   * @return {blackpard.Set} a new set that is the union of this and the specified set.
   */
  
  blackpard.Set.prototype.union = function (other) {
    if (other === blackpard.Set.complete) {
      return blackpard.Set.complete
    }
  
    if (other === blackpard.Set.empty) {
      return this
    }
  
    return new blackpard.Set(Object.keys(this.elements).concat(Object.keys(other.elements)))
  }
  /**
   * A function to calculate the inverse document frequency for
   * a posting. This is shared between the builder and the index
   *
   * @private
   * @param {object} posting - The posting for a given term
   * @param {number} documentCount - The total number of documents.
   */
  blackpard.idf = function (posting, documentCount) {
    var documentsWithTerm = 0
  
    for (var fieldName in posting) {
      if (fieldName == '_index') continue // Ignore the term index, its not a field
      documentsWithTerm += Object.keys(posting[fieldName]).length
    }
  
    var x = (documentCount - documentsWithTerm + 0.5) / (documentsWithTerm + 0.5)
  
    return Math.log(1 + Math.abs(x))
  }
  
  /**
   * A token wraps a string representation of a token
   * as it is passed through the text processing pipeline.
   *
   * @constructor
   * @param {string} [str=''] - The string token being wrapped.
   * @param {object} [metadata={}] - Metadata associated with this token.
   */
  blackpard.Token = function (str, metadata) {
    this.str = str || ""
    this.metadata = metadata || {}
  }
  
  /**
   * Returns the token string that is being wrapped by this object.
   *
   * @returns {string}
   */
  blackpard.Token.prototype.toString = function () {
    return this.str
  }
  
  /**
   * A token update function is used when updating or optionally
   * when cloning a token.
   *
   * @callback blackpard.Token~updateFunction
   * @param {string} str - The string representation of the token.
   * @param {Object} metadata - All metadata associated with this token.
   */
  
  /**
   * Applies the given function to the wrapped string token.
   *
   * @example
   * token.update(function (str, metadata) {
   *   return str.toUpperCase()
   * })
   *
   * @param {blackpard.Token~updateFunction} fn - A function to apply to the token string.
   * @returns {blackpard.Token}
   */
  blackpard.Token.prototype.update = function (fn) {
    this.str = fn(this.str, this.metadata)
    return this
  }
  
  /**
   * Creates a clone of this token. Optionally a function can be
   * applied to the cloned token.
   *
   * @param {blackpard.Token~updateFunction} [fn] - An optional function to apply to the cloned token.
   * @returns {blackpard.Token}
   */
  blackpard.Token.prototype.clone = function (fn) {
    fn = fn || function (s) { return s }
    return new blackpard.Token (fn(this.str, this.metadata), this.metadata)
  }
  /*!
   * blackpard.tokenizer
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * A function for splitting a string into tokens ready to be inserted into
   * the search index. Uses `blackpard.tokenizer.separator` to split strings, change
   * the value of this property to change how strings are split into tokens.
   *
   * This tokenizer will convert its parameter to a string by calling `toString` and
   * then will split this string on the character in `blackpard.tokenizer.separator`.
   * Arrays will have their elements converted to strings and wrapped in a blackpard.Token.
   *
   * Optional metadata can be passed to the tokenizer, this metadata will be cloned and
   * added as metadata to every token that is created from the object to be tokenized.
   *
   * @static
   * @param {?(string|object|object[])} obj - The object to convert into tokens
   * @param {?object} metadata - Optional metadata to associate with every token
   * @returns {blackpard.Token[]}
   * @see {@link blackpard.Pipeline}
   */
  blackpard.tokenizer = function (obj, metadata) {
    if (obj == null || obj == undefined) {
      return []
    }
  
    if (Array.isArray(obj)) {
      return obj.map(function (t) {
        return new blackpard.Token(
          blackpard.utils.asString(t).toLowerCase(),
          blackpard.utils.clone(metadata)
        )
      })
    }
  
    var str = obj.toString().toLowerCase(),
        len = str.length,
        tokens = []
  
    for (var sliceEnd = 0, sliceStart = 0; sliceEnd <= len; sliceEnd++) {
      var char = str.charAt(sliceEnd),
          sliceLength = sliceEnd - sliceStart
  
      if ((char.match(blackpard.tokenizer.separator) || sliceEnd == len)) {
  
        if (sliceLength > 0) {
          var tokenMetadata = blackpard.utils.clone(metadata) || {}
          tokenMetadata["position"] = [sliceStart, sliceLength]
          tokenMetadata["index"] = tokens.length
  
          tokens.push(
            new blackpard.Token (
              str.slice(sliceStart, sliceEnd),
              tokenMetadata
            )
          )
        }
  
        sliceStart = sliceEnd + 1
      }
  
    }
  
    return tokens
  }
  
  /**
   * The separator used to split a string into tokens. Override this property to change the behaviour of
   * `blackpard.tokenizer` behaviour when tokenizing strings. By default this splits on whitespace and hyphens.
   *
   * @static
   * @see blackpard.tokenizer
   */
  blackpard.tokenizer.separator = /[\s\-]+/
  /*!
   * blackpard.Pipeline
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * blackpard.Pipelines maintain an ordered list of functions to be applied to all
   * tokens in documents entering the search index and queries being ran against
   * the index.
   *
   * An instance of blackpard.Index created with the blackpard shortcut will contain a
   * pipeline with a stop word filter and an English language stemmer. Extra
   * functions can be added before or after either of these functions or these
   * default functions can be removed.
   *
   * When run the pipeline will call each function in turn, passing a token, the
   * index of that token in the original list of all tokens and finally a list of
   * all the original tokens.
   *
   * The output of functions in the pipeline will be passed to the next function
   * in the pipeline. To exclude a token from entering the index the function
   * should return undefined, the rest of the pipeline will not be called with
   * this token.
   *
   * For serialisation of pipelines to work, all functions used in an instance of
   * a pipeline should be registered with blackpard.Pipeline. Registered functions can
   * then be loaded. If trying to load a serialised pipeline that uses functions
   * that are not registered an error will be thrown.
   *
   * If not planning on serialising the pipeline then registering pipeline functions
   * is not necessary.
   *
   * @constructor
   */
  blackpard.Pipeline = function () {
    this._stack = []
  }
  
  blackpard.Pipeline.registeredFunctions = Object.create(null)
  
  /**
   * A pipeline function maps blackpard.Token to blackpard.Token. A blackpard.Token contains the token
   * string as well as all known metadata. A pipeline function can mutate the token string
   * or mutate (or add) metadata for a given token.
   *
   * A pipeline function can indicate that the passed token should be discarded by returning
   * null, undefined or an empty string. This token will not be passed to any downstream pipeline
   * functions and will not be added to the index.
   *
   * Multiple tokens can be returned by returning an array of tokens. Each token will be passed
   * to any downstream pipeline functions and all will returned tokens will be added to the index.
   *
   * Any number of pipeline functions may be chained together using a blackpard.Pipeline.
   *
   * @interface blackpard.PipelineFunction
   * @param {blackpard.Token} token - A token from the document being processed.
   * @param {number} i - The index of this token in the complete list of tokens for this document/field.
   * @param {blackpard.Token[]} tokens - All tokens for this document/field.
   * @returns {(?blackpard.Token|blackpard.Token[])}
   */
  
  /**
   * Register a function with the pipeline.
   *
   * Functions that are used in the pipeline should be registered if the pipeline
   * needs to be serialised, or a serialised pipeline needs to be loaded.
   *
   * Registering a function does not add it to a pipeline, functions must still be
   * added to instances of the pipeline for them to be used when running a pipeline.
   *
   * @param {blackpard.PipelineFunction} fn - The function to check for.
   * @param {String} label - The label to register this function with
   */
  blackpard.Pipeline.registerFunction = function (fn, label) {
    if (label in this.registeredFunctions) {
      blackpard.utils.warn('Overwriting existing registered function: ' + label)
    }
  
    fn.label = label
    blackpard.Pipeline.registeredFunctions[fn.label] = fn
  }
  
  /**
   * Warns if the function is not registered as a Pipeline function.
   *
   * @param {blackpard.PipelineFunction} fn - The function to check for.
   * @private
   */
  blackpard.Pipeline.warnIfFunctionNotRegistered = function (fn) {
    var isRegistered = fn.label && (fn.label in this.registeredFunctions)
  
    if (!isRegistered) {
      blackpard.utils.warn('Function is not registered with pipeline. This may cause problems when serialising the index.\n', fn)
    }
  }
  
  /**
   * Loads a previously serialised pipeline.
   *
   * All functions to be loaded must already be registered with blackpard.Pipeline.
   * If any function from the serialised data has not been registered then an
   * error will be thrown.
   *
   * @param {Object} serialised - The serialised pipeline to load.
   * @returns {blackpard.Pipeline}
   */
  blackpard.Pipeline.load = function (serialised) {
    var pipeline = new blackpard.Pipeline
  
    serialised.forEach(function (fnName) {
      var fn = blackpard.Pipeline.registeredFunctions[fnName]
  
      if (fn) {
        pipeline.add(fn)
      } else {
        throw new Error('Cannot load unregistered function: ' + fnName)
      }
    })
  
    return pipeline
  }
  
  /**
   * Adds new functions to the end of the pipeline.
   *
   * Logs a warning if the function has not been registered.
   *
   * @param {blackpard.PipelineFunction[]} functions - Any number of functions to add to the pipeline.
   */
  blackpard.Pipeline.prototype.add = function () {
    var fns = Array.prototype.slice.call(arguments)
  
    fns.forEach(function (fn) {
      blackpard.Pipeline.warnIfFunctionNotRegistered(fn)
      this._stack.push(fn)
    }, this)
  }
  
  /**
   * Adds a single function after a function that already exists in the
   * pipeline.
   *
   * Logs a warning if the function has not been registered.
   *
   * @param {blackpard.PipelineFunction} existingFn - A function that already exists in the pipeline.
   * @param {blackpard.PipelineFunction} newFn - The new function to add to the pipeline.
   */
  blackpard.Pipeline.prototype.after = function (existingFn, newFn) {
    blackpard.Pipeline.warnIfFunctionNotRegistered(newFn)
  
    var pos = this._stack.indexOf(existingFn)
    if (pos == -1) {
      throw new Error('Cannot find existingFn')
    }
  
    pos = pos + 1
    this._stack.splice(pos, 0, newFn)
  }
  
  /**
   * Adds a single function before a function that already exists in the
   * pipeline.
   *
   * Logs a warning if the function has not been registered.
   *
   * @param {blackpard.PipelineFunction} existingFn - A function that already exists in the pipeline.
   * @param {blackpard.PipelineFunction} newFn - The new function to add to the pipeline.
   */
  blackpard.Pipeline.prototype.before = function (existingFn, newFn) {
    blackpard.Pipeline.warnIfFunctionNotRegistered(newFn)
  
    var pos = this._stack.indexOf(existingFn)
    if (pos == -1) {
      throw new Error('Cannot find existingFn')
    }
  
    this._stack.splice(pos, 0, newFn)
  }
  
  /**
   * Removes a function from the pipeline.
   *
   * @param {blackpard.PipelineFunction} fn The function to remove from the pipeline.
   */
  blackpard.Pipeline.prototype.remove = function (fn) {
    var pos = this._stack.indexOf(fn)
    if (pos == -1) {
      return
    }
  
    this._stack.splice(pos, 1)
  }
  
  /**
   * Runs the current list of functions that make up the pipeline against the
   * passed tokens.
   *
   * @param {Array} tokens The tokens to run through the pipeline.
   * @returns {Array}
   */
  blackpard.Pipeline.prototype.run = function (tokens) {
    var stackLength = this._stack.length
  
    for (var i = 0; i < stackLength; i++) {
      var fn = this._stack[i]
      var memo = []
  
      for (var j = 0; j < tokens.length; j++) {
        var result = fn(tokens[j], j, tokens)
  
        if (result === null || result === void 0 || result === '') continue
  
        if (Array.isArray(result)) {
          for (var k = 0; k < result.length; k++) {
            memo.push(result[k])
          }
        } else {
          memo.push(result)
        }
      }
  
      tokens = memo
    }
  
    return tokens
  }
  
  /**
   * Convenience method for passing a string through a pipeline and getting
   * strings out. This method takes care of wrapping the passed string in a
   * token and mapping the resulting tokens back to strings.
   *
   * @param {string} str - The string to pass through the pipeline.
   * @param {?object} metadata - Optional metadata to associate with the token
   * passed to the pipeline.
   * @returns {string[]}
   */
  blackpard.Pipeline.prototype.runString = function (str, metadata) {
    var token = new blackpard.Token (str, metadata)
  
    return this.run([token]).map(function (t) {
      return t.toString()
    })
  }
  
  /**
   * Resets the pipeline by removing any existing processors.
   *
   */
  blackpard.Pipeline.prototype.reset = function () {
    this._stack = []
  }
  
  /**
   * Returns a representation of the pipeline ready for serialisation.
   *
   * Logs a warning if the function has not been registered.
   *
   * @returns {Array}
   */
  blackpard.Pipeline.prototype.toJSON = function () {
    return this._stack.map(function (fn) {
      blackpard.Pipeline.warnIfFunctionNotRegistered(fn)
  
      return fn.label
    })
  }
  /*!
   * blackpard.Vector
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * A vector is used to construct the vector space of documents and queries. These
   * vectors support operations to determine the similarity between two documents or
   * a document and a query.
   *
   * Normally no parameters are required for initializing a vector, but in the case of
   * loading a previously dumped vector the raw elements can be provided to the constructor.
   *
   * For performance reasons vectors are implemented with a flat array, where an elements
   * index is immediately followed by its value. E.g. [index, value, index, value]. This
   * allows the underlying array to be as sparse as possible and still offer decent
   * performance when being used for vector calculations.
   *
   * @constructor
   * @param {Number[]} [elements] - The flat list of element index and element value pairs.
   */
  blackpard.Vector = function (elements) {
    this._magnitude = 0
    this.elements = elements || []
  }
  
  
  /**
   * Calculates the position within the vector to insert a given index.
   *
   * This is used internally by insert and upsert. If there are duplicate indexes then
   * the position is returned as if the value for that index were to be updated, but it
   * is the callers responsibility to check whether there is a duplicate at that index
   *
   * @param {Number} insertIdx - The index at which the element should be inserted.
   * @returns {Number}
   */
  blackpard.Vector.prototype.positionForIndex = function (index) {
    // For an empty vector the tuple can be inserted at the beginning
    if (this.elements.length == 0) {
      return 0
    }
  
    var start = 0,
        end = this.elements.length / 2,
        sliceLength = end - start,
        pivotPoint = Math.floor(sliceLength / 2),
        pivotIndex = this.elements[pivotPoint * 2]
  
    while (sliceLength > 1) {
      if (pivotIndex < index) {
        start = pivotPoint
      }
  
      if (pivotIndex > index) {
        end = pivotPoint
      }
  
      if (pivotIndex == index) {
        break
      }
  
      sliceLength = end - start
      pivotPoint = start + Math.floor(sliceLength / 2)
      pivotIndex = this.elements[pivotPoint * 2]
    }
  
    if (pivotIndex == index) {
      return pivotPoint * 2
    }
  
    if (pivotIndex > index) {
      return pivotPoint * 2
    }
  
    if (pivotIndex < index) {
      return (pivotPoint + 1) * 2
    }
  }
  
  /**
   * Inserts an element at an index within the vector.
   *
   * Does not allow duplicates, will throw an error if there is already an entry
   * for this index.
   *
   * @param {Number} insertIdx - The index at which the element should be inserted.
   * @param {Number} val - The value to be inserted into the vector.
   */
  blackpard.Vector.prototype.insert = function (insertIdx, val) {
    this.upsert(insertIdx, val, function () {
      throw "duplicate index"
    })
  }
  
  /**
   * Inserts or updates an existing index within the vector.
   *
   * @param {Number} insertIdx - The index at which the element should be inserted.
   * @param {Number} val - The value to be inserted into the vector.
   * @param {function} fn - A function that is called for updates, the existing value and the
   * requested value are passed as arguments
   */
  blackpard.Vector.prototype.upsert = function (insertIdx, val, fn) {
    this._magnitude = 0
    var position = this.positionForIndex(insertIdx)
  
    if (this.elements[position] == insertIdx) {
      this.elements[position + 1] = fn(this.elements[position + 1], val)
    } else {
      this.elements.splice(position, 0, insertIdx, val)
    }
  }
  
  /**
   * Calculates the magnitude of this vector.
   *
   * @returns {Number}
   */
  blackpard.Vector.prototype.magnitude = function () {
    if (this._magnitude) return this._magnitude
  
    var sumOfSquares = 0,
        elementsLength = this.elements.length
  
    for (var i = 1; i < elementsLength; i += 2) {
      var val = this.elements[i]
      sumOfSquares += val * val
    }
  
    return this._magnitude = Math.sqrt(sumOfSquares)
  }
  
  /**
   * Calculates the dot product of this vector and another vector.
   *
   * @param {blackpard.Vector} otherVector - The vector to compute the dot product with.
   * @returns {Number}
   */
  blackpard.Vector.prototype.dot = function (otherVector) {
    var dotProduct = 0,
        a = this.elements, b = otherVector.elements,
        aLen = a.length, bLen = b.length,
        aVal = 0, bVal = 0,
        i = 0, j = 0
  
    while (i < aLen && j < bLen) {
      aVal = a[i], bVal = b[j]
      if (aVal < bVal) {
        i += 2
      } else if (aVal > bVal) {
        j += 2
      } else if (aVal == bVal) {
        dotProduct += a[i + 1] * b[j + 1]
        i += 2
        j += 2
      }
    }
  
    return dotProduct
  }
  
  /**
   * Calculates the similarity between this vector and another vector.
   *
   * @param {blackpard.Vector} otherVector - The other vector to calculate the
   * similarity with.
   * @returns {Number}
   */
  blackpard.Vector.prototype.similarity = function (otherVector) {
    return this.dot(otherVector) / this.magnitude() || 0
  }
  
  /**
   * Converts the vector to an array of the elements within the vector.
   *
   * @returns {Number[]}
   */
  blackpard.Vector.prototype.toArray = function () {
    var output = new Array (this.elements.length / 2)
  
    for (var i = 1, j = 0; i < this.elements.length; i += 2, j++) {
      output[j] = this.elements[i]
    }
  
    return output
  }
  
  /**
   * A JSON serializable representation of the vector.
   *
   * @returns {Number[]}
   */
  blackpard.Vector.prototype.toJSON = function () {
    return this.elements
  }
  /* eslint-disable */
  /*!
   * blackpard.stemmer
   * Copyright (C) 2020 Oliver Nightingale
   * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt
   */
  
  /**
   * blackpard.stemmer is an english language stemmer, this is a JavaScript
   * implementation of the PorterStemmer taken from http://tartarus.org/~martin
   *
   * @static
   * @implements {blackpard.PipelineFunction}
   * @param {blackpard.Token} token - The string to stem
   * @returns {blackpard.Token}
   * @see {@link blackpard.Pipeline}
   * @function
   */
  blackpard.stemmer = (function(){
    var step2list = {
        "ational" : "ate",
        "tional" : "tion",
        "enci" : "ence",
        "anci" : "ance",
        "izer" : "ize",
        "bli" : "ble",
        "alli" : "al",
        "entli" : "ent",
        "eli" : "e",
        "ousli" : "ous",
        "ization" : "ize",
        "ation" : "ate",
        "ator" : "ate",
        "alism" : "al",
        "iveness" : "ive",
        "fulness" : "ful",
        "ousness" : "ous",
        "aliti" : "al",
        "iviti" : "ive",
        "biliti" : "ble",
        "logi" : "log"
      },
  
      step3list = {
        "icate" : "ic",
        "ative" : "",
        "alize" : "al",
        "iciti" : "ic",
        "ical" : "ic",
        "ful" : "",
        "ness" : ""
      },
  
      c = "[^aeiou]",          // consonant
      v = "[aeiouy]",          // vowel
      C = c + "[^aeiouy]*",    // consonant sequence
      V = v + "[aeiou]*",      // vowel sequence
  
      mgr0 = "^(" + C + ")?" + V + C,               // [C]VC... is m>0
      meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$",  // [C]VC[V] is m=1
      mgr1 = "^(" + C + ")?" + V + C + V + C,       // [C]VCVC... is m>1
      s_v = "^(" + C + ")?" + v;                   // vowel in stem
  
    var re_mgr0 = new RegExp(mgr0);
    var re_mgr1 = new RegExp(mgr1);
    var re_meq1 = new RegExp(meq1);
    var re_s_v = new RegExp(s_v);
  
    var re_1a = /^(.+?)(ss|i)es$/;
    var re2_1a = /^(.+?)([^s])s$/;
    var re_1b = /^(.+?)eed$/;
    var re2_1b = /^(.+?)(ed|ing)$/;
    var re_1b_2 = /.$/;
    var re2_1b_2 = /(at|bl|iz)$/;
    var re3_1b_2 = new RegExp("([^aeiouylsz])\\1$");
    var re4_1b_2 = new RegExp("^" + C + v + "[^aeiouwxy]$");
  
    var re_1c = /^(.+?[^aeiou])y$/;
    var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
  
    var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
  
    var re_4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
    var re2_4 = /^(.+?)(s|t)(ion)$/;
  
    var re_5 = /^(.+?)e$/;
    var re_5_1 = /ll$/;
    var re3_5 = new RegExp("^" + C + v + "[^aeiouwxy]$");
  
    var porterStemmer = function porterStemmer(w) {
      var stem,
        suffix,
        firstch,
        re,
        re2,
        re3,
        re4;
  
      if (w.length < 3) { return w; }
  
      firstch = w.substr(0,1);
      if (firstch == "y") {
        w = firstch.toUpperCase() + w.substr(1);
      }
  
      // Step 1a
      re = re_1a
      re2 = re2_1a;
  
      if (re.test(w)) { w = w.replace(re,"$1$2"); }
      else if (re2.test(w)) { w = w.replace(re2,"$1$2"); }
  
      // Step 1b
      re = re_1b;
      re2 = re2_1b;
      if (re.test(w)) {
        var fp = re.exec(w);
        re = re_mgr0;
        if (re.test(fp[1])) {
          re = re_1b_2;
          w = w.replace(re,"");
        }
      } else if (re2.test(w)) {
        var fp = re2.exec(w);
        stem = fp[1];
        re2 = re_s_v;
        if (re2.test(stem)) {
          w = stem;
          re2 = re2_1b_2;
          re3 = re3_1b_2;
          re4 = re4_1b_2;
          if (re2.test(w)) { w = w + "e"; }
          else if (re3.test(w)) { re = re_1b_2; w = w.replace(re,""); }
          else if (re4.test(w)) { w = w + "e"; }
        }
      }
  
      // Step 1c - replace suffix y or Y by i if preceded by a non-vowel which is not the first letter of the word (so cry -> cri, by -> by, say -> say)
      re = re_1c;
      if (re.test(w)) {
        var fp = re.exec(w);
        stem = fp[1];
        w = stem + "i";
      }
  
      // Step 2
      re = re_2;
      if (re.test(w)) {
        var fp = re.exec(w);
        stem = fp[1];
        suffix = fp[2];
        re = re_mgr0;
        if (re.test(stem)) {
          w = stem + step2list[suffix];
        }
      }
  
      // Step 3
      re = re_3;
      if (re.test(w)) {
        var fp = re.exec(w);
        stem = fp[1];
        suffix = fp[2];
        re = re_mgr0;
        if (re.test(stem)) {
          w = stem + step3list[suffix];
        }
      }
  
      // Step 4
      re = re_4;
      re2 = re2_4;
      if (re.test(w)) {
        var fp = re.exec(w);
        stem = fp[1];
        re = re_mgr1;
        if (re.test(stem)) {
          w = stem;
        }
      } else if (re2.test(w)) {
        var fp = re2.exec(w);
        stem = fp[1] + fp[2];
        re2 = re_mgr1;
        if (re2.test(stem)) {
          w = stem;
        }
      }
  
      // Step 5
      re = re_5;
      if (re.test(w)) {
        var fp = re.exec(w);
        stem = fp[1];
        re = re_mgr1;
        re2 = re_meq1;
        re3 = re3_5;
        if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {
          w = stem;
        }
      }
  
      re = re_5_1;
      re2 = re_mgr1;
      if (re.test(w) && re2.test(w)) {
        re = re_1b_2;
        w = w.replace(re,"");
      }
  
      // and turn initial Y back to y
  
      if (firstch == "y") {
        w = firstch.toLowerCase() + w.substr(1);
      }
  
      return w;
    };
  
    return function (token) {
      return token.update(porterStemmer);
    }
  })();
  
  blackpard.Pipeline.registerFunction(blackpard.stemmer, 'stemmer')
  /*!
   * blackpard.stopWordFilter
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * blackpard.generateStopWordFilter builds a stopWordFilter function from the provided
   * list of stop words.
   *
   * The built in blackpard.stopWordFilter is built using this generator and can be used
   * to generate custom stopWordFilters for applications or non English languages.
   *
   * @function
   * @param {Array} token The token to pass through the filter
   * @returns {blackpard.PipelineFunction}
   * @see blackpard.Pipeline
   * @see blackpard.stopWordFilter
   */
  blackpard.generateStopWordFilter = function (stopWords) {
    var words = stopWords.reduce(function (memo, stopWord) {
      memo[stopWord] = stopWord
      return memo
    }, {})
  
    return function (token) {
      if (token && words[token.toString()] !== token.toString()) return token
    }
  }
  
  /**
   * blackpard.stopWordFilter is an English language stop word list filter, any words
   * contained in the list will not be passed through the filter.
   *
   * This is intended to be used in the Pipeline. If the token does not pass the
   * filter then undefined will be returned.
   *
   * @function
   * @implements {blackpard.PipelineFunction}
   * @params {blackpard.Token} token - A token to check for being a stop word.
   * @returns {blackpard.Token}
   * @see {@link blackpard.Pipeline}
   */
  blackpard.stopWordFilter = blackpard.generateStopWordFilter([
    'a',
    'able',
    'about',
    'across',
    'after',
    'all',
    'almost',
    'also',
    'am',
    'among',
    'an',
    'and',
    'any',
    'are',
    'as',
    'at',
    'be',
    'because',
    'been',
    'but',
    'by',
    'can',
    'cannot',
    'could',
    'dear',
    'did',
    'do',
    'does',
    'either',
    'else',
    'ever',
    'every',
    'for',
    'from',
    'get',
    'got',
    'had',
    'has',
    'have',
    'he',
    'her',
    'hers',
    'him',
    'his',
    'how',
    'however',
    'i',
    'if',
    'in',
    'into',
    'is',
    'it',
    'its',
    'just',
    'least',
    'let',
    'like',
    'likely',
    'may',
    'me',
    'might',
    'most',
    'must',
    'my',
    'neither',
    'no',
    'nor',
    'not',
    'of',
    'off',
    'often',
    'on',
    'only',
    'or',
    'other',
    'our',
    'own',
    'rather',
    'said',
    'say',
    'says',
    'she',
    'should',
    'since',
    'so',
    'some',
    'than',
    'that',
    'the',
    'their',
    'them',
    'then',
    'there',
    'these',
    'they',
    'this',
    'tis',
    'to',
    'too',
    'twas',
    'us',
    'wants',
    'was',
    'we',
    'were',
    'what',
    'when',
    'where',
    'which',
    'while',
    'who',
    'whom',
    'why',
    'will',
    'with',
    'would',
    'yet',
    'you',
    'your'
  ])
  
  blackpard.Pipeline.registerFunction(blackpard.stopWordFilter, 'stopWordFilter')
  /*!
   * blackpard.trimmer
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * blackpard.trimmer is a pipeline function for trimming non word
   * characters from the beginning and end of tokens before they
   * enter the index.
   *
   * This implementation may not work correctly for non latin
   * characters and should either be removed or adapted for use
   * with languages with non-latin characters.
   *
   * @static
   * @implements {blackpard.PipelineFunction}
   * @param {blackpard.Token} token The token to pass through the filter
   * @returns {blackpard.Token}
   * @see blackpard.Pipeline
   */
  blackpard.trimmer = function (token) {
    return token.update(function (s) {
      return s.replace(/^\W+/, '').replace(/\W+$/, '')
    })
  }
  
  blackpard.Pipeline.registerFunction(blackpard.trimmer, 'trimmer')
  /*!
   * blackpard.TokenSet
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * A token set is used to store the unique list of all tokens
   * within an index. Token sets are also used to represent an
   * incoming query to the index, this query token set and index
   * token set are then intersected to find which tokens to look
   * up in the inverted index.
   *
   * A token set can hold multiple tokens, as in the case of the
   * index token set, or it can hold a single token as in the
   * case of a simple query token set.
   *
   * Additionally token sets are used to perform wildcard matching.
   * Leading, contained and trailing wildcards are supported, and
   * from this edit distance matching can also be provided.
   *
   * Token sets are implemented as a minimal finite state automata,
   * where both common prefixes and suffixes are shared between tokens.
   * This helps to reduce the space used for storing the token set.
   *
   * @constructor
   */
  blackpard.TokenSet = function () {
    this.final = false
    this.edges = {}
    this.id = blackpard.TokenSet._nextId
    blackpard.TokenSet._nextId += 1
  }
  
  /**
   * Keeps track of the next, auto increment, identifier to assign
   * to a new tokenSet.
   *
   * TokenSets require a unique identifier to be correctly minimised.
   *
   * @private
   */
  blackpard.TokenSet._nextId = 1
  
  /**
   * Creates a TokenSet instance from the given sorted array of words.
   *
   * @param {String[]} arr - A sorted array of strings to create the set from.
   * @returns {blackpard.TokenSet}
   * @throws Will throw an error if the input array is not sorted.
   */
  blackpard.TokenSet.fromArray = function (arr) {
    var builder = new blackpard.TokenSet.Builder
  
    for (var i = 0, len = arr.length; i < len; i++) {
      builder.insert(arr[i])
    }
  
    builder.finish()
    return builder.root
  }
  
  /**
   * Creates a token set from a query clause.
   *
   * @private
   * @param {Object} clause - A single clause from blackpard.Query.
   * @param {string} clause.term - The query clause term.
   * @param {number} [clause.editDistance] - The optional edit distance for the term.
   * @returns {blackpard.TokenSet}
   */
  blackpard.TokenSet.fromClause = function (clause) {
    if ('editDistance' in clause) {
      return blackpard.TokenSet.fromFuzzyString(clause.term, clause.editDistance)
    } else {
      return blackpard.TokenSet.fromString(clause.term)
    }
  }
  
  /**
   * Creates a token set representing a single string with a specified
   * edit distance.
   *
   * Insertions, deletions, substitutions and transpositions are each
   * treated as an edit distance of 1.
   *
   * Increasing the allowed edit distance will have a dramatic impact
   * on the performance of both creating and intersecting these TokenSets.
   * It is advised to keep the edit distance less than 3.
   *
   * @param {string} str - The string to create the token set from.
   * @param {number} editDistance - The allowed edit distance to match.
   * @returns {blackpard.Vector}
   */
  blackpard.TokenSet.fromFuzzyString = function (str, editDistance) {
    var root = new blackpard.TokenSet
  
    var stack = [{
      node: root,
      editsRemaining: editDistance,
      str: str
    }]
  
    while (stack.length) {
      var frame = stack.pop()
  
      // no edit
      if (frame.str.length > 0) {
        var char = frame.str.charAt(0),
            noEditNode
  
        if (char in frame.node.edges) {
          noEditNode = frame.node.edges[char]
        } else {
          noEditNode = new blackpard.TokenSet
          frame.node.edges[char] = noEditNode
        }
  
        if (frame.str.length == 1) {
          noEditNode.final = true
        }
  
        stack.push({
          node: noEditNode,
          editsRemaining: frame.editsRemaining,
          str: frame.str.slice(1)
        })
      }
  
      if (frame.editsRemaining == 0) {
        continue
      }
  
      // insertion
      if ("*" in frame.node.edges) {
        var insertionNode = frame.node.edges["*"]
      } else {
        var insertionNode = new blackpard.TokenSet
        frame.node.edges["*"] = insertionNode
      }
  
      if (frame.str.length == 0) {
        insertionNode.final = true
      }
  
      stack.push({
        node: insertionNode,
        editsRemaining: frame.editsRemaining - 1,
        str: frame.str
      })
  
      // deletion
      // can only do a deletion if we have enough edits remaining
      // and if there are characters left to delete in the string
      if (frame.str.length > 1) {
        stack.push({
          node: frame.node,
          editsRemaining: frame.editsRemaining - 1,
          str: frame.str.slice(1)
        })
      }
  
      // deletion
      // just removing the last character from the str
      if (frame.str.length == 1) {
        frame.node.final = true
      }
  
      // substitution
      // can only do a substitution if we have enough edits remaining
      // and if there are characters left to substitute
      if (frame.str.length >= 1) {
        if ("*" in frame.node.edges) {
          var substitutionNode = frame.node.edges["*"]
        } else {
          var substitutionNode = new blackpard.TokenSet
          frame.node.edges["*"] = substitutionNode
        }
  
        if (frame.str.length == 1) {
          substitutionNode.final = true
        }
  
        stack.push({
          node: substitutionNode,
          editsRemaining: frame.editsRemaining - 1,
          str: frame.str.slice(1)
        })
      }
  
      // transposition
      // can only do a transposition if there are edits remaining
      // and there are enough characters to transpose
      if (frame.str.length > 1) {
        var charA = frame.str.charAt(0),
            charB = frame.str.charAt(1),
            transposeNode
  
        if (charB in frame.node.edges) {
          transposeNode = frame.node.edges[charB]
        } else {
          transposeNode = new blackpard.TokenSet
          frame.node.edges[charB] = transposeNode
        }
  
        if (frame.str.length == 1) {
          transposeNode.final = true
        }
  
        stack.push({
          node: transposeNode,
          editsRemaining: frame.editsRemaining - 1,
          str: charA + frame.str.slice(2)
        })
      }
    }
  
    return root
  }
  
  /**
   * Creates a TokenSet from a string.
   *
   * The string may contain one or more wildcard characters (*)
   * that will allow wildcard matching when intersecting with
   * another TokenSet.
   *
   * @param {string} str - The string to create a TokenSet from.
   * @returns {blackpard.TokenSet}
   */
  blackpard.TokenSet.fromString = function (str) {
    var node = new blackpard.TokenSet,
        root = node
  
    /*
     * Iterates through all characters within the passed string
     * appending a node for each character.
     *
     * When a wildcard character is found then a self
     * referencing edge is introduced to continually match
     * any number of any characters.
     */
    for (var i = 0, len = str.length; i < len; i++) {
      var char = str[i],
          final = (i == len - 1)
  
      if (char == "*") {
        node.edges[char] = node
        node.final = final
  
      } else {
        var next = new blackpard.TokenSet
        next.final = final
  
        node.edges[char] = next
        node = next
      }
    }
  
    return root
  }
  
  /**
   * Converts this TokenSet into an array of strings
   * contained within the TokenSet.
   *
   * This is not intended to be used on a TokenSet that
   * contains wildcards, in these cases the results are
   * undefined and are likely to cause an infinite loop.
   *
   * @returns {string[]}
   */
  blackpard.TokenSet.prototype.toArray = function () {
    var words = []
  
    var stack = [{
      prefix: "",
      node: this
    }]
  
    while (stack.length) {
      var frame = stack.pop(),
          edges = Object.keys(frame.node.edges),
          len = edges.length
  
      if (frame.node.final) {
        /* In Safari, at this point the prefix is sometimes corrupted, see:
         * https://github.com/olivernn/blackpard.js/issues/279 Calling any
         * String.prototype method forces Safari to "cast" this string to what
         * it's supposed to be, fixing the bug. */
        frame.prefix.charAt(0)
        words.push(frame.prefix)
      }
  
      for (var i = 0; i < len; i++) {
        var edge = edges[i]
  
        stack.push({
          prefix: frame.prefix.concat(edge),
          node: frame.node.edges[edge]
        })
      }
    }
  
    return words
  }
  
  /**
   * Generates a string representation of a TokenSet.
   *
   * This is intended to allow TokenSets to be used as keys
   * in objects, largely to aid the construction and minimisation
   * of a TokenSet. As such it is not designed to be a human
   * friendly representation of the TokenSet.
   *
   * @returns {string}
   */
  blackpard.TokenSet.prototype.toString = function () {
    // NOTE: Using Object.keys here as this.edges is very likely
    // to enter 'hash-mode' with many keys being added
    //
    // avoiding a for-in loop here as it leads to the function
    // being de-optimised (at least in V8). From some simple
    // benchmarks the performance is comparable, but allowing
    // V8 to optimize may mean easy performance wins in the future.
  
    if (this._str) {
      return this._str
    }
  
    var str = this.final ? '1' : '0',
        labels = Object.keys(this.edges).sort(),
        len = labels.length
  
    for (var i = 0; i < len; i++) {
      var label = labels[i],
          node = this.edges[label]
  
      str = str + label + node.id
    }
  
    return str
  }
  
  /**
   * Returns a new TokenSet that is the intersection of
   * this TokenSet and the passed TokenSet.
   *
   * This intersection will take into account any wildcards
   * contained within the TokenSet.
   *
   * @param {blackpard.TokenSet} b - An other TokenSet to intersect with.
   * @returns {blackpard.TokenSet}
   */
  blackpard.TokenSet.prototype.intersect = function (b) {
    var output = new blackpard.TokenSet,
        frame = undefined
  
    var stack = [{
      qNode: b,
      output: output,
      node: this
    }]
  
    while (stack.length) {
      frame = stack.pop()
  
      // NOTE: As with the #toString method, we are using
      // Object.keys and a for loop instead of a for-in loop
      // as both of these objects enter 'hash' mode, causing
      // the function to be de-optimised in V8
      var qEdges = Object.keys(frame.qNode.edges),
          qLen = qEdges.length,
          nEdges = Object.keys(frame.node.edges),
          nLen = nEdges.length
  
      for (var q = 0; q < qLen; q++) {
        var qEdge = qEdges[q]
  
        for (var n = 0; n < nLen; n++) {
          var nEdge = nEdges[n]
  
          if (nEdge == qEdge || qEdge == '*') {
            var node = frame.node.edges[nEdge],
                qNode = frame.qNode.edges[qEdge],
                final = node.final && qNode.final,
                next = undefined
  
            if (nEdge in frame.output.edges) {
              // an edge already exists for this character
              // no need to create a new node, just set the finality
              // bit unless this node is already final
              next = frame.output.edges[nEdge]
              next.final = next.final || final
  
            } else {
              // no edge exists yet, must create one
              // set the finality bit and insert it
              // into the output
              next = new blackpard.TokenSet
              next.final = final
              frame.output.edges[nEdge] = next
            }
  
            stack.push({
              qNode: qNode,
              output: next,
              node: node
            })
          }
        }
      }
    }
  
    return output
  }
  blackpard.TokenSet.Builder = function () {
    this.previousWord = ""
    this.root = new blackpard.TokenSet
    this.uncheckedNodes = []
    this.minimizedNodes = {}
  }
  
  blackpard.TokenSet.Builder.prototype.insert = function (word) {
    var node,
        commonPrefix = 0
  
    if (word < this.previousWord) {
      throw new Error ("Out of order word insertion")
    }
  
    for (var i = 0; i < word.length && i < this.previousWord.length; i++) {
      if (word[i] != this.previousWord[i]) break
      commonPrefix++
    }
  
    this.minimize(commonPrefix)
  
    if (this.uncheckedNodes.length == 0) {
      node = this.root
    } else {
      node = this.uncheckedNodes[this.uncheckedNodes.length - 1].child
    }
  
    for (var i = commonPrefix; i < word.length; i++) {
      var nextNode = new blackpard.TokenSet,
          char = word[i]
  
      node.edges[char] = nextNode
  
      this.uncheckedNodes.push({
        parent: node,
        char: char,
        child: nextNode
      })
  
      node = nextNode
    }
  
    node.final = true
    this.previousWord = word
  }
  
  blackpard.TokenSet.Builder.prototype.finish = function () {
    this.minimize(0)
  }
  
  blackpard.TokenSet.Builder.prototype.minimize = function (downTo) {
    for (var i = this.uncheckedNodes.length - 1; i >= downTo; i--) {
      var node = this.uncheckedNodes[i],
          childKey = node.child.toString()
  
      if (childKey in this.minimizedNodes) {
        node.parent.edges[node.char] = this.minimizedNodes[childKey]
      } else {
        // Cache the key for this node since
        // we know it can't change anymore
        node.child._str = childKey
  
        this.minimizedNodes[childKey] = node.child
      }
  
      this.uncheckedNodes.pop()
    }
  }
  /*!
   * blackpard.Index
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * An index contains the built index of all documents and provides a query interface
   * to the index.
   *
   * Usually instances of blackpard.Index will not be created using this constructor, instead
   * blackpard.Builder should be used to construct new indexes, or blackpard.Index.load should be
   * used to load previously built and serialized indexes.
   *
   * @constructor
   * @param {Object} attrs - The attributes of the built search index.
   * @param {Object} attrs.invertedIndex - An index of term/field to document reference.
   * @param {Object<string, blackpard.Vector>} attrs.fieldVectors - Field vectors
   * @param {blackpard.TokenSet} attrs.tokenSet - An set of all corpus tokens.
   * @param {string[]} attrs.fields - The names of indexed document fields.
   * @param {blackpard.Pipeline} attrs.pipeline - The pipeline to use for search terms.
   */
  blackpard.Index = function (attrs) {
    this.invertedIndex = attrs.invertedIndex
    this.fieldVectors = attrs.fieldVectors
    this.tokenSet = attrs.tokenSet
    this.fields = attrs.fields
    this.pipeline = attrs.pipeline
  }
  
  /**
   * A result contains details of a document matching a search query.
   * @typedef {Object} blackpard.Index~Result
   * @property {string} ref - The reference of the document this result represents.
   * @property {number} score - A number between 0 and 1 representing how similar this document is to the query.
   * @property {blackpard.MatchData} matchData - Contains metadata about this match including which term(s) caused the match.
   */
  
  /**
   * Although blackpard provides the ability to create queries using blackpard.Query, it also provides a simple
   * query language which itself is parsed into an instance of blackpard.Query.
   *
   * For programmatically building queries it is advised to directly use blackpard.Query, the query language
   * is best used for human entered text rather than program generated text.
   *
   * At its simplest queries can just be a single term, e.g. `hello`, multiple terms are also supported
   * and will be combined with OR, e.g `hello world` will match documents that contain either 'hello'
   * or 'world', though those that contain both will rank higher in the results.
   *
   * Wildcards can be included in terms to match one or more unspecified characters, these wildcards can
   * be inserted anywhere within the term, and more than one wildcard can exist in a single term. Adding
   * wildcards will increase the number of documents that will be found but can also have a negative
   * impact on query performance, especially with wildcards at the beginning of a term.
   *
   * Terms can be restricted to specific fields, e.g. `title:hello`, only documents with the term
   * hello in the title field will match this query. Using a field not present in the index will lead
   * to an error being thrown.
   *
   * Modifiers can also be added to terms, blackpard supports edit distance and boost modifiers on terms. A term
   * boost will make documents matching that term score higher, e.g. `foo^5`. Edit distance is also supported
   * to provide fuzzy matching, e.g. 'hello~2' will match documents with hello with an edit distance of 2.
   * Avoid large values for edit distance to improve query performance.
   *
   * Each term also supports a presence modifier. By default a term's presence in document is optional, however
   * this can be changed to either required or prohibited. For a term's presence to be required in a document the
   * term should be prefixed with a '+', e.g. `+foo bar` is a search for documents that must contain 'foo' and
   * optionally contain 'bar'. Conversely a leading '-' sets the terms presence to prohibited, i.e. it must not
   * appear in a document, e.g. `-foo bar` is a search for documents that do not contain 'foo' but may contain 'bar'.
   *
   * To escape special characters the backslash character '\' can be used, this allows searches to include
   * characters that would normally be considered modifiers, e.g. `foo\~2` will search for a term "foo~2" instead
   * of attempting to apply a boost of 2 to the search term "foo".
   *
   * @typedef {string} blackpard.Index~QueryString
   * @example <caption>Simple single term query</caption>
   * hello
   * @example <caption>Multiple term query</caption>
   * hello world
   * @example <caption>term scoped to a field</caption>
   * title:hello
   * @example <caption>term with a boost of 10</caption>
   * hello^10
   * @example <caption>term with an edit distance of 2</caption>
   * hello~2
   * @example <caption>terms with presence modifiers</caption>
   * -foo +bar baz
   */
  
  /**
   * Performs a search against the index using blackpard query syntax.
   *
   * Results will be returned sorted by their score, the most relevant results
   * will be returned first.  For details on how the score is calculated, please see
   * the {@link https://blackpardjs.com/guides/searching.html#scoring|guide}.
   *
   * For more programmatic querying use blackpard.Index#query.
   *
   * @param {blackpard.Index~QueryString} queryString - A string containing a blackpard query.
   * @throws {blackpard.QueryParseError} If the passed query string cannot be parsed.
   * @returns {blackpard.Index~Result[]}
   */
  blackpard.Index.prototype.search = function (queryString) {
    return this.query(function (query) {
      var parser = new blackpard.QueryParser(queryString, query)
      parser.parse()
    })
  }
  
  /**
   * A query builder callback provides a query object to be used to express
   * the query to perform on the index.
   *
   * @callback blackpard.Index~queryBuilder
   * @param {blackpard.Query} query - The query object to build up.
   * @this blackpard.Query
   */
  
  /**
   * Performs a query against the index using the yielded blackpard.Query object.
   *
   * If performing programmatic queries against the index, this method is preferred
   * over blackpard.Index#search so as to avoid the additional query parsing overhead.
   *
   * A query object is yielded to the supplied function which should be used to
   * express the query to be run against the index.
   *
   * Note that although this function takes a callback parameter it is _not_ an
   * asynchronous operation, the callback is just yielded a query object to be
   * customized.
   *
   * @param {blackpard.Index~queryBuilder} fn - A function that is used to build the query.
   * @returns {blackpard.Index~Result[]}
   */
  blackpard.Index.prototype.query = function (fn) {
    // for each query clause
    // * process terms
    // * expand terms from token set
    // * find matching documents and metadata
    // * get document vectors
    // * score documents
  
    var query = new blackpard.Query(this.fields),
        matchingFields = Object.create(null),
        queryVectors = Object.create(null),
        termFieldCache = Object.create(null),
        requiredMatches = Object.create(null),
        prohibitedMatches = Object.create(null)
  
    /*
     * To support field level boosts a query vector is created per
     * field. An empty vector is eagerly created to support negated
     * queries.
     */
    for (var i = 0; i < this.fields.length; i++) {
      queryVectors[this.fields[i]] = new blackpard.Vector
    }
  
    fn.call(query, query)
  
    for (var i = 0; i < query.clauses.length; i++) {
      /*
       * Unless the pipeline has been disabled for this term, which is
       * the case for terms with wildcards, we need to pass the clause
       * term through the search pipeline. A pipeline returns an array
       * of processed terms. Pipeline functions may expand the passed
       * term, which means we may end up performing multiple index lookups
       * for a single query term.
       */
      var clause = query.clauses[i],
          terms = null,
          clauseMatches = blackpard.Set.empty
  
      if (clause.usePipeline) {
        terms = this.pipeline.runString(clause.term, {
          fields: clause.fields
        })
      } else {
        terms = [clause.term]
      }
  
      for (var m = 0; m < terms.length; m++) {
        var term = terms[m]
  
        /*
         * Each term returned from the pipeline needs to use the same query
         * clause object, e.g. the same boost and or edit distance. The
         * simplest way to do this is to re-use the clause object but mutate
         * its term property.
         */
        clause.term = term
  
        /*
         * From the term in the clause we create a token set which will then
         * be used to intersect the indexes token set to get a list of terms
         * to lookup in the inverted index
         */
        var termTokenSet = blackpard.TokenSet.fromClause(clause),
            expandedTerms = this.tokenSet.intersect(termTokenSet).toArray()
  
        /*
         * If a term marked as required does not exist in the tokenSet it is
         * impossible for the search to return any matches. We set all the field
         * scoped required matches set to empty and stop examining any further
         * clauses.
         */
        if (expandedTerms.length === 0 && clause.presence === blackpard.Query.presence.REQUIRED) {
          for (var k = 0; k < clause.fields.length; k++) {
            var field = clause.fields[k]
            requiredMatches[field] = blackpard.Set.empty
          }
  
          break
        }
  
        for (var j = 0; j < expandedTerms.length; j++) {
          /*
           * For each term get the posting and termIndex, this is required for
           * building the query vector.
           */
          var expandedTerm = expandedTerms[j],
              posting = this.invertedIndex[expandedTerm],
              termIndex = posting._index
  
          for (var k = 0; k < clause.fields.length; k++) {
            /*
             * For each field that this query term is scoped by (by default
             * all fields are in scope) we need to get all the document refs
             * that have this term in that field.
             *
             * The posting is the entry in the invertedIndex for the matching
             * term from above.
             */
            var field = clause.fields[k],
                fieldPosting = posting[field],
                matchingDocumentRefs = Object.keys(fieldPosting),
                termField = expandedTerm + "/" + field,
                matchingDocumentsSet = new blackpard.Set(matchingDocumentRefs)
  
            /*
             * if the presence of this term is required ensure that the matching
             * documents are added to the set of required matches for this clause.
             *
             */
            if (clause.presence == blackpard.Query.presence.REQUIRED) {
              clauseMatches = clauseMatches.union(matchingDocumentsSet)
  
              if (requiredMatches[field] === undefined) {
                requiredMatches[field] = blackpard.Set.complete
              }
            }
  
            /*
             * if the presence of this term is prohibited ensure that the matching
             * documents are added to the set of prohibited matches for this field,
             * creating that set if it does not yet exist.
             */
            if (clause.presence == blackpard.Query.presence.PROHIBITED) {
              if (prohibitedMatches[field] === undefined) {
                prohibitedMatches[field] = blackpard.Set.empty
              }
  
              prohibitedMatches[field] = prohibitedMatches[field].union(matchingDocumentsSet)
  
              /*
               * Prohibited matches should not be part of the query vector used for
               * similarity scoring and no metadata should be extracted so we continue
               * to the next field
               */
              continue
            }
  
            /*
             * The query field vector is populated using the termIndex found for
             * the term and a unit value with the appropriate boost applied.
             * Using upsert because there could already be an entry in the vector
             * for the term we are working with. In that case we just add the scores
             * together.
             */
            queryVectors[field].upsert(termIndex, clause.boost, function (a, b) { return a + b })
  
            /**
             * If we've already seen this term, field combo then we've already collected
             * the matching documents and metadata, no need to go through all that again
             */
            if (termFieldCache[termField]) {
              continue
            }
  
            for (var l = 0; l < matchingDocumentRefs.length; l++) {
              /*
               * All metadata for this term/field/document triple
               * are then extracted and collected into an instance
               * of blackpard.MatchData ready to be returned in the query
               * results
               */
              var matchingDocumentRef = matchingDocumentRefs[l],
                  matchingFieldRef = new blackpard.FieldRef (matchingDocumentRef, field),
                  metadata = fieldPosting[matchingDocumentRef],
                  fieldMatch
  
              if ((fieldMatch = matchingFields[matchingFieldRef]) === undefined) {
                matchingFields[matchingFieldRef] = new blackpard.MatchData (expandedTerm, field, metadata)
              } else {
                fieldMatch.add(expandedTerm, field, metadata)
              }
  
            }
  
            termFieldCache[termField] = true
          }
        }
      }
  
      /**
       * If the presence was required we need to update the requiredMatches field sets.
       * We do this after all fields for the term have collected their matches because
       * the clause terms presence is required in _any_ of the fields not _all_ of the
       * fields.
       */
      if (clause.presence === blackpard.Query.presence.REQUIRED) {
        for (var k = 0; k < clause.fields.length; k++) {
          var field = clause.fields[k]
          requiredMatches[field] = requiredMatches[field].intersect(clauseMatches)
        }
      }
    }
  
    /**
     * Need to combine the field scoped required and prohibited
     * matching documents into a global set of required and prohibited
     * matches
     */
    var allRequiredMatches = blackpard.Set.complete,
        allProhibitedMatches = blackpard.Set.empty
  
    for (var i = 0; i < this.fields.length; i++) {
      var field = this.fields[i]
  
      if (requiredMatches[field]) {
        allRequiredMatches = allRequiredMatches.intersect(requiredMatches[field])
      }
  
      if (prohibitedMatches[field]) {
        allProhibitedMatches = allProhibitedMatches.union(prohibitedMatches[field])
      }
    }
  
    var matchingFieldRefs = Object.keys(matchingFields),
        results = [],
        matches = Object.create(null)
  
    /*
     * If the query is negated (contains only prohibited terms)
     * we need to get _all_ fieldRefs currently existing in the
     * index. This is only done when we know that the query is
     * entirely prohibited terms to avoid any cost of getting all
     * fieldRefs unnecessarily.
     *
     * Additionally, blank MatchData must be created to correctly
     * populate the results.
     */
    if (query.isNegated()) {
      matchingFieldRefs = Object.keys(this.fieldVectors)
  
      for (var i = 0; i < matchingFieldRefs.length; i++) {
        var matchingFieldRef = matchingFieldRefs[i]
        var fieldRef = blackpard.FieldRef.fromString(matchingFieldRef)
        matchingFields[matchingFieldRef] = new blackpard.MatchData
      }
    }
  
    for (var i = 0; i < matchingFieldRefs.length; i++) {
      /*
       * Currently we have document fields that match the query, but we
       * need to return documents. The matchData and scores are combined
       * from multiple fields belonging to the same document.
       *
       * Scores are calculated by field, using the query vectors created
       * above, and combined into a final document score using addition.
       */
      var fieldRef = blackpard.FieldRef.fromString(matchingFieldRefs[i]),
          docRef = fieldRef.docRef
  
      if (!allRequiredMatches.contains(docRef)) {
        continue
      }
  
      if (allProhibitedMatches.contains(docRef)) {
        continue
      }
  
      var fieldVector = this.fieldVectors[fieldRef],
          score = queryVectors[fieldRef.fieldName].similarity(fieldVector),
          docMatch
  
      if ((docMatch = matches[docRef]) !== undefined) {
        docMatch.score += score
        docMatch.matchData.combine(matchingFields[fieldRef])
      } else {
        var match = {
          ref: docRef,
          score: score,
          matchData: matchingFields[fieldRef]
        }
        matches[docRef] = match
        results.push(match)
      }
    }
  
    /*
     * Sort the results objects by score, highest first.
     */
    return results.sort(function (a, b) {
      return b.score - a.score
    })
  }
  
  /**
   * Prepares the index for JSON serialization.
   *
   * The schema for this JSON blob will be described in a
   * separate JSON schema file.
   *
   * @returns {Object}
   */
  blackpard.Index.prototype.toJSON = function () {
    var invertedIndex = Object.keys(this.invertedIndex)
      .sort()
      .map(function (term) {
        return [term, this.invertedIndex[term]]
      }, this)
  
    var fieldVectors = Object.keys(this.fieldVectors)
      .map(function (ref) {
        return [ref, this.fieldVectors[ref].toJSON()]
      }, this)
  
    return {
      version: blackpard.version,
      fields: this.fields,
      fieldVectors: fieldVectors,
      invertedIndex: invertedIndex,
      pipeline: this.pipeline.toJSON()
    }
  }
  
  /**
   * Loads a previously serialized blackpard.Index
   *
   * @param {Object} serializedIndex - A previously serialized blackpard.Index
   * @returns {blackpard.Index}
   */
  blackpard.Index.load = function (serializedIndex) {
    var attrs = {},
        fieldVectors = {},
        serializedVectors = serializedIndex.fieldVectors,
        invertedIndex = Object.create(null),
        serializedInvertedIndex = serializedIndex.invertedIndex,
        tokenSetBuilder = new blackpard.TokenSet.Builder,
        pipeline = blackpard.Pipeline.load(serializedIndex.pipeline)
  
    if (serializedIndex.version != blackpard.version) {
      blackpard.utils.warn("Version mismatch when loading serialised index. Current version of blackpard '" + blackpard.version + "' does not match serialized index '" + serializedIndex.version + "'")
    }
  
    for (var i = 0; i < serializedVectors.length; i++) {
      var tuple = serializedVectors[i],
          ref = tuple[0],
          elements = tuple[1]
  
      fieldVectors[ref] = new blackpard.Vector(elements)
    }
  
    for (var i = 0; i < serializedInvertedIndex.length; i++) {
      var tuple = serializedInvertedIndex[i],
          term = tuple[0],
          posting = tuple[1]
  
      tokenSetBuilder.insert(term)
      invertedIndex[term] = posting
    }
  
    tokenSetBuilder.finish()
  
    attrs.fields = serializedIndex.fields
  
    attrs.fieldVectors = fieldVectors
    attrs.invertedIndex = invertedIndex
    attrs.tokenSet = tokenSetBuilder.root
    attrs.pipeline = pipeline
  
    return new blackpard.Index(attrs)
  }
  /*!
   * blackpard.Builder
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * blackpard.Builder performs indexing on a set of documents and
   * returns instances of blackpard.Index ready for querying.
   *
   * All configuration of the index is done via the builder, the
   * fields to index, the document reference, the text processing
   * pipeline and document scoring parameters are all set on the
   * builder before indexing.
   *
   * @constructor
   * @property {string} _ref - Internal reference to the document reference field.
   * @property {string[]} _fields - Internal reference to the document fields to index.
   * @property {object} invertedIndex - The inverted index maps terms to document fields.
   * @property {object} documentTermFrequencies - Keeps track of document term frequencies.
   * @property {object} documentLengths - Keeps track of the length of documents added to the index.
   * @property {blackpard.tokenizer} tokenizer - Function for splitting strings into tokens for indexing.
   * @property {blackpard.Pipeline} pipeline - The pipeline performs text processing on tokens before indexing.
   * @property {blackpard.Pipeline} searchPipeline - A pipeline for processing search terms before querying the index.
   * @property {number} documentCount - Keeps track of the total number of documents indexed.
   * @property {number} _b - A parameter to control field length normalization, setting this to 0 disabled normalization, 1 fully normalizes field lengths, the default value is 0.75.
   * @property {number} _k1 - A parameter to control how quickly an increase in term frequency results in term frequency saturation, the default value is 1.2.
   * @property {number} termIndex - A counter incremented for each unique term, used to identify a terms position in the vector space.
   * @property {array} metadataWhitelist - A list of metadata keys that have been whitelisted for entry in the index.
   */
  blackpard.Builder = function () {
    this._ref = "id"
    this._fields = Object.create(null)
    this._documents = Object.create(null)
    this.invertedIndex = Object.create(null)
    this.fieldTermFrequencies = {}
    this.fieldLengths = {}
    this.tokenizer = blackpard.tokenizer
    this.pipeline = new blackpard.Pipeline
    this.searchPipeline = new blackpard.Pipeline
    this.documentCount = 0
    this._b = 0.75
    this._k1 = 1.2
    this.termIndex = 0
    this.metadataWhitelist = []
  }
  
  /**
   * Sets the document field used as the document reference. Every document must have this field.
   * The type of this field in the document should be a string, if it is not a string it will be
   * coerced into a string by calling toString.
   *
   * The default ref is 'id'.
   *
   * The ref should _not_ be changed during indexing, it should be set before any documents are
   * added to the index. Changing it during indexing can lead to inconsistent results.
   *
   * @param {string} ref - The name of the reference field in the document.
   */
  blackpard.Builder.prototype.ref = function (ref) {
    this._ref = ref
  }
  
  /**
   * A function that is used to extract a field from a document.
   *
   * blackpard expects a field to be at the top level of a document, if however the field
   * is deeply nested within a document an extractor function can be used to extract
   * the right field for indexing.
   *
   * @callback fieldExtractor
   * @param {object} doc - The document being added to the index.
   * @returns {?(string|object|object[])} obj - The object that will be indexed for this field.
   * @example <caption>Extracting a nested field</caption>
   * function (doc) { return doc.nested.field }
   */
  
  /**
   * Adds a field to the list of document fields that will be indexed. Every document being
   * indexed should have this field. Null values for this field in indexed documents will
   * not cause errors but will limit the chance of that document being retrieved by searches.
   *
   * All fields should be added before adding documents to the index. Adding fields after
   * a document has been indexed will have no effect on already indexed documents.
   *
   * Fields can be boosted at build time. This allows terms within that field to have more
   * importance when ranking search results. Use a field boost to specify that matches within
   * one field are more important than other fields.
   *
   * @param {string} fieldName - The name of a field to index in all documents.
   * @param {object} attributes - Optional attributes associated with this field.
   * @param {number} [attributes.boost=1] - Boost applied to all terms within this field.
   * @param {fieldExtractor} [attributes.extractor] - Function to extract a field from a document.
   * @throws {RangeError} fieldName cannot contain unsupported characters '/'
   */
  blackpard.Builder.prototype.field = function (fieldName, attributes) {
    if (/\//.test(fieldName)) {
      throw new RangeError ("Field '" + fieldName + "' contains illegal character '/'")
    }
  
    this._fields[fieldName] = attributes || {}
  }
  
  /**
   * A parameter to tune the amount of field length normalisation that is applied when
   * calculating relevance scores. A value of 0 will completely disable any normalisation
   * and a value of 1 will fully normalise field lengths. The default is 0.75. Values of b
   * will be clamped to the range 0 - 1.
   *
   * @param {number} number - The value to set for this tuning parameter.
   */
  blackpard.Builder.prototype.b = function (number) {
    if (number < 0) {
      this._b = 0
    } else if (number > 1) {
      this._b = 1
    } else {
      this._b = number
    }
  }
  
  /**
   * A parameter that controls the speed at which a rise in term frequency results in term
   * frequency saturation. The default value is 1.2. Setting this to a higher value will give
   * slower saturation levels, a lower value will result in quicker saturation.
   *
   * @param {number} number - The value to set for this tuning parameter.
   */
  blackpard.Builder.prototype.k1 = function (number) {
    this._k1 = number
  }
  
  /**
   * Adds a document to the index.
   *
   * Before adding fields to the index the index should have been fully setup, with the document
   * ref and all fields to index already having been specified.
   *
   * The document must have a field name as specified by the ref (by default this is 'id') and
   * it should have all fields defined for indexing, though null or undefined values will not
   * cause errors.
   *
   * Entire documents can be boosted at build time. Applying a boost to a document indicates that
   * this document should rank higher in search results than other documents.
   *
   * @param {object} doc - The document to add to the index.
   * @param {object} attributes - Optional attributes associated with this document.
   * @param {number} [attributes.boost=1] - Boost applied to all terms within this document.
   */
  blackpard.Builder.prototype.add = function (doc, attributes) {
    var docRef = doc[this._ref],
        fields = Object.keys(this._fields)
  
    this._documents[docRef] = attributes || {}
    this.documentCount += 1
  
    for (var i = 0; i < fields.length; i++) {
      var fieldName = fields[i],
          extractor = this._fields[fieldName].extractor,
          field = extractor ? extractor(doc) : doc[fieldName],
          tokens = this.tokenizer(field, {
            fields: [fieldName]
          }),
          terms = this.pipeline.run(tokens),
          fieldRef = new blackpard.FieldRef (docRef, fieldName),
          fieldTerms = Object.create(null)
  
      this.fieldTermFrequencies[fieldRef] = fieldTerms
      this.fieldLengths[fieldRef] = 0
  
      // store the length of this field for this document
      this.fieldLengths[fieldRef] += terms.length
  
      // calculate term frequencies for this field
      for (var j = 0; j < terms.length; j++) {
        var term = terms[j]
  
        if (fieldTerms[term] == undefined) {
          fieldTerms[term] = 0
        }
  
        fieldTerms[term] += 1
  
        // add to inverted index
        // create an initial posting if one doesn't exist
        if (this.invertedIndex[term] == undefined) {
          var posting = Object.create(null)
          posting["_index"] = this.termIndex
          this.termIndex += 1
  
          for (var k = 0; k < fields.length; k++) {
            posting[fields[k]] = Object.create(null)
          }
  
          this.invertedIndex[term] = posting
        }
  
        // add an entry for this term/fieldName/docRef to the invertedIndex
        if (this.invertedIndex[term][fieldName][docRef] == undefined) {
          this.invertedIndex[term][fieldName][docRef] = Object.create(null)
        }
  
        // store all whitelisted metadata about this token in the
        // inverted index
        for (var l = 0; l < this.metadataWhitelist.length; l++) {
          var metadataKey = this.metadataWhitelist[l],
              metadata = term.metadata[metadataKey]
  
          if (this.invertedIndex[term][fieldName][docRef][metadataKey] == undefined) {
            this.invertedIndex[term][fieldName][docRef][metadataKey] = []
          }
  
          this.invertedIndex[term][fieldName][docRef][metadataKey].push(metadata)
        }
      }
  
    }
  }
  
  /**
   * Calculates the average document length for this index
   *
   * @private
   */
  blackpard.Builder.prototype.calculateAverageFieldLengths = function () {
  
    var fieldRefs = Object.keys(this.fieldLengths),
        numberOfFields = fieldRefs.length,
        accumulator = {},
        documentsWithField = {}
  
    for (var i = 0; i < numberOfFields; i++) {
      var fieldRef = blackpard.FieldRef.fromString(fieldRefs[i]),
          field = fieldRef.fieldName
  
      documentsWithField[field] || (documentsWithField[field] = 0)
      documentsWithField[field] += 1
  
      accumulator[field] || (accumulator[field] = 0)
      accumulator[field] += this.fieldLengths[fieldRef]
    }
  
    var fields = Object.keys(this._fields)
  
    for (var i = 0; i < fields.length; i++) {
      var fieldName = fields[i]
      accumulator[fieldName] = accumulator[fieldName] / documentsWithField[fieldName]
    }
  
    this.averageFieldLength = accumulator
  }
  
  /**
   * Builds a vector space model of every document using blackpard.Vector
   *
   * @private
   */
  blackpard.Builder.prototype.createFieldVectors = function () {
    var fieldVectors = {},
        fieldRefs = Object.keys(this.fieldTermFrequencies),
        fieldRefsLength = fieldRefs.length,
        termIdfCache = Object.create(null)
  
    for (var i = 0; i < fieldRefsLength; i++) {
      var fieldRef = blackpard.FieldRef.fromString(fieldRefs[i]),
          fieldName = fieldRef.fieldName,
          fieldLength = this.fieldLengths[fieldRef],
          fieldVector = new blackpard.Vector,
          termFrequencies = this.fieldTermFrequencies[fieldRef],
          terms = Object.keys(termFrequencies),
          termsLength = terms.length
  
  
      var fieldBoost = this._fields[fieldName].boost || 1,
          docBoost = this._documents[fieldRef.docRef].boost || 1
  
      for (var j = 0; j < termsLength; j++) {
        var term = terms[j],
            tf = termFrequencies[term],
            termIndex = this.invertedIndex[term]._index,
            idf, score, scoreWithPrecision
  
        if (termIdfCache[term] === undefined) {
          idf = blackpard.idf(this.invertedIndex[term], this.documentCount)
          termIdfCache[term] = idf
        } else {
          idf = termIdfCache[term]
        }
  
        score = idf * ((this._k1 + 1) * tf) / (this._k1 * (1 - this._b + this._b * (fieldLength / this.averageFieldLength[fieldName])) + tf)
        score *= fieldBoost
        score *= docBoost
        scoreWithPrecision = Math.round(score * 1000) / 1000
        // Converts 1.23456789 to 1.234.
        // Reducing the precision so that the vectors take up less
        // space when serialised. Doing it now so that they behave
        // the same before and after serialisation. Also, this is
        // the fastest approach to reducing a number's precision in
        // JavaScript.
  
        fieldVector.insert(termIndex, scoreWithPrecision)
      }
  
      fieldVectors[fieldRef] = fieldVector
    }
  
    this.fieldVectors = fieldVectors
  }
  
  /**
   * Creates a token set of all tokens in the index using blackpard.TokenSet
   *
   * @private
   */
  blackpard.Builder.prototype.createTokenSet = function () {
    this.tokenSet = blackpard.TokenSet.fromArray(
      Object.keys(this.invertedIndex).sort()
    )
  }
  
  /**
   * Builds the index, creating an instance of blackpard.Index.
   *
   * This completes the indexing process and should only be called
   * once all documents have been added to the index.
   *
   * @returns {blackpard.Index}
   */
  blackpard.Builder.prototype.build = function () {
    this.calculateAverageFieldLengths()
    this.createFieldVectors()
    this.createTokenSet()
  
    return new blackpard.Index({
      invertedIndex: this.invertedIndex,
      fieldVectors: this.fieldVectors,
      tokenSet: this.tokenSet,
      fields: Object.keys(this._fields),
      pipeline: this.searchPipeline
    })
  }
  
  /**
   * Applies a plugin to the index builder.
   *
   * A plugin is a function that is called with the index builder as its context.
   * Plugins can be used to customise or extend the behaviour of the index
   * in some way. A plugin is just a function, that encapsulated the custom
   * behaviour that should be applied when building the index.
   *
   * The plugin function will be called with the index builder as its argument, additional
   * arguments can also be passed when calling use. The function will be called
   * with the index builder as its context.
   *
   * @param {Function} plugin The plugin to apply.
   */
  blackpard.Builder.prototype.use = function (fn) {
    var args = Array.prototype.slice.call(arguments, 1)
    args.unshift(this)
    fn.apply(this, args)
  }
  /**
   * Contains and collects metadata about a matching document.
   * A single instance of blackpard.MatchData is returned as part of every
   * blackpard.Index~Result.
   *
   * @constructor
   * @param {string} term - The term this match data is associated with
   * @param {string} field - The field in which the term was found
   * @param {object} metadata - The metadata recorded about this term in this field
   * @property {object} metadata - A cloned collection of metadata associated with this document.
   * @see {@link blackpard.Index~Result}
   */
  blackpard.MatchData = function (term, field, metadata) {
    var clonedMetadata = Object.create(null),
        metadataKeys = Object.keys(metadata || {})
  
    // Cloning the metadata to prevent the original
    // being mutated during match data combination.
    // Metadata is kept in an array within the inverted
    // index so cloning the data can be done with
    // Array#slice
    for (var i = 0; i < metadataKeys.length; i++) {
      var key = metadataKeys[i]
      clonedMetadata[key] = metadata[key].slice()
    }
  
    this.metadata = Object.create(null)
  
    if (term !== undefined) {
      this.metadata[term] = Object.create(null)
      this.metadata[term][field] = clonedMetadata
    }
  }
  
  /**
   * An instance of blackpard.MatchData will be created for every term that matches a
   * document. However only one instance is required in a blackpard.Index~Result. This
   * method combines metadata from another instance of blackpard.MatchData with this
   * objects metadata.
   *
   * @param {blackpard.MatchData} otherMatchData - Another instance of match data to merge with this one.
   * @see {@link blackpard.Index~Result}
   */
  blackpard.MatchData.prototype.combine = function (otherMatchData) {
    var terms = Object.keys(otherMatchData.metadata)
  
    for (var i = 0; i < terms.length; i++) {
      var term = terms[i],
          fields = Object.keys(otherMatchData.metadata[term])
  
      if (this.metadata[term] == undefined) {
        this.metadata[term] = Object.create(null)
      }
  
      for (var j = 0; j < fields.length; j++) {
        var field = fields[j],
            keys = Object.keys(otherMatchData.metadata[term][field])
  
        if (this.metadata[term][field] == undefined) {
          this.metadata[term][field] = Object.create(null)
        }
  
        for (var k = 0; k < keys.length; k++) {
          var key = keys[k]
  
          if (this.metadata[term][field][key] == undefined) {
            this.metadata[term][field][key] = otherMatchData.metadata[term][field][key]
          } else {
            this.metadata[term][field][key] = this.metadata[term][field][key].concat(otherMatchData.metadata[term][field][key])
          }
  
        }
      }
    }
  }
  
  /**
   * Add metadata for a term/field pair to this instance of match data.
   *
   * @param {string} term - The term this match data is associated with
   * @param {string} field - The field in which the term was found
   * @param {object} metadata - The metadata recorded about this term in this field
   */
  blackpard.MatchData.prototype.add = function (term, field, metadata) {
    if (!(term in this.metadata)) {
      this.metadata[term] = Object.create(null)
      this.metadata[term][field] = metadata
      return
    }
  
    if (!(field in this.metadata[term])) {
      this.metadata[term][field] = metadata
      return
    }
  
    var metadataKeys = Object.keys(metadata)
  
    for (var i = 0; i < metadataKeys.length; i++) {
      var key = metadataKeys[i]
  
      if (key in this.metadata[term][field]) {
        this.metadata[term][field][key] = this.metadata[term][field][key].concat(metadata[key])
      } else {
        this.metadata[term][field][key] = metadata[key]
      }
    }
  }
  /**
   * A blackpard.Query provides a programmatic way of defining queries to be performed
   * against a {@link blackpard.Index}.
   *
   * Prefer constructing a blackpard.Query using the {@link blackpard.Index#query} method
   * so the query object is pre-initialized with the right index fields.
   *
   * @constructor
   * @property {blackpard.Query~Clause[]} clauses - An array of query clauses.
   * @property {string[]} allFields - An array of all available fields in a blackpard.Index.
   */
  blackpard.Query = function (allFields) {
    this.clauses = []
    this.allFields = allFields
  }
  
  /**
   * Constants for indicating what kind of automatic wildcard insertion will be used when constructing a query clause.
   *
   * This allows wildcards to be added to the beginning and end of a term without having to manually do any string
   * concatenation.
   *
   * The wildcard constants can be bitwise combined to select both leading and trailing wildcards.
   *
   * @constant
   * @default
   * @property {number} wildcard.NONE - The term will have no wildcards inserted, this is the default behaviour
   * @property {number} wildcard.LEADING - Prepend the term with a wildcard, unless a leading wildcard already exists
   * @property {number} wildcard.TRAILING - Append a wildcard to the term, unless a trailing wildcard already exists
   * @see blackpard.Query~Clause
   * @see blackpard.Query#clause
   * @see blackpard.Query#term
   * @example <caption>query term with trailing wildcard</caption>
   * query.term('foo', { wildcard: blackpard.Query.wildcard.TRAILING })
   * @example <caption>query term with leading and trailing wildcard</caption>
   * query.term('foo', {
   *   wildcard: blackpard.Query.wildcard.LEADING | blackpard.Query.wildcard.TRAILING
   * })
   */
  
  blackpard.Query.wildcard = new String ("*")
  blackpard.Query.wildcard.NONE = 0
  blackpard.Query.wildcard.LEADING = 1
  blackpard.Query.wildcard.TRAILING = 2
  
  /**
   * Constants for indicating what kind of presence a term must have in matching documents.
   *
   * @constant
   * @enum {number}
   * @see blackpard.Query~Clause
   * @see blackpard.Query#clause
   * @see blackpard.Query#term
   * @example <caption>query term with required presence</caption>
   * query.term('foo', { presence: blackpard.Query.presence.REQUIRED })
   */
  blackpard.Query.presence = {
    /**
     * Term's presence in a document is optional, this is the default value.
     */
    OPTIONAL: 1,
  
    /**
     * Term's presence in a document is required, documents that do not contain
     * this term will not be returned.
     */
    REQUIRED: 2,
  
    /**
     * Term's presence in a document is prohibited, documents that do contain
     * this term will not be returned.
     */
    PROHIBITED: 3
  }
  
  /**
   * A single clause in a {@link blackpard.Query} contains a term and details on how to
   * match that term against a {@link blackpard.Index}.
   *
   * @typedef {Object} blackpard.Query~Clause
   * @property {string[]} fields - The fields in an index this clause should be matched against.
   * @property {number} [boost=1] - Any boost that should be applied when matching this clause.
   * @property {number} [editDistance] - Whether the term should have fuzzy matching applied, and how fuzzy the match should be.
   * @property {boolean} [usePipeline] - Whether the term should be passed through the search pipeline.
   * @property {number} [wildcard=blackpard.Query.wildcard.NONE] - Whether the term should have wildcards appended or prepended.
   * @property {number} [presence=blackpard.Query.presence.OPTIONAL] - The terms presence in any matching documents.
   */
  
  /**
   * Adds a {@link blackpard.Query~Clause} to this query.
   *
   * Unless the clause contains the fields to be matched all fields will be matched. In addition
   * a default boost of 1 is applied to the clause.
   *
   * @param {blackpard.Query~Clause} clause - The clause to add to this query.
   * @see blackpard.Query~Clause
   * @returns {blackpard.Query}
   */
  blackpard.Query.prototype.clause = function (clause) {
    if (!('fields' in clause)) {
      clause.fields = this.allFields
    }
  
    if (!('boost' in clause)) {
      clause.boost = 1
    }
  
    if (!('usePipeline' in clause)) {
      clause.usePipeline = true
    }
  
    if (!('wildcard' in clause)) {
      clause.wildcard = blackpard.Query.wildcard.NONE
    }
  
    if ((clause.wildcard & blackpard.Query.wildcard.LEADING) && (clause.term.charAt(0) != blackpard.Query.wildcard)) {
      clause.term = "*" + clause.term
    }
  
    if ((clause.wildcard & blackpard.Query.wildcard.TRAILING) && (clause.term.slice(-1) != blackpard.Query.wildcard)) {
      clause.term = "" + clause.term + "*"
    }
  
    if (!('presence' in clause)) {
      clause.presence = blackpard.Query.presence.OPTIONAL
    }
  
    this.clauses.push(clause)
  
    return this
  }
  
  /**
   * A negated query is one in which every clause has a presence of
   * prohibited. These queries require some special processing to return
   * the expected results.
   *
   * @returns boolean
   */
  blackpard.Query.prototype.isNegated = function () {
    for (var i = 0; i < this.clauses.length; i++) {
      if (this.clauses[i].presence != blackpard.Query.presence.PROHIBITED) {
        return false
      }
    }
  
    return true
  }
  
  /**
   * Adds a term to the current query, under the covers this will create a {@link blackpard.Query~Clause}
   * to the list of clauses that make up this query.
   *
   * The term is used as is, i.e. no tokenization will be performed by this method. Instead conversion
   * to a token or token-like string should be done before calling this method.
   *
   * The term will be converted to a string by calling `toString`. Multiple terms can be passed as an
   * array, each term in the array will share the same options.
   *
   * @param {object|object[]} term - The term(s) to add to the query.
   * @param {object} [options] - Any additional properties to add to the query clause.
   * @returns {blackpard.Query}
   * @see blackpard.Query#clause
   * @see blackpard.Query~Clause
   * @example <caption>adding a single term to a query</caption>
   * query.term("foo")
   * @example <caption>adding a single term to a query and specifying search fields, term boost and automatic trailing wildcard</caption>
   * query.term("foo", {
   *   fields: ["title"],
   *   boost: 10,
   *   wildcard: blackpard.Query.wildcard.TRAILING
   * })
   * @example <caption>using blackpard.tokenizer to convert a string to tokens before using them as terms</caption>
   * query.term(blackpard.tokenizer("foo bar"))
   */
  blackpard.Query.prototype.term = function (term, options) {
    if (Array.isArray(term)) {
      term.forEach(function (t) { this.term(t, blackpard.utils.clone(options)) }, this)
      return this
    }
  
    var clause = options || {}
    clause.term = term.toString()
  
    this.clause(clause)
  
    return this
  }
  blackpard.QueryParseError = function (message, start, end) {
    this.name = "QueryParseError"
    this.message = message
    this.start = start
    this.end = end
  }
  
  blackpard.QueryParseError.prototype = new Error
  blackpard.QueryLexer = function (str) {
    this.lexemes = []
    this.str = str
    this.length = str.length
    this.pos = 0
    this.start = 0
    this.escapeCharPositions = []
  }
  
  blackpard.QueryLexer.prototype.run = function () {
    var state = blackpard.QueryLexer.lexText
  
    while (state) {
      state = state(this)
    }
  }
  
  blackpard.QueryLexer.prototype.sliceString = function () {
    var subSlices = [],
        sliceStart = this.start,
        sliceEnd = this.pos
  
    for (var i = 0; i < this.escapeCharPositions.length; i++) {
      sliceEnd = this.escapeCharPositions[i]
      subSlices.push(this.str.slice(sliceStart, sliceEnd))
      sliceStart = sliceEnd + 1
    }
  
    subSlices.push(this.str.slice(sliceStart, this.pos))
    this.escapeCharPositions.length = 0
  
    return subSlices.join('')
  }
  
  blackpard.QueryLexer.prototype.emit = function (type) {
    this.lexemes.push({
      type: type,
      str: this.sliceString(),
      start: this.start,
      end: this.pos
    })
  
    this.start = this.pos
  }
  
  blackpard.QueryLexer.prototype.escapeCharacter = function () {
    this.escapeCharPositions.push(this.pos - 1)
    this.pos += 1
  }
  
  blackpard.QueryLexer.prototype.next = function () {
    if (this.pos >= this.length) {
      return blackpard.QueryLexer.EOS
    }
  
    var char = this.str.charAt(this.pos)
    this.pos += 1
    return char
  }
  
  blackpard.QueryLexer.prototype.width = function () {
    return this.pos - this.start
  }
  
  blackpard.QueryLexer.prototype.ignore = function () {
    if (this.start == this.pos) {
      this.pos += 1
    }
  
    this.start = this.pos
  }
  
  blackpard.QueryLexer.prototype.backup = function () {
    this.pos -= 1
  }
  
  blackpard.QueryLexer.prototype.acceptDigitRun = function () {
    var char, charCode
  
    do {
      char = this.next()
      charCode = char.charCodeAt(0)
    } while (charCode > 47 && charCode < 58)
  
    if (char != blackpard.QueryLexer.EOS) {
      this.backup()
    }
  }
  
  blackpard.QueryLexer.prototype.more = function () {
    return this.pos < this.length
  }
  
  blackpard.QueryLexer.EOS = 'EOS'
  blackpard.QueryLexer.FIELD = 'FIELD'
  blackpard.QueryLexer.TERM = 'TERM'
  blackpard.QueryLexer.EDIT_DISTANCE = 'EDIT_DISTANCE'
  blackpard.QueryLexer.BOOST = 'BOOST'
  blackpard.QueryLexer.PRESENCE = 'PRESENCE'
  
  blackpard.QueryLexer.lexField = function (lexer) {
    lexer.backup()
    lexer.emit(blackpard.QueryLexer.FIELD)
    lexer.ignore()
    return blackpard.QueryLexer.lexText
  }
  
  blackpard.QueryLexer.lexTerm = function (lexer) {
    if (lexer.width() > 1) {
      lexer.backup()
      lexer.emit(blackpard.QueryLexer.TERM)
    }
  
    lexer.ignore()
  
    if (lexer.more()) {
      return blackpard.QueryLexer.lexText
    }
  }
  
  blackpard.QueryLexer.lexEditDistance = function (lexer) {
    lexer.ignore()
    lexer.acceptDigitRun()
    lexer.emit(blackpard.QueryLexer.EDIT_DISTANCE)
    return blackpard.QueryLexer.lexText
  }
  
  blackpard.QueryLexer.lexBoost = function (lexer) {
    lexer.ignore()
    lexer.acceptDigitRun()
    lexer.emit(blackpard.QueryLexer.BOOST)
    return blackpard.QueryLexer.lexText
  }
  
  blackpard.QueryLexer.lexEOS = function (lexer) {
    if (lexer.width() > 0) {
      lexer.emit(blackpard.QueryLexer.TERM)
    }
  }
  
  // This matches the separator used when tokenising fields
  // within a document. These should match otherwise it is
  // not possible to search for some tokens within a document.
  //
  // It is possible for the user to change the separator on the
  // tokenizer so it _might_ clash with any other of the special
  // characters already used within the search string, e.g. :.
  //
  // This means that it is possible to change the separator in
  // such a way that makes some words unsearchable using a search
  // string.
  blackpard.QueryLexer.termSeparator = blackpard.tokenizer.separator
  
  blackpard.QueryLexer.lexText = function (lexer) {
    while (true) {
      var char = lexer.next()
  
      if (char == blackpard.QueryLexer.EOS) {
        return blackpard.QueryLexer.lexEOS
      }
  
      // Escape character is '\'
      if (char.charCodeAt(0) == 92) {
        lexer.escapeCharacter()
        continue
      }
  
      if (char == ":") {
        return blackpard.QueryLexer.lexField
      }
  
      if (char == "~") {
        lexer.backup()
        if (lexer.width() > 0) {
          lexer.emit(blackpard.QueryLexer.TERM)
        }
        return blackpard.QueryLexer.lexEditDistance
      }
  
      if (char == "^") {
        lexer.backup()
        if (lexer.width() > 0) {
          lexer.emit(blackpard.QueryLexer.TERM)
        }
        return blackpard.QueryLexer.lexBoost
      }
  
      // "+" indicates term presence is required
      // checking for length to ensure that only
      // leading "+" are considered
      if (char == "+" && lexer.width() === 1) {
        lexer.emit(blackpard.QueryLexer.PRESENCE)
        return blackpard.QueryLexer.lexText
      }
  
      // "-" indicates term presence is prohibited
      // checking for length to ensure that only
      // leading "-" are considered
      if (char == "-" && lexer.width() === 1) {
        lexer.emit(blackpard.QueryLexer.PRESENCE)
        return blackpard.QueryLexer.lexText
      }
  
      if (char.match(blackpard.QueryLexer.termSeparator)) {
        return blackpard.QueryLexer.lexTerm
      }
    }
  }
  
  blackpard.QueryParser = function (str, query) {
    this.lexer = new blackpard.QueryLexer (str)
    this.query = query
    this.currentClause = {}
    this.lexemeIdx = 0
  }
  
  blackpard.QueryParser.prototype.parse = function () {
    this.lexer.run()
    this.lexemes = this.lexer.lexemes
  
    var state = blackpard.QueryParser.parseClause
  
    while (state) {
      state = state(this)
    }
  
    return this.query
  }
  
  blackpard.QueryParser.prototype.peekLexeme = function () {
    return this.lexemes[this.lexemeIdx]
  }
  
  blackpard.QueryParser.prototype.consumeLexeme = function () {
    var lexeme = this.peekLexeme()
    this.lexemeIdx += 1
    return lexeme
  }
  
  blackpard.QueryParser.prototype.nextClause = function () {
    var completedClause = this.currentClause
    this.query.clause(completedClause)
    this.currentClause = {}
  }
  
  blackpard.QueryParser.parseClause = function (parser) {
    var lexeme = parser.peekLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    switch (lexeme.type) {
      case blackpard.QueryLexer.PRESENCE:
        return blackpard.QueryParser.parsePresence
      case blackpard.QueryLexer.FIELD:
        return blackpard.QueryParser.parseField
      case blackpard.QueryLexer.TERM:
        return blackpard.QueryParser.parseTerm
      default:
        var errorMessage = "expected either a field or a term, found " + lexeme.type
  
        if (lexeme.str.length >= 1) {
          errorMessage += " with value '" + lexeme.str + "'"
        }
  
        throw new blackpard.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  }
  
  blackpard.QueryParser.parsePresence = function (parser) {
    var lexeme = parser.consumeLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    switch (lexeme.str) {
      case "-":
        parser.currentClause.presence = blackpard.Query.presence.PROHIBITED
        break
      case "+":
        parser.currentClause.presence = blackpard.Query.presence.REQUIRED
        break
      default:
        var errorMessage = "unrecognised presence operator'" + lexeme.str + "'"
        throw new blackpard.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  
    var nextLexeme = parser.peekLexeme()
  
    if (nextLexeme == undefined) {
      var errorMessage = "expecting term or field, found nothing"
      throw new blackpard.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  
    switch (nextLexeme.type) {
      case blackpard.QueryLexer.FIELD:
        return blackpard.QueryParser.parseField
      case blackpard.QueryLexer.TERM:
        return blackpard.QueryParser.parseTerm
      default:
        var errorMessage = "expecting term or field, found '" + nextLexeme.type + "'"
        throw new blackpard.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
    }
  }
  
  blackpard.QueryParser.parseField = function (parser) {
    var lexeme = parser.consumeLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    if (parser.query.allFields.indexOf(lexeme.str) == -1) {
      var possibleFields = parser.query.allFields.map(function (f) { return "'" + f + "'" }).join(', '),
          errorMessage = "unrecognised field '" + lexeme.str + "', possible fields: " + possibleFields
  
      throw new blackpard.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  
    parser.currentClause.fields = [lexeme.str]
  
    var nextLexeme = parser.peekLexeme()
  
    if (nextLexeme == undefined) {
      var errorMessage = "expecting term, found nothing"
      throw new blackpard.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  
    switch (nextLexeme.type) {
      case blackpard.QueryLexer.TERM:
        return blackpard.QueryParser.parseTerm
      default:
        var errorMessage = "expecting term, found '" + nextLexeme.type + "'"
        throw new blackpard.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
    }
  }
  
  blackpard.QueryParser.parseTerm = function (parser) {
    var lexeme = parser.consumeLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    parser.currentClause.term = lexeme.str.toLowerCase()
  
    if (lexeme.str.indexOf("*") != -1) {
      parser.currentClause.usePipeline = false
    }
  
    var nextLexeme = parser.peekLexeme()
  
    if (nextLexeme == undefined) {
      parser.nextClause()
      return
    }
  
    switch (nextLexeme.type) {
      case blackpard.QueryLexer.TERM:
        parser.nextClause()
        return blackpard.QueryParser.parseTerm
      case blackpard.QueryLexer.FIELD:
        parser.nextClause()
        return blackpard.QueryParser.parseField
      case blackpard.QueryLexer.EDIT_DISTANCE:
        return blackpard.QueryParser.parseEditDistance
      case blackpard.QueryLexer.BOOST:
        return blackpard.QueryParser.parseBoost
      case blackpard.QueryLexer.PRESENCE:
        parser.nextClause()
        return blackpard.QueryParser.parsePresence
      default:
        var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'"
        throw new blackpard.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
    }
  }
  
  blackpard.QueryParser.parseEditDistance = function (parser) {
    var lexeme = parser.consumeLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    var editDistance = parseInt(lexeme.str, 10)
  
    if (isNaN(editDistance)) {
      var errorMessage = "edit distance must be numeric"
      throw new blackpard.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  
    parser.currentClause.editDistance = editDistance
  
    var nextLexeme = parser.peekLexeme()
  
    if (nextLexeme == undefined) {
      parser.nextClause()
      return
    }
  
    switch (nextLexeme.type) {
      case blackpard.QueryLexer.TERM:
        parser.nextClause()
        return blackpard.QueryParser.parseTerm
      case blackpard.QueryLexer.FIELD:
        parser.nextClause()
        return blackpard.QueryParser.parseField
      case blackpard.QueryLexer.EDIT_DISTANCE:
        return blackpard.QueryParser.parseEditDistance
      case blackpard.QueryLexer.BOOST:
        return blackpard.QueryParser.parseBoost
      case blackpard.QueryLexer.PRESENCE:
        parser.nextClause()
        return blackpard.QueryParser.parsePresence
      default:
        var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'"
        throw new blackpard.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
    }
  }
  
  blackpard.QueryParser.parseBoost = function (parser) {
    var lexeme = parser.consumeLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    var boost = parseInt(lexeme.str, 10)
  
    if (isNaN(boost)) {
      var errorMessage = "boost must be numeric"
      throw new blackpard.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  
    parser.currentClause.boost = boost
  
    var nextLexeme = parser.peekLexeme()
  
    if (nextLexeme == undefined) {
      parser.nextClause()
      return
    }
  
    switch (nextLexeme.type) {
      case blackpard.QueryLexer.TERM:
        parser.nextClause()
        return blackpard.QueryParser.parseTerm
      case blackpard.QueryLexer.FIELD:
        parser.nextClause()
        return blackpard.QueryParser.parseField
      case blackpard.QueryLexer.EDIT_DISTANCE:
        return blackpard.QueryParser.parseEditDistance
      case blackpard.QueryLexer.BOOST:
        return blackpard.QueryParser.parseBoost
      case blackpard.QueryLexer.PRESENCE:
        parser.nextClause()
        return blackpard.QueryParser.parsePresence
      default:
        var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'"
        throw new blackpard.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
    }
  }
  
    /**
     * export the module via AMD, CommonJS or as a browser global
     * Export code from https://github.com/umdjs/umd/blob/master/returnExports.js
     */
    ;(function (root, factory) {
      if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory)
      } else if (typeof exports === 'object') {
        /**
         * Node. Does not work with strict CommonJS, but
         * only CommonJS-like enviroments that support module.exports,
         * like Node.
         */
        module.exports = factory()
      } else {
        // Browser globals (root is window)
        root.blackpard = factory()
      }
    }(this, function () {
      /**
       * Just return a value to define the module export.
       * This example returns an object, but the module
       * can return a function as the exported value.
       */
      return blackpard
    }))
  })();

  /* blackpard v1.6.5 craig.is/killing/mice */
(function(q,u,c){function v(a,b,g){a.addEventListener?a.addEventListener(b,g,!1):a.attachEvent("on"+b,g)}function z(a){if("keypress"==a.type){var b=String.fromCharCode(a.which);a.shiftKey||(b=b.toLowerCase());return b}return n[a.which]?n[a.which]:r[a.which]?r[a.which]:String.fromCharCode(a.which).toLowerCase()}function F(a){var b=[];a.shiftKey&&b.push("shift");a.altKey&&b.push("alt");a.ctrlKey&&b.push("ctrl");a.metaKey&&b.push("meta");return b}function w(a){return"shift"==a||"ctrl"==a||"alt"==a||
"meta"==a}function A(a,b){var g,d=[];var e=a;"+"===e?e=["+"]:(e=e.replace(/\+{2}/g,"+plus"),e=e.split("+"));for(g=0;g<e.length;++g){var m=e[g];B[m]&&(m=B[m]);b&&"keypress"!=b&&C[m]&&(m=C[m],d.push("shift"));w(m)&&d.push(m)}e=m;g=b;if(!g){if(!p){p={};for(var c in n)95<c&&112>c||n.hasOwnProperty(c)&&(p[n[c]]=c)}g=p[e]?"keydown":"keypress"}"keypress"==g&&d.length&&(g="keydown");return{key:m,modifiers:d,action:g}}function D(a,b){return null===a||a===u?!1:a===b?!0:D(a.parentNode,b)}function d(a){function b(a){a=
a||{};var b=!1,l;for(l in p)a[l]?b=!0:p[l]=0;b||(x=!1)}function g(a,b,t,f,g,d){var l,E=[],h=t.type;if(!k._callbacks[a])return[];"keyup"==h&&w(a)&&(b=[a]);for(l=0;l<k._callbacks[a].length;++l){var c=k._callbacks[a][l];if((f||!c.seq||p[c.seq]==c.level)&&h==c.action){var e;(e="keypress"==h&&!t.metaKey&&!t.ctrlKey)||(e=c.modifiers,e=b.sort().join(",")===e.sort().join(","));e&&(e=f&&c.seq==f&&c.level==d,(!f&&c.combo==g||e)&&k._callbacks[a].splice(l,1),E.push(c))}}return E}function c(a,b,c,f){k.stopCallback(b,
b.target||b.srcElement,c,f)||!1!==a(b,c)||(b.preventDefault?b.preventDefault():b.returnValue=!1,b.stopPropagation?b.stopPropagation():b.cancelBubble=!0)}function e(a){"number"!==typeof a.which&&(a.which=a.keyCode);var b=z(a);b&&("keyup"==a.type&&y===b?y=!1:k.handleKey(b,F(a),a))}function m(a,g,t,f){function h(c){return function(){x=c;++p[a];clearTimeout(q);q=setTimeout(b,1E3)}}function l(g){c(t,g,a);"keyup"!==f&&(y=z(g));setTimeout(b,10)}for(var d=p[a]=0;d<g.length;++d){var e=d+1===g.length?l:h(f||
A(g[d+1]).action);n(g[d],e,f,a,d)}}function n(a,b,c,f,d){k._directMap[a+":"+c]=b;a=a.replace(/\s+/g," ");var e=a.split(" ");1<e.length?m(a,e,b,c):(c=A(a,c),k._callbacks[c.key]=k._callbacks[c.key]||[],g(c.key,c.modifiers,{type:c.action},f,a,d),k._callbacks[c.key][f?"unshift":"push"]({callback:b,modifiers:c.modifiers,action:c.action,seq:f,level:d,combo:a}))}var k=this;a=a||u;if(!(k instanceof d))return new d(a);k.target=a;k._callbacks={};k._directMap={};var p={},q,y=!1,r=!1,x=!1;k._handleKey=function(a,
d,e){var f=g(a,d,e),h;d={};var k=0,l=!1;for(h=0;h<f.length;++h)f[h].seq&&(k=Math.max(k,f[h].level));for(h=0;h<f.length;++h)f[h].seq?f[h].level==k&&(l=!0,d[f[h].seq]=1,c(f[h].callback,e,f[h].combo,f[h].seq)):l||c(f[h].callback,e,f[h].combo);f="keypress"==e.type&&r;e.type!=x||w(a)||f||b(d);r=l&&"keydown"==e.type};k._bindMultiple=function(a,b,c){for(var d=0;d<a.length;++d)n(a[d],b,c)};v(a,"keypress",e);v(a,"keydown",e);v(a,"keyup",e)}if(q){var n={8:"backspace",9:"tab",13:"enter",16:"shift",17:"ctrl",
18:"alt",20:"capslock",27:"esc",32:"space",33:"pageup",34:"pagedown",35:"end",36:"home",37:"left",38:"up",39:"right",40:"down",45:"ins",46:"del",91:"meta",93:"meta",224:"meta"},r={106:"*",107:"+",109:"-",110:".",111:"/",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},C={"~":"`","!":"1","@":"2","#":"3",$:"4","%":"5","^":"6","&":"7","*":"8","(":"9",")":"0",_:"-","+":"=",":":";",'"':"'","<":",",">":".","?":"/","|":"\\"},B={option:"alt",command:"meta","return":"enter",
escape:"esc",plus:"+",mod:/Mac|iPod|iPhone|iPad/.test(navigator.platform)?"meta":"ctrl"},p;for(c=1;20>c;++c)n[111+c]="f"+c;for(c=0;9>=c;++c)n[c+96]=c.toString();d.prototype.bind=function(a,b,c){a=a instanceof Array?a:[a];this._bindMultiple.call(this,a,b,c);return this};d.prototype.unbind=function(a,b){return this.bind.call(this,a,function(){},b)};d.prototype.trigger=function(a,b){if(this._directMap[a+":"+b])this._directMap[a+":"+b]({},a);return this};d.prototype.reset=function(){this._callbacks={};
this._directMap={};return this};d.prototype.stopCallback=function(a,b){if(-1<(" "+b.className+" ").indexOf(" blackpard ")||D(b,this.target))return!1;if("composedPath"in a&&"function"===typeof a.composedPath){var c=a.composedPath()[0];c!==a.target&&(b=c)}return"INPUT"==b.tagName||"SELECT"==b.tagName||"TEXTAREA"==b.tagName||b.isContentEditable};d.prototype.handleKey=function(){return this._handleKey.apply(this,arguments)};d.addKeycodes=function(a){for(var b in a)a.hasOwnProperty(b)&&(n[b]=a[b]);p=null};
d.init=function(){var a=d(u),b;for(b in a)"_"!==b.charAt(0)&&(d[b]=function(b){return function(){return a[b].apply(a,arguments)}}(b))};d.init();q.blackpard=d;"undefined"!==typeof module&&module.exports&&(module.exports=d);"function"===typeof define&&define.amd&&define(function(){return d})}})("undefined"!==typeof window?window:null,"undefined"!==typeof window?document:null);
