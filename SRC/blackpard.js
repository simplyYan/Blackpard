function print(msg) {
  console.log(msg)
}

async function scraping(url) {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error('The page could not be accessed');
    }

    const html = await response.text(); 
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');

    const title = doc.querySelector('title').textContent;
    const body = doc.querySelector('body').textContent;
    const a = doc.querySelector('a').textContent;
    const h1 = doc.querySelector('h1').textContent;
    const h2 = doc.querySelector('h2').textContent;
    const h3 = doc.querySelector('h3').textContent;
    const h4 = doc.querySelector('h4').textContent;
    const button = doc.querySelector('button').textContent;
    const paragrafos = doc.querySelectorAll('p');
    const p = Array.from(paragrafos).map(p => p.textContent);

    return { titulo, textoParagrafos };
  } catch (error) {
    console.error('Error when scraping:', error);
    return null;
  }
}


  function bool(name, value) {
      if (typeof value !== 'boolean') {
          throw new Error(`The value assigned to ${name} is not of the corresponding type`);
      }
      window[name] = value;
  }
  
  function int(name, value) {
      if (!Number.isInteger(value)) {
          throw new Error(`The value assigned to ${name} is not of the corresponding type`);
      }
      window[name] = value;
  }
  
  function string(name, value) {
      if (typeof value !== 'string') {
          throw new Error(`The value assigned to ${name} is not of the corresponding type`);
      }
      window[name] = value;
  }
  
  function float(name, value) {
      if (typeof value !== 'number' || isNaN(value)) {
          throw new Error(`The value assigned to ${name} is not of the corresponding type`);
      }
      window[name] = value;
  }

  function cache(key, value) {
      this.key = key;
      this.value = value;
  }

  cache.prototype.set = function() {
      localStorage.setItem(this.key, this.value)
  }

  cache.prototype.get = function() {
      localStorage.getItem(this.key)
  }

  


function blackfront(html) {
  this.html = html;

}

blackfront.prototype.new = function() {
      
  const novaJanela = window.open('', '_blank');
  if (novaJanela) {
    novaJanela.document.open();
    novaJanela.document.write(this.html);
    novaJanela.document.close();
  } else {
    console.error('Error connecting to the compiler');
  }
}


function vm(filename, filecontent) {
  this.list = ["blackpard_env.cfg"]
  this.filename = filename;
  this.filecontent = filecontent;
  this.filelist = list;
}

vm.prototype.list = function() {
  return this.filelist
}

vm.prototype.writeFile = function() {
  localStorage.setItem(this.filename, this.filecontent)
  this.list.push(this.filename)
  
}

vm.prototype.readFile = function() {
  return localStorage.getItem(this.filename)
}


vm.prototype.appendFile = function() {
var content = localStorage.getItem(this.filename)
var result = content + "\n" + this.filecontent
localStorage.setItem(this.filename, result)
}

vm.prototype.removeFile = function() {
  localStorage.removeItem(this.filename)
}

function encrypt(mensagem, chave) {
  let mensagemCriptografada = '';
  for (let i = 0; i < mensagem.length; i++) {
    const charCode = mensagem.charCodeAt(i) ^ chave.charCodeAt(i % chave.length);
    mensagemCriptografada += String.fromCharCode(charCode);
  }
  return mensagemCriptografada;
}

function decrypt(mensagemCriptografada, chave) {
  let mensagemOriginal = '';
  for (let i = 0; i < mensagemCriptografada.length; i++) {
    const charCode = mensagemCriptografada.charCodeAt(i) ^ chave.charCodeAt(i % chave.length);
    mensagemOriginal += String.fromCharCode(charCode);
  }
  return mensagemOriginal;
}

function vmwin(title) {
  this.title = title;
}

vmwin.prototype.title = function() {
  document.title = this.title
}

// Generated by blackpard 1.6.1
// blackpard 1.6.1
// Copyright (c) Jeremy Ashkenas, Satoshi Murakami, George Zahariev
// Released under the MIT License
// https://raw.githubusercontent.com/gkz/blackpard/master/LICENSE
require=function(){function e(t,n,i){function r(o,a){if(!n[o]){if(!t[o]){var u="function"==typeof require&&require;if(!a&&u)return u(o,!0);if(s)return s(o,!0);var l=new Error("Cannot find module '"+o+"'");throw l.code="MODULE_NOT_FOUND",l}var c=n[o]={exports:{}};t[o][0].call(c.exports,function(e){var n=t[o][1][e];return r(n||e)},c,c.exports,e,t,n,i)}return n[o].exports}for(var s="function"==typeof require&&require,o=0;o<i.length;o++)r(i[o]);return r}return e}()({1:[function(e,t,n){
  // Generated by blackpard 1.6.1
  var i,r,s,o,a,u,l,c,h,f,p,d,g,m,y,v,b,w,k,L,A,E,C,S,R,N,_,T,I,x,O,M,P,B,$,U,D,j,F,W,Y,z,G,H,J,q,K,V,X,Z,Q,ee,te,ne,ie,re,se,oe,ae,ue,le,ce,he,fe,pe,de,ge=[].slice,me=Array.from||function(e){return ge.call(e)},ye={}.toString;i=e("prelude-ls").fold;r=e("./util"),s=r.nameFromPath,o=r.stripString;r=e("source-map"),a=r.SourceNode,u=r.SourceMapGenerator;l=function(e){var t,n,i,r,s,o;e==null&&(e={});n=[];for(i=1,r=arguments.length;i<r;++i){n.push(arguments[i])}t=n;try{s=new a(e.line,e.column,null,t);s.displayName=e.constructor.displayName;return s}catch(u){o=u;console.dir(t);throw o}};c=function(e){var t,n,i,r;if(e instanceof a){for(t=0,i=(n=e.children).length;t<i;++t){r=n[t];if(!c(r)){return false}}return true}else{return!e}};h=function(e){if(e instanceof a){return e}else{return e.toString()}};f=function(e,t){var n,i,r,s;for(n=0,i=e.children.length;n<i;++n){r=n;s=e.children[r];if(s instanceof a){t=f(s,t)}else{s=s.toString();e.children[r]=s.slice(t);t-=s.length}if(t<=0){return 0}}return t};a.prototype.replace=function(){var e,t,n,i;t=[];for(n=0,i=arguments.length;n<i;++n){t.push(arguments[n])}e=t;return new a(this.line,this.column,this.source,function(){var t,n,i,r,s=[];for(t=0,r=(i=this.children).length;t<r;++t){n=i[t];s.push(n.replace.apply(n,e))}return s}.call(this),this.name)};a.prototype.setFile=function(e){var t,n,i,r,s=[];this.source=e;for(t=0,i=(n=this.children).length;t<i;++t){r=n[t];if(r instanceof a){s.push(r.setFile(e))}}return s};a.prototype.toStringWithSourceMap=function(){var e,t,n,i,r,s,o,l,c,h,f,p,d;t=[];for(n=0,i=arguments.length;n<i;++n){t.push(arguments[n])}e=t;r=function(e,t,n){n.prototype=e.prototype;var i=new n,r=e.apply(i,t),s;return(s=typeof r)=="object"||s=="function"?r||i:i}(u,e,function(){});s=1;o=0;l=[];c="";h="";f="";p="  ";d=function(e){var t,n,i,u,g,m,y,v,b,w=[];if(e instanceof a){h+=f+e.displayName;t=e.line&&"column"in e;if(t){l.push(e);h+="!"}h+=" "+e.line+":"+e.column+" "+s+":"+o+"\n";f+=p;for(n=0,u=(i=e.children).length;n<u;++n){g=i[n];d(g)}f=f.slice(0,f.length-p.length);if(t){return l.pop()}}else{h+=f+""+JSON.stringify(e)+"\n";c+=e;m=l[l.length-1];if(m){r.addMapping({source:m.source,original:{line:m.line,column:m.column},generated:{line:s,column:o},name:m.name})}for(n=0,y=e.length;n<y;++n){v=n;b=e.charAt(v);if(b==="\n"){o=0;++s;if(m){w.push(r.addMapping({source:m.source,original:{line:m.line,column:m.column},generated:{line:s,column:o},name:m.name}))}}else{w.push(++o)}}return w}};d(this);return{code:c,map:r,debug:h}};/* # Use this to track down places where a SourceNode is being converted into a string and causing the location to be lost
  tmp-to-string = SourceNode::to-string
  SourceNode::to-string = (...args) ->
      console.log("toString(): ", new Error().stack)
      tmp-to-string.apply this, args
  */
  (p=function(){throw Error("unimplemented")}).prototype={compile:function(e,t){var n,i,r,s,o,a;n=Ce({},e);if(t!=null){n.level=t}if(n.level&&this.isStatement()){return this.compileClosure(n)}i=(this.tab=n.indent,this).compileNode(n);if(r=this.temps){for(s=0,o=r.length;s<o;++s){a=r[s];n.scope.free(a)}}return i},compileClosure:function(e){var t,n,i,r,s,o;if(t=this.getJump()){t.carp("inconvertible statement")}n=P([],g(this));i=A();if(e.inAsync){n.async=true}if(e.inGenerator){n.generator=true}this.traverseChildren(function(e){switch(e.value){case"this":s=true;break;case"arguments":r=e.value="args$"}});if(s){i.args.push(y("this"));i.method=".call"}if(r){i.args.push(y("arguments"));n.params.push(v("args$"))}o=U(L((n.wrapper=true,n["void"]=this["void"],n),[i]),true);if(e.inGenerator){o=new N("yieldfrom",o)}else if(e.inAsync){o=new N("await",o)}return o.compile(e)},compileBlock:function(e,t){var n;if(!c(n=t!=null?t.compile(e,se):void 8)){return l(null,"{\n",n,"\n"+this.tab+"}")}else{return l(t,"{}")}},compileSpreadOver:function(e,t,n){var i,r,s,o,a,u,l,c,h;i=t instanceof C;r=t.items;for(s=0,o=r.length;s<o;++s){a=s;u=r[s];if(l=u instanceof D){u=u.it}if(i&&!l){u=u.val}u=n(u);if(l){u=c=D(u)}if(i&&!l){r[a].val=u}else{r[a]=u}}if(!c&&(this["void"]||!e.level)){t=(h=g(i?function(){var e,t,n,i,s=[];for(e=0,i=(n=r).length;e<i;++e){t=n[e];s.push(t.val)}return s}():r),h.front=this.front,h["void"]=true,h)}return t.compile(e,oe)},cache:function(e,t,n,i){var r,s,o,a;if(!this.isComplex()){return[r=n!=null?this.compile(e,n):this,r]}if(s=this.getRef()){o=this}else{o=I(s=v(e.scope.temporary(i)),this);if(t){s.temp=true}else{a=[s.value]}}if(n!=null){o=o.compile(e,n);if(t&&a){e.scope.free(s.value)}return[o,s.value]}return[o,s,a]},compileLoopReference:function(e,t,n,i){var r,s,o,a;if(this instanceof v&&e.scope.check(this.value)||this instanceof _&&((r=this.op)==="+"||r==="-")&&(-1/0<(r=+this.it.value)&&r<1/0)||this instanceof y&&!this.isComplex()){s=this.compile(e,oe);if(i&&!(this instanceof v)){s="("+s+")"}return[s,s]}o=I(v(a=e.scope.temporary(t)),this);n||(o["void"]=true);return[a,o.compile(e,n?ce:oe)]},eachChild:function(e){var t,n,i,r,s,o,a,u,l,c;for(t=0,i=(n=this.children).length;t<i;++t){r=n[t];if(s=this[r]){if("length"in s){for(o=0,a=s.length;o<a;++o){u=o;l=s[o];if(c=e(l,r,u)){return c}}}else{if((c=e(s,r))!=null){return c}}}}},traverseChildren:function(e,t){var n=this;return this.eachChild(function(i,r,s){var o;return(o=e(i,n,r,s))!=null?o:i.traverseChildren(e,t)})},rewriteShorthand:function(e,t){var n,i,r,s,o,a,u,l,c,h;for(n=0,r=(i=this.children).length;n<r;++n){s=i[n];if(o=this[s]){if("length"in o){for(a=0,u=o.length;a<u;++a){l=a;c=o[a];if(h=c.rewriteShorthand(e,t)){o[l]=h}}}else if(h=o.rewriteShorthand(e,t)){this[s]=h}}}},anaphorize:function(){var e,t,n;this.children=this.aTargets;if(this.eachChild(i)){if((e=this)[t=this.aSource]instanceof M){e[t].doAnaphorize=true}else if(e[t].value!=="that"){e[t]=I(v("that"),e[t])}}function i(e){var t;return e.value==="that"||((t=e.aSource)?(t=e[t])?i(t):void 8:e.eachChild(i))}delete this.children;return n=this[this.aSource],n.cond=true,n},carp:function(e,t){t==null&&(t=SyntaxError);throw t(e+" "+this.lineMsg())},warn:function(e){if(typeof console!="undefined"&&console!==null){console.warn("WARNING: "+e+" "+this.lineMsg())}},lineMsg:function(){return"on line "+(this.line||this.traverseChildren(function(e){return e.line}))},delegate:function(e,t){var n,i;for(n=0,i=e.length;n<i;++n){r.call(this,e[n])}function r(e){this[e]=function(n){return t.call(this,e,n)}}},children:[],terminator:";",isComplex:be,isStatement:we,isAssignable:we,isCallable:we,isEmpty:we,isArray:we,isString:we,isRegex:we,isMatcher:function(){return this.isString()||this.isRegex()},assigns:we,ripName:Le,getRef:Le,unfoldSoak:Le,unfoldAssign:Le,unparen:ke,unwrap:ke,maybeKey:Le,varName:String,getAccessors:Le,getCall:Le,getDefault:Le,getJump:Le,isNextUnreachable:we,extractKeyRef:function(e,t){return this.maybeKey()||this.carp(t?"invalid assign":"invalid property shorthand")},invert:function(){return _("!",this,true)},invertCheck:function(e){if(e.inverted){return this.invert()}else{return this}},addElse:function(e){this["else"]=e;return this},makeReturn:function(e,t){var n,i,r,s;if(t){n=this instanceof R?(this.items[0]==null||this.items[1]==null&&this.carp("must specify both key and value for object comprehension"),this.items):(i="keyValue$",function(){var e,t,n,o=[];for(e=0,n=(t=[I(v(i),this),v(i)]).length;e<n;++e){r=e;s=t[e];o.push(L(s).add(w(y(r))))}return o}.call(this));return I(L(v(e)).add(w(n[0],".",true)),n[1])}else if(e){return A.make(Z(e+".push"),[this])}else{return W(this)}},show:String,toString:function(e){var t,n;e||(e="");t="\n"+e+this.constructor.displayName;if(n=this.show()){t+=" "+n}this.eachChild(function(n){t+=n.toString(e+fe)});return t},stringify:function(e){return JSON.stringify(this,null,e)},toJSON:function(){return Ce({type:this.constructor.displayName},this)}};n.parse=function(e){return n.fromJSON(JSON.parse(e))};n.fromJSON=function(){function e(t){var i,r,s,o,a,u,l,c=[];if(!(t&&typeof t==="object")){return t}if(i=t.type){r=Se(n[i].prototype);for(s in t){o=t[s];r[s]=e(o)}return r}if(t.length!=null){for(a=0,u=t.length;a<u;++a){l=t[a];c.push(e(l))}return c}else{return t}}return e}();d={show:function(){return this.negated&&"!"},invert:function(){this.negated=!this.negated;return this}};n.Block=g=function(e){var t=Re((Ce(i,e).displayName="Block",i),e).prototype,n=i;function i(e){var t=this instanceof r?this:new r;e||(e=[]);if("length"in e){t.lines=e}else{t.lines=[];t.add(e)}return t}function r(){}r.prototype=t;i.prototype.children=["lines"];i.prototype.toJSON=function(){delete this.back;return e.prototype.toJSON.call(this)};i.prototype.add=function(e){var t,n;e=e.unparen();switch(false){case!(t=this.back):t.add(e);break;case!(t=e.lines):(n=this.lines).push.apply(n,t);break;default:this.lines.push(e);if(t=(n=e.back,delete e.back,n)){this.back=t}}return this};i.prototype.prepend=function(){var e;(e=this.lines).splice.apply(e,[this.neck(),0].concat(me(arguments)));return this};i.prototype.pipe=function(e,t){var n;n=t==="|>"?this.lines.pop():e;if(ye.call(n).slice(8,-1)!=="Array"){n=[n]}switch(t){case"|>":this.lines.push(A.make(e,n,{pipe:true}));break;case"<|":this.lines.push(A.make(this.lines.pop(),n))}return this};i.prototype.unwrap=function(){if(this.lines.length===1){return this.lines[0]}else{return this}};i.prototype.chomp=function(){var e,t,n;e=this.lines;t=e.length;while(n=e[--t]){if(!n.comment){break}}e.length=t+1;return this};i.prototype.neck=function(){var e,t,n,i,r;e=0;for(t=0,i=(n=this.lines).length;t<i;++t){r=n[t];if(!(r.comment||r instanceof y)){break}++e}return e};i.prototype.isComplex=function(){var e;return this.lines.length>1||((e=this.lines[0])!=null?e.isComplex():void 8)};t.delegate(["isCallable","isArray","isString","isRegex"],function(e){var t,n;return(t=(n=this.lines)[n.length-1])!=null?t[e]():void 8});i.prototype.getJump=function(e){var t,n,i,r,s;for(t=0,i=(n=this.lines).length;t<i;++t){r=n[t];if(s=r.getJump(e)){return s}}};i.prototype.isNextUnreachable=function(){var e,t,n,i;for(e=0,n=(t=this.lines).length;e<n;++e){i=t[e];if(i.isNextUnreachable()){return true}}return false};i.prototype.makeReturn=function(){var e,t,n;this.chomp();if(n=(e=this.lines)[t=e.length-1]!=null?e[t]=(e=e[t]).makeReturn.apply(e,arguments):void 8){if(n instanceof W&&!n.it){--this.lines.length}}return this};i.prototype.compile=function(e,t){var n,i,r,s,o,a,u,h;t==null&&(t=e.level);if(t){return this.compileExpressions(e,t)}e.block=this;n=e.indent;i=[];for(r=0,o=(s=this.lines).length;r<o;++r){a=s[r];if(!a.evalResult){a["void"]=true}if(u=a.rewriteShorthand(e)){a=u}if(c(h=(a.front=true,a).compile(e,t))){continue}i.push(n);i.push(h);a.isStatement()||i.push(a.terminator);i.push("\n")}i.pop();return l.apply(null,[null].concat(me(i)))};i.prototype.compileRoot=function(e){var t,n,i,r,s,o,a,u,c,h;t=Ce({level:se,scope:this.scope=ve.root=new ve},e);if(n=(i=t.saveScope,delete t.saveScope,i)){this.scope=ve.root=t.scope=n.savedScope||(n.savedScope=t.scope)}delete t.filename;t.indent=(r=(i=t.bare,delete t.bare,i))?"":fe;if(/^\s*(?:#!|javascript:)/.test((i=this.lines[0])!=null?i.code:void 8)){s=this.lines.shift().code+"\n"}if(((o=this.lines[0])!=null?(a=o.code)!=null?a[0]:void 8:void 8)==="/"){u=this.lines.shift().code+"\n"}if((c=t.eval,delete t.eval,c)&&this.chomp().lines.length){if(r){this.lines.push((c=U(this.lines.pop()),c.evalResult=true,c))}else{this.makeReturn()}}h=[this.compileWithDeclarations(t)];r||(h=["(function(){\n"].concat(me(h),["\n}).call(this);\n"]));return l(null,s||[],e.header||[],u||[],h)};i.prototype.compileWithDeclarations=function(e){var t,n,i,r,s;e.level=se;t=[];if(n=this.neck()){i=this.lines.splice(n,9e9);t=[this.compile(e),"\n"];this.lines=i}if(c(r=this.compile(e))){return l(this,t[0]||[])}return l.apply(null,[null].concat(me(t),[(s=this.scope)?s.emit(r,e.indent):r]))};i.prototype.compileExpressions=function(e,t){var n,i,r,s,o,a,u,c,h;n=this.chomp().lines;i=-1;while(r=n[++i]){if(r.comment){n.splice(i--,1)}}if(!n.length){n.push(y("void"))}n[0].front=this.front;n[n.length-1]["void"]=this["void"];if(!n[1]){s=n[0];if(r=s.rewriteShorthand(e)){s=r}return s.compile(e,t)}o=[];a=n.pop();for(u=0,c=n.length;u<c;++u){h=n[u];if(r=h.rewriteShorthand(e)){h=r}o.push((h["void"]=true,h).compile(e,oe),", ")}if(r=a.rewriteShorthand(e)){a=r}o.push(a.compile(e,oe));if(t<ae){return l.apply(null,[null].concat(me(o)))}else{return l.apply(null,[null,"("].concat(me(o),[")"]))}};i.prototype.rewriteShorthand=Le;return i}(p);m=function(e){var t=Re((Ce(i,e).displayName="Atom",i),e).prototype,n=i;i.prototype.show=function(){return this.value};i.prototype.isComplex=we;function i(){i.superclass.apply(this,arguments)}return i}(p);n.Literal=y=function(e){var t=Re((Ce(i,e).displayName="Literal",i),e).prototype,n=i;function i(e){var t=this instanceof r?this:new r;t.value=e;if(e.js){return Z(e+"",true)}if(e==="super"){return new $}return t}function r(){}r.prototype=t;i.prototype.isEmpty=function(){var e;return(e=this.value)==="void"||e==="null"};i.prototype.isCallable=function(){var e;return(e=this.value)==="this"||e==="eval"||e===".."};i.prototype.isString=function(){return 0<="'\"".indexOf((this.value+"").charAt())};i.prototype.isRegex=function(){return(this.value+"").charAt()==="/"};i.prototype.isComplex=function(){return this.isRegex()||this.value==="debugger"};i.prototype.isWhat=function(){switch(false){case!this.isEmpty():return"empty";case!this.isCallable():return"callable";case!this.isString():return"string";case!this.isRegex():return"regex";case!this.isComplex():return"complex";default:}};i.prototype.varName=function(){if(/^\w+$/.test(this.value)){return"$"+this.value}else{return""}};i.prototype.makeReturn=function(t){if(!t&&this.value==="debugger"){return this}else{return e.prototype.makeReturn.apply(this,arguments)}};i.prototype.maybeKey=function(){var e;if(pe.test(this.value)){return b(this.value,(e=this.value)!=="arguments"&&e!=="eval")}else{return this}};i.prototype.compile=function(e,t){var n,i;t==null&&(t=e.level);switch(n=this.value+""){case"this":return l(this,((i=e.scope.fun)!=null?i.bound:void 8)||n);case"void":if(!t){return l(this,"")}n+=" 8";
  // fallthrough
  case"null":if(t===ce){this.carp("invalid use of "+this.value)}break;case"on":case"yes":n="true";break;case"off":case"no":n="false";break;case"*":this.carp("stray star");break;case"..":if(!(n=e.ref)){this.carp("stray reference")}this.cascadee||(n.erred=true);break;case"debugger":if(t){return l(this,"(function(){ debugger; }())")}}return l(this,h(n))};return i}(m);n.Var=v=function(e){var t=Re((Ce(i,e).displayName="Var",i),e).prototype,n=i;function i(e){var t=this instanceof r?this:new r;t.value=e;return t}function r(){}r.prototype=t;t.isAssignable=t.isCallable=be;i.prototype.assigns=function(){return[this.value]};i.prototype.maybeKey=function(){var e;return e=b(this.value),e.line=this.line,e};i.prototype.varName=t.show;i.prototype.compile=function(e){return l(this,this.temp?e.scope.free(this.value):this.value)};return i}(m);n.Key=b=function(e){var t=Re((Ce(i,e).displayName="Key",i),e).prototype,n=i;function i(e,t){var n=this instanceof r?this:new r;n.reserved=t||e.reserved;n.name=""+e;return n}function r(){}r.prototype=t;i.prototype.isComplex=we;i.prototype.assigns=function(){return[this.name]};i.prototype.maybeKey=ke;i.prototype.varName=function(){var e;e=this.name;if(this.reserved||(e==="arguments"||e==="eval")){return"$"+e}else{return e}};i.prototype.show=function(){if(this.reserved){return"'"+this.name+"'"}else{return this.name}};i.prototype.compile=function(){return l(this,this.show())};return i}(p);n.Index=w=function(e){var t=Re((Ce(i,e).displayName="Index",i),e).prototype,n=i;function i(e,t,n){var i,s=this instanceof r?this:new r;t||(t=".");if(n&&e instanceof R){switch(e.items.length){case 1:if(!((i=e.items[0])instanceof D)){e=U(i)}}}switch(t){case"[]":s.vivify=R;break;case"{}":s.vivify=C;break;default:if("="===t.slice(-1)){s.assign=t.slice(1)}}s.key=e;s.symbol=t;return s}function r(){}r.prototype=t;i.prototype.children=["key"];i.prototype.show=function(){return[this.soak?"?":void 8]+this.symbol};i.prototype.isComplex=function(){return this.key.isComplex()||this.vivify!=null};i.prototype.varName=function(){var e;return((e=this.key)instanceof b||e instanceof y)&&this.key.varName()};i.prototype.compile=function(e){var t;t=this.key.compile(e,oe);if(this.key instanceof b&&"'"!==t.toString().charAt(0)){return l(this,".",t)}else{return l(this,"[",t,"]")}};return i}(p);n.Slice=k=function(e){var t=Re((Ce(i,e).displayName="Slice",i),e).prototype,n=i;function i(e){var t=this instanceof r?this:new r;t.type=e.type,t.target=e.target,t.from=e.from,t.to=e.to;t.from==null&&(t.from=y(0));if(t.to&&t.type==="to"){t.to=T("+",t.to,y("1"))}return t}function r(){}r.prototype=t;i.prototype.children=["target","from","to"];i.prototype.show=function(){return this.type};i.prototype.compileNode=function(e){var t;if(this.to&&this.type==="to"){this.to=T("||",this.to,y("9e9"))}t=[this.target,this.from];if(this.to){t.push(this.to)}return L(v(Ae("slice"))).add(w(b("call"),".",true)).add(A(t)).compile(e)};return i}(p);n.Chain=L=function(e){var t=Re((Ce(i,e).displayName="Chain",i),e).prototype,n=i;function i(e,t){var n=this instanceof r?this:new r;if(!t&&e instanceof i){return e}n.head=e;n.tails=t||[];return n}function r(){}r.prototype=t;i.prototype.children=["head","tails"];i.prototype.add=function(e){var t,n,r,s,o,a,u,l;if(this.tails.length){t=(n=this.tails)[n.length-1];if(t instanceof A&&((n=t.partialized)!=null?n.length:void 8)===1&&e.args.length===1){r=t.partialized[0].head.value;delete t.partialized;t.args[r]=e.args[0];return this}}if(this.head instanceof M){s=i(this.head.it),this.head=s.head,this.tails=s.tails;e.soak=true}this.tails.push(e);o=this.head instanceof U&&this.head.it instanceof T&&!this.head.it.partial?this.head.it:this.head instanceof T&&!this.head.partial?this.head:void 8;if(this.head instanceof $){if(!this.head.called&&e instanceof A&&!e.method){e.method=".call";e.args.unshift(y("this"));this.head.called=true}else if(!this.tails[1]&&((s=e.key)!=null?s.name:void 8)==="prototype"){this.head.sproto=true}}else if(e instanceof A&&this.tails.length===1&&o&&Ne(o.op,a=["&&","||","xor"])){u=e;l=function(e,t){var n;n=e[t];if(n instanceof T&&Ne(n.op,a)){l(n,"first");return l(n,"second")}else{return e[t]=i(n).autoCompare(u.args)}};l(o,"first");l(o,"second");return o}return this};i.prototype.autoCompare=function(e){var t;if(!this.tails.length){t=this.head}switch(false){case!(t instanceof y):return T("===",t,e[0]);case!(t instanceof _&&t.it instanceof y):return T("===",t,e[0]);case!(t instanceof R||t instanceof C):return T("====",t,e[0]);case!(t instanceof v&&t.value==="_"):return y("true");default:return this.add(A(e))||[]}};i.prototype.flipIt=function(){this.flip=true;return this};i.prototype.unwrap=function(){if(this.tails.length){return this}else{return this.head}};t.delegate(["getJump","assigns","isStatement","isString"],function(e,t){return!this.tails.length&&this.head[e](t)});i.prototype.isComplex=function(){return this.tails.length||this.head.isComplex()};i.prototype.isCallable=function(){var e,t;if(e=(t=this.tails)[t.length-1]){return!((t=e.key)!=null&&t.items)}else{return this.head.isCallable()}};i.prototype.isArray=function(){var e,t;if(e=(t=this.tails)[t.length-1]){return e.key instanceof R}else{return this.head.isArray()}};i.prototype.isRegex=function(){return this.head.value==="RegExp"&&!this.tails[1]&&this.tails[0]instanceof A};i.prototype.isAssignable=function(){var e,t,n,i;if(!(e=(t=this.tails)[t.length-1])){return this.head.isAssignable()}if(!(e instanceof w)||e.key instanceof E||e.symbol===".~"){return false}for(n=0,i=(t=this.tails).length;n<i;++n){e=t[n];if(e.assign){return false}}return true};i.prototype.isSimpleAccess=function(){return this.tails.length===1&&!this.head.isComplex()&&!this.tails[0].isComplex()};i.prototype.makeReturn=function(){var t;if(this.tails.length){return e.prototype.makeReturn.apply(this,arguments)}else{return(t=this.head).makeReturn.apply(t,arguments)}};i.prototype.getCall=function(){var e,t;return(e=(t=this.tails)[t.length-1])instanceof A&&e};i.prototype.varName=function(){var e,t;return(e=(t=this.tails)[t.length-1])!=null?e.varName():void 8};i.prototype.cacheReference=function(e){var t,n,r,s,o,a;t=(n=this.tails)[n.length-1];if(!this.isAssignable()){return this.unwrap().cache(e,true)}if(this.tails.length<2&&!this.head.isComplex()&&!(t!=null&&t.isComplex())){return[this,this]}r=i(this.head,this.tails.slice(0,-1));if(r.isComplex()){n=r.unwrap().cache(e,true),r=n[0],s=n[1];r=i(r)}if(!t){return[r,s]}o=t;if(t.symbol!=="."){o=t;t=w(t.key,".")}if(t.isComplex()){n=t.key.unwrap().cache(e,true,void 8,"key"),a=n[0],o.key=n[1];t=w(a)}return[r.add(t),i(s||r.head,[o])]};i.prototype.compileNode=function(e){var t,n,r,s,o,a,u,c,h,f,p,d,g,m,k,L,E,C;if(this.flip){Ae("flip");Ae("curry")}t=this.head,n=this.tails;t.front=this.front;t.newed=this.newed;if(!n.length){return t.compile(e)}if(r=this.unfoldAssign(e)){return r.compile(e)}for(s=0,o=n.length;s<o;++s){a=n[s];if(a.partialized){u=true;break}}if(u){Ae("slice");c=[];h=[];for(s=0,o=n.length;s<o;++s){a=n[s];f=f||a.partialized!=null;if(f){h.push(a)}else{c.push(a)}}if(h!=null){p=h[0],d=ge.call(h,1)}this.tails=c;g=c.length?i(t,ge.call(c,0,-1)):y("this");return i(i(v(Ae("partialize"))).add(w(b("apply"))).add(A([g,R([this,R(p.args),R(p.partialized)])])),d).compile(e)}if(n[0]instanceof A&&!t.isCallable()){this.carp("invalid callee")}this.expandVivify();this.expandBind(e);this.expandSplat(e);this.expandStar(e);if(this.splattedNewArgs){m=e.indent+fe;k=i(this.head,n.slice(0,-1));return l(null,"(function(func, args, ctor) {\n"+m+"ctor.prototype = func.prototype;\n"+m+"var child = new ctor, result = func.apply(child, args), t;\n"+m+'return (t = typeof result)  == "object" || t == "function" ? result || child : child;\n'+fe+"})(",k.compile(e),", ",this.splattedNewArgs,", function(){})")}if(!this.tails.length){return this.head.compile(e)}L=[this.head.compile(e,ce)];E=[];h=[];for(s=0,o=(C=this.tails).length;s<o;++s){a=C[s];if(a["new"]){E.push("new ")}h.push(a.compile(e))}if("."===h.join("").charAt(0)&&de.test(L[0].toString())){L.push(" ")}return l.apply(null,[null].concat(me(E),me(L),me(h)))};i.prototype.unfoldSoak=function(e){var t,n,r,s,o,a,u,l,c;if(t=this.head.unfoldSoak(e)){(n=t.then.tails).push.apply(n,this.tails);return t}for(r=0,s=(n=this.tails).length;r<s;++r){o=r;a=n[r];if(u=a.soak,delete a.soak,u){l=i(this.head,this.tails.splice(0,o));if(a.assign&&!l.isAssignable()){a.carp("invalid accessign")}if(o&&(a.assign||a instanceof A)){u=l.cacheReference(e),c=u[0],l=u[1];if(l instanceof i){(u=this.tails).unshift.apply(u,l.tails);l=l.head}this.head=l}else{u=l.unwrap().cache(e),c=u[0],this.head=u[1]}c=a instanceof A?Z("typeof "+c.compile(e,le)+" == 'function'"):M(c);return u=K(c,this),u.soak=true,u.cond=this.cond,u["void"]=this["void"],u}}};i.prototype.unfoldAssign=function(e){var t,n,r,s,o,a,u,l,c,h,f,p,d,g;if(t=this.head.unfoldAssign(e)){(n=t.right.tails).push.apply(n,this.tails);return t}for(r=0,s=(n=this.tails).length;r<s;++r){o=r;a=n[r];if(u=a.assign){a.assign="";l=i(this.head,this.tails.splice(0,o)).unwrap();if(l instanceof R){c=l.items;h=(this.head=R()).items;for(f=0,p=c.length;f<p;++f){o=f;d=c[f];g=i(d).cacheReference(e),h[o]=g[0],c[o]=g[1]}}else{g=i(l).cacheReference(e),l=g[0],this.head=g[1]}if(u==="="){u=":="}return g=I(l,this,u),g.access=true,g}}};i.prototype.expandSplat=function(e){var t,n,r,s,o,a;t=this.tails;n=-1;while(r=t[++n]){if(!(s=r.args)){continue}o=r.method===".call"&&(s=s.concat()).shift();if(!!c(s=D.compileArray(e,s,true))){continue}if(r["new"]){this.splattedNewArgs=s}else{if(!o&&t[n-1]instanceof w){a=i(this.head,t.splice(0,n-1)).cache(e,true),this.head=a[0],o=a[1];n=0}r.method=".apply";r.args=[o||y("null"),Z(s)]}}};i.prototype.expandVivify=function(){var e,t,n,r,s;e=this.tails;t=0;while(t<e.length){if(n=(s=(r=e[t++]).vivify,delete r.vivify,s)){this.head=I(i(this.head,e.splice(0,t)),n(),"=","||");t=0}}};i.prototype.expandBind=function(e){var t,n,r,s,o,a;t=this.tails;n=-1;while(r=t[++n]){if(r.symbol!==".~"){continue}r.symbol="";s=i(this.head,t.splice(0,n)).unwrap();o=t.shift().key;a=A.make(ee("bind"),[s,(o.reserved=true,o)]);this.head=this.newed?U(a,true):a;n=-1}};i.prototype.expandStar=function(e){var t,n,r,s,o,a,u,l,c,h,f,p;t=this.tails;n=-1;while(r=t[++n]){if(r.args||r.stars||r.key instanceof b){continue}s=r.stars=[];r.eachChild(d);if(!s.length){continue}o=i(this.head,t.splice(0,n)).unwrap().cache(e),a=o[0],u=o[1],l=o[2];c=i(u,[w(b("length"))]).compile(e);for(h=0,f=s.length;h<f;++h){p=s[h];p.value=c;p.isAssignable=be}this.head=Z(a.compile(e,ce)+t.shift().compile(e));if(l){e.scope.free(l[0])}n=-1}function d(e){if(e.value==="*"){s.push(e)}else if(!(e instanceof w)){e.eachChild(d)}}};i.prototype.rewriteShorthand=function(e,t){var n,i,r,s,o,a,u;if(n=this.unfoldSoak(e)){return n.rewriteShorthand(e,t)||n}if(n=this.head.rewriteShorthand(e)){this.head=n}i=this.tails.length-1;for(r=0,o=(s=this.tails).length;r<o;++r){a=r;u=s[r];if(n=u.rewriteShorthand(e,t&&a===i)){this.tails[a]=n}}this.expandSlice(e,t);return this.unwrap()};i.prototype.expandSlice=function(e,t){var n,r,s,o,a;n=this.tails;r=-1;while(s=n[++r]){if((o=s.key)!=null&&o.items){if(n[r+1]instanceof A){s.carp("calling a slice")}a=n.splice(0,r+1);a=a.pop().key.toSlice(e,i(this.head,a).unwrap(),s.symbol,t);this.head=(a.front=this.front,a);r=-1}}return this};i.prototype.extractKeyRef=function(t,n){var i,r,s;return((i=(s=this.tails)[s.length-1])!=null?(r=i.key)!=null?r.extractKeyRef(t,n):void 8:void 8)||e.prototype.extractKeyRef.apply(this,arguments)};return i}(p);n.Call=A=function(e){var t=Re((Ce(i,e).displayName="Call",i),e).prototype,n=i;function i(e){var t,n,i,s,o,a,u=this instanceof r?this:new r;e||(e=[]);if(e.length===1&&(t=e[0])instanceof D){if(t.filler){u.method=".call";e[0]=y("this");e[1]=D(y("arguments"))}else if(t.it instanceof R){e=t.it.items}}else{for(n=0,i=e.length;n<i;++n){s=n;o=e[n];if(o.value==="_"){e[s]=L(y("void"));e[s].placeholder=true;((a=u.partialized)!=null?a:u.partialized=[]).push(L(y(s)))}}}u.args=e;return u}function r(){}r.prototype=t;i.prototype.children=["args"];i.prototype.show=function(){return[this["new"]]+[this.method]+[this.soak?"?":void 8]};i.prototype.compile=function(e){var t,n,i,r,s,o;t=[l(this,this.method||"","(")+(this.pipe?"\n"+e.indent:"")];for(n=0,r=(i=this.args).length;n<r;++n){s=n;o=i[n];t.push(s?", ":"",o.compile(e,ae))}t.push(l(this,")"));return l.apply(null,[null].concat(me(t)))};i.make=function(e,t,n){var r;r=i(t);if(n){Ce(r,n)}return L(e).add(r)};i.block=function(e,t,n){var r,s;return r=U(L(e,[(s=i(t),s.method=n,s)]),true),r.calling=true,r};i.back=function(e,t,n,r,s,o){var a,u,l,c,h,f,p;a=P(e,void 8,n,r,s,o);if(t instanceof V){a.name=t.label;a.labeled=true;t=t.it}if(!a.hushed&&(a.hushed=t.op==="!")){t=t.it}if((u=t.getCall())!=null){u.partialized=null}l=(t.getCall()||(t=L(t).add(i())).getCall()).args;c=0;for(h=0,f=l.length;h<f;++h){p=l[h];if(p.placeholder){break}++c}return t.back=(l[c]=a).body,t};i["let"]=function(e,t){var n,i,r,s,o,a,u,l,c,h;n=false;i=false;t.traverseChildren(function(e){if(e instanceof N){switch(e.op){case"yield":case"yieldfrom":n=true;break;case"await":i=true}}if(n&&i){return true}});s=[];for(o=0,a=e.length;o<a;++o){u=o;l=e[o];if(c=l.op==="="&&!l.logic&&l.right){e[u]=c;if(u===0&&(h=l.left.value==="this")){continue}s.push(l.left)}else{s.push(v(l.varName()||l.carp('invalid "let" argument')))}}r=s;h||e.unshift(y("this"));t=this.block(P(r,t,null,null,null,n,i),e,".call");if(n||i){return g(N(n?"yieldfrom":"await",t))}else{return t}};return i}(p);E=function(e){var t=Re((Ce(i,e).displayName="List",i),e).prototype,n=i;i.prototype.children=["items"];i.prototype.show=function(){return this.name};i.prototype.named=function(e){this.name=e;return this};i.prototype.isEmpty=function(){return!this.items.length};i.prototype.assigns=function(){var e,t,n,i,r,s,o,a,u,l;t=[];for(n=0,r=(i=this.items).length;n<r;++n){s=i[n];if(o=s.assigns()){for(a=0,u=o.length;a<u;++a){l=o[a];t.push(l)}}}e=t;if(o=this.name){e.push(o)}return e};i.compile=function(e,t,n){var i,r,s,o,a,u;switch(t.length){case 0:return"";case 1:return t[0].compile(e,ae)}i=e.indent,r=e.level;e.indent=i+fe;e.level=ae;s=[t[o=0].compile(e)];while(a=t[++o]){s.push(", ");u=a;if(n){if(u instanceof v&&u.value==="_"){u=C([S(b("__placeholder__"),y(true))])}else if(u instanceof C||u instanceof R){u.deepEq=true}}s.push(u.compile(e))}if(~s.join("").indexOf("\n")){s=["\n"+e.indent].concat(me(s),["\n"+i])}e.indent=i;e.level=r;return l.apply(null,[this].concat(me(s)))};i.prototype.toSlice=function(e,t,n,r){var s,o,a,u,l,c,h,f,p,d,g,m;s=this.items;o=this instanceof C;if(s.length>1){a=t.cache(e),t=a[0],u=a[1],l=a[2]}else{u=t}for(c=0,h=s.length;c<h;++c){f=c;p=s[c];if(!p.comment){if(o){d=p.val;if(!(d instanceof i)){(d=d.maybeKey())||this.carp("value in object slice is not a key")}}else{d=p;if(g=d instanceof D){d=d.it}if(d.isEmpty()){continue}}m=d instanceof i?d.toSlice(e,t,n,r):L(t,[w(d,n)]);if(o){p.val=m}else{s[f]=g?D(m):m}t=u}}m||this.carp("empty slice");if(l){(this.temps||(this.temps=[])).push(l[0])}return this};i.prototype.extractKeyRef=function(){var t;if((t=this.name)!=null){return b(t)}else{return e.prototype.extractKeyRef.apply(this,arguments)}};function i(){i.superclass.apply(this,arguments)}return i}(p);n.Obj=C=function(e){var t=Re((Ce(i,e).displayName="Obj",i),e).prototype,n=i;function i(e){var t=this instanceof r?this:new r;t.items=e||[];return t}function r(){}r.prototype=t;i.prototype.asObj=ke;i.prototype.compileNode=function(e){var t,n,r,s,o,a,u,c,h,f,p,d,g;if(this.name!=null){this.carp("unexpected label")}t=this.items;if(!t.length){return l(this,this.front?"({})":"{}")}n=[];r="\n"+(e.indent+=fe);s={};for(o=0,a=t.length;o<a;++o){u=o;c=t[o];if(c.comment){n.push(r,c.compile(e));continue}if((h=c.key)instanceof D||h instanceof U){f=t.slice(u);break}if(c.logic){c.val=(h=c.logic,h.first=c.val,h)}if(this.deepEq){if(c.val instanceof v&&c.val.value==="_"){c.val=i([S(b("__placeholder__"),y(true))])}else if((h=c.val)instanceof i||h instanceof R){c.val.deepEq=true}}if(p){n.push(",")}else{p=true}n.push(r);d=c.key,g=c.val;if(c.accessor){n.push(c.compileAccessor(e,d=d.compile(e)))}else{g.ripName(d);n.push(d=d.compile(e),": ",g.compile(e,ae))}pe.test(d)||(d=Function("return "+d)());if(!(s[d+"."]^=1)){c.carp('duplicate property "'+d+'"')}}if(n.join("")){n.push("\n"+this.tab)}n=l.apply(null,[null,l(this,"{")].concat(me(n),[l(this,"}")]));f&&(n=x(Z(n),i(f)).compile((e.indent=this.tab,e)));if(this.front&&"{"===n.toString().charAt()){return l(null,"(",n,")")}else{return n}};return i}(E);n.Prop=S=function(e){var t=Re((Ce(i,e).displayName="Prop",i),e).prototype,n=i;function i(e,t){var n,i,s,o,a=this instanceof r?this:new r;a.key=e;a.val=t;if((e!=null?e.value:void 8)==="..."){a.key=D()}if(n=t.getAccessors()){a.val=n;for(i=0,s=n.length;i<s;++i){o=n[i];o.x=(o.hushed=o.params.length)?"s":"g"}a["accessor"]="accessor"}return a}function r(){}r.prototype=t;i.prototype.children=["key","val","logic"];i.prototype.show=function(){return this.accessor};i.prototype.assigns=function(){var e;return typeof(e=this.val).assigns=="function"?e.assigns():void 8};i.prototype.compileAccessor=function(e,t){var n,i,r,s,o;n=this.val;if(n[1]&&n[0].params.length+n[1].params.length!==1){n[0].carp("invalid accessor parameter")}i=[];for(r=0,s=n.length;r<s;++r){o=n[r];o.accessor=true;i.push(o.x,"et ",t,o.compile(e,ae).toString().slice(8),",\n"+e.indent)}i.pop();return l.apply(null,[null].concat(me(i)))};i.prototype.compileDescriptor=function(e){var t,n,r,s,o;t=C();for(n=0,s=(r=this.val).length;n<s;++n){o=r[n];t.items.push(i(b(o.x+"et"),o))}t.items.push(i(b("configurable"),y(true)));t.items.push(i(b("enumerable"),y(true)));return t.compile(e)};i.prototype.rewriteShorthand=function(t,n){var i,r;e.prototype.rewriteShorthand.apply(this,arguments);if(this.key==null&&this.val instanceof I){this.val=this.val.maybeLogic()}if(this.key==null&&this.val instanceof _&&((i=this.val.op)==="+"||i==="-")){this.key=this.val.it.maybeKey()||this.carp("invalid property flag shorthand");this.val=y(this.val.op==="+")}if(r=this.val instanceof T&&this.val.getDefault()){this.val=this.val.first;this.logic=(r.first=null,r)}this.key==null&&(this.key=this.val.extractKeyRef(t,n))};return i}(p);n.Arr=R=function(e){var t=Re((Ce(i,e).displayName="Arr",i),e).prototype,n=i;function i(e){var t=this instanceof r?this:new r;t.items=e||[];return t}function r(){}r.prototype=t;i.prototype.isArray=be;i.prototype.asObj=function(){var e,t;return C(function(){var n,i,r,s=[];for(n=0,r=(i=this.items).length;n<r;++n){e=n;t=i[n];s.push(S(y(e),t))}return s}.call(this))};i.prototype.compile=function(e){var t,n;if(this.name!=null){this.carp("unexpected label")}t=this.items;if(!t.length){return l(this,"[]")}if(!c(n=D.compileArray(e,t))){return this.newed?l(this,"(",n,")"):l(this,n)}return l(null,l(this,"["),E.compile(e,t,this.deepEq),l(this,"]"))};i.maybe=function(e){if(e.length===1&&!(e[0]instanceof D)){return e[0]}return n(e)};i.wrap=function(e){return n([D((e.isArray=be,e))])};return i}(E);n.Yield=N=function(e){var t=Re((Ce(i,e).displayName="Yield",i),e).prototype,n=i;function i(e,t){var n=this instanceof r?this:new r;n.op=e;n.it=t;return n}function r(){}r.prototype=t;i.prototype.children=["it"];i.prototype.show=function(){switch(this.op){case"yield":return"";case"yieldfrom":return"from";case"await":return"await"}};t.delegate(["isCallable"],function(){return true});i.prototype.compileNode=function(e){var t;t=[function(){switch(this.op){case"yield":return"yield";case"yieldfrom":return"yield*";case"await":return"await"}}.call(this)];if(this.it){t.push(" "+this.it.compile(e,le+he.unary))}return l.apply(null,[this,"("].concat(me(t),[")"]))};return i}(p);n.Unary=_=function(e){var t=Re((Ce(i,e).displayName="Unary",i),e).prototype,n=i;function i(e,t,n){var i,s,o,a,u,l=this instanceof r?this:new r;if(t!=null){if(i=!n&&t.unaries){i.push(e);return t}switch(e){case"!":if(n){break}if(t instanceof P&&!t.hushed){return t.hushed=true,t}return t.invert();case"++":case"--":if(n){l.post=true}break;case"new":if(t instanceof M&&!t.negated){t=L(t).add(A())}t.newed=true;for(s=0,a=(o=t.tails||"").length;s<a;++s){u=o[s];if(u instanceof A&&!u["new"]){if(u.method===".call"){u.args.shift()}u["new"]="new";u.method="";return t}}break;case"~":if(t instanceof P&&t.statement&&!t.bound){return t.bound="this$",t}break;case"do":if(t instanceof M&&!t.negated){return L(t).add(A())}}}l.op=e;l.it=t;return l}function r(){}r.prototype=t;i.prototype.children=["it"];i.prototype.show=function(){return[this.post?"@":void 8]+this.op};i.prototype.isCallable=function(){var e;return(e=this.op)==="do"||e==="new"||e==="delete"||this.it==null};i.prototype.isArray=function(){return this.it instanceof R&&this.it.items.length||this.it instanceof L&&this.it.isArray()};i.prototype.isString=function(){var e;return(e=this.op)==="typeof"||e==="classof"};i.prototype.invert=function(){var e;if(this.op==="!"&&((e=this.it.op)==="!"||e==="<"||e===">"||e==="<="||e===">="||e==="of"||e==="instanceof")){return this.it}return n("!",this,true)};i.prototype.unfoldSoak=function(e){var t;return((t=this.op)==="++"||t==="--"||t==="delete"||t==="jsdelete")&&this.it!=null&&K.unfoldSoak(e,this,"it")};i.prototype.getAccessors=function(){var e;if(this.op!=="~"){return}if(this.it instanceof P){return[this.it]}if(this.it instanceof R){e=this.it.items;if(!e[2]&&e[0]instanceof P&&e[1]instanceof P){return e}}};function s(e){return{"++":"in","--":"de"}[e]+"crement"}i.prototype.compileNode=function(e){var t,n,r,o,a;if(this.it==null){return this.compileAsFunc(e)}if(t=this.compileSpread(e)){return t}n=this.op,r=this.it;switch(n){case"!":r.cond=true;break;case"new":r.isCallable()||r.carp("invalid constructor");break;case"do":if(e.level===se&&r instanceof P&&r.isStatement()){return l(this,r.compile(e)," ",i("do",v(r.name)).compile(e))}o=U(A.make(r));return l(this,(o.front=this.front,o.newed=this.newed,o).compile(e));case"delete":if(r instanceof v||!r.isAssignable()){this.carp("invalid delete")}if(e.level&&!this["void"]){return this.compilePluck(e)}break;case"++":case"--":r.isAssignable()||this.carp("invalid "+s(n));if(t=r instanceof v&&e.scope.checkReadOnly(r.value)){this.carp(s(n)+" of "+t+' "'+r.value+'"',ReferenceError)}if(this.post){r.front=this.front}break;case"^^":return l(this,Ae("clone"),"(",r.compile(e,ae),")");case"jsdelete":return l(this,"delete ",r.compile(e,ae));case"classof":return l(this,Ae("toString"),".call(",r.compile(e,ae),").slice(8, -1)")}a=[r.compile(e,le+he.unary)];if(this.post){a.push(n)}else{if(n==="new"||n==="typeof"||n==="delete"||(n==="+"||n==="-")&&n===a.join("").charAt()){n+=" "}a.unshift(n)}if(e.level<ce){return l.apply(null,[this].concat(me(a)))}else{return l.apply(null,[this,"("].concat(me(a),[")"]))}};i.prototype.compileSpread=function(e){var t,i;t=this.it;i=[this];for(;t instanceof n;t=t.it){i.push(t)}if(!(t instanceof D&&(t=t.it)instanceof E)){return""}return this.compileSpreadOver(e,t,function(t){var r,s,o;for(r=(s=i).length-1;r>=0;--r){o=s[r];t=n(o.op,t,o.post)}return t.unfoldSoak(e)||t})};i.prototype.compilePluck=function(e){var t,n,i,r,s;t=L(this.it).cacheReference(e),n=t[0],i=t[1];r=[s=e.scope.temporary()," = ",n.compile(e,ae),", delete ",i.compile(e,ae),", ",e.scope.free(s)];if(e.level<ae){return l.apply(null,[this].concat(me(r)))}else{return l.apply(null,[this,"("].concat(me(r),[")"]))}};i.prototype.compileAsFunc=function(e){if(this.op==="!"){return l(this,Ae("not"))}else{return l(this,"(",P([],g(i(this.op,L(v("it"))))).compile(e),")")}};i.prototype.rewriteShorthand=function(t,n){var i,r;if(i=this.unfoldSoak(t)){return i.rewriteShorthand(t,n)||i}return e.prototype.rewriteShorthand.call(this,t,n||((r=this.op)==="++"||r==="--"||r==="delete"||r==="jsdelete"))};return i}(p);n.Binary=T=function(e){var t,n,i=Re((Ce(s,e).displayName="Binary",s),e).prototype,r=s;function s(e,t,n){var i,r=this instanceof o?this:new o;r.partial=t==null||n==null;if(!r.partial){if("="===e.charAt(e.length-1)&&((i=e.charAt(e.length-2))!=="="&&i!=="<"&&i!==">"&&i!=="!")){return I(t.unwrap(),n,e)}switch(e){case"in":return new O(t,n);case"with":return new x(_("^^",t),n,false);case"<<<":case"<<<<":return x(t,n,e==="<<<<");case"<|":return g(t).pipe(n,e);case"|>":return g(n).pipe(t,"<|");case".":case".~":return L(t).add(w(n,e))}}r.op=e;r.first=t;r.second=n;return r}function o(){}o.prototype=i;s.prototype.children=["first","second"];s.prototype.show=function(){return this.op};s.prototype.isCallable=function(){var e;return this.partial||((e=this.op)==="&&"||e==="||"||e==="?"||e==="<<"||e===">>")&&this.first.isCallable()&&this.second.isCallable()};s.prototype.isArray=function(){switch(this.op){case"*":return this.first.isArray();case"/":return this.second.isMatcher()}};s.prototype.isString=function(){switch(this.op){case"+":case"*":return this.first.isString()||this.second.isString();case"-":return this.second.isMatcher()}};t=/^(?:[!=]=|[<>])=?$/;n={"===":"!==","!==":"===","==":"!=","!=":"=="};s.prototype.invert=function(){var e;if(e=!t.test(this.second.op)&&n[this.op]){this.op=e;this.wasInverted=true;return this}return _("!",U(this),true)};s.prototype.invertIt=function(){this.inverted=true;return this};s.prototype.getDefault=function(){switch(this.op){case"?":case"||":case"&&":return this}};s.prototype.assigns=function(){var e;return(e=this.getDefault())!=null?e.first.assigns():void 8};s.prototype.xorChildren=function(e){var t,n;if(!(!(n=e(this.first))!==!(t=e(this.second))&&(n||t))){return false}return n?[this.first,this.second]:[this.second,this.first]};s.prototype.compileNode=function(e){var n,i,r,s,o,a,u;if(this.partial){return this.compilePartial(e)}switch(this.op){case"?":return this.compileExistence(e);case"*":if(this.second.isString()){return this.compileJoin(e)}if(this.first.isString()||this.first.isArray()){return this.compileRepeat(e)}break;case"-":if(this.second.isMatcher()){return this.compileRemove(e)}break;case"/":if(this.second.isMatcher()){return this.compileSplit(e)}break;case"**":case"^":return this.compilePow(e);case"<?":case">?":return this.compileMinMax(e);case"<<":case">>":return this.compileCompose(e);case"++":return this.compileConcat(e);case"%%":return this.compileMod(e);case"xor":return this.compileXor(e);case"&&":case"||":if(n=this["void"]||!e.level){this.second["void"]=true}if(n||this.cond){this.first.cond=true;this.second.cond=true}break;case"instanceof":i=this.second,r=i.items;if(i instanceof R){if(r[1]){return this.compileAnyInstanceOf(e,r)}this.second=r[0]||i}this.second.isCallable()||this.second.carp("invalid instanceof operand");break;case"====":case"!===":this.op=this.op.slice(0,3);
  // fallthrough
  case"<==":case">==":case"<<=":case">>=":return this.compileDeepEq(e);default:if(t.test(this.op)){if(s=((o=this.op)==="==="||o==="!==")&&this.xorChildren(function(e){return e.isRegex()})){return this.compileRegexEquals(e,s)}if(this.op==="==="&&(this.first instanceof y&&this.second instanceof y)&&this.first.isWhat()!==this.second.isWhat()){if(e.warn){this.warn("strict comparison of two different types will always be false: "+this.first.value+" == "+this.second.value)}}}if(t.test(this.op)&&t.test(this.second.op)){return this.compileChain(e)}}this.first.front=this.front;a=[this.first.compile(e,u=le+he[this.op])," ",this.mapOp(this.op)," ",this.second.compile(e,u)];if(e.level<=u){return l.apply(null,[this].concat(me(a)))}else{return l.apply(null,[this,"("].concat(me(a),[")"]))}};s.prototype.mapOp=function(e){var t;switch(false){case!(t=e.match(/\.([&\|\^]|<<|>>>?)\./)):return t[1];case e!=="of":return"in";default:return e}};s.prototype.compileChain=function(e){var t,n,i,r;t=[this.first.compile(e,n=le+he[this.op])];i=this.second.first.cache(e,true),r=i[0],this.second.first=i[1];t.push(" ",this.op," ",r.compile(e,n)," && ",this.second.compile(e,le));if(e.level<=le){return l.apply(null,[this].concat(me(t)))}else{return l.apply(null,[this,"("].concat(me(t),[")"]))}};s.prototype.compileExistence=function(e){var t;if(this["void"]||!e.level){t=s("&&",M(this.first,true),U(this.second.unwrap()));return(t["void"]=true,t).compileNode(e)}t=this.first.cache(e,true);return l(this,K(M(t[0]),t[1]).addElse(this.second).compileExpression(e))};s.prototype.compileAnyInstanceOf=function(e,t){var n,i,r,o,a,u,c;n=this.first.cache(e),i=n[0],r=n[1],this.temps=n[2];o=s("instanceof",i,t.shift());for(a=0,u=t.length;a<u;++a){c=t[a];o=s("||",o,s("instanceof",r,c))}return l(this,U(o).compile(e))};s.prototype.compileMinMax=function(e){var t,n,i;t=this.first.cache(e,true);n=this.second.cache(e,true);i=s(this.op.charAt(),t[0],n[0]);return l(this,K(i,t[1]).addElse(n[1]).compileExpression(e))};s.prototype.compileMethod=function(e,t,n,i){var r;r=[this.second].concat(i||[]);if(this.first["is"+t]()){return l(this,L(this.first,[w(b(n)),A(r)]).compile(e))}else{r.unshift(this.first);return l(this,A.make(Z(Ae(n)+".call"),r).compile(e))}};s.prototype.compileJoin=function(e){return this.compileMethod(e,"Array","join")};s.prototype.compileRemove=function(e){return this.compileMethod(e,"String","replace",Z("''"))};s.prototype.compileSplit=function(e){return this.compileMethod(e,"String","split")};s.prototype.compileRepeat=function(e){var t,n,i,r,s,o,a,u,h,f,p,d;t=this.first,n=t.items,i=this.second;r=t.isArray()&&"Array";if(n&&!c(s=D.compileArray(e,n))){t=Z(s);n=null}if(r&&!n||!(i instanceof y&&i.value<32)){return l(this,A.make(ee("repeat"+(r||"String")),[t,i]).compile(e))}i=+i.value;if(1<=i&&i<2){return l(this,t.compile(e))}if(n){if(i<1){return l(this,g(n).add(Z("[]")).compile(e))}o=[];for(a=0,u=n.length;a<u;++a){h=a;f=n[a];p=f.cache(e,1),n[h]=p[0],o[o.length]=p[1]}n.push((p=Z(),p.compile=function(){return l.apply(null,[this].concat(me(_e([", ",E.compile(e,o)],i-1).slice(1))))},p));return l(this,t.compile(e))}else if(t instanceof y){return l(this,(d=(t=t.compile(e).toString()).charAt())+Te(t.slice(1,-1)+"",i)+d)}else{if(i<1){return l(this,g(t.it).add(Z("''")).compile(e))}t=(o=t.cache(e,1,le))[0]+Te(" + "+o[1],i-1);if(e.level<le+he["+"]){return l(this,t)}else{return l(this,"(",t,")")}}};s.prototype.compilePow=function(e){return l(null,A.make(ne(this,Z("Math.pow")),[this.first,this.second]).compile(e))};s.prototype.compileConcat=function(e){var t;t=function(e){switch(false){case!(e instanceof s&&e.op==="++"):return t(e.first).concat(t(e.second));default:return[e]}};return l(null,L(this.first).add(ne(this,w(b("concat"),".",true))).add(A(t(this.second))).compile(e))};s.prototype.compileCompose=function(e){var t,n,i;t=this.op;n=[this.first];i=this.second;while(i instanceof s&&i.op===t&&!i.partial){n.push(i.first);i=i.second}n.push(i);if(t==="<<"){n.reverse()}return l(this,L(v(Ae("compose"))).add(A(n)).compile(e))};s.prototype.compileMod=function(e){var t,n;t=e.scope.temporary();n=[l(this,"(("),this.first.compile(e),l(this,") % ("),l(this,t," = "),this.second.compile(e),l(this,") + ",t,") % ",t)];e.scope.free(t);if(e.level<le+he["%"]){return l.apply(null,[null].concat(me(n)))}else{return l.apply(null,[null,"("].concat(me(n),[")"]))}};s.prototype.compilePartial=function(e){var t,n,i;t=v("it");switch(false){case!(this.first==null&&this.second==null):n=v("x$");i=v("y$");return l(this,P([n,i],g(s(this.op,n,i).invertCheck(this)),false,true).compile(e));case this.first==null:return l(this,"(",P([t],g(s(this.op,this.first,t).invertCheck(this)),true).compile(e),")");default:return l(this,"(",P([t],g(s(this.op,t,this.second).invertCheck(this)),true).compile(e),")")}};s.prototype.compileRegexEquals=function(e,t){var n,i,r;n=t[0],i=t[1];if(this.op==="==="){r=this.wasInverted?"test":"exec";return l(this,L(n).add(w(b(r))).add(A([i])).compile(e))}else{return l(this,_("!",L(n).add(w(b("test"))).add(A([i]))).compile(e))}};s.prototype.compileDeepEq=function(e){var t,n,i,r,s,o;if((t=this.op)===">=="||t===">>="){t=[this.second,this.first],this.first=t[0],this.second=t[1];this.op=this.op===">=="?"<==":"<<="}if(this.op==="!=="){this.op="===";n=true}for(i=0,r=(t=[this.first,this.second]).length;i<r;++i){s=t[i];if(s instanceof C||s instanceof R){s.deepEq=true}}o=L(v(Ae("deepEq"))).add(A([this.first,this.second,y("'"+this.op+"'")]));return l(this,(n?_("!",o):o).compile(e))};s.prototype.compileXor=function(e){var t,n;t=L(this.first).cacheReference(e);n=L(this.second).cacheReference(e);return l(this,s("&&",s("!==",_("!",t[0]),_("!",n[0])),U(s("||",t[1],n[1]))).compile(e))};s.prototype.rewriteShorthand=function(t,n){var i;if(this.partial){return e.prototype.rewriteShorthand.apply(this,arguments)}if(i=this.first.rewriteShorthand(t,n)){this.first=i}if(i=this.second.rewriteShorthand(t)){this.second=i}};return s}(p);n.Assign=I=function(e){var t=Re((Ce(i,e).displayName="Assign",i),e).prototype,n=i;function i(e,t,n,i,s){var o=this instanceof r?this:new r;o.left=e;o.op=n||"=";o.logic=i||o.op.logic;o.defParam=s;o.opLoc=o.op;o.op+="";o[t instanceof p?"right":"unaries"]=t;return o}function r(){}r.prototype=t;i.prototype.children=["left","right"];i.prototype.show=function(){return[void 8].concat(this.unaries).reverse().join(" ")+[this.logic]+this.op};i.prototype.assigns=function(){return this.left.assigns()};i.prototype.getRef=function(){if(!this.left.isComplex()){return this.left}};t.delegate(["isCallable","isRegex"],function(e){var t;return((t=this.op)==="="||t===":=")&&this.right&&this.right[e]()});i.prototype.isArray=function(){switch(this.op){case"=":case":=":return this.right&&this.right.isArray();case"/=":return this.right&&this.right.isMatcher()}};i.prototype.isString=function(){switch(this.op){case"=":case":=":case"+=":case"*=":return this.right&&this.right.isString();case"-=":return this.right&&this.right.isMatcher()}};i.prototype.unfoldSoak=function(e){var t,n,r,s,o;if(this.left instanceof M){if(t=(r=(n=this.left=this.left.it).name,delete n.name,r)){s=this.right;s=i(this.right=v(t),s)}else{n=this.right.cache(e),s=n[0],this.right=n[1],o=n[2]}return n=K(M(s),this),n.soak=true,n.temps=o,n.cond=this.cond,n["void"]=this["void"],n}return K.unfoldSoak(e,this,"left")};i.prototype.unfoldAssign=function(){return this.access&&this};i.prototype.compileNode=function(e){var t,n,r,s,o,a,u,c,h,f,p,d,m,y,b,w,A;if(t=this.unfoldSoak(e)){return t.compile(e)}if(this.left instanceof k&&this.op==="="){return this.compileSplice(e)}n=this.left;if(r=this.left instanceof D){n=n.it}if(r){n instanceof E||this.left.carp("invalid splat");return this.compileSpread(e,n)}if(!this.right){n.isAssignable()||n.carp("invalid unary assign");s=L(n).cacheReference(e),n=s[0],this.right=s[1];for(o=0,a=(s=this.unaries).length;o<a;++o){u=s[o];this.right=_(u,this.right)}}if(n.isEmpty()){return l(null,(s=U(this.right),s.front=this.front,s.newed=this.newed,s).compile(e))}if(n.getDefault()){this.right=T(n.op,this.right,n.second);n=n.first}if(n.soak){this.left=n.then;n.then=this;return n.compile(e)}if(n.items){return this.compileDestructuring(e,n)}n.isAssignable()||n.carp("invalid assign");if(this.logic){return this.compileConditional(e,n)}u=this.op,c=this.right;if(u==="<?="||u===">?="){return this.compileMinMax(e,n,c)}if(u==="**="||u==="^="||u==="%%="||u==="++="||u==="|>="||u==="*="&&c.isString()||(u==="-="||u==="/=")&&c.isMatcher()){s=L(n).cacheReference(e),n=s[0],h=s[1];c=T(u.slice(0,-1),h,c);u=":="}if(u===".&.="||u===".|.="||u===".^.="||u===".<<.="||u===".>>.="||u===".>>>.="){u=u.slice(1,-2)+"="}(c=c.unparen()).ripName(n=n.unwrap());if(n instanceof L){n.expandVivify();if((n=n.unwrap())instanceof i){s=L(n.left).cacheReference(e),n.left=s[0],this.left=s[1];return g([n,(s=Se(this),s.terminator="",s)]).compile(e)}}f=l(this.opLoc," ",u.replace(":","")," ");p=(n.front=true,n).compile(e,ae);if(d=n instanceof v){if(u==="="){e.scope.declare(p.toString(),n,this["const"]||!this.defParam&&e["const"]&&"$"!==p.toString().slice(-1))}else if(t=e.scope.checkReadOnly(p.toString())){n.carp("assignment to "+t+' "'+p+'"',ReferenceError)}}if(n instanceof L&&c instanceof P){m=p.toString().split(".prototype.");y=p.toString().split(".");if(m.length>1){c.inClass=m[0]}else if(y.length>1){c.inClassStatic=ge.call(y,0,-1).join("")}}b=!e.level&&c instanceof Y&&!c["else"]&&(d||n instanceof L&&n.isSimpleAccess())?(w=c.objComp?"{}":"[]",[A=e.scope.temporary("res")," = "+w+";\n"+this.tab,c.makeReturn(A).compile(e),"\n"+this.tab,p,f,e.scope.free(A)]):[p,f,c.compile(e,ae)];if(e.level>ae){b=["("].concat(me(b),[")"])}return l.apply(null,[null].concat(me(b)))};i.prototype.compileConditional=function(e,t){var n,i,r;if(t instanceof v&&this.logic==="?"&&this.op==="="){e.scope.declare(t.value,t)}n=L(t).cacheReference(e),i=n[0],t=n[1];e.level+=le<e.level;if(this.logic==="?"&&((n=this.op)!=="="&&n!==":=")){this.logic="&&";i=M(i)}r=T(this.logic,i,(this.logic=false,this.left=t,this));return l(this,(r["void"]=this["void"],r).compileNode(e))};i.prototype.compileMinMax=function(e,t,n){var r,s,o,a,u;r=L(t).cacheReference(e);s=n.cache(e,true);o=T(this.op.replace("?",""),r[0],s[0]);a=i(r[1],s[1],":=");if(this["void"]||!e.level){return U(T("||",o,a)).compile(e)}u=o.first.cache(e,true),o.first=u[0],t=u[1];return l(this,K(o,t).addElse(a).compileExpression(e))};i.prototype.compileDestructuring=function(e,t){var n,i,r,s,o,a,u,c,h,f,p,d,g,m;n=t.items,i=n.length;r=e.level&&!this["void"];s=this.right.compile(e,i===1?ce:ae);if(o=t.name){a=l(this,o," = ",s);e.scope.declare(s=o,t)}else if((r||i>1)&&(!pe.test(s.toString())||(o=t.assigns())&&Ne(s.toString(),o))){a=l(this,u=e.scope.temporary()," = ",s);s=u}if(s.toString()==="arguments"&&!r){c=true;if(!(t instanceof R)){this.carp("arguments can only destructure to array")}}h=this["rend"+t.constructor.displayName](e,n,s,c);if(u){e.scope.free(u)}if(a){h.unshift(a)}if(r||!h.length){h.push(s)}f=[];p=c?"; ":", ";for(d=0,g=h.length;d<g;++d){m=h[d];f.push(m,p)}f.pop();if(e.level<le&&h.length<2||e.level<ae){return l.apply(null,[this].concat(me(f)))}else{return l.apply(null,[this,"("].concat(me(f),[")"]))}};i.prototype.compileSplice=function(e){var t,n,i,r,s,o;t=L(this.left.from).cacheReference(e),n=t[0],i=t[1];t=L(this.right).cacheReference(e),r=t[0],s=t[1];o=T("-",this.left.to,i);return l(this,g([L(v(Ae("splice"))).add(w(b("apply"),".",true)).add(A([this.left.target,L(R([n,o])).add(w(b("concat"),".",true)).add(A([r]))])),s]).compile(e,ae))};i.prototype.compileSpread=function(e,t){var i,r,s,o,a=this;r=(i=this.unaries)?[i,i]:t.items.length<=1?[r=this.right,r]:this.right.cache(e,true),s=r[0],o=r[1];return this.compileSpreadOver(e,t,function(e){var t;t=n(e,s,a.op,a.logic);s=o;return t})};i.prototype.rendArr=function(e,t,n,i){var r,s,o,a,u,l,c,h,f,p,d,g,m,k,A;function E(e,t){return new z({ref:true,from:e,op:"til",to:t}).makeComprehension(L(v("arguments")).add(w(y(".."))),[])}r=[];for(s=0,o=t.length;s<o;++s){a=s;u=t[s];if(u.isEmpty()){continue}if(u instanceof D){c&&u.carp("multiple splat in an assignment");l=(u=u.it).isEmpty();if(a+1===(c=t.length)){if(l){break}if(i){h=E(y(a),L(v("arguments")).add(w(b("length"))))}else{h=R.wrap(Z(Ae("slice")+".call("+n+(a?", "+a+")":")")))}}else{h=f=n+".length - "+(c-a-1);if(l&&a+2===c){continue}p=a+1;(this.temps||(this.temps=[])).push(f=e.scope.temporary("i"));h=C()}}else{(d=f)&&p<a&&(d+=" + "+(a-p));h=L(g||(g=y(n)),[w(Z(d||a))])}if(i){if(!(u instanceof v)&&h instanceof z){(this.temps||(this.temps=[])).push(m=e.scope.temporary("ref"));k=v(m);r.push((A=Se(this),A.left=k,A.right=h,A["void"]=true,A).compile(e,se));r.push((A=Se(this),A.left=u,A.right=k,A["void"]=true,A).compile(e,se))}else{r.push((A=Se(this),A.left=u,A.right=h,A["void"]=true,A).compile(e,se))}}else{r.push((A=Se(this),A.left=u,A.right=h,A["void"]=true,A).compile(e,oe))}}return r;function C(){switch(false){case!l:return R.wrap(Z(a+" < ("+f+" = "+h+") ? "+a+" : ("+f+" = "+a+")"));case!i:return E(Z(a+" < ("+f+" = "+h+") ? "+a+" : ("+f+" = "+a+")"),v(f));default:return R.wrap(Z(a+" < ("+f+" = "+h+") ? "+Ae("slice")+".call("+n+", "+a+", "+f+") : ("+f+" = "+a+", [])"))}}};i.prototype.rendObj=function(e,t,n){var i,r,s,o,a,u,l,c,h,f,p,d,g,m=[];i=[];r=[];s=v(n);for(o=0,a=t.length;o<a;++o){u=t[o],l=u.key,c=u.val,h=u.logic;c=c.unparen();if(l instanceof D){h!=null&&this.carp("invalid assign");f=C(b.call(this));p=L(v(Ae("copyWithout"))).add(A([s,f]))}else{i.push(l);if(h){c=(h.first=c,h)}p=L(s,[w(l)])}r.push([c,p])}for(o=0,a=r.length;o<a;++o){u=r[o],d=u[0],g=u[1];m.push((u=Se(this),u.left=d,u.right=g,u["void"]=true,u.temps=[],u).compile(e,oe))}return m;function b(){var t,n,r,s,o=[];for(t=0,s=(r=i).length;t<s;++t){n=r[t];o.push(S(n.extractKeyRef(e,true,this),y(0)))}return o}};i.prototype.rewriteShorthand=function(e,t){var n,i,r,s;if(t){if(this===(n=this.maybeLogic())){this.carp("invalid assign")}return(i=n.rewriteShorthand(e,true))!=null?i:n}if(r=this.unfoldSoak(e)){return r.rewriteShorthand(e,t)||r}if(r=(i=this.left)!=null?i.rewriteShorthand(e,true):void 8){this.left=r}if(r=(s=this.right)!=null?s.rewriteShorthand(e):void 8){this.right=r}};i.prototype.maybeLogic=function(){if(this.op==="="){return T(this.logic||"?",this.left,this.right)}else{return this}};return i}(p);n.Import=x=function(e){var t=Re((Ce(i,e).displayName="Import",i),e).prototype,n=i;function i(e,t,n){var i=this instanceof r?this:new r;i.left=e;i.right=t;i.all=n&&"All";if(!n&&e instanceof C&&t.items){return C(e.items.concat(t.asObj().items))}return i}function r(){}r.prototype=t;i.prototype.children=["left","right"];i.prototype.show=function(){return this.all};t.delegate(["isCallable","isArray"],function(e){return this.left[e]()});i.prototype.unfoldSoak=function(e){var t,n,i,r;t=this.left;if(t instanceof M&&!t.negated){if((t=t.it)instanceof v){n=(this.left=t).value;if(!e.scope.check(n,true)){t=Z("typeof "+n+" != 'undefined' && "+n)}}else{i=t.cache(e),t=i[0],this.left=i[1],r=i[2]}return i=K(t,this),i.temps=r,i.soak=true,i.cond=this.cond,i["void"]=this["void"],i}return K.unfoldSoak(e,this,"left")||this["void"]&&K.unfoldSoak(e,this,"right")};i.prototype.compileNode=function(e){var t;t=this.right;if(!this.all){if(t instanceof L){t=t.unfoldSoak(e)||t.unfoldAssign(e)||t}if(t instanceof E){return this.compileAssign(e,t.asObj().items)}}return ne(this,A.make(ee("import"+(this.all||"")),[this.left,t])).compileNode(e)};i.prototype.compileAssign=function(e,t){var n,r,s,o,a,u,c,h,f,p,d,g,m,y,v;if(!t.length){return this.left.compile(e)}n=!e.level;if(this.proto||t.length<2&&(n||this["void"]||t[0].key instanceof D)){r=this.left;if(r.isComplex()){r=U(r)}}else{s=this.left.cache(e),o=s[0],r=s[1],this.temps=s[2]}s=n?[";","\n"+this.tab]:[","," "],a=s[0],u=s[1];a+=u;c=this.temps?[o.compile(e,oe),a]:[];for(h=0,f=t.length;h<f;++h){p=h;d=t[h];p&&c.push(g?u:a);if(g=d.comment){c.push(d.compile(e));continue}m=d.key,y=d.val,v=d.logic;if(m instanceof D){c.push(ne(this,i(r,y)).compile(e));continue}if(d.accessor){if(m instanceof b){m=Z("'"+m.name+"'")}c.push("Object.defineProperty(",r.compile(e,ae),", ",m.compile(e,ae),", ",d.compileDescriptor(e),")");continue}v&&(y=(v.first=y,v));c.push(I(L(r,[w(m)]),y).compile(e,oe))}if(n){return l.apply(null,[null].concat(me(c)))}this["void"]||m instanceof D||c.push(g?" ":", ",r.compile(e,oe));if(e.level<ae){return l.apply(null,[null].concat(me(c)))}else{return l.apply(null,[null,"("].concat(me(c),[")"]))}};i.prototype.rewriteShorthand=function(e,t){var n,i,r;if(n=this.unfoldSoak(e)){return n.rewriteShorthand(e,t)||n}if(n=(i=this.left)!=null?i.rewriteShorthand(e,t):void 8){this.left=n}if(n=(r=this.right)!=null?r.rewriteShorthand(e):void 8){this.right=n}};return i}(p);n.In=O=function(e){var t=Re((Ce(i,e).displayName="In",i),e).prototype,n=i;Ie(t,arguments[1]);function i(e,t){this.item=e;this.array=t}i.prototype.children=["item","array"];i.prototype.compileNode=function(e){var t,n,r,s,o,a,u,c,h,f,p,d,g;n=(t=this.array).items;if(!(t instanceof R)){return l(this,this.negated?"!":"",Ae("in"),"(",this.item.compile(e,ae),", ",t.compile(e,ae),")")}if(n.length===0){if(e.warn){this.warn("value can never be `in` an empty array")}r=!!this.negated+"";return this.item.isComplex()?l(this,"(",this.item.compile(e,ae),", ",r,")"):l(this,r)}s=[];o=n.length===1?[o=this.item.compile(e,oe),o]:this.item.cache(e,false,oe),a=o[0],u=o[1];o=this.negated?[" !== "," && "]:[" === "," || "],c=o[0],h=o[1];for(f=0,p=n.length;f<p;++f){d=f;g=n[f];if(s.length>0){s.push(h)}if(g instanceof D){s.push((o=new i(v(u),g.it),o.negated=this.negated,o).compile(e,se));if(!(d||a===u)){s=["("+a+", "].concat(me(s),[")"])}}else{s.push(d||a===u?u:"("+a+")",c,g.compile(e,le+he["=="]))}}a===u||e.scope.free(u);if(e.level<le+he[n.length===1?"===":"||"]){return l.apply(null,[this].concat(me(s)))}else{return l.apply(null,[this,"("].concat(me(s),[")"]))}};return i}(p,d);n.Existence=M=function(e){var t=Re((Ce(i,e).displayName="Existence",i),e).prototype,n=i;Ie(t,arguments[1]);function i(e,t){var n=this instanceof r?this:new r;n.it=e;n.negated=t;return n}function r(){}r.prototype=t;i.prototype.children=["it"];i.prototype.compileNode=function(e){var t,n,i,r,s,o,a,u;t=(n=this.it.unwrap(),n.front=this.front,n);i=[t.compile(e,le+he["=="])];if(this.doAnaphorize){e.scope.declare("that",v("that"))}if(t instanceof v&&!e.scope.check(i.join(""),true)){n=this.negated?["||","="]:["&&","!"],r=n[0],s=n[1];if(this.doAnaphorize){n=this.negated?[["(that = undefined) || "],[]]:[[],[" && (that = "].concat(me(i),[", true)"])],o=n[0],a=n[1]}i=["typeof "].concat(me(i),[" "+s+"= 'undefined' "+r+" "],me(i),[" "+s+"== null"]);if((u=o)!=null){i=u.concat(i)}if((u=a)!=null){i=i.concat(u)}}else{if(this.doAnaphorize){i=["(that = "].concat(me(i),[")"])}i.push(" "+(r=this.negated?"==":"!=")+" null")}if(e.level<le+he[r]){return l.apply(null,[this].concat(me(i)))}else{return l(this,"(",i,")")}};return i}(p,d);n.Fun=P=function(e){var t=Re((Ce(r,e).displayName="Fun",r),e).prototype,n=r;function r(e,t,n,i,r,o,a){var u=this instanceof s?this:new s;u.params=e||[];u.body=t||g();u.bound=n&&"this$";u.curried=i||false;u.hushed=r!=null?r:false;u.generator=o!=null?o:false;u.async=a!=null?a:false;return u}function s(){}s.prototype=t;r.prototype.children=["params","body"];r.prototype.show=function(){var e;return[this.name]+[(e=this.bound)?"~"+e:void 8]};r.prototype.named=function(e){return this.name=e,this.statement=true,this};r.prototype.isCallable=be;r.prototype.isStatement=function(){return!!this.statement};r.prototype.traverseChildren=function(t,n){if(n){return e.prototype.traverseChildren.apply(this,arguments)}};r.prototype.rewriteShorthand=Le;r.prototype.makeReturn=function(){if(this.statement){return this.returns=true,this}else{return e.prototype.makeReturn.apply(this,arguments)}};r.prototype.ripName=function(e){this.name||(this.name=e.varName())};r.prototype.compileNode=function(e){var t,n,i,r,s,o,a,u,h,f,p,d,g=this;t=e.scope;n=t.shared||t;i=e.scope=this.body.scope=new ve(this.wrapper?t:n,this.wrapper&&n);i.fun=this;if(r=this.proto){i.assign("prototype",r.compile(e)+".prototype")}if(r=this.cname){i.assign("constructor",r)}if(s=(o=e.loop,delete e.loop,o)){e.indent=this.tab=""}e.indent+=fe;a=this.body,u=this.name,h=this.tab;f=["function"];if(this.async){this.ctor&&this.carp("a constructor can't be async");e.inAsync=true;f.unshift("async ")}else if(!this.wrapper){e.inAsync=false}if(this.generator){this.ctor&&this.carp("a constructor can't be a generator");e.inGenerator=true;f.push("*")}else if(!this.wrapper){e.inGenerator=false}if(this.bound==="this$"){if(this.ctor){i.assign("this$","this instanceof ctor$ ? this : new ctor$");a.lines.push(W(y("this$")))}else if(r=(o=n.fun)!=null?o.bound:void 8){this.bound=r}else if(this.usesThis()){n.assign("this$","this")}}if(this.statement){u||this.carp("nameless function declaration");t===e.block.scope||this.carp("misplaced function declaration");this.accessor&&this.carp("named accessor");t.add(u,"function",this)}if(this.statement||u&&this.labeled){f.push(" ",i.add(u,"function",this))}this.hushed||this.ctor||this.newed||a.makeReturn();f.push("(",this.compileParams(e,i),")");f=[l.apply(null,[this].concat(me(f)))];f.push("{");if(!c(p=a.compileWithDeclarations(e))){f.push("\n",p,"\n"+h)}f.push("}");d=function(){if(g.curried&&g.hasSplats){g.carp("cannot curry a function with a variable number of arguments")}if(g.curried&&g.params.length>1&&!g.classBound){if(g.bound){return[Ae("curry"),"(("].concat(me(f),["), true)"])}else{return[Ae("curry"),"("].concat(me(f),[")"])}}else{return f}};if(s){return t.assign(t.temporary("fn"),l.apply(null,[null].concat(me(d()))))}if(this.returns){f.push("\n"+h+"return ",u,";")}else if(this.bound&&this.ctor){f.push(" function ctor$(){} ctor$.prototype = prototype;")}f=d();if(this.front&&!this.statement){return l.apply(null,[null,"("].concat(me(f),[")"]))}else{return l.apply(null,[null].concat(me(f)))}};r.prototype.compileParams=function(e,t){var n,r,s,o,a,u,c,h,f,p,d,g,m,b,w,k,L,A,E;n=this.params,r=n.length,s=this.body;for(o=n.length-1;o>=0;--o){a=n[o];if(!(a.isEmpty()||a.filler)){break}--n.length}for(o=0,u=n.length;o<u;++o){c=o;a=n[o];if(a.left instanceof D){a.carp("invalid splat")}if(a instanceof D){this.hasSplats=true;h=c}else if(a.op==="="){n[c]=T(a.logic||"?",a.left,a.right)}}if(h!=null){f=n.splice(h,9e9)}else if(this.accessor){if(p=n[1]){p.carp("excess accessor parameter")}}else if(!(r||this.wrapper)){if(s.traverseChildren(function(e){return e.value==="it"||null})){n[0]=v("it")}}d=[];g=[];for(o=0,u=n.length;o<u;++o){a=n[o];m=a;if(b=m.getDefault()){m=m.first}if(m.isEmpty()){m=v(t.temporary("arg"))}else if(m.value===".."){m=v(e.ref=t.temporary())}else if(!(m instanceof v)){w=[];while(m instanceof _){k=true;w.push(m);m=m.it}L=v((E=(A=m.it||m).name,delete A.name,E)||m.varName()||t.temporary("arg"));g.push(I(m,C()));m=L}else if(b){g.push(I(m,a.second,"=",a.op,true))}d.push(t.add(m.value,"arg",a),", ")}if(f){while(h--){f.unshift(R())}g.push(I(R(f),y("arguments")))}if(g.length){(A=this.body).prepend.apply(A,g)}d.pop();return l.apply(null,[null].concat(me(d)));function C(){switch(false){case!b:return T(a.op,L,a.second);case!k:return i(function(e,t){t.it=e;return t},L,w.reverse());default:return L}}};r.prototype.usesThis=function(){return p.prototype.traverseChildren.call(this,function(e){switch(false){case!(e instanceof y&&e.value==="this"):return true;case!(e instanceof r&&e.bound&&e.usesThis()):return true}})};return r}(p);n.Class=B=function(e){var t=Re((Ce(i,e).displayName="Class",i),e).prototype,n=i;function i(e){var t;this.title=e.title,this.sup=e.sup,this.mixins=e.mixins,t=e.body;this.fun=P([],t)}i.prototype.children=["title","sup","mixins","fun"];i.prototype.isCallable=be;i.prototype.ripName=function(e){this.name=e.varName()};i.prototype.getRef=function(){var e,t;if(t=((e=this.title)!=null?e.varName():void 8)||this.name){return v(t)}};i.prototype.compile=function(e,t){var n,i,r,s,o,a,u,c,h,f,p,d,m,k,E,S,R,N,_,T,O,M,B,j,F;n=this.fun,i=n.body,r=i.lines,s=this.title;ne(this,n);o=[];a=[];u=s!=null?s.varName():void 8;c=u||this.name;if(pe.test(c||"")){n.cname=c}else{c="constructor"}h=v("prototype");f=n.proto=v(n.bound=c);p="constructor$$";k=function(t,n){var i,r,s,u,l,c,h;i=0;for(;i<t.items.length;i++){r=t.items[i];s=r.key;if(s instanceof b&&s.name===p||s instanceof y&&s.value==="'"+p+"'"){if(d){t.carp("redundant constructor")}d=r.val;t.items.splice(i--,1);m=n}if(!(r.val instanceof P||r.accessor)){continue}if(s.isComplex()){s=v(e.scope.temporary("key"));r.key=I(s,r.key)}if(r.val.bound){if(r.val.curried){a.push(r.key)}else{o.push(r.key)}r.val.bound=false;r.val.classBound=true}for(u=0,c=(l=[].concat(r.val)).length;u<c;++u){h=l[u];h.meth=s}}if(t.items.length){return l=x(L(f).add(w(b("prototype"))),t),l.proto=true,l}else{return y("void")}};for(E=0,S=r.length;E<S;++E){R=E;N=r[E];if(N instanceof C){r[R]=k(N,R)}else if(N instanceof P&&!N.statement){d&&N.carp("redundant constructor");d=N}else if(N instanceof I&&N.left instanceof L&&N.left.head.value==="this"&&N.right instanceof P){N.right.stat=N.left.tails[0].key}else{N.traverseChildren(Y)}}d||(d=r[r.length]=this.sup?P([],g(L(new $).add(A([D(y("arguments"))])))):P());if(!(d instanceof P)){r.splice(m+1,0,I(v(p),d));r.unshift(d=P([],g(W(L(v(p)).add(A([D("arguments",true)]))))))}d.name=c;d.ctor=true;d.statement=true;for(E=0,S=o.length;E<S;++E){_=o[E];d.body.lines.unshift(I(L(y("this")).add(w(_)),L(v(Ae("bind"))).add(A([y("this"),y("'"+_.name+"'"),v("prototype")]))))}for(E=0,S=a.length;E<S;++E){_=a[E];d.body.lines.unshift(I(L(y("this")).add(w(b("_"+_.name))),L(v(Ae("curry"))).add(A([L(v("prototype")).add(w(_)),v("true")]))),I(L(y("this")).add(w(_)),L(v(Ae("bind"))).add(A([y("this"),y("'_"+_.name+"'")]))))}r.push(f);T=[];if(O=this.sup){T.push(O);M=L(x(y("this"),v("superclass")));n.proto=ee.Extends(n.cname?g([I(M.add(w(b("displayName"))),y("'"+c+"'")),y(c)]):M,(B=n.params)[B.length]=v("superclass"))}if(O=this.mixins){j=[];for(E=0,S=O.length;E<S;++E){T[T.length]=O[E];j.push(x(h,Z("arguments["+(T.length-1)+"]"),true))}M=j;i.prepend.apply(i,M)}if(n.cname&&!this.sup){i.prepend(y(c+".displayName = '"+c+"'"))}F=U(A.make(n,T),true);if(u&&s.isComplex()){F=I(f,F)}if(s){F=I(s,F)}return l(null,F.compile(e,t));function Y(e){var t,n,i,r,s;if(e instanceof g){for(t=0,i=(n=e.lines).length;t<i;++t){r=t;s=n[t];if(s instanceof C){e.lines[r]=k(s,R)}}}}};return i}(p);n.Super=$=function(e){var t=Re((Ce(i,e).displayName="Super",i),e).prototype,n=i;function i(){}i.prototype.isCallable=be;i.prototype.compile=function(e){var t,n,i,r;t=e.scope;if(!this.sproto){for(;n=!t.get("superclass")&&t.fun;t=t.parent){i=n;if(n=i.meth){return l(this,"superclass.prototype",w(n).compile(e))}if(n=i.stat){return l(this,"superclass",w(n).compile(e))}if(n=t.fun.inClass){return l(this,n,".superclass.prototype.",t.fun.name)}else if(n=t.fun.inClassStatic){return l(this,n,".superclass.",t.fun.name)}}if(n=(r=e.scope.fun)!=null?r.name:void 8){return l(this,n,".superclass")}}return l(this,"superclass")};i.prototype.maybeKey=function(){return b("super",true)};return i}(p);n.Parens=U=function(e){var t=Re((Ce(i,e).displayName="Parens",i),e).prototype,n=i;function i(e,t,n,i,s){var o=this instanceof r?this:new r;o.it=e;o.keep=t;o.string=n;o.lb=i;o.rb=s;return o}function r(){}r.prototype=t;i.prototype.children=["it"];i.prototype.show=function(){return this.string&&'""'};t.delegate(["isComplex","isCallable","isArray","isRegex","isNextUnreachable","getRef"],function(e){return this.it[e]()});i.prototype.isString=function(){return this.string||this.it.isString()};i.prototype.unparen=function(){if(this.keep){return this}else{return this.it.unparen()}};i.prototype.compile=function(e,t){var n;t==null&&(t=e.level);n=this.it;n.cond||(n.cond=this.cond),n["void"]||(n["void"]=this["void"]);if(this.calling&&(!t||this["void"])){n.head.hushed=true}if(!(this.keep||this.newed||t>=le+he[n.op])){return(n.front=this.front,n).compile(e,t||oe)}if(n.isStatement()){return n.compileClosure(e)}else{return l(null,l(this.lb,"("),n.compile(e,oe),l(this.rb,")"))}};i.prototype.maybeKey=ke;i.prototype.extractKeyRef=function(e,t,n){var r,s,o,a,u;if(n!=null&&(r=this.it)instanceof v&&(s=r.temp,delete r.temp,s)){(n.temps||(n.temps=[])).push(r.value)}if(this.it instanceof L&&t){s=this.it.cacheReference(e),this.it=s[0],o=s[1];return i(o)}s=this.it.cache(e,true),a=s[0],u=s[1];if(t){s=[u,a],a=s[0],u=s[1]}this.it=u.unparen();return i(a)};i.prototype.rewriteShorthand=function(e){var t;if(t=this.it.rewriteShorthand(e)){this.it=t}};return i}(p);n.Splat=D=function(e){var t,n=Re((Ce(r,e).displayName="Splat",r),e).prototype,i=r;function r(e,t){var n=this instanceof s?this:new s;n.it=e;n.filler=t;return n}function s(){}s.prototype=n;t=U.prototype,n.children=t.children,n.isComplex=t.isComplex;r.prototype.isAssignable=be;r.prototype.assigns=function(){return this.it.assigns()};r.prototype.compile=function(){return this.carp("invalid splat")};r.compileArray=function(e,t,n){var i,s,u,c,h,f,p;o(t);i=0;for(s=0,u=t.length;s<u;++s){c=t[s];if(c instanceof r){break}++i}if(i>=t.length){return l(this,"")}if(!t[1]){return l(this,(n?Object:a)(t[0].it).compile(e,ae))}h=[];f=[];for(s=0,u=(p=t.splice(i,9e9)).length;s<u;++s){c=p[s];if(c instanceof r){if(f.length){h.push(R(f.splice(0,9e9)))}h.push(a(c.it))}else{f.push(c)}}if(f.length){h.push(R(f))}return l(null,(i?R(t):h.shift()).compile(e,ce),l(this,".concat("),E.compile(e,h),l(this,")"))};function o(e){var t,n,i;t=-1;while(n=e[++t]){if(n instanceof r){i=n.it;if(i.isEmpty()){e.splice(t--,1)}else if(i instanceof R){e.splice.apply(e,[t,1].concat(me(o(i.items))));t+=i.items.length-1}}}return e}function a(e){if(e.isArray()){return e}Ae("slice");return A.make(ee("arrayFrom"),[e])}return r}(p);n.Jump=j=function(e){var t=Re((Ce(i,e).displayName="Jump",i),e).prototype,n=i;function i(e,t){this.verb=e;this.label=t}i.prototype.show=function(){var e;return(this.verb||"")+((e=this.label)?" "+e:"")};i.prototype.isStatement=be;i.prototype.makeReturn=ke;i.prototype.isNextUnreachable=be;i.prototype.getJump=function(e){var t,n;e||(e={});if(!e[this.verb]){return this}if(t=this.label){return!Ne(t,(n=e.labels)!=null?n:e.labels=[])&&this}};i.prototype.compileNode=function(e){var t,n;if(t=this.label){Ne(t,(n=e.labels)!=null?n:e.labels=[])||this.carp('unknown label "'+t+'"')}else{e[this.verb]||this.carp("stray "+this.verb)}return l(this,this.show()+";")};i.extended=function(e){e.prototype.children=["it"];this[e.displayName.toLowerCase()]=e};return i}(p);n.Throw=F=function(e){var t=Re((Ce(i,e).displayName="Throw",i),e).prototype,n=i;function i(e){var t=this instanceof r?this:new r;t.it=e;return t}function r(){}r.prototype=t;i.prototype.getJump=Le;i.prototype.compileNode=function(e){var t;return l(this,"throw ",((t=this.it)!=null?t.compile(e,oe):void 8)||"null",";")};return i}(j);n.Return=W=function(e){var t=Re((Ce(i,e).displayName="Return",i),e).prototype,n=i;function i(e){var t=this instanceof r?this:new r;if(e&&e.value!=="void"){t.it=e}return t}function r(){}r.prototype=t;i.prototype.getJump=ke;i.prototype.compileNode=function(e){var t;return l.apply(null,[this,"return"].concat((t=this.it)?[" ",t.compile(e,oe)]:[],[";"]))};return i}(j);n.While=Y=function(e){var t=Re((Ce(i,e).displayName="While",i),e).prototype,n=i;function i(e,t,n){this.un=t;n&&(n instanceof p?this.update=n:this.post=true);if(this.post||e.value!==""+!t){this.test=e}}i.prototype.children=["test","body","update","else"];i.prototype.aSource="test";i.prototype.aTargets=["body","update"];i.prototype.show=function(){return[this.un?"!":void 8,this.post?"do":void 8].join("")};t.isStatement=t.isArray=be;i.prototype.makeComprehension=function(e,t){this.isComprehension=true;while(t.length){e=t.pop().addBody(g(e));if(!e.isComprehension){e.inComprehension=true}}return this.addBody(g(e))};i.prototype.getJump=function(e){var t,n,i,r,s;e||(e={});e["continue"]=true;e["break"]=true;for(n=0,r=(i=((t=this.body)!=null?t.lines:void 8)||[]).length;n<r;++n){s=i[n];if(s.getJump(e)){return s}}};i.prototype.addBody=function(e){var t;this.body=e;if(this.guard){
  this.body=g(K(this.guard,this.body))}t=this.body.lines[0];if((t!=null?t.verb:void 8)==="continue"&&!t.label){this.body.lines.length=0}return this};i.prototype.addGuard=function(e){this.guard=e;return this};i.prototype.addObjComp=function(e){this.objComp=e!=null?e:true;return this};i.prototype.makeReturn=function(e){var t,n,i,r;if(this.hasReturned){return this}if(e){if(this.objComp){this.body=g(this.body.makeReturn(e,true))}else{if(!(this.body||this.index)){this.addBody(g(v(this.index="ridx$")))}n=(t=this.body.lines)!=null?t[t.length-1]:void 8;if((this.isComprehension||this.inComprehension)&&!(n!=null&&n.isComprehension)){(i=this.body).makeReturn.apply(i,arguments);if((i=this["else"])!=null){i.makeReturn.apply(i,arguments)}this.hasReturned=true}else{this.resVar=e;if((r=this["else"])!=null){r.makeReturn.apply(r,arguments)}}}}else{this.getJump()||(this.returns=true)}return this};i.prototype.compileNode=function(e){var t,n,i,r;e.loop=true;this.test&&(this.un?this.test=this.test.invert():this.anaphorize());if(this.post){return l(null,l(this,"do {"),this.compileBody((e.indent+=fe,e)))}n=((t=this.test)!=null?t.compile(e,oe):void 8)||"";if(!(this.update||this["else"])){i=!c(n)?[l(this,"while ("),n]:[l(this,"for (;;")]}else{i=[l(this,"for (")];if(this["else"]){i.push(this.yet=e.scope.temporary("yet")," = true")}i.push(l(this,";"),n.toString()&&" ",n,l(this,";"));if(r=this.update){i.push(" ",r.compile(e,oe))}}return l.apply(null,[null].concat(me(i),[l(this,") {"),this.compileBody((e.indent+=fe,e))]))};i.prototype.compileBody=function(e){var t,n,r,s,o,a,u,h,f,p,d,m,y,k,E,S,N=this;e["break"]=e["continue"]=true;t=this.body.lines,n=this.yet,r=this.tab;s=[];o=[];a=[];u=this.objComp?"{}":"[]";f=function(){return h!=null?h:h=e.scope.temporary(N.objComp?"resultObj":"results")};p=t!=null?t[t.length-1]:void 8;if(!(this.isComprehension||this.inComprehension)||p!=null&&p.isComprehension){d=false;if(p!=null){p.traverseChildren(function(e){var t;if(e instanceof g&&(t=e.lines)[t.length-1]instanceof i){d=true}})}if(this.returns&&!this.resVar){this.resVar=m=e.scope.assign(f(),u)}if(this.resVar&&(p instanceof i||d)){y=e.scope.temporary("lresult");t.unshift(I(v(y),t[t.length-1].objComp?C():R(),"="));if(t[k=t.length-1]!=null){t[k]=t[k].makeReturn(y)}a.push(fe,L(v(this.resVar)).add(w(b("push"),".",true)).add(A([L(v(y))])).compile(e),";\n"+this.tab)}else{this.hasReturned=true;if(this.resVar){this.body.makeReturn(this.resVar)}}}if(this.returns){if(!p instanceof i&&!this.hasReturned||this.isComprehension||this.inComprehension){if(t[k=t.length-1]!=null){t[k]=t[k].makeReturn(m=e.scope.assign(f(),u),this.objComp)}}o.push("\n"+this.tab+"return ",m||u,";");if((E=this["else"])!=null){E.makeReturn()}}n&&t.unshift(Z(n+" = false;"));if(!c(S=this.body.compile(e,se))){s.push("\n",S,"\n"+r)}s.push.apply(s,a);s.push("}");if(this.post){s.push(l(this," while ("),this.test.compile((e.tab=r,e),oe),l(this,");"))}if(n){s.push(l(this," if ("),n,l(this,") "),this.compileBlock(e,g(this["else"])));e.scope.free(n)}return l.apply(null,[null].concat(me(s),me(o)))};return i}(p);n.For=z=function(e){var t=Re((Ce(i,e).displayName="For",i),e).prototype,n=i;function i(e){var t,n,i,r;Ie(this,e);if(this.item instanceof v&&!this.item.value){this.item=null}for(t=0,r=(i=this.kind||[]).length;t<r;++t){n=i[t];this[n]=true}if(this.own&&!this.object){this.carp("`for own` requires `of`")}}i.prototype.children=["item","source","from","to","step","body"];i.prototype.aSource=null;i.prototype.show=function(){return(this.kind||[]).concat(this.index).join(" ")};i.prototype.addBody=function(t){var n,i,r,s,o,a;if(this["let"]){if(n=this.ref,delete this.ref,n){this.item=y("..")}i=(r=[],(s=this.index)&&r.push(I(v(s),y("index$$"))),(s=this.item)&&r.push(I(s,y("item$$"))),r);t=g(this.guard?(o=function(){var e,t,n,r,o,u,l,c=[];for(e=0,r=(n=i).length;e<r;++e){t=n[e];if(s=t.assigns()){for(o=0,l=(u=s).length;o<l;++o){a=u[o];c.push(v(a))}}}return c}(),i.concat([K((n=this.guard,delete this.guard,n),A["let"](o,t))])):A["let"](i,t))}e.prototype.addBody.call(this,t);if(this["let"]){delete this.index;delete this.item}return this};i.prototype.isNextUnreachable=we;i.prototype.compileNode=function(e){var t,n,i,r,s,o,a,u,c,h,f,p,d,m,b,w,k;e.loop=true;t=this.temps=[];if(this.object&&this.index){e.scope.declare(n=this.index)}else{t.push(n=e.scope.temporary("i"))}if(!this.body){this.addBody(g(v(n)))}if(!this.object){i=(this.step||y(1)).compileLoopReference(e,"step"),r=i[0],s=i[1];r===s||t.push(r)}if(this.from){if(this.ref){this.item=v(n)}i=this.to.compileLoopReference(e,"to"),o=i[0],a=i[1];u=this.from.compile(e,ae);c=n+" = "+u;if(a!==o){c+=", "+a;t.push(o)}if(!this.step&&+u>+o){r=s=-1}h=this.op==="til"?"":"=";f=+r?n+" "+"<>".charAt(r<0)+h+" "+o:r+" < 0 ? "+n+" >"+h+" "+o+" : "+n+" <"+h+" "+o}else{if(this.ref){this.item=v(e.scope.temporary("x"))}if(this.item||this.object&&this.own||this["let"]){i=this.source.compileLoopReference(e,"ref",!this.object,true),p=i[0],d=i[1];p===d||t.push(p)}else{p=d=this.source.compile(e,oe)}if(!this.object){if(0>r&&~~r===+r){c=n+" = "+d+".length - 1";f=n+" >= 0"}else{t.push(m=e.scope.temporary("len"));c=n+" = 0, "+m+" = "+d+".length";f=n+" < "+m}}}this["else"]&&(this.yet=e.scope.temporary("yet"));b=[l(this,"for (")];if(this.object){b.push(n," in ")}if(w=this.yet){b.push(w," = true, ")}if(this.object){b.push(d)}else{s===r||(c+=", "+s);b.push(c,"; ",f,"; "+(1==Math.abs(r)?(r<0?"--":"++")+n:n+(r<0?" -= "+r.toString().slice(1):" += "+r)))}this.own&&b.push(l(this,") if ("),e.scope.assign("own$","{}.hasOwnProperty"),".call(",p,", ",n,")");b.push(l(this,") {"));if(this["let"]){this.body.traverseChildren(function(e){switch(e.value){case"index$$":e.value=n;break;case"item$$":e.value=p+"["+n+"]"}})}e.indent+=fe;if(this.index&&!this.object){b.push("\n"+e.indent,I(v(this.index),Z(n)).compile(e,se),";")}if(this.item&&!this.item.isEmpty()&&!this.from){b.push("\n"+e.indent,I(this.item,Z(p+"["+n+"]")).compile(e,se),";")}if(this.ref){e.ref=this.item.value}k=this.compileBody(e);if((this.item||this.index&&!this.object)&&"}"===k.toString().charAt(0)){b.push("\n"+this.tab)}return l.apply(null,[null].concat(me(b),[k]))};return i}(Y);n.StepSlice=G=function(e){var t=Re((Ce(i,e).displayName="StepSlice",i),e).prototype,n=i;i.prototype.makeReturn=function(t){this.makeReturnArg=t;return e.prototype.makeReturn.apply(this,arguments)};i.prototype.compileNode=function(t){var n,i,r,s,o;this.index=t.scope.temporary("x");n=this.target.unwrap().cache(t),i=n[0],r=n[1],s=n[2];this.guard=T("<",y(this.index),L(r).add(w(b("length"))));this.makeComprehension(L(r).add(w(y(this.index))),this);if(this.makeReturnArg!=null){this.makeReturn(this.makeReturnArg)}o=[];if(s){o.push(i.compile(t),";"+"\n"+t.indent)}o.push(e.prototype.compileNode.apply(this,arguments));return l.apply(null,[this].concat(me(o)))};function i(){i.superclass.apply(this,arguments)}return i}(z);n.Try=H=function(e){var t=Re((Ce(i,e).displayName="Try",i),e).prototype,n=i;function i(e,t,n,i){var r;this.attempt=e;this.thrown=t;this.recovery=n;this.ensure=i;if((r=this.recovery)!=null){r.lines.unshift(I(this.thrown||v("e"),v("e$")))}}i.prototype.children=["attempt","recovery","ensure"];i.prototype.show=function(){return this.thrown};i.prototype.isStatement=be;i.prototype.isCallable=function(){var e;return((e=this.recovery)!=null?e.isCallable():void 8)&&this.attempt.isCallable()};i.prototype.getJump=function(e){var t;return this.attempt.getJump(e)||((t=this.recovery)!=null?t.getJump(e):void 8)};i.prototype.isNextUnreachable=function(){var e,t;return((e=this.ensure)!=null?e.isNextUnreachable():void 8)||this.attempt.isNextUnreachable()&&((t=this.recovery)!=null?t.isNextUnreachable():true)};i.prototype.makeReturn=function(){var e;this.attempt=(e=this.attempt).makeReturn.apply(e,arguments);if(this.recovery!=null){this.recovery=(e=this.recovery).makeReturn.apply(e,arguments)}return this};i.prototype.compileNode=function(e){var t,n;e.indent+=fe;t=[l(this,"try "),this.compileBlock(e,this.attempt)];if(n=this.recovery||!this.ensure&&Z("")){t.push(l(n," catch (e$) "),this.compileBlock(e,n))}if(n=this.ensure){t.push(l(n," finally "),this.compileBlock(e,n))}return l.apply(null,[null].concat(me(t)))};return i}(p);n.Switch=J=function(e){var t=Re((Ce(i,e).displayName="Switch",i),e).prototype,n=i;function i(e,t,n,i){var r,s;this.type=e;this.topic=t;this.cases=n;this["default"]=i;if(e==="match"){if(t){this.topic=R(t)}}else{if(t){if(t.length>1){throw"can't have more than one topic in switch statement"}this.topic=this.topic[0]}}if(this.cases.length&&(r=(s=this.cases)[s.length-1]).tests.length===1&&r.tests[0]instanceof v&&r.tests[0].value==="_"){this.cases.pop();this["default"]=r.body}}i.prototype.children=["topic","cases","default"];i.prototype.aSource="topic";i.prototype.aTargets=["cases","default"];i.prototype.show=function(){return this.type};i.prototype.isStatement=be;i.prototype.isCallable=function(){var e,t,n,i;for(e=0,n=(t=this.cases).length;e<n;++e){i=t[e];if(!i.isCallable()){return false}}if(this["default"]){return this["default"].isCallable()}else{return true}};i.prototype.getJump=function(e){var t,n,i,r,s;e||(e={});e["break"]=true;for(t=0,i=(n=this.cases).length;t<i;++t){r=n[t];if(s=r.body.getJump(e)){return s}}return(n=this["default"])!=null?n.getJump(e):void 8};i.prototype.isNextUnreachable=function(){var e,t,n,i;for(e=0,n=(t=this.cases).length;e<n;++e){i=t[e];if(!i.body.isNextUnreachable()){return false}}return(t=this["default"])!=null?t.isNextUnreachable():void 8};i.prototype.makeReturn=function(){var e,t,n,i;for(e=0,n=(t=this.cases).length;e<n;++e){i=t[e];i.makeReturn.apply(i,arguments)}if((t=this["default"])!=null){t.makeReturn.apply(t,arguments)}return this};i.prototype.compileNode=function(e){var t,n,i,r,s,o,a,u,c,f,p,d,m;t=this.tab;n=this.type==="match"?(this.topic&&(i=L(this.topic).cacheReference(e),r=i[0],s=i[1]),o=s?[r]:[],g(o.concat([y("false")])).compile(e,oe)):!!this.topic&&this.anaphorize().compile(e,oe);a=[l(this,"switch (",h(n),") {\n")];u=this["default"]||this.cases.length-1;e["break"]=true;for(c=0,f=(i=this.cases).length;c<f;++c){p=c;d=i[c];a.push(d.compileCase(e,t,p===u,this.type==="match"||!n,this.type,s))}if(this["default"]){e.indent=t+fe;if(m=this["default"].compile(e,se)){a.push(t+"default:\n",m,"\n")}}return l.apply(null,[null].concat(me(a),[t+"}"]))};return i}(p);n.Case=q=function(e){var t=Re((Ce(i,e).displayName="Case",i),e).prototype,n=i;function i(e,t){this.tests=e;this.body=t}i.prototype.children=["tests","body"];i.prototype.isCallable=function(){return this.body.isCallable()};i.prototype.makeReturn=function(){var e,t;if(((e=(t=this.body.lines)[t.length-1])!=null?e.value:void 8)!=="fallthrough"){(t=this.body).makeReturn.apply(t,arguments)}return this};i.prototype.compileCase=function(e,t,n,i,r,s){var o,a,u,h,f,p,d,g,m,v,b,k,A,E,C,S,N,_;o=[];for(a=0,h=(u=this.tests).length;a<h;++a){f=u[a];if(f instanceof R&&r!=="match"){for(p=0,g=(d=f.items).length;p<g;++p){m=d[p];o.push(m)}}else{o.push(f)}}o.length||o.push(y("void"));if(r==="match"){for(a=0,h=o.length;a<h;++a){v=a;f=o[a];b=L(s).add(w(y(v),".",true));o[v]=U(L(f).autoCompare(s?[b]:null))}}if(i){k=r==="match"?"&&":"||";m=o[0];v=0;while(A=o[++v]){m=T(k,m,A)}o=[(this.t=m,this.aSource="t",this.aTargets=["body"],this).anaphorize().invert()]}E=[];for(a=0,h=o.length;a<h;++a){m=o[a];E.push(t,l(m,"case ",m.compile(e,oe),":\n"))}C=this.body.lines;S=C[C.length-1];if(N=(S!=null?S.value:void 8)==="fallthrough"){C[C.length-1]=Z("// fallthrough")}e.indent=t+=fe;if(!c(_=this.body.compile(e,se))){E.push(_,"\n")}if(!(n||N||S!=null&&S.isNextUnreachable())){E.push(t+"break;\n")}return l.apply(null,[null].concat(me(E)))};return i}(p);n.If=K=function(e){var t=Re((Ce(i,e).displayName="If",i),e).prototype,n=i;function i(e,t,n){var i=this instanceof r?this:new r;i["if"]=e;i.then=t;i.un=n;return i}function r(){}r.prototype=t;i.prototype.children=["if","then","else"];i.prototype.aSource="if";i.prototype.aTargets=["then"];i.prototype.show=function(){return this.un&&"!"};i.prototype.terminator="";t.delegate(["isCallable","isArray","isString","isRegex","isNextUnreachable"],function(e){var t;return((t=this["else"])!=null?t[e]():void 8)&&this.then[e]()});i.prototype.getJump=function(e){var t;return this.then.getJump(e)||((t=this["else"])!=null?t.getJump(e):void 8)};i.prototype.makeReturn=function(){var e;this.then=(e=this.then).makeReturn.apply(e,arguments);if(this["else"]!=null){this["else"]=(e=this["else"]).makeReturn.apply(e,arguments)}return this};i.prototype.compileNode=function(e){if(this.un){this["if"]=this["if"].invert()}else{this.soak||this.anaphorize()}if(e.level){return this.compileExpression(e)}else{return this.compileStatement(e)}};i.prototype.compileStatement=function(e){var t,i;t=[l(this,"if (",this["if"].compile(e,oe),") ")];e.indent+=fe;t.push(this.compileBlock(e,g(this.then)));if(!(i=this["else"])){return l.apply(null,[null].concat(me(t)))}return l.apply(null,[null].concat(me(t),[l(i," else "),i instanceof n?i.compile((e.indent=this.tab,e),se):this.compileBlock(e,i)]))};i.prototype.compileExpression=function(e){var t,n,i,r;t=this.then,n=this["else"]||y("void");this["void"]&&(t["void"]=n["void"]=true);if(!this["else"]&&(this.cond||this["void"])){return U(T("&&",this["if"],U(t.unwrap()))).compile(e)}i=[l(this,this["if"].compile(e,ue))];r=n.isComplex()?"\n"+(e.indent+=fe):" ";i.push(r+"",l(t,"? "),t.compile(e,ae),r+"",l(n,": "),n.compile(e,ae));if(e.level<ue){return l.apply(null,[null].concat(me(i)))}else{return l(null,"(",i,")")}};i.unfoldSoak=function(e,t,n){var i;if(i=t[n].unfoldSoak(e)){t[n]=i.then;return i.cond=t.cond,i["void"]=t["void"],i.then=L(t),i}};return i}(p);n.Label=V=function(e){var t,n=Re((Ce(r,e).displayName="Label",r),e).prototype,i=r;function r(e,t){var n;this.label=e||"_";this.it=t;if(this.it.curried){this.carp("can't use label with a curried function (attempted label '"+this.label+"')")}if(n=(t instanceof P||t instanceof B)&&t||t.calling&&t.it.head){n.name||(n.name=this.label,n.labeled=true);return t}}t=U.prototype,n.children=t.children,n.isCallable=t.isCallable,n.isArray=t.isArray;r.prototype.show=function(){return this.label};r.prototype.isStatement=be;r.prototype.getJump=function(e){var t;e||(e={});((t=e.labels)!=null?t:e.labels=[]).push(this.label);return this.it.getJump((e["break"]=true,e))};r.prototype.makeReturn=function(){var e;this.it=(e=this.it).makeReturn.apply(e,arguments);return this};r.prototype.compileNode=function(e){var t,n,i;t=this.label,n=this.it;i=e.labels=me(e.labels||[]);if(Ne(t,i)){this.carp('duplicate label "'+t+'"')}i.push(t);n.isStatement()||(n=g(n));return l(null,l(this,t,": "),n instanceof g?(e.indent+=fe,this.compileBlock(e,n)):n.compile(e))};return r}(p);n.Cascade=X=function(e){var t=Re((Ce(i,e).displayName="Cascade",i),e).prototype,n=i;function i(e,t,n){var i=this instanceof r?this:new r;i.input=e;i.output=t;i.prog1=n;return i}function r(){}r.prototype=t;i.prototype.show=function(){return this.prog1};i.prototype.children=["input","output"];i.prototype.terminator="";t.delegate(["isCallable","isArray","isString","isRegex"],function(e){return this[this.prog1?"input":"output"][e]()});i.prototype.getJump=function(e){return this.output.getJump(e)};i.prototype.makeReturn=function(e){this.ret=e;return this};i.prototype.compileNode=function(e){var t,n,r,s,o,a,u,c;t=e.level;n=this.input,r=this.output,s=this.prog1,o=this.ref;if(s&&("ret"in this||t&&!this["void"])){r.add((a=y(".."),a.cascadee=true,a))}if("ret"in this){r=r.makeReturn(this.ret)}if(o){s||(r=I(v(o),r))}else{o=e.scope.temporary("x")}if(n instanceof i){n.ref=o}else{n&&(n=I(v(o),n))}e.level&&(e.level=oe);u=[n.compile(e)];c=g(r).compile((e.ref=new String(o),e));if(s==="cascade"&&!e.ref.erred){this.carp("unreferred cascadee")}if(!t){return l.apply(null,[null].concat(me(u),[n.terminator,"\n",c]))}u.push(", ",c);if(t>oe){return l.apply(null,[null,"("].concat(me(u),[")"]))}else{return l.apply(null,[null].concat(me(u)))}};return i}(p);n.JS=Z=function(e){var t=Re((Ce(i,e).displayName="JS",i),e).prototype,n=i;function i(e,t,n){var i=this instanceof r?this:new r;i.code=e;i.literal=t;i.comment=n;return i}function r(){}r.prototype=t;i.prototype.show=function(){if(this.comment){return this.code}else{return"`"+this.code+"`"}};i.prototype.terminator="";t.isAssignable=t.isCallable=function(){return!this.comment};i.prototype.compile=function(e){return l(this,h(this.literal?Ee(this.code,e.indent):this.code))};return i}(p);n.Require=Q=function(e){var t=Re((Ce(i,e).displayName="Require",i),e).prototype,n=i;function i(e){var t=this instanceof r?this:new r;t.body=e;return t}function r(){}r.prototype=t;i.prototype.children=["body"];i.prototype.compile=function(e){var t,n,i,r,a,u,c,h=this;t=function(e,t){switch(false){case!(e instanceof b):return e.name;case!(e instanceof v):return e.value;case!(e instanceof y):return e.value;default:if(t){return h.carp("invalid require! argument")}else{return e}}};n=function(n){var i,r,a,u,c,h;i=function(){var e;switch(false){case!(n instanceof S):return[n.val,(e=n.key)!=null?e:n.val];default:return[n,n]}}(),r=i[0],a=i[1];u=t(r);c=ye.call(u).slice(8,-1)==="String"?ne(r,v(s(u))):r;a=o(t(a,true));h=L(ne(this,v("require"))).add(A([y("'"+a+"'")]));return l(n,I(c,h).compile(e))};if(this.body.items!=null){i=[];for(r=0,u=(a=this.body.items).length;r<u;++r){c=a[r];i.push(n(c),";\n"+e.indent)}i.pop();return l.apply(null,[null].concat(me(i)))}else{return l(null,n(this.body))}};return i}(p);n.Util=ee=function(e){var t=Re((Ce(i,e).displayName="Util",i),e).prototype,n=i;function i(e){var t=this instanceof r?this:new r;t.verb=e;return t}function r(){}r.prototype=t;i.prototype.show=j.prototype.show;i.prototype.isCallable=be;i.prototype.compile=function(){return l(this,Ae(this.verb))};i.Extends=function(){return A.make(i("extend"),[arguments[0],arguments[1]])};return i}(p);n.Vars=te=function(e){var t=Re((Ce(i,e).displayName="Vars",i),e).prototype,n=i;function i(e){var t=this instanceof r?this:new r;t.vars=e;return t}function r(){}r.prototype=t;i.prototype.children=["vars"];i.prototype.makeReturn=ke;i.prototype.compile=function(e,t){var n,i,r,s,o;for(n=0,r=(i=this.vars).length;n<r;++n){s=i[n],o=s.value;if(!(s instanceof v)){s.carp("invalid variable declaration")}if(e.scope.check(o)){s.carp('redeclaration of "'+o+'"')}e.scope.declare(o,s)}return l(this,y("void").compile(e,t))};return i}(p);n.L=function(e,t,n){if(n&&typeof n==="object"){n.first_line=e.first_line+1;n.first_column=e.first_column;n.last_line=t.last_line+1;n.last_column=t.last_column;n.line=e.first_line+1;n.column=e.first_column}return n};n.CopyL=ne=function(e,t){if(t&&typeof t==="object"){t.first_line=e.first_line;t.first_column=e.first_column;t.last_line=e.last_line;t.last_column=e.last_column;t.line=e.line;t.column=e.column}return t};n.Box=function(e){if(typeof e==="object"){return e}else{return new e.constructor(e)}};n.Decl=function(e,t,n){if(!t[0]){throw SyntaxError("empty "+e+" on line "+n)}return ie[e](t)};ie={"export":function(e){var t,n,i,r,s;t=-1;n=ee("out");while(i=e[++t]){if(i instanceof g){e.splice.apply(e,[t--,1].concat(me(i.lines)));continue}if(r=i instanceof P&&i.name){e.splice(t++,0,I(L(n,[w(b(r))]),v(r)));continue}e[t]=(r=i.varName()||i instanceof I&&i.left.varName()||i instanceof B&&((s=i.title)!=null?s.varName():void 8))?I(L(n,[w(b(r))]),i):x(n,i)}return g(e)},"import":function(e,t){var n,i,r,s;for(n=0,i=e.length;n<i;++n){r=n;s=e[n];e[r]=x(y("this"),s,t)}return g(e)},importAll:function(e){return this["import"](e,true)},"const":function(e){var t,n,i;for(t=0,n=e.length;t<n;++t){i=e[t];i.op==="="||i.carp("invalid constant variable declaration");i["const"]=true}return g(e)},"var":te};function ve(e,t){this.parent=e;this.shared=t;this.variables={}}r=ve.prototype;r.READ_ONLY={"const":"constant","function":"function",undefined:"undeclared"};r.add=function(e,t,n){var i,r;if(n&&(i=this.variables[e+"."])){if(r=this.READ_ONLY[i]||this.READ_ONLY[t]){n.carp("redeclaration of "+r+' "'+e+'"')}else if(i===t&&t==="arg"){n.carp('duplicate parameter "'+e+'"')}else if(i==="upvar"){n.carp('accidental shadow of "'+e+'"')}if(i==="arg"||i==="function"){return e}}this.variables[e+"."]=t;return e};r.get=function(e){return this.variables[e+"."]};r.declare=function(e,t,n){var i,r;if(i=this.shared){if(this.check(e)){return}r=i}else{r=this}return r.add(e,n&&e!=="that"?"const":"var",t)};r.assign=function(e,t){return this.add(e,{value:t})};r.temporary=function(e){var t;e||(e="ref");while((t=this.variables[e+"$."])!=="reuse"&&t!==void 8){e=e.length<2&&e<"z"?String.fromCharCode(e.charCodeAt()+1):e.replace(/\d*$/,n)}return this.add(e+"$","var");function n(e){return++e}};r.free=function(e){return this.add(e,"reuse")};r.check=function(e,t){var n,i;if((n=this.variables[e+"."])||!t){return n}return(i=this.parent)!=null?i.check(e,t):void 8};r.checkReadOnly=function(e){var t,n,i;if(t=this.READ_ONLY[this.check(e,true)]){return t}(n=this.variables)[i=e+"."]||(n[i]="upvar");return""};r.emit=function(e,t){var n,i,r,s,o,u,c,h,p;n=[];i=[];r=[];for(s in o=this.variables){u=o[s];s=s.slice(0,-1);if(u==="var"||u==="const"||u==="reuse"){n.push(s,", ")}else if(c=u.value){if(~(h=Ee(c,t)).toString().lastIndexOf("function(",0)){if(h instanceof a){f(h,8)}else{h=h.slice(8)}r.push("function ",s,h,"\n"+t)}else{i.push(s," = ",h,", ")}}}p=n.concat(i);p.pop();r.pop();if(p.length>0){e=l.apply(null,[this,t+"var "].concat(me(p),[";\n",e]))}if(r.length>0){return l.apply(null,[this,e,"\n"+t].concat(me(r)))}else{return l(this,e)}};function be(){return true}function we(){return false}function ke(){return this}function Le(){}re={clone:"function(it){\n  function fun(){} fun.prototype = it;\n  return new fun;\n}",extend:"function(sub, sup){\n  function fun(){} fun.prototype = (sub.superclass = sup).prototype;\n  (sub.prototype = new fun).constructor = sub;\n  if (typeof sup.extended == 'function') sup.extended(sub);\n  return sub;\n}",bind:"function(obj, key, target){\n  return function(){ return (target || obj)[key].apply(obj, arguments) };\n}","import":"function(obj, src){\n  var own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key)) obj[key] = src[key];\n  return obj;\n}",importAll:"function(obj, src){\n  for (var key in src) obj[key] = src[key];\n  return obj;\n}",copyWithout:"function(src, ex){\n  var obj = {}, own = {}.hasOwnProperty;\n  for (var key in src) if (own.call(src, key) && !own.call(ex, key)) obj[key] = src[key];\n  return obj;\n}",repeatString:"function(str, n){\n  for (var r = ''; n > 0; (n >>= 1) && (str += str)) if (n & 1) r += str;\n  return r;\n}",repeatArray:"function(arr, n){\n  for (var r = []; n > 0; (n >>= 1) && (arr = arr.concat(arr)))\n    if (n & 1) r.push.apply(r, arr);\n  return r;\n}","in":"function(x, xs){\n  var i = -1, l = xs.length >>> 0;\n  while (++i < l) if (x === xs[i]) return true;\n  return false;\n}",out:"typeof exports != 'undefined' && exports || this",curry:"function(f, bound){\n  var context,\n  _curry = function(args) {\n    return f.length > 1 ? function(){\n      var params = args ? args.concat() : [];\n      context = bound ? context || this : this;\n      return params.push.apply(params, arguments) <\n          f.length && arguments.length ?\n        _curry.call(context, params) : f.apply(context, params);\n    } : f;\n  };\n  return _curry();\n}",flip:"function(f){\n  return curry$(function (x, y) { return f(y, x); });\n}",partialize:"function(f, args, where){\n  var context = this;\n  return function(){\n    var params = slice$.call(arguments), i,\n        len = params.length, wlen = where.length,\n        ta = args ? args.concat() : [], tw = where ? where.concat() : [];\n    for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }\n    return len < wlen && len ?\n      partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);\n  };\n}",not:"function(x){ return !x; }",compose:"function() {\n  var functions = arguments;\n  return function() {\n    var i, result;\n    result = functions[0].apply(this, arguments);\n    for (i = 1; i < functions.length; ++i) {\n      result = functions[i](result);\n    }\n    return result;\n  };\n}",deepEq:"function(x, y, type){\n  var toString = {}.toString, hasOwnProperty = {}.hasOwnProperty,\n      has = function (obj, key) { return hasOwnProperty.call(obj, key); };\n  var first = true;\n  return eq(x, y, []);\n  function eq(a, b, stack) {\n    var className, length, size, result, alength, blength, r, key, ref, sizeB;\n    if (a == null || b == null) { return a === b; }\n    if (a.__placeholder__ || b.__placeholder__) { return true; }\n    if (a === b) { return a !== 0 || 1 / a == 1 / b; }\n    className = toString.call(a);\n    if (toString.call(b) != className) { return false; }\n    switch (className) {\n      case '[object String]': return a == String(b);\n      case '[object Number]':\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        return +a == +b;\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') { return false; }\n    length = stack.length;\n    while (length--) { if (stack[length] == a) { return true; } }\n    stack.push(a);\n    size = 0;\n    result = true;\n    if (className == '[object Array]') {\n      alength = a.length;\n      blength = b.length;\n      if (first) {\n        switch (type) {\n        case '===': result = alength === blength; break;\n        case '<==': result = alength <= blength; break;\n        case '<<=': result = alength < blength; break;\n        }\n        size = alength;\n        first = false;\n      } else {\n        result = alength === blength;\n        size = alength;\n      }\n      if (result) {\n        while (size--) {\n          if (!(result = size in a == size in b && eq(a[size], b[size], stack))){ break; }\n        }\n      }\n    } else {\n      if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) {\n        return false;\n      }\n      for (key in a) {\n        if (has(a, key)) {\n          size++;\n          if (!(result = has(b, key) && eq(a[key], b[key], stack))) { break; }\n        }\n      }\n      if (result) {\n        sizeB = 0;\n        for (key in b) {\n          if (has(b, key)) { ++sizeB; }\n        }\n        if (first) {\n          if (type === '<<=') {\n            result = size < sizeB;\n          } else if (type === '<==') {\n            result = size <= sizeB\n          } else {\n            result = size === sizeB;\n          }\n        } else {\n          first = false;\n          result = size === sizeB;\n        }\n      }\n    }\n    stack.pop();\n    return result;\n  }\n}",arrayFrom:"Array.from || function(x){return slice$.call(x);}",split:"''.split",replace:"''.replace",toString:"{}.toString",join:"[].join",slice:"[].slice",splice:"[].splice"};se=0;oe=1;ae=2;ue=3;le=4;ce=5;(function(){this["&&"]=this["||"]=this["xor"]=.2;this[".&."]=this[".^."]=this[".|."]=.3;this["=="]=this["!="]=this["~="]=this["!~="]=this["==="]=this["!=="]=.4;this["<"]=this[">"]=this["<="]=this[">="]=this.of=this["instanceof"]=.5;this["<<="]=this[">>="]=this["<=="]=this[">=="]=this["++"]=.5;this[".<<."]=this[".>>."]=this[".>>>."]=.6;this["+"]=this["-"]=.7;this["*"]=this["/"]=this["%"]=.8}).call(he={unary:.9});fe="  ";pe=/^(?!\d)[\w$\xAA-\uFFDC]+$/;de=/^\d+$/;function Ae(e){return ve.root.assign(e+"$",re[e])}function Ee(e,t){return e.replace(/\n/g,"\n"+t)}function Ce(e,t){var n={}.hasOwnProperty;for(var i in t)if(n.call(t,i))e[i]=t[i];return e}function Se(e){function t(){}t.prototype=e;return new t}function Re(e,t){function n(){}n.prototype=(e.superclass=t).prototype;(e.prototype=new n).constructor=e;if(typeof t.extended=="function")t.extended(e);return e}function Ne(e,t){var n=-1,i=t.length>>>0;while(++n<i)if(e===t[n])return true;return false}function _e(e,t){for(var n=[];t>0;(t>>=1)&&(e=e.concat(e)))if(t&1)n.push.apply(n,e);return n}function Te(e,t){for(var n="";t>0;(t>>=1)&&(e+=e))if(t&1)n+=e;return n}function Ie(e,t){for(var n in t)e[n]=t[n];return e}},{"./util":6,"prelude-ls":19,"source-map":31}],2:[function(e,t,n){(function(t){
  // Generated by blackpard 1.6.1
  var i,r,s,o,a,u,l={}.toString;i=e("./lexer");r=e("./parser").parser;s=e("./ast");o=e("source-map").SourceNode;a=e("path");r.yy=s;r.lexer={lex:function(){var e,t,n,i,r,s;e=this.tokens[++this.pos]||[""],t=e[0],this.yytext=e[1],n=e[2],i=e[3];e=this.tokens[this.pos+1]||[""],r=e[2],s=e[3];this.yylineno=n;this.yylloc={first_line:n,first_column:i,last_line:r,last_column:s};return t},setInput:function(e){this.pos=-1;return this.tokens=e},upcomingInput:function(){return""}};u=t.alloc&&t.from||function(e){return new t(e)};n.VERSION="1.6.1";n.compile=function(e,t){var s,o,l,c,h,f,p,d,g;t==null&&(t={});t.warn==null&&(t.warn=true);t.header==null&&(t.header=true);if(t.header===true){t.header="// Generated by blackpard "+n.VERSION+"\n"}try{if(t.json){s=Function(n.compile(e,{bare:true,run:true,print:true}))();return JSON.stringify(s,null,2)+"\n"}else{o=r.parse(i.lex(e));if(t.run&&t.print){o.makeReturn()}l=o.compileRoot(t);if(t.map&&t.map!=="none"){c=t.filename,h=t.outputFilename;if(!c){c="unnamed-"+Math.floor(Math.random()*4294967296).toString(16)+".ls"}l.setFile(a.basename(c));s=l.toStringWithSourceMap();if(t.map==="embedded"){s.map.setSourceContent(c,e)}if((f=t.map)==="linked"||f==="debug"){p=a.basename(h)+".map";s.code+="\n//# sourceMappingURL="+p+"\n"}else{s.code+="\n//# sourceMappingURL=data:application/json;base64,"+u(s.map.toString()).toString("base64")+"\n"}return s}else{return l.toString()}}}catch(m){d=m;if(g=t.filename){d.message+="\nat "+g}throw d}};n.ast=function(e){return r.parse(typeof e==="string"?i.lex(e):e)};n.tokens=i.lex;n.lex=function(e){return i.lex(e,{raw:true})};n.run=function(e,t){var i,r;i=n.compile(e,(r={},c(r,t),r.bare=true,r));return Function(l.call(i).slice(8,-1)==="String"?i:i.code)()};n.tokens.rewrite=i.rewrite;h(n.ast,r.yy);if(e.extensions){e("./node")(n)}else{n.require=e}function c(e,t){var n={}.hasOwnProperty;for(var i in t)if(n.call(t,i))e[i]=t[i];return e}function h(e,t){for(var n in t)e[n]=t[n];return e}}).call(this,e("buffer").Buffer)},{"./ast":1,"./lexer":3,"./node":4,"./parser":5,buffer:9,path:13,"source-map":31}],3:[function(e,t,n){
  // Generated by blackpard 1.6.1
  var i,r,s,o,a,u,l,c,h,f,p,d,g,m,y,v,b,w,k,L,A,E,C,S,R,N,_,T,I,x,O,M,P,B,$,U,D=[].slice,j=Array.from||function(e){return D.call(e)};n.lex=function(e,t){return ne(n).tokenize(e||"",t||{})};n.rewrite=function(e){var t;e||(e=this.tokens);q(e);V(e);K(e);X(e);Q(e);Z(e);if(((t=e[0])!=null?t[0]:void 8)==="NEWLINE"){e.shift()}return e};n.tokenize=function(e,t){var n,i,r,s,o;this.inter||(e=e.replace(/[\r\u2028\u2029\uFEFF]/g,""));e="\n"+e;this.tokens=[this.last=["NEWLINE","\n",0,0]];this.line=~-t.line;this.column=t.column||0;this.dents=[];this.closes=[];this.parens=[];this.flags=[];n=0;i=n;this.charsCounted=0;this.isAtPrefix=true;while(r=e.charAt(n)){s=n-i;i=n;if(this.charsCounted>s){throw new Error("Location information out-of-sync in lexer")}this.column+=s-this.charsCounted;this.charsCounted=0;switch(r){case" ":n+=this.doSpace(e,n);break;case"\n":n+=this.doLine(e,n);break;case"\\":n+=this.doBackslash(e,n);break;case"'":case'"':n+=this.doString(e,n,r);break;case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":n+=this.doNumber(e,n);break;case"/":switch(e.charAt(n+1)){case"*":n+=this.doComment(e,n);break;case"/":n+=this.doHeregex(e,n);break;default:n+=this.doRegex(e,n)||this.doLiteral(e,n)}break;case"`":if("`"===e.charAt(n+1)){n+=this.doJS(e,n)}else{n+=this.doLiteral(e,n)}break;default:n+=this.doID(e,n)||this.doLiteral(e,n)||this.doSpace(e,n)}}this.dedent(this.dent);if(o=this.closes.pop()){this.carp("missing `"+o+"`")}if(this.inter){this.rest==null&&this.carp("unterminated interpolation")}else{this.last.spaced=true;this.newline()}t.raw||this.rewrite();return this.tokens};n.dent=0;n.identifiers={};n.reset=function(){this.dent=0;this.identifiers={}};n.hasOwn=Object.prototype.hasOwnProperty;n.checkConsistency=function(e,t){if(this.hasOwn.call(this.identifiers,e)&&this.identifiers[e]!==t){throw new ReferenceError("Inconsistent use of "+e+" as "+t+" on line "+-~this.line)}else{return this.identifiers[e]=t}};n.doID=function(e,t){var n,i,r,s,o,a,u,c,h;i=(n=(m.lastIndex=t,m).exec(e))[0];if(!i){return 0}r=l(n[1]);if(/-/.test(n[1])){this.checkConsistency(r,n[1])}if(_.test(r)){try{Function("var "+r)}catch(g){s=g;this.carp("invalid identifier '"+r+"'")}}o=this.last;if(n[2]||o[0]==="DOT"||this.adi()){this.token("ID",ie(r,d)?(a=Object(r),a.reserved=true,a):r);if(n[2]){this.token(":",":")}return i.length}switch(r){case"true":case"false":case"on":case"off":case"yes":case"no":case"null":case"void":case"arguments":case"debugger":u="LITERAL";break;case"new":case"do":case"typeof":case"delete":u="UNARY";break;case"yield":case"await":u="YIELD";break;case"return":case"throw":u="HURL";break;case"break":case"continue":u="JUMP";break;case"this":case"eval":case"super":return this.token("LITERAL",r,true).length;case"for":r=[];this.fset("for",true);this.fset("to",false);this.fset("by",true);break;case"then":this.fset("for",false);this.fset("to",false);break;case"catch":case"function":r="";break;case"in":case"of":if(this.fget("for")){this.fset("for",false);if(r==="in"){this.fset("by",true);r="";if(o[0]==="ID"&&((a=(c=this.tokens)[c.length-2][0])===","||a==="]"||a==="}")){r=this.tokens.pop()[1];if((a=this.tokens)[a.length-1][0]===","){this.tokens.pop()}}}break}
  // fallthrough
  case"instanceof":if(o[1]==="!"){r=this.tokens.pop()[1]+r}u=(a=this.tokens)[a.length-1][0]==="("?"BIOPR":"RELATION";break;case"not":if(o.alias&&o[1]==="==="){return o[1]="!==",3}u="UNARY";r="!";break;case"and":case"or":case"xor":case"is":case"isnt":this.unline();u=r==="is"||r==="isnt"?"COMPARE":"LOGIC";if(o[0]==="("){u="BIOP"}this.token(u,function(){switch(r){case"is":return"===";case"isnt":return"!==";case"or":return"||";case"and":return"&&";case"xor":return"xor"}}());this.last.alias=true;return r.length;case"unless":u="IF";break;case"until":u="WHILE";break;case"import":if(o[0]==="("){r="<<<";u="BIOP"}else{if(W(this.tokens)){r="<<<"}else{u="DECL"}}break;case"export":case"const":case"var":u="DECL";break;case"with":u=function(){switch(false){case!W(this.tokens):return"CLONEPORT";case o[0]!=="(":return"BIOP";default:return"WITH"}}.call(this);break;case"when":u="CASE";
  // fallthrough
  case"case":if(this.doCase()){return i.length}break;case"match":u="SWITCH";break;case"loop":this.token("WHILE",r);this.token("LITERAL","true");return i.length;case"let":case"own":if(o[0]==="FOR"&&!ie(r,o[1])){o[1].push(r);return 3}
  // fallthrough
  default:if(ie(r,f)){break}if(ie(r,p)){this.carp("reserved word '"+r+"'")}if(!o[1]&&((a=o[0])==="FUNCTION"||a==="GENERATOR"||a==="LABEL")){o[1]=r;o.spaced=false;return i.length}u="ID";switch(r){case"otherwise":if((a=o[0])==="CASE"||a==="|"){o[0]="DEFAULT";return r.length}break;case"all":if(h=o[1]==="<<<"&&"<"||o[1]==="import"&&"All"){o[1]+=h;return 3}break;case"from":if(o[1]==="yield"){o[1]+="from";return 4}this.forange()&&(u="FROM");break;case"to":case"til":this.forange()&&this.tokens.push(["FROM","",this.line,this.column],["STRNUM","0",this.line,this.column]);if(this.fget("from")){this.fset("from",false);this.fset("by",true);u="TO"}else if(!o.callable&&o[0]==="STRNUM"&&(a=this.tokens)[a.length-2][0]==="["){o[0]="RANGE";o.op=r;return r.length}else if(ie("]",this.closes)){this.token("TO",r);return r.length}break;case"by":if(o[0]==="STRNUM"&&(a=this.tokens)[a.length-2][0]==="RANGE"&&(a=this.tokens)[a.length-3][0]==="["){u="RANGE_BY"}else if(ie("]",this.closes)){u="BY"}else if(this.fget("by")&&o[0]!=="FOR"){u="BY";this.fset("by",false)}break;case"ever":if(o[0]==="FOR"){this.fset("for",false);o[0]="WHILE";u="LITERAL";r="true"}}}u||(u=n[1].toUpperCase());if((u==="COMPARE"||u==="LOGIC"||u==="RELATION")&&o[0]==="("){u=u==="RELATION"?"BIOPR":"BIOP"}if(u==="THEN"||u==="IF"||u==="WHILE"){this.fset("for",false);this.fset("by",false)}if(u==="RELATION"||u==="THEN"||u==="ELSE"||u==="CASE"||u==="DEFAULT"||u==="CATCH"||u==="FINALLY"||u==="IN"||u==="OF"||u==="FROM"||u==="TO"||u==="BY"||u==="EXTENDS"||u==="IMPLEMENTS"||u==="WHERE"){this.unline()}this.token(u,r);return i.length};n.doNumber=function(e,t){var n,i,r,s,o,a,u,l;A.lastIndex=t;if(!(n=(i=A.exec(e))[0])){return 0}r=this.last;if(i[5]&&(r[0]==="DOT"||this.adi())){this.token("STRNUM",i[4].replace(E,""));return i[4].length}if(s=i[1]){o=parseInt(a=i[2].replace(E,""),s);u=false;if(s>36||s<2){if(/[0-9]/.exec(a)){this.carp("invalid number base "+s+" (with number "+a+"),base must be from 2 to 36")}else{u=true}}if(isNaN(o)||o===parseInt(a.slice(0,-1),s)){this.strnum(i[1]);this.token("DOT",".~");this.token("ID",i[2]);return n.length}o+=""}else{o=(i[3]||n).replace(E,"");if(i[3]&&o.charAt()==="0"&&((l=o.charAt(1))!==""&&l!==".")){this.carp("deprecated octal literal "+i[4])}}if(!r.spaced&&r[0]==="+-"){r[0]="STRNUM";r[1]+=o;return n.length}this.strnum(o);return n.length};n.doString=function(e,t,n){var i,r;if(n===e.charAt(t+1)){return n===e.charAt(t+2)?this.doHeredoc(e,t,n):(this.strnum(n+n),2)}if(n==='"'){i=this.interpolate(e,t,n);this.addInterpolated(i,s);return i.size}r=(w.lastIndex=t,w).exec(e)[0]||this.carp("unterminated string");this.strnum(s(this.string(n,r.slice(1,-1))));return this.countLines(r).length};n.doHeredoc=function(e,t,n){var i,r,s,a,u,l,c,h,f;if(n==="'"){~(i=e.indexOf(n+n+n,t+3))||this.carp("unterminated heredoc");r=e.slice(t+3,i);s=r.replace(R,"");this.strnum(o(this.string(n,G(z(s,Y(s))))));return this.countLines(r).length+6}a=this.interpolate(e,t,n+n+n);u=Y(e.slice(t+3,t+a.size-3).replace(R,""));for(l=0,c=a.length;l<c;++l){h=l;f=a[l];if(f[0]==="S"){if(h+1===a.length){f[1]=f[1].replace(R,"")}f[1]=z(f[1],u);if(h===0){f[1]=G(f[1])}}}this.addInterpolated(a,o);return a.size};n.doComment=function(e,t){var n,i,r;n=~(i=e.indexOf("*/",t+2))?e.slice(t,i+2):e.slice(t)+"*/";if((r=this.last[0])==="NEWLINE"||r==="INDENT"||r==="THEN"){this.token("COMMENT",z(n,this.dent));this.token("NEWLINE","\n")}return this.countLines(n).length};n.doJS=function(e,t){var n,i;k.lastIndex=t;n=k.exec(e)[0]||this.carp("unterminated JS literal");this.token("LITERAL",(i=Object(z(n.slice(2,-2),this.dent)),i.js=true,i),true);return this.countLines(n).length};n.doRegex=function(e,t){var n,i,r,s,o;if(n=W(this.tokens)||this.last[0]==="CREMENT"){if(!this.last.spaced||((i=e.charAt(t+1))===" "||i==="=")){return 0}}i=(C.lastIndex=t,C).exec(e),r=i[0],s=i[1],o=i[2];if(r){this.regex(s,o)}else if(!n&&this.last[0]!=="("){this.carp("unterminated regex")}return r.length};n.doHeregex=function(e,t){var n,i,r,s,o,l,h,f,p,d,g,m;n=this.tokens,i=this.last;r=this.interpolate(e,t,"//");s=e.slice(t+r.size);o=this.validate(/^(?:[gimy]{1,4}|[?$]?)/.exec(s)[0]);if(r[1]){if(o==="$"){this.adi();this.token("(",'"')}else{n.push(["ID","RegExp",i[2],i[3]],["CALL(","",i[2],i[3]]);if(o==="?"){for(l=r.length-1;l>=0;--l){h=l;f=r[l];if(f[0]==="TOKENS"){p=r.splice(h,1)[0][1];break}}}}for(l=0,d=r.length;l<d;++l){h=l;f=r[l];if(f[0]==="TOKENS"){n.push.apply(n,f[1])}else{g=c(f[1]);if(m&&!g){continue}m=n.push((f[0]="STRNUM",f[1]=this.string("'",a(g)),f))}n.push(["+-","+",n[n.length-1][2],n[n.length-1][3]])}--n.length;if(p||o>="g"){this.token(",",",");if(p){n.push.apply(n,p)}else{this.token("STRNUM","'"+o+"'")}}this.token(o==="$"?")":")CALL","")}else{this.regex(u(c(r[0][1])),o)}return r.size+o.length};n.doBackslash=function(e,t){var n,i,r;L.lastIndex=t;n=L.exec(e),i=n[0],r=n[1];if(r){this.strnum(this.string("'",r))}else{this.countLines(i)}return i.length};n.doLine=function(e,t){var n,i,r,s,o,a,u,l,c;n=(b.lastIndex=t,b).exec(e),i=n[0],r=n[1];s=this.countLines(i).length;o=this.last;o.eol=true;o.spaced=true;if(t+s>=e.length){return s}if(a=r&&(this.emender||(this.emender=RegExp("[^"+r.charAt()+"]"))).exec(r)){this.carp("contaminated indent "+escape(a))}if(0>(u=r.length-this.dent)){this.dedent(-u);this.newline()}else{l=o[0],c=o[1];if(l==="ASSIGN"&&((n=c+"")!=="="&&n!==":="&&n!=="+=")||l==="CREMENT"&&c==="++"&&(n=this.tokens)[n.length-2].spaced||(l==="+-"||l==="PIPE"||l==="BACKPIPE"||l==="COMPOSE"||l==="DOT"||l==="LOGIC"||l==="MATH"||l==="COMPARE"||l==="RELATION"||l==="SHIFT"||l==="IN"||l==="OF"||l==="TO"||l==="BY"||l==="FROM"||l==="EXTENDS"||l==="IMPLEMENTS")){return s}if(u){this.indent(u)}else{this.newline()}}this.fset("for",false);this.fset("by",false);return s};n.doSpace=function(e,t){var n;v.lastIndex=t;if(n=v.exec(e)[0]){this.last.spaced=true}return n.length};n.doCase=function(){var e,t;this.fset("for",false);if((e=this.last[0])==="ASSIGN"||e==="->"||e===":"||this.last[0]==="INDENT"&&((e=(t=this.tokens)[t.length-2][0])==="ASSIGN"||e==="->"||e===":")){this.token("SWITCH","switch");return this.token("CASE","case")}};n.doLiteral=function(e,t){var n,i,r,s,o;if(!(n=(y.lastIndex=t,y).exec(e)[0])){return 0}switch(i=r=n){case"|":i="CASE";if(this.doCase()){return n.length}break;case"|>":i="PIPE";break;case"`":i="BACKTICK";break;case"<<":case">>":i="COMPOSE";break;case"<|":i="BACKPIPE";break;case"+":case"-":i="+-";break;case"&&":case"||":i="LOGIC";break;case".&.":case".|.":case".^.":i="BITWISE";break;case"^^":i="CLONE";break;case"**":case"^":i="POWER";break;case"?":if(this.last[0]==="("){this.token("PARAM(","(");this.token(")PARAM",")");this.token("->","->");this.token("ID","it")}else{if(this.last.spaced){i="LOGIC"}}break;case"/":case"%":case"%%":i="MATH";break;case"++":case"--":i="CREMENT";break;case"<<<":case"<<<<":i="IMPORT";break;case";":i="NEWLINE";this.fset("by",false);break;case"..":this.token("LITERAL","..",true);return 2;case".":if(this.last[1]==="?"){this.last[0]="?"}i="DOT";break;case",":switch(this.last[0]){case",":case"[":case"(":case"CALL(":this.token("LITERAL","void");break;case"FOR":case"OWN":this.token("ID","")}break;case"!=":case"~=":if(!(W(this.tokens)||((s=this.last[0])==="("||s==="CREMENT"))){this.tokens.push(r==="!="?["UNARY","!",this.line,this.column]:["UNARY","~",this.line,this.column],["ASSIGN","=",this.line,this.column]);return 2}
  // fallthrough
  case"!~=":case"==":r=function(){switch(r){case"~=":return"==";case"!~=":return"!=";case"==":return"===";case"!=":return"!=="}}();i="COMPARE";break;case"===":case"!==":r+="=";
  // fallthrough
  case"<":case">":case"<=":case">=":case"<==":case">==":case">>=":case"<<=":i="COMPARE";break;case".<<.":case".>>.":case".>>>.":case"<?":case">?":i="SHIFT";break;case"(":if(!((s=this.last[0])==="FUNCTION"||s==="GENERATOR"||s==="LET"||this.able(true)||this.last[1]===".@")){this.token("(","(");this.closes.push(")");this.parens.push(this.last);return 1}i="CALL(";this.closes.push(")CALL");break;case"[":case"{":this.adi();this.closes.push("]}".charAt(r==="{"));break;case"}":if(this.inter&&r!==(s=this.closes)[s.length-1]){this.rest=e.slice(t+1);return 9e9}
  // fallthrough
  case"]":case")":if(i===")"&&((s=this.last[0])==="+-"||s==="COMPARE"||s==="LOGIC"||s==="MATH"||s==="POWER"||s==="SHIFT"||s==="BITWISE"||s==="CONCAT"||s==="COMPOSE"||s==="RELATION"||s==="PIPE"||s==="BACKPIPE"||s==="IMPORT"||s==="CLONEPORT"||s==="ASSIGN")){(s=this.tokens)[s.length-1][0]=function(){switch(this.last[0]){case"RELATION":return"BIOPR";case"PIPE":this.parameters(false,-1);return"BIOPP";default:return"BIOP"}}.call(this)}if(")"===(i=r=this.pair(r))){this.lpar=this.parens.pop()}break;case"=":case":":if(r===":"){switch(this.last[0]){case"ID":case"STRNUM":case")":break;case"...":this.last[0]="STRNUM";break;default:i="LABEL";r=""}this.token(i,r);return n.length}
  // fallthrough
  case":=":case"+=":case"-=":case"*=":case"/=":case"%=":case"%%=":case"<?=":case">?=":case"**=":case"^=":case".&.=":case".|.=":case".^.=":case".<<.=":case".>>.=":case".>>>.=":case"++=":case"|>=":if(this.last[1]==="."||this.last[0]==="?"&&this.adi()){this.last[1]+=r;return r.length}if(this.last[0]==="LOGIC"){(r=Object(r)).logic=this.tokens.pop()[1]}else if((r==="+="||r==="-=")&&!W(this.tokens)&&((s=this.last[0])!=="+-"&&s!=="UNARY"&&s!=="LABEL")){this.token("UNARY",r.charAt());r="="}i="ASSIGN";break;case"::=":this.token("DOT",".");this.token("ID","prototype");this.token("IMPORT","<<");return n.length;case"*":if(this.last[0]==="FUNCTION"){this.last[0]="GENERATOR";return n.length}if(o=((s=this.last[0])==="NEWLINE"||s==="INDENT"||s==="THEN"||s==="=>")&&(N.lastIndex=t+1,N).exec(e)[0].length){this.tokens.push(["LITERAL","void",this.line,this.column],["ASSIGN","=",this.line,this.column]);this.indent(t+o-1-this.dent-e.lastIndexOf("\n",t-1));return o}i=W(this.tokens)||this.last[0]==="CREMENT"&&W(this.tokens,this.tokens.length-1)||this.last[0]==="("?"MATH":"STRNUM";break;case"@":this.adi();if(this.last[0]==="DOT"&&this.last[1]==="."&&(s=this.tokens)[s.length-2][0]==="ID"&&(s=this.tokens)[s.length-2][1]==="constructor"){this.tokens.pop();this.tokens.pop();this.token("LITERAL","this",true);this.adi();this.token("ID","constructor",true)}else{this.token("LITERAL","this",true)}return 1;case"@@":this.adi();this.token("ID","constructor",true);return 2;case"&":this.token("LITERAL","arguments");return 1;case"!":switch(false){default:if(!this.last.spaced){if(this.last[1]==="require"){this.last[0]="REQUIRE";this.last[1]="require!"}else if(W(this.tokens,null,true)){this.token("CALL(","!");this.token(")CALL",")")}else if(this.last[1]==="typeof"){this.last[1]="classof"}else if(this.last[1]==="delete"){this.last[1]="jsdelete"}else{break}return 1}}i="UNARY";break;case"|":i="BITWISE";break;case"~":if(this.dotcat(r)){return 1}i="UNARY";break;case"::":this.adi();r="prototype";i="ID";break;case"=>":this.unline();this.fset("for",false);i="THEN";break;default:if(/^!?(?:--?|~~?)>>?\*?$/.test(r)){this.parameters(i="->")}else if(/^\*?<(?:--?|~~?)!?$/.test(r)){this.parameters(i="<-")}else{switch(r.charAt(0)){case"(":this.token("CALL(","(");i=")CALL";r=")";break;case"<":if(r.length<4){this.carp("unterminated words")}this.token("WORDS",r.slice(2,-2),this.adi());return this.countLines(r).length}}}if((i==="+-"||i==="COMPARE"||i==="LOGIC"||i==="MATH"||i==="POWER"||i==="SHIFT"||i==="BITWISE"||i==="CONCAT"||i==="RELATION"||i==="PIPE"||i==="BACKPIPE"||i==="COMPOSE"||i==="IMPORT")&&this.last[0]==="("){i=i==="BACKPIPE"?"BIOPBP":"BIOP"}if(i===","||i==="CASE"||i==="PIPE"||i==="BACKPIPE"||i==="COMPOSE"||i==="DOT"||i==="LOGIC"||i==="COMPARE"||i==="MATH"||i==="POWER"||i==="IMPORT"||i==="SHIFT"||i==="BITWISE"){this.unline()}this.token(i,r);return n.length};n.token=function(e,t,n){this.tokens.push(this.last=[e,t,this.line,this.column]);if(n){this.last.callable=true}return t};n.indent=function(e){this.dent+=e;this.dents.push(this.token("INDENT",e));this.closes.push("DEDENT")};n.dedent=function(e){var t;this.dent-=e;while(e>0&&(t=this.dents.pop())){if(e<t&&!this.inter){this.carp("unmatched dedent ("+e+" for "+t+")")}this.pair("DEDENT");e-=typeof t==="number"?this.token("DEDENT",t):t}};n.newline=function(){var e;if(!(this.last[0]==="NEWLINE"&&this.last[1]==="\n")){this.tokens.push(this.last=(e=["NEWLINE","\n",this.line,this.column],e.spaced=true,e))}};n.unline=function(){var e;if(!this.tokens[1]){return}switch(this.last[0]){case"INDENT":(e=this.dents)[e.length-1]+="";
  // fallthrough
  case"NEWLINE":this.tokens.length--}};n.parameters=function(e,t){var n,i,r,s,o;if(this.last[0]===")"&&")"===this.last[1]){this.lpar[0]="PARAM(";this.last[0]=")PARAM";return}if(e==="->"){this.token("PARAM(","")}else{for(n=(i=this.tokens).length-1;n>=0;--n){r=n;s=i[n];if((o=s[0])==="NEWLINE"||o==="INDENT"||o==="THEN"||o==="=>"||o==="("){break}}this.tokens.splice(r+1,0,["PARAM(","",s[2],s[3]])}if(t){this.tokens.splice(this.tokens.length+t,0,[")PARAM","",s[2],s[3]])}else{this.token(")PARAM","")}};n.interpolate=function(e,t,i){var r,s,o,a,u,c,h,f,p,d,g,y,v,b,w,k,L,A;r=[];s=i.charAt(0);o=0;a=-1;e=e.slice(t+i.length);u=[this.line,this.column],c=u[0],h=u[1];this.countLines(i);while(f=e.charAt(++a)){switch(f){case s:if(i!==e.slice(a,a+i.length)){continue}r.push(["S",this.countLines(e.slice(0,a)),c,h]);this.countLines(i);return r.size=o+a+i.length*2,r;case"#":p=e.charAt(a+1);d=p==="@"&&p||(m.lastIndex=a+1,m).exec(e)[1];if(!(d||p==="{")){continue}break;case"\\":++a;
  // fallthrough
  default:continue}if(a||k&&!g){g=r.push(["S",this.countLines(e.slice(0,a)),c,h]);u=[this.line,this.column],c=u[0],h=u[1]}if(d){y=d.length;if(d==="@"){d="this"}if(d==="this"){v="LITERAL"}else{d=l(d);try{Function("'use strict'; var "+d)}catch(E){b=E;this.carp("invalid variable interpolation '"+d+"'")}v="ID"}e=e.slice(w=a+1+y);r.push(["TOKENS",k=[[v,d,this.line,this.column]]])}else{L=(u=ne(n),u.inter=true,u.emender=this.emender,u);k=L.tokenize(e.slice(a+2),{line:this.line,column:this.column+2,raw:true});w=e.length-L.rest.length;this.countLines(e.slice(a,w));e=L.rest;while(((u=k[0])!=null?u[0]:void 8)==="NEWLINE"){k.shift()}if(k.length){k.unshift(["(","(",c,h]);k.push([")",")",this.line,this.column-1]);r.push(["TOKENS",k])}A=[this.line,this.column],c=A[0],h=A[1]}o+=w;a=-1}this.carp("missing `"+i+"`")};n.addInterpolated=function(e,t){var n,i,r,s,o,a,u,l,c,h,f;if(!e[1]){return this.strnum(t(this.string('"',e[0][1])))}n=this.tokens,i=this.last;r=!i.spaced&&i[1]==="%"?(--n.length,this.last=i=n[n.length-1],["[","]",[",",","]]):["(",")",["+-","+"]],s=r[0],o=r[1],a=r[2];u=this.adi();n.push([s,'"',i[2],i[3]]);for(l=0,c=e.length;l<c;++l){h=l;f=e[l];if(f[0]==="TOKENS"){n.push.apply(n,f[1])}else{if(h>1&&!f[1]){continue}n.push(["STRNUM",t(this.string('"',f[1])),f[2],f[3]])}n.push(a.concat(n[n.length-1][2],n[n.length-1][3]))}--n.length;this.token(o,"",u)};n.strnum=function(e){this.token("STRNUM",e,this.adi()||this.last[0]==="DOT")};n.regex=function(e,t){var n;try{RegExp(e)}catch(i){n=i;this.carp(n.message)}if(t==="$"){return this.strnum(this.string("'",a(e)))}return this.token("LITERAL","/"+(e||"(?:)")+"/"+this.validate(t))};n.adi=function(){if(this.last.spaced){return}if(!W(this.tokens)){return}return this.token("DOT",".")};n.dotcat=function(e){if(this.last[1]==="."||this.adi()){return this.last[1]+=e}};n.pair=function(e){var t,n;if(!(e===(t=(n=this.closes)[n.length-1])||")CALL"===t&&e===")")){if("DEDENT"!==t){this.carp("unmatched `"+e+"`")}this.dedent((n=this.dents)[n.length-1]);return this.pair(e)}this.unline();this.fclear();return this.closes.pop()};n.able=function(e){return!this.last.spaced&&W(this.tokens,null,e)};n.countLines=function(e){var t;if(!this.isAtPrefix){this.column+=e.length}while(t=1+e.indexOf("\n",t)){if(!this.isAtPrefix){this.column=0}this.column+=e.length-t;++this.line;this.isAtPrefix=false}this.charsCounted+=e.length;return e};n.forange=function(){var e,t,n;if(((e=(t=this.tokens)[t.length-2-((n=this.last[0])==="NEWLINE"||n==="INDENT")])!=null?e[0]:void 8)==="FOR"||this.last[0]==="FOR"){this.fset("for",false);this.fset("from",true);return true}else{return false}};n.validate=function(e){var t;if(t=e&&/(.).*\1/.exec(e)){this.carp("duplicate regex flag `"+t[1]+"`")}return e};n.fget=function(e){var t;return(t=this.flags[this.closes.length])!=null?t[e]:void 8};n.fset=function(e,t){var n,i;((n=this.flags)[i=this.closes.length]||(n[i]={}))[e]=t};n.fclear=function(){this.flags.splice(this.closes.length)};n.carp=function(e){F(e,this.line)};n.string=function(e,t){return i(e,t,this.line)};function F(e,t){throw SyntaxError(e+" on line "+-~t)}function W(e,t,n){var i,r;t==null&&(t=e.length);r=(i=e[t-1])[0];return r==="ID"||r==="]"||r==="?"||(n?i.callable||(r===")"||r===")CALL"||r==="BIOPBP")&&i[1]:r==="}"||r===")"||r===")CALL"||r==="STRNUM"||r==="LITERAL"||r==="WORDS")}i=function(e){return function(t,n,i){n=n.replace(e,function(e,n,r,s){if(e===t||e==="\\"){return"\\"+e}if(n){return"\\x"+(256+parseInt(n,8)).toString(16).slice(1)}if(r){F("malformed character escape sequence",i)}if(!s||t===s){return e}else{return s}});return t+n+t}}.call(this,/['"]|\\(?:([0-3]?[0-7]{2}|[1-7]|0(?=[89]))|x[\dA-Fa-f]{2}|u[\dA-Fa-f]{4}|([xu])|[\\0bfnrtv]|[^\n\S]|([\w\W]))?/g);function Y(e){var t,n,i;t=0/0;while(n=r.exec(e)){t<=(i=n[0].length-1)||(t=i)}return t}r=/\n(?!$)[^\n\S]*/gm;function z(e,t){if(t){return e.replace(z[t]||(z[t]=RegExp("\\n[^\\n\\S]{1,"+t+"}","g")),"\n")}else{return e}}s=function(e){return e.replace(/\n[^\n\S]*/g,"")};o=function(e){return e.replace(/\n/g,"\\n")};a=function(e){return e.replace(/\\/g,"\\\\")};u=function(e){return e.replace(/(\\.)|\//g,function(){return arguments[1]||"\\/"})};l=function(e){return e.replace(/-[a-z]/gi,function(e){return e.charAt(1).toUpperCase()})};c=function(e){return e.replace(/\s+(?:#.*)?|(\\[\s\S])/g,function(e,t){t||(t="");if("\n"===t.charAt(1)){return"\\n"}else{return t}})};function G(e){return e.slice(1+e.lastIndexOf("\n",0))}function H(e,t){if(!isNaN(e)){return[+e]}e=e.length>8?"ng":Function("return "+e)();e.length===1||F("bad string in range",t);return[e.charCodeAt(),true]}function J(e){return'"\\u'+("000"+e.toString(16)).slice(-4)+'"'}h=typeof JSON=="undefined"||JSON===null?J:function(e){switch(e){case 8232:case 8233:return J(e);default:return JSON.stringify(String.fromCharCode(e))}};function q(e){var t,n,i,r,s,o,a,u,l,c,h,f,p;t=["NEWLINE","\n",0];n=0;while(i=e[++n]){r=i[0],s=i[1],o=i[2],a=i[3];switch(r){case"ASSIGN":if(ie(t[1],g)&&e[n-2][0]!=="DOT"){F("cannot assign to reserved word '"+t[1]+"'",o)}break;case"DOT":switch(false){case!(t[0]==="]"&&e[n-2][0]==="["&&e[n-3][0]==="DOT"):e.splice(n-2,3);e[n-3][1]="[]";n-=3;break;case!(t[0]==="}"&&e[n-2][0]==="{"&&e[n-3][0]==="DOT"):e.splice(n-2,3);e[n-3][1]="{}";n-=3;break;case!(s==="."&&i.spaced&&t.spaced):e[n]=["COMPOSE","<<",o,a];break;default:u=e[n+1];if(t[0]==="("&&u[0]===")"){e[n][0]="BIOP"}else if(t[0]==="("){e.splice(n,0,["PARAM(","(",o,a],[")PARAM",")",o,a],["->","~>",o,a],["ID","it",o,a])}else if(u[0]===")"){e.splice(n+1,0,["[","[",o,a],["ID","it",o,a],["]","]",o,a]);l=1;e:for(c=n+1;c>=0;--c){h=c;switch(e[h][0]){case")":++l;break;case"(":if(--l===0){e.splice(h+1,0,["PARAM(","(",o,a],["ID","it",o,a],[")PARAM",")",o,a],["->","~>",o,a]);break e}}}}}break;case"CREMENT":if(!(s==="++"&&(u=e[n+1]))){break}f=["ID","LITERAL","STRNUM"];if(t.spaced&&i.spaced||!(t.spaced||i.spaced)&&ie(t[0],f)&&ie(u[0],f)){e[n][0]="CONCAT"}if(t[0]==="("&&u[0]===")"||t[0]==="("&&i.spaced||u[0]===")"&&t.spaced){e[n][0]="BIOP"}break;case"ID":if(s!=="async"){break}u=e[n+1];if((p=u[0])==="FUNCTION"||p==="GENERATOR"){i[0]="ASYNC"}}t=i;continue}}function K(e){var t,n,i;t=-1;while(n=e[++t]){i=n[0];if(i==="IF"||i==="CLASS"||i==="CATCH"){ee(e,t+1,r,s)}}function r(e){var t;return(t=e[0])==="NEWLINE"||t==="INDENT"}function s(t,r){var s,o;if(i==="IF"){if(t[0]!=="INDENT"||!t[1]&&!t.then||ie(e[r-1][0],U)){n[0]="POST_IF"}}else if(t[0]!=="INDENT"){e.splice(r,0,["INDENT",0,s=e[r-1][2],o=e[r-1][3]],["DEDENT",0,s,o])}}}function V(e){var t,n,i,r,s,o,a,u,l;t=0;while(n=e[++t]){i=n[0];if(i!=="->"&&i!=="THEN"&&i!=="ELSE"&&i!=="DEFAULT"&&i!=="TRY"&&i!=="FINALLY"&&i!=="DECL"){continue}switch(r=e[t+1][0]){case"IF":if(i==="ELSE"){continue}break;case"INDENT":case"THEN":if(i==="THEN"){e.splice(t--,1)}continue}s=["INDENT",0,n[2],n[3]];o=["DEDENT",0];if(i==="THEN"){(e[t]=s).then=true}else{e.splice(++t,0,s)}switch(false){case i!=="DECL":break;case r!=="DOT"&&r!=="?"&&r!==","&&r!=="PIPE"&&r!=="BACKPIPE":--t;
  // fallthrough
  case!((r==="ID"||r==="STRNUM"||r==="LITERAL")&&","===((a=e[t+2])!=null?a[0]:void 8)):h(0,t+=2);++t;continue;case!((r==="("||r==="["||r==="{")&&","===((u=e[l=1+te(e,t+1)])!=null?u[0]:void 8)):h(0,l);++t;continue}ee(e,t+1,c,h)}function c(t,n){var r,s;r=t[0];s=i;if(i===r||i==="THEN"&&r==="SWITCH"){i=""}switch(r){case"NEWLINE":return t[1]!==";";case"DOT":case"?":case",":case"PIPE":case"BACKPIPE":return e[n-1].eol;case"ELSE":return s==="THEN";case"CATCH":return s==="TRY";case"FINALLY":return s==="TRY"||s==="CATCH"||s==="THEN";case"CASE":case"DEFAULT":return s==="CASE"||s==="THEN"}}function h(t,n){var i;i=e[n-1];e.splice(i[0]===","?n-1:n,0,(o[2]=i[2],o[3]=i[3],o))}}function X(e){var t,n,i,r,s,o,a,u,l,c,h;t=0;n=[];while(i=e[++t]){if(i[1]==="do"&&e[t+1][0]==="INDENT"){r=te(e,t+1);if(e[r+1][0]==="NEWLINE"&&((s=e[r+2])!=null?s[0]:void 8)==="WHILE"){i[0]="DO";e[r+2].done=true;e.splice(r+1,1)}else{(i=e[1+t])[0]="(";(o=e[r])[0]=")";i.doblock=true;e.splice(t,1)}}a=i[0];u=e[t-1];a==="["&&n.push(u[0]==="DOT");if(u[0]==="]"){if(n.pop()){u.index=true}else{continue}}if(!((l=u[0])==="FUNCTION"||l==="GENERATOR"||l==="LET"||l==="WHERE"||u.spaced&&W(e,t,true))){continue}if(i.doblock){i[0]="CALL(";o[0]=")CALL";continue}if(!f(i)){continue}if(a==="CREMENT"){if(i.spaced||!ie((l=e[t+1])!=null?l[0]:void 8,B)){continue}}c=h=false;e.splice(t++,0,["CALL(","",i[2],i[3]]);ee(e,t,p,d)}function f(e){var t;t=e[0];return ie(t,$)||!e.spaced&&(t==="+-"||t==="CLONE")}function p(t,n){var i,r,s;i=t[0];if(i==="POST_IF"||i==="PIPE"||i==="BACKPIPE"){return true}if(!c){if(t.alias&&((r=t[1])==="&&"||r==="||"||r==="xor")||(i==="TO"||i==="BY"||i==="IMPLEMENTS")){return true}}s=e[n-1];switch(i){case"NEWLINE":return s[0]!==",";case"DOT":case"?":return!c&&(s.spaced||s[0]==="DEDENT");case"SWITCH":h=true;
  // fallthrough
  case"IF":case"CLASS":case"FUNCTION":case"GENERATOR":case"LET":case"WITH":case"CATCH":c=true;break;case"CASE":if(h){c=true}else{return true}break;case"INDENT":if(c){return c=false}return!ie(s[0],U);case"WHILE":if(t.done){return false}
  // fallthrough
  case"FOR":c=true;return W(e,n)||s[0]==="CREMENT"||s[0]==="..."&&s.spaced}return false}function d(t,n){e.splice(n,0,[")CALL","",e[n-1][2],e[n-1][3]])}}function Z(e){var t,n,i,r,s,o,a,u,l,c,h;t=[];n=0;while(i=e[++n]){if(":"!==(r=i[0])){switch(false){case!ie(r,I):s=t.pop();break;case!ie(r,T):if(r==="INDENT"&&e[n-1][0]==="{"){r="{"}t.push([r,n])}continue}o=e[n-1][0]===")";a=o?s[1]:n-1;u=e[a-1];if(!((c=u[0])===":"||c==="ASSIGN"||c==="IMPORT"||((l=t[t.length-1])!=null?l[0]:void 8)!=="{")){continue}t.push(["{"]);h=!u.doblock&&((c=u[0])!=="NEWLINE"&&c!=="INDENT");while(((c=e[a-2])!=null?c[0]:void 8)==="COMMENT"){a-=2}e.splice(a,0,["{","{",e[a][2],e[a][3]]);ee(e,++n+1,f,p)}function f(t,n){var i,r,s,o;switch(i=t[0]){case",":break;case"NEWLINE":if(h){return true}break;case"DEDENT":return true;case"POST_IF":case"FOR":case"WHILE":return h;default:return false}s=(r=e[n+1])!=null?r[0]:void 8;return s!==(i===","?"NEWLINE":"COMMENT")&&":"!==((o=e[s==="("?1+te(e,n+1):n+2])!=null?o[0]:void 8)}function p(t,n){e.splice(n,0,["}","",t[2],t[3]])}}function Q(e){var t,n,r,s,o,a,u,l,c,f,p,d,g,m,y,v,b,w,k,L,A,E,C,S,R,N,_;t=0;while(r=e[++t]){switch(r[0]){case"STRNUM":if(~"-+".indexOf(s=r[1].charAt(0))){r[1]=r[1].slice(1);e.splice(t++,0,["+-",s,r[2],r[3]])}if(r.callable){continue}break;case"TO":case"TIL":if(!(e[t-1][0]==="["&&(e[t+2][0]==="]"&&((u=e[t+1][1].charAt(0))==="'"||u==='"'||+e[t+1][1]>=0)||e[t+2][0]==="BY"&&((o=e[t+3])!=null?o[0]:void 8)==="STRNUM"&&((a=e[t+4])!=null?a[0]:void 8)==="]"))){continue}if(e[t+2][0]==="BY"){e[t+2][0]="RANGE_BY"}r.op=r[1];n=0;
  // fallthrough
  case"RANGE":l=r[2];c=r[3];if(n!=null||e[t-1][0]==="["&&e[t+1][0]==="STRNUM"&&(e[t+2][0]==="]"&&((p=e[t+1][1].charAt(0))==="'"||p==='"'||+e[t+1][1]>=0)||e[t+2][0]==="RANGE_BY"&&((u=e[t+3])!=null?u[0]:void 8)==="STRNUM"&&((f=e[t+4])!=null?f[0]:void 8)==="]")){if(n==null){p=H(r[1],l),n=p[0],d=p[1]}p=H(e[t+1][1],l),g=p[0],m=p[1];if(g==null||d^m){F('bad "to" in range',l)}y=1;if(v=((p=e[t+2])!=null?p[0]:void 8)==="RANGE_BY"){if(!(y=+((b=e[t+3])!=null?b[1]:void 8))){F('bad "by" in range',e[t+2][2])}}else if(n>g){y=-1}w=[];k=d?h:String;L=T;if(r.op==="to"){for(A=n;y<0?A>=g:A<=g;A+=y){E=A;L()}}else{for(A=n;y<0?A>g:A<g;A+=y){E=A;L()}}w.pop()||F("empty range",l);e.splice.apply(e,[t,2+2*v].concat(j(w)));t+=w.length-1}else{r[0]="STRNUM";if(((C=e[t+2])!=null?C[0]:void 8)==="RANGE_BY"){e.splice(t+2,1,["BY","by",l,c])}e.splice(t+1,0,["TO",r.op,l,c])}n=null;break;case"WORDS":w=[["[","[",l=r[2],c=r[3]]];for(A=0,R=(S=r[1].match(/\S+/g)||"").length;A<R;++A){N=S[A];w.push(["STRNUM",i("'",N,l),l,c],[",",",",l,c])}e.splice.apply(e,[t,1].concat(j(w),[["]","]",l,c]]));t+=w.length;break;case"INDENT":if(_=e[t-1]){if(_[1]==="new"){e.splice(t++,0,["PARAM(","",r[2],r[3]],[")PARAM","",r[2],r[3]],["->","",r[2],r[3]])}else if((S=_[0])==="FUNCTION"||S==="GENERATOR"||S==="LET"){e.splice(t,0,["CALL(","",r[2],r[3]],[")CALL","",r[2],r[3]]);t+=2}}continue;case"LITERAL":case"}":break;case")":case")CALL":if(r[1]){continue}break;case"]":if(r.index){continue}break;case"CREMENT":if(!W(e,t)){continue}break;case"BIOP":if(!r.spaced&&((S=r[1])==="+"||S==="-")&&e[t+1][0]!==")"){e[t][0]="+-"}continue;default:continue}if(r.spaced&&ie(e[t+1][0],$)){e.splice(++t,0,[",",",",r[2],r[3]])}}function T(){if(65536<w.push(["STRNUM",k(E),l,c],[",",",",l,c])){F("range limit exceeded",l)}}}function ee(e,t,n,i){var r,s,o;r=0;for(;s=e[t];++t){if(!r&&n(s,t)){return i(s,t)}o=s[0];if(0>(r+=ie(o,T)||-ie(o,I))){return i(s,t)}}}function te(e,t){var n,i,r,s;n=1;i=x[r=e[t][0]];while(s=e[++t]){switch(s[0]){case r:++n;break;case i:if(!--n){return t}}}return-1}f=["true","false","null","this","void","super","return","throw","break","continue","if","else","for","while","switch","case","default","try","catch","finally","function","class","extends","implements","new","do","delete","typeof","in","instanceof","let","with","var","const","import","export","debugger","yield"];p=["enum","interface","package","private","protected","public","static"];d=f.concat(p);g=["xor","match","where"];m=/((?!\s)[a-z_$\xAA-\uFFDC](?:(?!\s)[\w$\xAA-\uFFDC]|-[a-z])*)([^\n\S]*:(?![:=]))?|/gi;y=/[-\/^]=|[%+:*]{1,2}=|\|>=|\.(?:[&\|\^]|<<|>>>?)\.=?|\.{1,3}|\^\^|\*?<(?:--?|~~?)!?|!?(?:--?|~~?)>>?\*?|([-+&|:])\1|%%|&|\([^\n\S]*\)|[!=]==?|!?\~=|@@?|<\[(?:[\s\S]*?\]>)?|<<<<?|<\||[<>]==|<<=|>>=|<<|>>|[<>]\??=?|\|>|\||=>|\*\*|\^|`|[^\s#]?/g;v=/[^\n\S]*(?:#.*)?/g;b=/(?:\s*#.*)*(?:\n([^\n\S]*))*/g;w=/'[^\\']*(?:\\[\s\S][^\\']*)*'|/g;k=/``[^\\`]*(?:\\[\s\S][^\\`]*)*``|/g;L=RegExp("\\\\(?:(\\S[^\\s,;)}\\]]*)|(?:"+v.source+"\\n?)*)","g");A=/0x[\dA-Fa-f][\dA-Fa-f_]*|(\d*)~([\dA-Za-z]\w*)|((\d[\d_]*)(\.\d[\d_]*)?(?:e[+-]?\d[\d_]*)?)[$\w]*|/g;E=/_+/g;C=/\/([^[\/\n\\]*(?:(?:\\.|\[[^\]\n\\]*(?:\\.[^\]\n\\]*)*\])[^[\/\n\\]*)*)\/([gimy]{1,4}|\$?)|/g;S=/\s+(?:#.*)?/g;R=/\n[^\n\S]*$/;N=/[^\n\S]*[^#\s]?/g;_=/[\x80-\uFFFF]/;T=["(","[","{","CALL(","PARAM(","INDENT"];I=[")","]","}",")CALL",")PARAM","DEDENT"];x=re(function(){var e,t,n,i={};for(e=0,n=(t=T).length;e<n;++e){O=e;M=t[e];i[M]=I[O]}return i}(),function(){var e,t,n,i={};for(e=0,n=(t=I).length;e<n;++e){O=e;P=t[e];i[P]=T[O]}return i}());B=["(","{","[","ID","STRNUM","LITERAL","LET","WITH","WORDS"];$=B.concat(["...","UNARY","YIELD","CREMENT","PARAM(","FUNCTION","GENERATOR","IF","SWITCH","TRY","CLASS","RANGE","LABEL","DECL","DO","BIOPBP"]);U=[",",":","->","ELSE","ASSIGN","IMPORT","UNARY","DEFAULT","TRY","FINALLY","HURL","DECL","DO","LET","FUNCTION","GENERATOR","..."];function ne(e){function t(){}t.prototype=e;return new t}function ie(e,t){var n=-1,i=t.length>>>0;while(++n<i)if(e===t[n])return true;return false}function re(e,t){var n={}.hasOwnProperty;for(var i in t)if(n.call(t,i))e[i]=t[i];return e}},{}],4:[function(e,t,n){(function(n){
  // Generated by blackpard 1.6.1
  t.exports=function(t){var o,a,u;o=e("fs");a=e("path");u=e("events");t.run=function(s,u,l){var c,h,f,p,d,g,m,y;if(u!=null){c=u.filename}h=l!=null?l:{},f=h.js,p=h.context;d=e.main;g=c?a.dirname(o.realpathSync(c=a.resolve(c))):c=".";d.paths=d.constructor._nodeModulePaths(g);d.filename=c;if(!f){s=t.compile(s,(h={},r(h,u),h.bare=true,h));if(m=s.code){s=m}}if(p){n.__runContext=p;s="return (function() {\n"+s+"\n}).call(global.__runContext);"}c+="(js)";try{return d._compile(s,c)}catch(v){y=v;throw i(y,s,c)}};s(t,u.EventEmitter.prototype);e.extensions[".ls"]=function(e,n){var r,s,a;r=o.readFileSync(n,"utf8");s=".json.ls"===n.substr(-8)?"module.exports = "+t.compile(r,{filename:n,json:true}):t.compile(r,{filename:n,bare:true,map:"embedded"}).code;try{return e._compile(s,n)}catch(u){a=u;throw i(a,s,n)}}};function i(e,t,n){var i,r,s,o,a,u,l,c,h,f,p,d,g,m;if(e!=null){i=e.stack}if(!i){return e}r=i.split("\n");if(!(r.length>1)){return e}for(s=0,o=r.length;s<o;++s){a=s;u=r[s];if(0>(l=u.indexOf("("+n+":"))){continue}c=(/:(\d+):/.exec(u.slice(l+n.length))||"")[1];if(!(c=+c)){continue}h=c+4;f=(""+h).length;p||(p=t.split("\n"));for(d=1>(g=c-4)?1:g;d<=h;++d){m=d;r[a]+="\n"+("    "+m).slice(-f)+""+"|+".charAt(m===c)+" "+[p[m-1]]}}return e.stack=r.join("\n"),e}function r(e,t){var n={}.hasOwnProperty;for(var i in t)if(n.call(t,i))e[i]=t[i];return e}function s(e,t){for(var n in t)e[n]=t[n];return e}}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{events:10,fs:8,path:13}],5:[function(e,t,n){(function(i){/* parser generated by jison 0.4.18 */
  /*
    Returns a Parser object of the following structure:
  
    Parser: {
      yy: {}
    }
  
    Parser.prototype: {
      yy: {},
      trace: function(),
      symbols_: {associative list: name ==> number},
      terminals_: {associative list: number ==> name},
      productions_: [...],
      performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
      table: [...],
      defaultActions: {...},
      parseError: function(str, hash),
      parse: function(input),
  
      lexer: {
          EOF: 1,
          parseError: function(str, hash),
          setInput: function(input),
          input: function(),
          unput: function(str),
          more: function(),
          less: function(n),
          pastInput: function(),
          upcomingInput: function(),
          showPosition: function(),
          test_match: function(regex_match_array, rule_index),
          next: function(),
          lex: function(),
          begin: function(condition),
          popState: function(),
          _currentRules: function(),
          topState: function(),
          pushState: function(condition),
  
          options: {
              ranges: boolean           (optional: true ==> token location info will include a .range[] member)
              flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
              backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
          },
  
          performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
          rules: [...],
          conditions: {associative list: name ==> set},
      }
    }
  
  
    token location info (@$, _$, etc.): {
      first_line: n,
      last_line: n,
      first_column: n,
      last_column: n,
      range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
    }
  
  
    the parseError function receives a 'hash' object with these members for lexer and parser errors: {
      text:        (matched text)
      token:       (the produced terminal token, if any)
      line:        (yylineno)
    }
    while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
      loc:         (yylloc)
      expected:    (string describing the set of expected tokens)
      recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
    }
  */
  var r=function(){var e=function(e,t,n,i){for(n=n||{},i=e.length;i--;n[e[i]]=t);return n},t=[2,60],n=[1,31],i=[1,34],r=[1,35],s=[1,36],o=[1,37],a=[1,38],u=[1,8],l=[1,15],c=[1,14],h=[1,39],f=[1,41],p=[1,29],d=[1,6],g=[1,10],m=[1,9],y=[1,11],v=[1,16],b=[1,17],w=[1,18],k=[1,19],L=[1,20],A=[1,21],E=[1,22],C=[1,23],S=[1,44],R=[1,24],N=[1,25],_=[1,26],T=[1,27],I=[1,28],x=[1,30],O=[1,43],M=[1,45],P=[1,20,25,47],B=[20,47],$=[2,64],U=[1,49],D=[1,50],j=[1,51],F=[1,52],W=[1,53],Y=[1,54],z=[1,55],G=[1,56],H=[1,57],J=[1,58],q=[1,59],K=[1,60],V=[1,61],X=[1,62],Z=[1,63],Q=[30,46,47,48],ee=[2,50],te=[1,68],ne=[1,67],ie=[1,12,19,20,22,24,25,26,30,33,34,35,46,47,48,58,59,62,63,64,65,66,67,68,69,70,71,72,79,81,82,102,105],re=[2,75],se=[1,77],oe=[1,78],ae=[1,73],ue=[1,79],le=[1,71],ce=[1,72],he=[1,74],fe=[1,75],pe=[1,83],de=[1,87],ge=[1,86],me=[1,84],ye=[1,95],ve=[1,109],be=[48,105],we=[2,201],ke=[1,113],Le=[2,1],Ae=[1,9,12,13,19,20,22,24,25,26,30,32,33,34,35,37,46,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,96,102,103,104,105],Ee=[2,2],Ce=[19,46,47,48],Se=[1,120],Re=[1,119],Ne=[22,46,47],_e=[2,156],Te=[1,130],Ie=[1,125],xe=[1,128],Oe=[1,129],Me=[25,47],Pe=[1,9,12,13,19,20,22,24,25,26,30,32,33,34,35,37,46,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,96,99,102,103,104,105],Be=[30,47,48],$e=[2,58],Ue=[1,169],De=[12,19,20,30,46,47,48],je=[2,55],Fe=[2,71],We=[12,46,47,48],Ye=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,58,59,62,63,64,66,67,68,70,71,72,79,81,82,102,105],ze=[20,46,47,48],Ge=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,79,81,82,102,105],He=[1,206],Je=[1,12,19,20,22,24,25,26,30,33,34,35,46,47,48,58,59,62,63,64,65,66,67,68,69,70,71,72,79,81,102,105],qe=[1,209],Ke=[46,48,82],Ve=[2,203],Xe=[1,215],Ze=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,71,72,79,81,82,102,105],Qe=[19,47,48],et=[1,227],tt=[20,22,46,47],nt=[9,13,20,22,32,33,37,46,47,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,96],it=[2,165],rt=[1,251],st=[19,20,22,47,48,81,102],ot=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,58,62,63,66,67,68,70,71,72,79,81,82,102,105],at=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,63,67,71,72,79,81,82,102,105],ut=[1,12,19,20,22,24,25,26,30,34,35,46,47,48,62,63,67,70,71,72,79,81,82,102,105],lt=[1,264],ct=[1,265],ht=[2,59],ft=[12,47,48],pt=[20,47,48],dt=[1,302],gt=[1,303],mt=[1,311],yt=[4,7,14,16,21,23,29,31,32,38,41,44,48,49,59,60,61,75,76,77,78,80,81,83,84,85,90,93,97,102],vt=[1,336],bt=[1,337],wt=[1,12,19,20,22,24,25,26,30,33,34,35,46,47,48,58,59,62,63,64,65,66,67,68,69,70,71,72,79,81,82,88,89,102,105],kt=[2,46],Lt=[1,369];var At={trace:function Ct(){},yy:{},symbols_:{error:2,Chain:3,ID:4,KeyLike:5,List:6,LITERAL:7,Index:8,"CALL(":9,ArgList:10,OptComma:11,")CALL":12,"?":13,LET:14,Block:15,"[":16,Expression:17,LoopHeads:18,"]":19,DEDENT:20,"{":21,"}":22,"(":23,BIOP:24,")":25,BIOPR:26,BIOPBP:27,BIOPP:28,"PARAM(":29,")PARAM":30,UNARY:31,CREMENT:32,BACKTICK:33,TO:34,BY:35,FROM:36,DOT:37,WITH:38,LoopHead:39,Else:40,STRNUM:41,Parenthetical:42,Properties:43,LABEL:44,Arg:45,",":46,NEWLINE:47,INDENT:48,"...":49,Lines:50,Line:51,"<-":52,COMMENT:53,REQUIRE:54,SplatChain:55,CLONEPORT:56,ASSIGN:57,IMPORT:58,"+-":59,CLONE:60,YIELD:61,COMPARE:62,LOGIC:63,MATH:64,POWER:65,SHIFT:66,BITWISE:67,CONCAT:68,COMPOSE:69,RELATION:70,PIPE:71,BACKPIPE:72,"!?":73,"->":74,FUNCTION:75,GENERATOR:76,ASYNC:77,IF:78,POST_IF:79,DO:80,WHILE:81,CASE:82,HURL:83,JUMP:84,SWITCH:85,Exprs:86,Cases:87,DEFAULT:88,ELSE:89,TRY:90,CATCH:91,FINALLY:92,CLASS:93,OptExtends:94,OptImplements:95,EXTENDS:96,DECL:97,KeyColon:98,":":99,Property:100,Body:101,FOR:102,IN:103,OF:104,IMPLEMENTS:105,Root:106,$accept:0,$end:1},terminals_:{2:"error",4:"ID",7:"LITERAL",9:"CALL(",12:")CALL",13:"?",14:"LET",16:"[",19:"]",20:"DEDENT",21:"{",22:"}",23:"(",24:"BIOP",25:")",26:"BIOPR",27:"BIOPBP",28:"BIOPP",29:"PARAM(",30:")PARAM",31:"UNARY",32:"CREMENT",33:"BACKTICK",34:"TO",35:"BY",36:"FROM",37:"DOT",38:"WITH",41:"STRNUM",44:"LABEL",46:",",47:"NEWLINE",48:"INDENT",49:"...",52:"<-",53:"COMMENT",54:"REQUIRE",56:"CLONEPORT",57:"ASSIGN",58:"IMPORT",59:"+-",60:"CLONE",61:"YIELD",62:"COMPARE",63:"LOGIC",64:"MATH",65:"POWER",66:"SHIFT",67:"BITWISE",68:"CONCAT",69:"COMPOSE",70:"RELATION",71:"PIPE",72:"BACKPIPE",73:"!?",74:"->",75:"FUNCTION",76:"GENERATOR",77:"ASYNC",78:"IF",79:"POST_IF",80:"DO",81:"WHILE",82:"CASE",83:"HURL",84:"JUMP",85:"SWITCH",88:"DEFAULT",89:"ELSE",90:"TRY",91:"CATCH",92:"FINALLY",93:"CLASS",96:"EXTENDS",97:"DECL",99:":",102:"FOR",103:"IN",104:"OF",105:"IMPLEMENTS"},productions_:[0,[3,1],[3,1],[3,1],[3,1],[3,2],[3,5],[3,2],[3,6],[3,4],[3,5],[3,7],[3,3],[3,4],[3,4],[3,3],[3,4],[3,4],[3,3],[3,7],[3,3],[3,7],[3,3],[3,3],[3,5],[3,6],[3,6],[3,5],[3,7],[3,6],[3,8],[3,4],[3,6],[3,9],[3,8],[3,7],[3,6],[3,6],[3,5],[3,3],[3,3],[5,1],[5,1],[8,2],[8,2],[8,2],[6,4],[6,4],[6,5],[6,5],[10,0],[10,1],[10,3],[10,4],[10,6],[45,1],[45,2],[45,1],[11,0],[11,1],[50,0],[50,1],[50,3],[50,2],[51,1],[51,2],[51,6],[51,1],[51,1],[51,2],[15,3],[55,2],[17,3],[17,3],[17,5],[17,1],[17,3],[17,3],[17,6],[17,3],[17,6],[17,2],[17,2],[17,3],[17,2],[17,3],[17,3],[17,3],[17,4],[17,4],[17,4],[17,2],[17,2],[17,2],[17,3],[17,3],[17,3],[17,6],[17,5],[17,1],[17,2],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,3],[17,2],[17,6],[17,6],[17,6],[17,7],[17,7],[17,4],[17,3],[17,4],[17,6],[17,2],[17,5],[17,1],[17,1],[17,2],[17,3],[17,5],[17,5],[17,2],[17,4],[17,4],[17,2],[17,2],[17,4],[17,6],[17,5],[17,7],[17,4],[17,5],[17,4],[17,3],[17,2],[17,2],[17,5],[86,1],[86,3],[98,2],[98,2],[100,2],[100,5],[100,1],[100,2],[100,1],[43,0],[43,1],[43,3],[43,4],[43,4],[42,3],[101,1],[101,1],[101,3],[40,0],[40,2],[40,5],[39,4],[39,6],[39,6],[39,8],[39,2],[39,4],[39,4],[39,6],[39,4],[39,6],[39,6],[39,8],[39,6],[39,5],[39,8],[39,7],[39,8],[39,7],[39,10],[39,9],[39,10],[39,9],[39,2],[39,4],[39,4],[39,6],[18,1],[18,2],[18,3],[18,3],[87,3],[87,4],[94,2],[94,0],[95,2],[95,0],[106,1]],performAction:function St(e,t,n,i,r,s,o){/* this == yyval */
  var a=s.length-1;switch(r){case 1:this.$=i.L(o[a],o[a],i.Chain(i.L(o[a],o[a],i.Var(s[a]))));break;case 2:case 3:this.$=i.L(o[a],o[a],i.Chain(s[a]));break;case 4:this.$=i.L(o[a],o[a],i.Chain(i.L(o[a],o[a],i.Literal(s[a]))));break;case 5:this.$=i.L(o[a-1],o[a],s[a-1].add(s[a]));break;case 6:this.$=i.L(o[a-4],o[a],s[a-4].add(i.L(o[a-3],o[a],i.Call(s[a-2]))));break;case 7:this.$=i.L(o[a-1],o[a],i.Chain(i.L(o[a-1],o[a],i.Existence(s[a-1].unwrap()))));break;case 8:this.$=i.L(o[a-5],o[a],i.Chain(i.L(o[a-5],o[a-1],i.Call["let"](s[a-3],s[a]))));break;case 9:this.$=i.L(o[a-3],o[a],i.Chain(i.L(o[a-3],o[a],s[a-1][0].makeComprehension(s[a-2],s[a-1].slice(1)))));break;case 10:this.$=i.L(o[a-4],o[a],i.Chain(i.L(o[a-4],o[a],s[a-2][0].makeComprehension(s[a-3],s[a-2].slice(1)))));break;case 11:this.$=i.L(o[a-6],o[a],i.Chain(i.L(o[a-6],o[a],s[a-1][0].addObjComp().makeComprehension(i.L(o[a-4],o[a-4],i.Arr(s[a-4])),s[a-1].slice(1)))));break;case 12:case 18:case 20:this.$=i.L(o[a-2],o[a],i.Chain(i.L(o[a-1],o[a-1],i.Binary(s[a-1]))));break;case 13:this.$=i.L(o[a-3],o[a],i.Chain(i.L(o[a-2],o[a-2],i.Binary(s[a-2],void 8,s[a-1]))));break;case 14:this.$=i.L(o[a-3],o[a],i.Chain(i.L(o[a-1],o[a-1],i.Binary(s[a-1],s[a-2]))));break;case 15:this.$=i.L(o[a-2],o[a],i.Chain(i.L(o[a-1],o[a-1],"!"===s[a-1].charAt(0)?i.Binary(s[a-1].slice(1)).invertIt():i.Binary(s[a-1]))));break;case 16:this.$=i.L(o[a-3],o[a],i.Chain(i.L(o[a-2],o[a-2],"!"===s[a-2].charAt(0)?i.Binary(s[a-2].slice(1),void 8,s[a-1]).invertIt():i.Binary(s[a-2],void 8,s[a-1]))));break;case 17:this.$=i.L(o[a-3],o[a],i.Chain(i.L(o[a-1],o[a-1],"!"===s[a-1].charAt(0)?i.Binary(s[a-1].slice(1),s[a-2]).invertIt():i.Binary(s[a-1],s[a-2]))));break;case 19:this.$=i.L(o[a-6],o[a],i.Chain(i.L(o[a-5],o[a-5],i.Binary(s[a-5],void 8,s[a-3]))));break;case 21:this.$=i.L(o[a-6],o[a],i.Chain(i.L(o[a-1],o[a-1],i.Binary(s[a-1],s[a-4]))));break;case 22:case 23:this.$=i.L(o[a-2],o[a],i.Chain(i.L(o[a-1],o[a-1],i.Unary(s[a-1]))));break;case 24:this.$=i.L(o[a-4],o[a],i.Chain(s[a-2]));break;case 25:this.$=i.L(o[a-5],o[a],i.Chain(i.L(o[a-4],o[a-1],s[a-2].add(i.L(o[a-4],o[a-4],i.Call([s[a-4]]))))));break;case 26:this.$=i.L(o[a-5],o[a],i.Chain(i.L(o[a-3],o[a-3],i.Chain(i.Var("flip$"))).add(i.L(o[a-3],o[a-3],i.Call([s[a-3]])))).flipIt().add(i.L(o[a-1],o[a-1],i.Call([s[a-1]]))));break;case 27:this.$=i.L(o[a-4],o[a],i.Chain(i.L(o[a-3],o[a-1],new i.For({from:s[a-3],op:s[a-2],to:s[a-1],inComprehension:true}))));break;case 28:this.$=i.L(o[a-6],o[a],i.Chain(i.L(o[a-5],o[a-1],new i.For({from:s[a-5],op:s[a-4],to:s[a-3],step:s[a-1],inComprehension:true}))));break;case 29:this.$=i.L(o[a-5],o[a],i.Chain(i.L(o[a-4],o[a-1],new i.For({from:s[a-3],op:s[a-2],to:s[a-1],inComprehension:true}))));break;case 30:this.$=i.L(o[a-7],o[a],i.Chain(i.L(o[a-6],o[a-1],new i.For({from:s[a-5],op:s[a-4],to:s[a-3],step:s[a-1],inComprehension:true}))));break;case 31:this.$=i.L(o[a-3],o[a],i.Chain(i.L(o[a-2],o[a-1],new i.For({from:i.Chain(i.Literal(0)),op:s[a-2],to:s[a-1],inComprehension:true}))));break;case 32:this.$=i.L(o[a-5],o[a],i.Chain(i.L(o[a-4],o[a-1],new i.For({from:i.Chain(i.Literal(0)),op:s[a-4],to:s[a-3],step:s[a-1],inComprehension:true}))));break;case 33:this.$=i.L(o[a-8],o[a],i.Chain(i.L(o[a-8],o[a],new i.StepSlice({op:s[a-4],target:s[a-8],from:s[a-5],to:s[a-3],step:s[a-1]}))));break;case 34:this.$=i.L(o[a-7],o[a],i.Chain(i.L(o[a-7],o[a],new i.StepSlice({op:s[a-4],target:s[a-7],from:i.Literal(0),to:s[a-3],step:s[a-1]}))));break;case 35:this.$=i.L(o[a-6],o[a],i.Chain(i.L(o[a-6],o[a],i.Slice({type:s[a-2],target:s[a-6],from:s[a-3],to:s[a-1]}))));break;case 36:this.$=i.L(o[a-5],o[a],i.Chain(i.L(o[a-5],o[a],i.Slice({type:s[a-1],target:s[a-5],from:s[a-2]}))));break;case 37:this.$=i.L(o[a-5],o[a],i.Chain(i.L(o[a-5],o[a],i.Slice({type:s[a-2],target:s[a-5],to:s[a-1]}))));break;case 38:this.$=i.L(o[a-4],o[a],i.Chain(i.L(o[a-4],o[a],i.Slice({type:s[a-1],target:s[a-4]}))));break;case 39:this.$=i.L(o[a-2],o[a],i.Chain(i.L(o[a-2],o[a-1],i.Cascade(s[a-1],s[a],"with"))));break;case 40:this.$=i.L(o[a-2],o[a],i.Chain(s[a-2].addBody(s[a-1]).addElse(s[a])));break;case 41:this.$=i.L(o[a],o[a],i.Literal(s[a]));break;case 42:case 55:case 58:case 59:case 63:case 64:case 162:case 163:break;case 43:this.$=i.L(o[a-1],o[a],i.Index(i.L(o[a],o[a],i.Key(s[a])),s[a-1],true));break;case 44:case 45:this.$=i.L(o[a-1],o[a],i.Index(s[a],s[a-1],true));break;case 46:this.$=i.L(o[a-3],o[a],i.Arr(s[a-2]));break;case 47:this.$=i.L(o[a-3],o[a],i.Obj(s[a-2]));break;case 48:this.$=i.L(o[a-4],o[a],i.Arr(s[a-3]).named(s[a]));break;case 49:this.$=i.L(o[a-4],o[a],i.Obj(s[a-3]).named(s[a]));break;case 50:case 156:this.$=i.L(o[a],o[a],[]);break;case 51:case 147:case 157:case 194:this.$=i.L(o[a],o[a],[s[a]]);break;case 52:case 148:case 158:case 196:case 197:this.$=i.L(o[a-2],o[a],s[a-2].concat(s[a]));break;case 53:case 159:this.$=i.L(o[a-3],o[a],s[a-3].concat(s[a]));break;case 54:this.$=i.L(o[a-5],o[a-2],s[a-5].concat(s[a-2]));break;case 56:this.$=i.L(o[a-1],o[a],i.Splat(s[a]));break;case 57:this.$=i.L(o[a],o[a],i.Splat(i.L(o[a],o[a],i.Arr()),true));break;case 60:this.$=i.L(o[a],o[a],i.Block());break;case 61:this.$=i.L(o[a],o[a],i.Block(s[a]));break;case 62:case 164:this.$=i.L(o[a-2],o[a],s[a-2].add(s[a]));break;case 65:this.$=i.L(o[a-1],o[a],i.Cascade(s[a-1],s[a],"cascade"));break;case 66:this.$=i.L(o[a-5],o[a],i.Call.back(s[a-4],s[a],/~/.test(s[a-1]),/--|~~/.test(s[a-1]),/!/.test(s[a-1]),/\*/.test(s[a-1])));break;case 67:case 155:this.$=i.L(o[a],o[a],i.JS(s[a],true,true));break;case 68:this.$=i.L(o[a],o[a],i.Throw(i.L(o[a],o[a],i.JS("Error('unimplemented')"))));break;case 69:this.$=i.L(o[a-1],o[a],i.Require(s[a].unwrap()));break;case 70:this.$=i.L(o[a-2],o[a],s[a-1]);break;case 71:this.$=i.L(o[a-1],o[a],i.Splat(s[a].unwrap()));break;case 72:this.$=i.L(o[a-2],o[a],i.Import(i.L(o[a-2],o[a-1],i.Unary("^^",s[a-2],{prec:"yy.UNARY"})),s[a],false));break;case 73:this.$=i.L(o[a-2],o[a],i.Import(i.L(o[a-2],o[a-1],i.Unary("^^",s[a-2],{prec:"yy.UNARY"})),s[a].unwrap(),false));break;case 74:this.$=i.L(o[a-4],o[a],s[a-2].add(i.L(o[a-4],o[a],i.Call([s[a-4],s[a]]))));break;case 75:this.$=i.L(o[a],o[a],s[a].unwrap());break;case 76:this.$=i.L(o[a-2],o[a],i.Assign(s[a-2].unwrap(),s[a],i.L(o[a-1],o[a-1],i.Box(s[a-1]))));break;case 77:this.$=i.L(o[a-2],o[a],i.Assign(s[a-2],s[a],i.L(o[a-1],o[a-1],i.Box(s[a-1]))));break;case 78:this.$=i.L(o[a-5],o[a],i.Assign(s[a-5].unwrap(),i.Arr.maybe(s[a-2]),i.L(o[a-4],o[a-4],i.Box(s[a-4]))));break;case 79:this.$=i.L(o[a-2],o[a],i.Import(s[a-2],s[a],s[a-1]==="<<<<"));break;case 80:this.$=i.L(o[a-5],o[a],i.Import(s[a-5],i.Arr.maybe(s[a-2]),s[a-4]==="<<<<"));break;case 81:this.$=i.L(o[a-1],o[a],i.Unary(s[a-1],s[a].unwrap()));break;case 82:this.$=i.L(o[a-1],o[a],i.Unary(s[a],s[a-1].unwrap(),true));break;case 83:this.$=i.L(o[a-2],o[a],i.Unary(s[a-2],i.Splat(s[a].unwrap())));break;case 84:this.$=i.L(o[a-1],o[a],i.Unary(s[a],s[a-1],true));break;case 85:case 86:case 87:this.$=i.L(o[a-2],o[a],i.Assign(s[a].unwrap(),[s[a-2]],i.L(o[a-1],o[a-1],i.Box(s[a-1]))));break;case 88:case 89:case 90:this.$=i.L(o[a-3],o[a],i.Assign(i.Splat(s[a].unwrap()),[s[a-3]],i.L(o[a-2],o[a-2],i.Box(s[a-2]))));break;case 91:case 92:case 93:this.$=i.L(o[a-1],o[a],i.Unary(s[a-1],s[a]));break;case 94:case 95:case 96:this.$=i.L(o[a-2],o[a],i.Unary(s[a-2],i.Splat(s[a])));break;case 97:this.$=i.L(o[a-5],o[a],i.Unary(s[a-5],i.Splat(i.Arr(s[a-2]))));break;case 98:this.$=i.L(o[a-4],o[a],i.Unary(s[a-4],i.Arr.maybe(s[a-2])));break;case 99:this.$=i.L(o[a],o[a],i.Yield(s[a]));break;case 100:this.$=i.L(o[a-1],o[a],i.Yield(s[a-1],s[a]));break;case 101:case 102:case 103:case 104:case 105:case 106:case 107:case 108:case 109:this.$=i.L(o[a-1],o[a-1],i.Binary(s[a-1],s[a-2],s[a]));break;case 110:this.$=i.L(o[a-2],o[a],"!"===s[a-1].charAt(0)?i.Binary(s[a-1].slice(1),s[a-2],s[a]).invert():i.Binary(s[a-1],s[a-2],s[a]));break;case 111:this.$=i.L(o[a-2],o[a],i.Block(s[a-2]).pipe(s[a],s[a-1]));break;case 112:this.$=i.L(o[a-2],o[a],i.Block(s[a-2]).pipe([s[a]],s[a-1]));break;case 113:this.$=i.L(o[a-1],o[a],i.Existence(s[a-1].unwrap(),true));break;case 114:this.$=i.L(o[a-5],o[a],i.Fun(s[a-4],s[a],/~/.test(s[a-1]),/--|~~/.test(s[a-1]),/!/.test(s[a-1]),/\*/.test(s[a-1]),/>>/.test(s[a-1])));break;case 115:this.$=i.L(o[a-5],o[a],i.Fun(s[a-3],s[a]).named(s[a-5]));break;case 116:this.$=i.L(o[a-5],o[a],i.Fun(s[a-3],s[a],false,false,false,true,false).named(s[a-5]));break;case 117:this.$=i.L(o[a-6],o[a],i.Fun(s[a-3],s[a],false,false,false,false,true).named(s[a-5]));break;case 118:this.$=i.L(o[a-6],o[a],i.Fun(s[a-3],s[a],false,false,false,true,true).named(s[a-5]));break;case 119:this.$=i.L(o[a-3],o[a-2],i.If(s[a-2],s[a-1],s[a-3]==="unless")).addElse(s[a]);break;case 120:this.$=i.L(o[a-1],o[a],i.If(s[a],s[a-2],s[a-1]==="unless"));break;case 121:this.$=i.L(o[a-3],o[a],new i.While(s[a],s[a-1]==="until",true).addBody(s[a-2]));break;case 122:this.$=i.L(o[a-5],o[a],new i.While(s[a-2],s[a-3]==="until",true).addGuard(s[a]).addBody(s[a-4]));break;case 123:this.$=i.L(o[a-1],o[a],i.Jump[s[a-1]](s[a]));break;case 124:this.$=i.L(o[a-4],o[a],i.Jump[s[a-4]](i.Arr.maybe(s[a-2])));break;case 125:this.$=i.L(o[a],o[a],i.Jump[s[a]]());break;case 126:this.$=i.L(o[a],o[a],new i.Jump(s[a]));break;case 127:this.$=i.L(o[a-1],o[a],new i.Jump(s[a-1],s[a]));break;case 128:this.$=i.L(o[a-2],o[a],new i.Switch(s[a-2],s[a-1],s[a]));break;case 129:case 130:this.$=i.L(o[a-4],o[a],new i.Switch(s[a-4],s[a-3],s[a-2],s[a]));break;case 131:this.$=i.L(o[a-1],o[a],new i.Switch(s[a-1],null,s[a]));break;case 132:case 133:this.$=i.L(o[a-3],o[a],new i.Switch(s[a-3],null,s[a-2],s[a]));break;case 134:this.$=i.L(o[a-1],o[a],new i.Switch(s[a-1],null,[],s[a]));break;case 135:this.$=i.L(o[a-1],o[a],new i.Try(s[a]));break;case 136:this.$=i.L(o[a-3],o[a],new i.Try(s[a-2],(void 8),i.L(o[a-1],o[a-1],s[a])));break;case 137:this.$=i.L(o[a-5],o[a],new i.Try(s[a-4],(void 8),i.L(o[a-3],o[a-3],s[a-2]),i.L(o[a-1],o[a-1],s[a])));break;case 138:this.$=i.L(o[a-4],o[a],new i.Try(s[a-3],s[a-1],i.L(o[a-2],o[a-1],s[a])));break;case 139:this.$=i.L(o[a-6],o[a],new i.Try(s[a-5],s[a-3],i.L(o[a-4],o[a-3],s[a-2]),i.L(o[a-1],o[a-1],s[a])));break;case 140:this.$=i.L(o[a-3],o[a],new i.Try(s[a-2],(void 8),(void 8),i.L(o[a-1],o[a-1],s[a])));break;case 141:this.$=i.L(o[a-4],o[a],new i.Class({title:s[a-3].unwrap(),sup:s[a-2],mixins:s[a-1],body:s[a]}));break;case 142:this.$=i.L(o[a-3],o[a],new i.Class({sup:s[a-2],mixins:s[a-1],body:s[a]}));break;case 143:this.$=i.L(o[a-2],o[a],i.Util.Extends(s[a-2].unwrap(),s[a]));break;case 144:case 145:this.$=i.L(o[a-1],o[a],new i.Label(s[a-1],s[a]));break;case 146:this.$=i.L(o[a-4],o[a],i.Decl(s[a-4],s[a-2],n+1));break;case 149:this.$=i.L(o[a-1],o[a],i.Key(s[a-1]));break;case 150:this.$=i.L(o[a-1],o[a],s[a-1]);break;case 151:this.$=i.L(o[a-1],o[a],i.Prop(s[a-1],s[a]));break;case 152:this.$=i.L(o[a-4],o[a],i.Prop(s[a-4],i.Arr.maybe(s[a-2])));break;case 153:this.$=i.L(o[a],o[a],i.Prop(null,s[a]));break;case 154:this.$=i.L(o[a-1],o[a],i.Prop(i.Splat(),s[a]));break;case 160:this.$=i.L(o[a-3],o[a],s[a-2]);break;case 161:this.$=i.L(o[a-2],o[a],i.Parens(s[a-1].chomp().unwrap(),false,s[a-2]==='"',i.L(o[a-2],o[a-2],{}),i.L(o[a],o[a],{})));break;case 165:case 201:case 203:this.$=i.L(o[a],o[a],null);break;case 166:case 200:case 202:this.$=i.L(o[a-1],o[a],s[a]);break;case 167:this.$=i.L(o[a-4],o[a],i.If(s[a-2],s[a-1],s[a-3]==="unless").addElse(s[a]));break;case 168:this.$=i.L(o[a-3],o[a],new i.For({kind:s[a-3],item:s[a-2].unwrap(),index:s[a-1],source:s[a]}));break;case 169:this.$=i.L(o[a-5],o[a],new i.For({kind:s[a-5],item:s[a-4].unwrap(),index:s[a-3],source:s[a-2],guard:s[a]}));break;case 170:this.$=i.L(o[a-5],o[a],new i.For({kind:s[a-5],item:s[a-4].unwrap(),index:s[a-3],source:s[a-2],step:s[a]}));break;case 171:this.$=i.L(o[a-7],o[a],new i.For({kind:s[a-7],item:s[a-6].unwrap(),index:s[a-5],source:s[a-4],step:s[a-2],guard:s[a]}));break;case 172:this.$=i.L(o[a-1],o[a],new i.For({kind:s[a-1],source:s[a],ref:true}));break;case 173:this.$=i.L(o[a-3],o[a],new i.For({kind:s[a-3],source:s[a-2],ref:true,guard:s[a]}));break;case 174:this.$=i.L(o[a-3],o[a],new i.For({kind:s[a-3],source:s[a-2],ref:true,step:s[a]}));break;case 175:this.$=i.L(o[a-5],o[a],new i.For({kind:s[a-5],source:s[a-4],ref:true,step:s[a-2],guard:s[a]}));break;case 176:this.$=i.L(o[a-3],o[a],new i.For({object:true,kind:s[a-3],index:s[a-2],source:s[a]}));break;case 177:this.$=i.L(o[a-5],o[a],new i.For({object:true,kind:s[a-5],index:s[a-4],source:s[a-2],guard:s[a]}));break;case 178:this.$=i.L(o[a-5],o[a],new i.For({object:true,kind:s[a-5],index:s[a-4],item:s[a-2].unwrap(),source:s[a]}));break;case 179:this.$=i.L(o[a-7],o[a],new i.For({object:true,kind:s[a-7],index:s[a-6],item:s[a-4].unwrap(),source:s[a-2],guard:s[a]}));break;case 180:this.$=i.L(o[a-5],o[a],new i.For({kind:s[a-5],index:s[a-4],from:s[a-2],op:s[a-1],to:s[a]}));break;case 181:this.$=i.L(o[a-4],o[a],new i.For({kind:s[a-4],from:s[a-2],op:s[a-1],to:s[a],ref:true}));break;case 182:this.$=i.L(o[a-7],o[a],new i.For({kind:s[a-7],index:s[a-6],from:s[a-4],op:s[a-3],to:s[a-2],guard:s[a]}));break;case 183:this.$=i.L(o[a-6],o[a],new i.For({kind:s[a-6],from:s[a-4],op:s[a-3],to:s[a-2],guard:s[a],ref:true}));break;case 184:this.$=i.L(o[a-7],o[a],new i.For({kind:s[a-7],index:s[a-6],from:s[a-4],op:s[a-3],to:s[a-2],step:s[a]}));break;case 185:this.$=i.L(o[a-6],o[a],new i.For({kind:s[a-6],from:s[a-4],op:s[a-3],to:s[a-2],step:s[a],ref:true}));break;case 186:this.$=i.L(o[a-9],o[a],new i.For({kind:s[a-9],index:s[a-8],from:s[a-6],op:s[a-5],to:s[a-4],step:s[a-2],guard:s[a]}));break;case 187:this.$=i.L(o[a-8],o[a],new i.For({kind:s[a-8],from:s[a-6],op:s[a-5],to:s[a-4],step:s[a-2],guard:s[a],ref:true}));break;case 188:this.$=i.L(o[a-9],o[a],new i.For({kind:s[a-9],index:s[a-8],from:s[a-6],op:s[a-5],to:s[a-4],guard:s[a-2],step:s[a]}));break;case 189:this.$=i.L(o[a-8],o[a],new i.For({kind:s[a-8],from:s[a-6],op:s[a-5],to:s[a-4],guard:s[a-2],step:s[a],ref:true}));break;case 190:this.$=i.L(o[a-1],o[a],new i.While(s[a],s[a-1]==="until"));break;case 191:this.$=i.L(o[a-3],o[a],new i.While(s[a-2],s[a-3]==="until").addGuard(s[a]));break;case 192:this.$=i.L(o[a-3],o[a],new i.While(s[a-2],s[a-3]==="until",s[a]));break;case 193:this.$=i.L(o[a-5],o[a],new i.While(s[a-4],s[a-5]==="until",s[a-2]).addGuard(s[a]));break;case 195:this.$=i.L(o[a-1],o[a],s[a-1].concat(s[a]));break;case 198:this.$=i.L(o[a-2],o[a],[i.L(o[a-2],o[a-1],new i.Case(s[a-1],s[a]))]);break;case 199:this.$=i.L(o[a-3],o[a],s[a-3].concat(i.L(o[a-2],o[a-1],new i.Case(s[a-1],s[a]))));break;case 204:return this.$;break}},table:[e([1,47],t,{106:1,101:2,50:3,15:4,51:5,17:7,3:12,55:13,5:32,6:33,39:40,42:42,4:n,7:i,14:r,16:s,21:o,23:a,29:u,31:l,32:c,38:h,41:f,44:p,48:d,49:g,53:m,54:y,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),{1:[3]},{1:[2,204]},e(N,[2,162],{47:M}),e(N,[2,163],{47:[1,46]}),e(P,[2,61]),e(B,t,{51:5,17:7,3:12,55:13,5:32,6:33,39:40,42:42,50:47,4:n,7:i,14:r,16:s,21:o,23:a,29:u,31:l,32:c,38:h,41:f,44:p,49:g,53:m,54:y,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(P,$,{15:48,33:U,48:d,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(Q,ee,{3:12,55:13,5:32,6:33,39:40,42:42,10:64,45:65,17:66,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(P,[2,67]),e(P,[2,68],{5:32,6:33,39:40,42:42,3:69,4:n,7:i,14:r,16:s,21:o,23:a,38:h,41:f,81:S,102:O}),{3:70,4:n,5:32,6:33,7:i,14:r,16:s,21:o,23:a,38:h,39:40,41:f,42:42,81:S,102:O},e(ie,re,{8:76,9:se,13:oe,32:ae,37:ue,56:le,57:ce,73:he,96:fe}),{32:[1,81],57:[1,80]},{3:82,4:n,5:32,6:33,7:i,14:r,16:s,21:o,23:a,38:h,39:40,41:f,42:42,49:pe,81:S,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:85,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,48:de,49:ge,55:13,57:me,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:89,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:[1,90],55:13,57:[1,88],59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:92,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:[1,93],55:13,57:[1,91],59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e([1,12,19,20,22,24,25,26,30,33,34,35,46,47,48,58,62,63,64,65,66,67,68,69,70,71,72,79,82,105],[2,99],{3:12,55:13,5:32,6:33,39:40,42:42,17:94,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ye,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),{9:[1,96]},{9:[1,97]},{75:[1,98],76:[1,99]},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:100,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{15:101,48:d},e([1,12,19,20,22,24,25,26,30,33,34,35,46,47,58,62,63,64,65,66,67,68,69,70,71,72,79,82,105],[2,125],{3:12,55:13,5:32,6:33,39:40,42:42,17:102,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,48:[1,103],49:ye,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(ie,[2,126],{4:[1,104]}),{3:12,4:n,5:32,6:33,7:i,14:r,15:107,16:s,17:108,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,48:d,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,82:ve,83:R,84:N,85:_,86:105,87:106,90:T,93:I,97:x,102:O},{15:110,48:d},e(be,we,{5:32,6:33,39:40,42:42,3:111,94:112,4:n,7:i,14:r,16:s,21:o,23:a,38:h,41:f,81:S,96:ke,102:O}),{3:12,4:n,5:32,6:33,7:i,14:r,15:115,16:s,17:114,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,48:d,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{48:[1,116]},e([1,9,12,13,19,20,22,24,25,26,30,32,33,34,35,37,46,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,96,102,104,105],Le),e(Ae,Ee),e(Ae,[2,3]),e(Ae,[2,4]),{9:[1,117]},e(Ce,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:118,10:121,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,34:Se,36:Re,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(Ne,_e,{3:12,55:13,6:33,39:40,42:42,43:123,100:124,98:126,17:127,5:131,4:Te,7:i,14:r,16:[1,122],21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,48:Ie,49:xe,53:Oe,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(Me,t,{50:3,15:4,51:5,3:12,55:13,5:32,6:33,39:40,42:42,17:133,101:141,4:n,7:i,14:r,16:s,21:o,23:a,24:[1,132],26:[1,134],27:[1,135],28:[1,136],29:[1,137],31:[1,138],32:[1,139],33:[1,140],38:h,41:f,44:p,48:d,49:g,53:m,54:y,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:142,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{15:143,48:d},e(Pe,[2,41]),e(Pe,[2,42]),{3:144,4:[1,146],5:32,6:33,7:i,14:r,16:s,17:145,21:o,23:a,29:te,31:l,32:c,36:[1,147],38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:148,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(P,[2,63],{17:7,3:12,55:13,5:32,6:33,39:40,42:42,51:149,4:n,7:i,14:r,16:s,21:o,23:a,29:u,31:l,32:c,38:h,41:f,44:p,49:g,53:m,54:y,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e([1,25,47],t,{51:5,17:7,3:12,55:13,5:32,6:33,39:40,42:42,50:150,4:n,7:i,14:r,16:s,21:o,23:a,29:u,31:l,32:c,38:h,41:f,44:p,49:g,53:m,54:y,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),{20:[1,151],47:M},e(P,[2,65]),{3:152,4:n,5:32,6:33,7:i,14:r,16:s,21:o,23:a,38:h,39:40,41:f,42:42,81:S,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:153,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,48:[1,154],49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:155,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:156,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:157,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:158,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:159,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:160,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:161,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:162,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:163,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:164,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:165,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:166,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:167,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(Be,$e,{11:168,46:Ue}),e(De,[2,51]),e(De,je,{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(De,[2,57],{55:13,5:32,6:33,39:40,42:42,17:170,3:171,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ye,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(Q,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:172,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e([32,57],Fe,{8:76,9:se,13:oe,37:ue}),e(P,[2,69],{8:76,9:se,13:oe,37:ue}),{3:12,4:n,5:32,6:33,7:i,14:r,15:174,16:s,17:173,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,48:d,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:175,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,48:[1,176],49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(ie,[2,82]),e(ie,[2,113]),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:177,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(Ae,[2,5]),e(We,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:178,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(Ae,[2,7]),{4:[1,180],5:181,6:182,16:[1,179],21:[1,183],23:[1,184],41:f,42:42},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:185,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(ie,[2,84]),e(ie,[2,81],{8:76,9:se,13:oe,37:ue}),{3:186,4:n,5:32,6:33,7:i,14:r,16:s,21:o,23:a,38:h,39:40,41:f,42:42,81:S,102:O},{3:187,4:n,5:32,6:33,7:i,14:r,16:s,21:o,23:a,38:h,39:40,41:f,42:42,49:[1,188],81:S,102:O},e(Ye,[2,91],{33:U,65:z,69:q}),{3:171,4:n,5:32,6:33,7:i,14:r,16:s,17:189,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,48:[1,190],49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(ze,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:191,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),{3:192,4:n,5:32,6:33,7:i,14:r,16:s,21:o,23:a,38:h,39:40,41:f,42:42,49:[1,193],81:S,102:O},e(Ye,[2,92],{33:U,65:z,69:q}),{3:171,4:n,5:32,6:33,7:i,14:r,16:s,17:194,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:195,4:n,5:32,6:33,7:i,14:r,16:s,21:o,23:a,38:h,39:40,41:f,42:42,49:[1,196],81:S,102:O},e(Ye,[2,93],{33:U,65:z,69:q}),{3:171,4:n,5:32,6:33,7:i,14:r,16:s,17:197,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(Ge,[2,100],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X}),{3:69,4:n,5:32,6:33,7:i,14:r,16:s,21:o,23:a,38:h,39:40,41:f,42:42,81:S,102:O},e(We,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:198,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(We,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:199,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),{9:[1,200]},{9:[1,201]},{15:202,33:U,48:d,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},{81:[1,203]},e(Ge,[2,123],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X}),e(ze,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:204,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(ie,[2,127]),{46:He,82:ve,87:205},e(Je,[2,131],{82:qe,88:[1,207],89:[1,208]}),e(ie,[2,134]),e(Ke,[2,147],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:108,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,86:210,90:T,93:I,97:x,102:O},e(ie,[2,135],{91:[1,211],92:[1,212]}),e(be,we,{8:76,94:213,9:se,13:oe,37:ue,96:ke}),{48:Ve,95:214,105:Xe},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:216,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(Ze,[2,144],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K}),e(ie,[2,145]),e(ze,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:217,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(We,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:218,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(Ce,je,{18:219,39:221,33:U,34:[1,220],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z,81:S,102:O}),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:222,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:223,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(Qe,$e,{11:224,46:Ue}),e(Ce,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:118,10:225,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,34:Se,36:Re,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e([22,47],$e,{11:226,46:et}),e(tt,[2,157]),e([20,46,47],_e,{3:12,55:13,6:33,39:40,42:42,100:124,98:126,17:127,5:131,43:228,4:Te,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,48:Ie,49:xe,53:Oe,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:229,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,48:[1,230],49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(tt,[2,153],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),{3:171,4:n,5:32,6:33,7:i,14:r,16:s,17:231,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(tt,[2,155]),e(nt,Le,{99:[1,232]}),e(nt,Ee,{99:[1,233]}),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:235,21:o,23:a,25:[1,234],29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(Me,$,{15:48,24:[1,236],26:[1,237],33:[1,238],48:d,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:240,21:o,23:a,25:[1,239],29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{9:[1,242],25:[1,241]},{25:[1,243]},e(Q,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:244,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:85,21:o,23:a,25:[1,245],29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,48:de,49:ge,55:13,57:me,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:82,4:n,5:32,6:33,7:i,14:r,16:s,21:o,23:a,25:[1,246],38:h,39:40,41:f,42:42,49:pe,81:S,102:O},{3:247,4:n,5:32,6:33,7:i,14:r,16:s,21:o,23:a,38:h,39:40,41:f,42:42,81:S,102:O},{25:[1,248]},{15:249,33:U,48:d,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},e(Ae,it,{40:250,89:rt}),e([19,20,22,33,35,47,48,58,59,62,63,64,65,66,67,68,69,70,71,72,79,81,82,102],re,{8:76,9:se,13:oe,32:ae,37:ue,56:le,57:ce,73:he,96:fe,103:[1,252]}),e(st,[2,172],{33:U,35:[1,254],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z,82:[1,253]}),e([9,13,19,20,22,32,33,35,37,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,96,102,103],Le,{36:[1,257],46:[1,256],104:[1,255]}),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:258,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(st,[2,190],{33:U,46:[1,260],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z,82:[1,259]}),e(P,[2,62]),e(N,[2,164],{47:M}),e([1,9,12,13,19,20,22,24,25,26,30,32,33,34,35,37,46,47,48,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,81,82,88,89,91,92,96,102,103,104,105],[2,70]),{8:76,9:se,13:oe,33:[1,261],37:ue},e(ot,[2,79],{33:U,59:j,64:Y,65:z,69:q}),e(ze,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:262,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e([1,12,19,20,22,24,25,26,30,34,35,46,47,48,58,59,62,63,66,67,68,70,71,72,79,81,82,102,105],[2,101],{33:U,64:Y,65:z,69:q}),e(at,[2,102],{33:U,58:D,59:j,62:F,64:Y,65:z,66:G,68:J,69:q,70:K}),e(Ze,[2,103],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K}),e(Ye,[2,104],{33:U,65:z,69:q}),e(Ye,[2,105],{33:U,
  65:z,69:q}),e(ot,[2,106],{33:U,59:j,64:Y,65:z,69:q}),e(at,[2,107],{33:U,58:D,59:j,62:F,64:Y,65:z,66:G,68:J,69:q,70:K}),e(ut,[2,108],{33:U,58:D,59:j,64:Y,65:z,66:G,68:J,69:q}),e([1,12,19,20,22,24,25,26,30,34,35,46,47,48,58,59,62,63,64,65,66,67,68,70,71,72,79,81,82,102,105],[2,109],{33:U,69:q}),e(ut,[2,110],{33:U,58:D,59:j,64:Y,65:z,66:G,68:J,69:q}),e(Ze,[2,111],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K}),e(Ge,[2,112],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X}),e(Ge,[2,120],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X}),{30:[1,263],47:lt,48:ct},e([12,19,20,30,47,48],ht,{3:12,55:13,5:32,6:33,39:40,42:42,17:66,45:266,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(De,[2,56],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(ie,re,{8:76,9:se,13:oe,32:Fe,57:Fe,37:ue,56:le,73:he,96:fe}),e(Be,$e,{11:267,46:Ue}),e(ot,[2,72],{33:U,59:j,64:Y,65:z,69:q}),e(ie,[2,73]),e(Ge,[2,76],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X}),e(ze,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:268,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(Ze,[2,143],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K}),e(ft,$e,{11:269,46:Ue}),e(Ce,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,10:121,17:270,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,34:[1,271],38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(Ae,[2,43]),e(Ae,[2,44]),e(Ae,[2,45]),e(Ne,_e,{3:12,55:13,6:33,39:40,42:42,43:123,100:124,98:126,17:127,5:131,4:Te,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,48:Ie,49:xe,53:Oe,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(Me,t,{50:3,15:4,51:5,17:7,3:12,55:13,5:32,6:33,39:40,42:42,101:141,4:n,7:i,14:r,16:s,21:o,23:a,29:u,31:l,32:c,38:h,41:f,44:p,48:d,49:g,53:m,54:y,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(Ge,[2,77],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X}),e(ie,[2,83],{8:76,9:se,13:oe,37:ue}),e(ie,[2,85],{8:76,9:se,13:oe,37:ue}),{3:272,4:n,5:32,6:33,7:i,14:r,16:s,21:o,23:a,38:h,39:40,41:f,42:42,81:S,102:O},e(Ye,[2,94],{33:U,65:z,69:q}),e(ze,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:273,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(pt,$e,{11:274,46:Ue}),e(ie,[2,86],{8:76,9:se,13:oe,37:ue}),{3:275,4:n,5:32,6:33,7:i,14:r,16:s,21:o,23:a,38:h,39:40,41:f,42:42,81:S,102:O},e(Ye,[2,95],{33:U,65:z,69:q}),e(ie,[2,87],{8:76,9:se,13:oe,37:ue}),{3:276,4:n,5:32,6:33,7:i,14:r,16:s,21:o,23:a,38:h,39:40,41:f,42:42,81:S,102:O},e(Ye,[2,96],{33:U,65:z,69:q}),e(ft,$e,{11:277,46:Ue}),e(ft,$e,{11:278,46:Ue}),e(We,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:279,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(We,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:280,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(ie,it,{40:281,89:rt}),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:282,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(pt,$e,{11:283,46:Ue}),e(Je,[2,128],{82:qe,88:[1,284],89:[1,285]}),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:286,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{15:287,48:d},{15:288,48:d},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:108,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,86:289,90:T,93:I,97:x,102:O},{15:290,46:He,48:d},{3:12,4:n,5:32,6:33,7:i,14:r,15:291,16:s,17:66,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,45:292,48:d,49:ne,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{15:293,48:d},{48:Ve,95:294,105:Xe},{15:295,48:d},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:108,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,86:296,90:T,93:I,97:x,102:O},e(be,[2,200],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(pt,$e,{11:297,46:Ue}),e(ft,$e,{11:298,46:Ue}),{19:[1,299],20:[1,300],39:301,47:dt,48:gt,81:S,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:304,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(st,[2,194]),{33:U,34:[1,305],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},{19:[1,306],33:U,35:[1,307],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},{19:[1,308],47:lt,48:ct},e(Qe,$e,{11:309,46:Ue}),{22:[1,310],47:mt},e([20,22,47],ht,{3:12,55:13,6:33,39:40,42:42,98:126,17:127,5:131,100:312,4:Te,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:xe,53:Oe,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(B,$e,{11:313,46:et}),e(tt,[2,151],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(ze,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:314,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(tt,[2,154],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(yt,[2,149]),e(yt,[2,150]),e(Ae,[2,12]),{25:[1,315],33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},{25:[1,316]},{25:[1,317]},{3:318,4:n,5:32,6:33,7:i,14:r,16:s,21:o,23:a,38:h,39:40,41:f,42:42,81:S,102:O},e(Ae,[2,15]),{25:[1,319],33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},e(Ae,[2,18]),e(We,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:320,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(Ae,[2,20]),e(Be,$e,{11:321,46:Ue}),e(Ae,[2,22]),e(Ae,[2,23]),{8:76,9:se,13:oe,33:[1,322],37:ue},e(Pe,[2,161]),e(Ae,[2,39]),e(Ae,[2,40]),{15:323,48:d,78:[1,324]},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:325,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:326,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:327,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:328,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:329,4:n,5:32,6:33,7:i,14:r,16:s,21:o,23:a,38:h,39:40,41:f,42:42,81:S,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:330,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{33:U,34:[1,331],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:332,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:333,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:334,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(pt,$e,{11:335,46:Ue}),{52:vt,74:bt},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:66,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,45:338,49:ne,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(ze,ee,{3:12,55:13,5:32,6:33,39:40,42:42,45:65,17:66,10:339,4:n,7:i,14:r,16:s,21:o,23:a,29:te,31:l,32:c,38:h,41:f,44:p,49:ne,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O}),e(De,[2,52]),{30:[1,340],47:lt,48:ct},e(pt,$e,{11:341,46:Ue}),{12:[1,342],47:lt,48:ct},e(Ce,je,{33:U,34:[1,343],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:344,19:[1,345],21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(ie,[2,88],{8:76,9:se,13:oe,37:ue}),e(pt,$e,{11:346,46:Ue}),{20:[1,347],47:lt,48:ct},e(ie,[2,89],{8:76,9:se,13:oe,37:ue}),e(ie,[2,90],{8:76,9:se,13:oe,37:ue}),{12:[1,348],47:lt,48:ct},{12:[1,349],47:lt,48:ct},e(ft,$e,{11:350,46:Ue}),e(ft,$e,{11:351,46:Ue}),e(ie,[2,119]),e([1,12,19,20,22,24,25,26,30,34,35,46,47,48,71,72,79,81,102,105],[2,121],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,82:[1,352]}),{20:[1,353],47:lt,48:ct},{15:354,48:d},{15:355,48:d},e(Ke,[2,148],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(ie,[2,132]),e(ie,[2,133]),{15:356,46:He,48:d},e(wt,[2,198]),e(ie,[2,136],{92:[1,357]}),{15:358,48:d},e(ie,[2,140]),{15:359,48:d},e(ie,[2,142]),{46:He,48:[2,202]},{20:[1,360],47:lt,48:ct},{12:[1,361],47:lt,48:ct},e(Ae,[2,9]),{19:[1,362]},e(st,[2,195]),{39:363,81:S,102:O},{39:364,81:S,102:O},{19:[1,365],33:U,35:[1,366],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:367,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(Ae,[2,31]),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:368,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(Ae,kt,{44:Lt}),{19:[1,370],47:lt,48:ct},e(Ae,[2,47],{44:[1,371]}),{3:12,4:Te,5:131,6:33,7:i,14:r,16:s,17:127,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:xe,53:Oe,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,98:126,100:372,102:O},e(tt,[2,158]),{20:[1,373],47:mt},e(pt,$e,{11:374,46:Ue}),e(Ae,[2,13]),e(Ae,[2,14]),e(Ae,[2,17]),{8:76,9:se,13:oe,33:[1,375],37:ue},e(Ae,[2,16]),e(ft,$e,{11:376,46:Ue}),{30:[1,377],47:lt,48:ct},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:379,21:o,23:a,25:[1,378],29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(Ae,[2,166]),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:380,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(st,[2,168],{33:U,35:[1,382],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z,82:[1,381]}),e(st,[2,173],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(st,[2,174],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z,82:[1,383]}),e(st,[2,176],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z,82:[1,384]}),{8:76,9:se,13:oe,37:ue,104:[1,385]},{33:U,34:[1,386],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:387,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(st,[2,191],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(st,[2,192],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z,82:[1,388]}),e(ie,[2,74]),{20:[1,389],47:lt,48:ct},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:390,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{15:391,48:d},e(De,[2,53]),e(pt,$e,{11:392,46:Ue}),{74:bt},{20:[1,393],47:lt,48:ct},e(Ae,[2,6]),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:394,19:[1,395],21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{19:[1,397],33:U,35:[1,396],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},e(Ae,[2,38]),{20:[1,398],47:lt,48:ct},e(ie,[2,98]),{15:399,48:d},{15:400,48:d},{12:[1,401],47:lt,48:ct},{12:[1,402],47:lt,48:ct},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:403,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(ie,[2,124]),e(ie,[2,129]),e(ie,[2,130]),e(wt,[2,199]),{15:404,48:d},e(ie,[2,138],{92:[1,405]}),e(ie,[2,141]),e(ie,[2,146]),{15:406,48:d},e(Ae,[2,10]),e(st,[2,196]),e(st,[2,197]),e(Ae,[2,27]),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:407,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{19:[1,408],33:U,35:[1,409],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},{19:[1,410],33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},e(Ae,[2,48]),e([9,13,22,32,33,37,46,47,56,57,58,59,62,63,64,65,66,67,68,69,70,71,72,73,79,96],kt,{39:221,18:411,44:Lt,81:S,102:O}),e(Ae,[2,49]),e(tt,[2,159]),e(tt,[2,160]),{20:[1,412],47:lt,48:ct},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:334,21:o,23:a,25:[1,413],29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{12:[1,414],47:lt,48:ct},{28:[1,415],52:vt,74:bt},e(Ae,[2,24]),{25:[1,416],33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},{15:417,33:U,48:d,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:418,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:419,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:420,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:421,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:422,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:423,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(st,[2,181],{33:U,35:[1,425],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z,82:[1,424]}),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:426,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(ie,[2,80]),e(P,[2,66],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(ie,[2,114]),{20:[1,427],47:lt,48:ct},e(ie,[2,78]),{19:[1,429],33:U,35:[1,428],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},e(Ae,[2,36]),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:430,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(Ae,[2,37]),e(ie,[2,97]),e(ie,[2,115]),e(ie,[2,116]),{15:431,48:d},{15:432,48:d},e(Ze,[2,122],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K}),e(ie,[2,137]),{15:433,48:d},e(Ae,[2,8]),{19:[1,434],33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},e(Ae,[2,29]),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:435,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(Ae,[2,32]),{22:[1,436],39:301,47:dt,48:gt,81:S,102:O},e(tt,[2,152]),e(Ae,[2,25]),{25:[1,437]},{25:[1,438]},e(Ae,[2,26]),e(Ae,it,{40:439,89:rt}),e(st,[2,169],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(st,[2,170],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z,82:[1,440]}),e(st,[2,175],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(st,[2,177],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(st,[2,178],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z,82:[1,441]}),e(st,[2,180],{33:U,35:[1,443],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z,82:[1,442]}),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:444,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:445,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(st,[2,193],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(De,[2,54]),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:446,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(Ae,[2,35]),{19:[1,447],33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},e(ie,[2,117]),e(ie,[2,118]),e(ie,[2,139]),e(Ae,[2,28]),{19:[1,448],33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},e(Ae,[2,11]),e(Ae,[2,19]),e(Ae,[2,21]),e(Ae,[2,167]),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:449,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:450,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:451,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:452,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(st,[2,183],{33:U,35:[1,453],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(st,[2,185],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z,82:[1,454]}),{19:[1,455],33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z},e(Ae,[2,34]),e(Ae,[2,30]),e(st,[2,171],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(st,[2,179],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(st,[2,182],{33:U,35:[1,456],58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(st,[2,184],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z,82:[1,457]}),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:458,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:459,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(Ae,[2,33]),{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:460,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},{3:12,4:n,5:32,6:33,7:i,14:r,16:s,17:461,21:o,23:a,29:te,31:l,32:c,38:h,39:40,41:f,42:42,44:p,49:ye,55:13,59:v,60:b,61:w,75:k,76:L,77:A,78:E,80:C,81:S,83:R,84:N,85:_,90:T,93:I,97:x,102:O},e(st,[2,189],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(st,[2,187],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(st,[2,188],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z}),e(st,[2,186],{33:U,58:D,59:j,62:F,63:W,64:Y,65:z,66:G,67:H,68:J,69:q,70:K,71:V,72:X,79:Z})],defaultActions:{2:[2,204]},parseError:function Rt(e,t){if(t.recoverable){this.trace(e)}else{var n=new Error(e);n.hash=t;throw n}},parse:function Nt(e){var t=this,n=[0],i=[],r=[null],s=[],o=this.table,a="",u=0,l=0,c=0,h=2,f=1;var p=s.slice.call(arguments,1);var d=Object.create(this.lexer);var g={yy:{}};for(var m in this.yy){if(Object.prototype.hasOwnProperty.call(this.yy,m)){g.yy[m]=this.yy[m]}}d.setInput(e,g.yy);g.yy.lexer=d;g.yy.parser=this;if(typeof d.yylloc=="undefined"){d.yylloc={}}var y=d.yylloc;s.push(y);var v=d.options&&d.options.ranges;if(typeof g.yy.parseError==="function"){this.parseError=g.yy.parseError}else{this.parseError=Object.getPrototypeOf(this).parseError}function b(e){n.length=n.length-2*e;r.length=r.length-e;s.length=s.length-e}e:var w=function(){var e;e=d.lex()||f;if(typeof e!=="number"){e=t.symbols_[e]||e}return e};var k,L,A,E,C,S,R={},N,_,T,I;while(true){A=n[n.length-1];if(this.defaultActions[A]){E=this.defaultActions[A]}else{if(k===null||typeof k=="undefined"){k=w()}E=o[A]&&o[A][k]}if(typeof E==="undefined"||!E.length||!E[0]){var x="";I=[];for(N in o[A]){if(this.terminals_[N]&&N>h){I.push("'"+this.terminals_[N]+"'")}}if(d.showPosition){x="Parse error on line "+(u+1)+":\n"+d.showPosition()+"\nExpecting "+I.join(", ")+", got '"+(this.terminals_[k]||k)+"'"}else{x="Parse error on line "+(u+1)+": Unexpected "+(k==f?"end of input":"'"+(this.terminals_[k]||k)+"'")}this.parseError(x,{text:d.match,token:this.terminals_[k]||k,line:d.yylineno,loc:y,expected:I})}if(E[0]instanceof Array&&E.length>1){throw new Error("Parse Error: multiple actions possible at state: "+A+", token: "+k)}switch(E[0]){case 1:n.push(k);r.push(d.yytext);s.push(d.yylloc);n.push(E[1]);k=null;if(!L){l=d.yyleng;a=d.yytext;u=d.yylineno;y=d.yylloc;if(c>0){c--}}else{k=L;L=null}break;case 2:_=this.productions_[E[1]][1];R.$=r[r.length-_];R._$={first_line:s[s.length-(_||1)].first_line,last_line:s[s.length-1].last_line,first_column:s[s.length-(_||1)].first_column,last_column:s[s.length-1].last_column};if(v){R._$.range=[s[s.length-(_||1)].range[0],s[s.length-1].range[1]]}S=this.performAction.apply(R,[a,l,u,g.yy,E[1],r,s].concat(p));if(typeof S!=="undefined"){return S}if(_){n=n.slice(0,-1*_*2);r=r.slice(0,-1*_);s=s.slice(0,-1*_)}n.push(this.productions_[E[1]][0]);r.push(R.$);s.push(R._$);T=o[n[n.length-2]][n[n.length-1]];n.push(T);break;case 3:return true}}return true}};function Et(){this.yy={}}Et.prototype=At;At.Parser=Et;return new Et}();if(typeof e!=="undefined"&&typeof n!=="undefined"){n.parser=r;n.Parser=r.Parser;n.parse=function(){return r.parse.apply(r,arguments)};n.main=function s(t){if(!t[1]){console.log("Usage: "+t[0]+" FILE");i.exit(1)}var r=e("fs").readFileSync(e("path").normalize(t[1]),"utf8");return n.parser.parse(r)};if(typeof t!=="undefined"&&e.main===t){n.main(i.argv.slice(1))}}}).call(this,e("_process"))},{_process:20,fs:8,path:13}],6:[function(e,t,n){
  // Generated by blackpard 1.6.1
  var i,r,s;i=e("path");r=function(e){var t;if(t=/^['"](.*)['"]$/.exec(e.trim())){return t[1]}else{return e}};s=function(e){return i.basename(r(e)).split(".")[0].replace(/-[a-z]/gi,function(e){return e.charAt(1).toUpperCase()})};t.exports={nameFromPath:s,stripString:r}},{path:13}],7:[function(e,t,n){"use strict";n.byteLength=c;n.toByteArray=f;n.fromByteArray=g;var i=[];var r=[];var s=typeof Uint8Array!=="undefined"?Uint8Array:Array;var o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(var a=0,u=o.length;a<u;++a){i[a]=o[a];r[o.charCodeAt(a)]=a}
  // Support decoding URL-safe base64 strings, as Node.js does.
  // See: https://en.wikipedia.org/wiki/Base64#URL_applications
  r["-".charCodeAt(0)]=62;r["_".charCodeAt(0)]=63;function l(e){var t=e.length;if(t%4>0){throw new Error("Invalid string. Length must be a multiple of 4")}
  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var n=e.indexOf("=");if(n===-1)n=t;var i=n===t?0:4-n%4;return[n,i]}
  // base64 is 4/3 + up to two characters of the original data
  function c(e){var t=l(e);var n=t[0];var i=t[1];return(n+i)*3/4-i}function h(e,t,n){return(t+n)*3/4-n}function f(e){var t;var n=l(e);var i=n[0];var o=n[1];var a=new s(h(e,i,o));var u=0;
  // if there are placeholders, only get up to the last complete 4 chars
  var c=o>0?i-4:i;for(var f=0;f<c;f+=4){t=r[e.charCodeAt(f)]<<18|r[e.charCodeAt(f+1)]<<12|r[e.charCodeAt(f+2)]<<6|r[e.charCodeAt(f+3)];a[u++]=t>>16&255;a[u++]=t>>8&255;a[u++]=t&255}if(o===2){t=r[e.charCodeAt(f)]<<2|r[e.charCodeAt(f+1)]>>4;a[u++]=t&255}if(o===1){t=r[e.charCodeAt(f)]<<10|r[e.charCodeAt(f+1)]<<4|r[e.charCodeAt(f+2)]>>2;a[u++]=t>>8&255;a[u++]=t&255}return a}function p(e){return i[e>>18&63]+i[e>>12&63]+i[e>>6&63]+i[e&63]}function d(e,t,n){var i;var r=[];for(var s=t;s<n;s+=3){i=(e[s]<<16&16711680)+(e[s+1]<<8&65280)+(e[s+2]&255);r.push(p(i))}return r.join("")}function g(e){var t;var n=e.length;var r=n%3;// if we have 1 byte left, pad 2 bytes
  var s=[];var o=16383;// must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later
  for(var a=0,u=n-r;a<u;a+=o){s.push(d(e,a,a+o>u?u:a+o))}
  // pad the end with zeros, but make sure to not forget the extra bytes
  if(r===1){t=e[n-1];s.push(i[t>>2]+i[t<<4&63]+"==")}else if(r===2){t=(e[n-2]<<8)+e[n-1];s.push(i[t>>10]+i[t>>4&63]+i[t<<2&63]+"=")}return s.join("")}},{}],8:[function(e,t,n){},{}],9:[function(e,t,n){(function(t){/*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  /* eslint-disable no-proto */
  "use strict";var i=e("base64-js");var r=e("ieee754");var s=e("isarray");n.Buffer=l;n.SlowBuffer=b;n.INSPECT_MAX_BYTES=50;/**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.
  
   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */
  l.TYPED_ARRAY_SUPPORT=t.TYPED_ARRAY_SUPPORT!==undefined?t.TYPED_ARRAY_SUPPORT:o();/*
   * Export kMaxLength after typed array support is determined.
   */
  n.kMaxLength=a();function o(){try{var e=new Uint8Array(1);e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}};// typed array instances can be augmented
  // chrome 9-10 lack `subarray`
  return e.foo()===42&&typeof e.subarray==="function"&&e.subarray(1,1).byteLength===0}catch(t){return false}}function a(){return l.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function u(e,t){if(a()<t){throw new RangeError("Invalid typed array length")}if(l.TYPED_ARRAY_SUPPORT){
  // Return an augmented `Uint8Array` instance, for best performance
  e=new Uint8Array(t);e.__proto__=l.prototype}else{
  // Fallback: Return an object instance of the Buffer class
  if(e===null){e=new l(t)}e.length=t}return e}/**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */
  function l(e,t,n){if(!l.TYPED_ARRAY_SUPPORT&&!(this instanceof l)){return new l(e,t,n)}
  // Common case.
  if(typeof e==="number"){if(typeof t==="string"){throw new Error("If encoding is specified then the first argument must be a string")}return p(this,e)}return c(this,e,t,n)}l.poolSize=8192;// not used by this implementation
  // TODO: Legacy, not needed anymore. Remove in next major version.
  l._augment=function(e){e.__proto__=l.prototype;return e};function c(e,t,n,i){if(typeof t==="number"){throw new TypeError('"value" argument must not be a number')}if(typeof ArrayBuffer!=="undefined"&&t instanceof ArrayBuffer){return m(e,t,n,i)}if(typeof t==="string"){return d(e,t,n)}return y(e,t)}/**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/
  l.from=function(e,t,n){return c(null,e,t,n)};if(l.TYPED_ARRAY_SUPPORT){l.prototype.__proto__=Uint8Array.prototype;l.__proto__=Uint8Array;if(typeof Symbol!=="undefined"&&Symbol.species&&l[Symbol.species]===l){
  // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
  Object.defineProperty(l,Symbol.species,{value:null,configurable:true})}}function h(e){if(typeof e!=="number"){throw new TypeError('"size" argument must be a number')}else if(e<0){throw new RangeError('"size" argument must not be negative')}}function f(e,t,n,i){h(t);if(t<=0){return u(e,t)}if(n!==undefined){
  // Only pay attention to encoding if it's a string. This
  // prevents accidentally sending in a number that would
  // be interpretted as a start offset.
  return typeof i==="string"?u(e,t).fill(n,i):u(e,t).fill(n)}return u(e,t)}/**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/
  l.alloc=function(e,t,n){return f(null,e,t,n)};function p(e,t){h(t);e=u(e,t<0?0:v(t)|0);if(!l.TYPED_ARRAY_SUPPORT){for(var n=0;n<t;++n){e[n]=0}}return e}/**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */
  l.allocUnsafe=function(e){return p(null,e)};/**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */
  l.allocUnsafeSlow=function(e){return p(null,e)};function d(e,t,n){if(typeof n!=="string"||n===""){n="utf8"}if(!l.isEncoding(n)){throw new TypeError('"encoding" must be a valid string encoding')}var i=w(t,n)|0;e=u(e,i);var r=e.write(t,n);if(r!==i){
  // Writing a hex string, for example, that contains invalid characters will
  // cause everything after the first invalid character to be ignored. (e.g.
  // 'abxxcd' will be treated as 'ab')
  e=e.slice(0,r)}return e}function g(e,t){var n=t.length<0?0:v(t.length)|0;e=u(e,n);for(var i=0;i<n;i+=1){e[i]=t[i]&255}return e}function m(e,t,n,i){t.byteLength;// this throws if `array` is not a valid ArrayBuffer
  if(n<0||t.byteLength<n){throw new RangeError("'offset' is out of bounds")}if(t.byteLength<n+(i||0)){throw new RangeError("'length' is out of bounds")}if(n===undefined&&i===undefined){t=new Uint8Array(t)}else if(i===undefined){t=new Uint8Array(t,n)}else{t=new Uint8Array(t,n,i)}if(l.TYPED_ARRAY_SUPPORT){
  // Return an augmented `Uint8Array` instance, for best performance
  e=t;e.__proto__=l.prototype}else{
  // Fallback: Return an object instance of the Buffer class
  e=g(e,t)}return e}function y(e,t){if(l.isBuffer(t)){var n=v(t.length)|0;e=u(e,n);if(e.length===0){return e}t.copy(e,0,0,n);return e}if(t){if(typeof ArrayBuffer!=="undefined"&&t.buffer instanceof ArrayBuffer||"length"in t){if(typeof t.length!=="number"||te(t.length)){return u(e,0)}return g(e,t)}if(t.type==="Buffer"&&s(t.data)){return g(e,t.data)}}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}function v(e){
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if(e>=a()){throw new RangeError("Attempt to allocate Buffer larger than maximum "+"size: 0x"+a().toString(16)+" bytes")}return e|0}function b(e){if(+e!=e){// eslint-disable-line eqeqeq
  e=0}return l.alloc(+e)}l.isBuffer=function ne(e){return!!(e!=null&&e._isBuffer)};l.compare=function ie(e,t){if(!l.isBuffer(e)||!l.isBuffer(t)){throw new TypeError("Arguments must be Buffers")}if(e===t)return 0;var n=e.length;var i=t.length;for(var r=0,s=Math.min(n,i);r<s;++r){if(e[r]!==t[r]){n=e[r];i=t[r];break}}if(n<i)return-1;if(i<n)return 1;return 0};l.isEncoding=function re(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return true;default:return false}};l.concat=function se(e,t){if(!s(e)){throw new TypeError('"list" argument must be an Array of Buffers')}if(e.length===0){return l.alloc(0)}var n;if(t===undefined){t=0;for(n=0;n<e.length;++n){t+=e[n].length}}var i=l.allocUnsafe(t);var r=0;for(n=0;n<e.length;++n){var o=e[n];if(!l.isBuffer(o)){throw new TypeError('"list" argument must be an Array of Buffers')}o.copy(i,r);r+=o.length}return i};function w(e,t){if(l.isBuffer(e)){return e.length}if(typeof ArrayBuffer!=="undefined"&&typeof ArrayBuffer.isView==="function"&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer)){return e.byteLength}if(typeof e!=="string"){e=""+e}var n=e.length;if(n===0)return 0;
  // Use a for loop to avoid recursion
  var i=false;for(;;){switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":case undefined:return V(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return n*2;case"hex":return n>>>1;case"base64":return Q(e).length;default:if(i)return V(e).length;// assume utf8
  t=(""+t).toLowerCase();i=true}}}l.byteLength=w;function k(e,t,n){var i=false;
  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if(t===undefined||t<0){t=0}
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if(t>this.length){return""}if(n===undefined||n>this.length){n=this.length}if(n<=0){return""}
  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  n>>>=0;t>>>=0;if(n<=t){return""}if(!e)e="utf8";while(true){switch(e){case"hex":return $(this,t,n);case"utf8":case"utf-8":return x(this,t,n);case"ascii":return P(this,t,n);case"latin1":case"binary":return B(this,t,n);case"base64":return I(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return U(this,t,n);default:if(i)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase();i=true}}}
  // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.
  l.prototype._isBuffer=true;function L(e,t,n){var i=e[t];e[t]=e[n];e[n]=i}l.prototype.swap16=function oe(){var e=this.length;if(e%2!==0){throw new RangeError("Buffer size must be a multiple of 16-bits")}for(var t=0;t<e;t+=2){L(this,t,t+1)}return this};l.prototype.swap32=function ae(){var e=this.length;if(e%4!==0){throw new RangeError("Buffer size must be a multiple of 32-bits")}for(var t=0;t<e;t+=4){L(this,t,t+3);L(this,t+1,t+2)}return this};l.prototype.swap64=function ue(){var e=this.length;if(e%8!==0){throw new RangeError("Buffer size must be a multiple of 64-bits")}for(var t=0;t<e;t+=8){L(this,t,t+7);L(this,t+1,t+6);L(this,t+2,t+5);L(this,t+3,t+4)}return this};l.prototype.toString=function le(){var e=this.length|0;if(e===0)return"";if(arguments.length===0)return x(this,0,e);return k.apply(this,arguments)};l.prototype.equals=function ce(e){if(!l.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(this===e)return true;return l.compare(this,e)===0};l.prototype.inspect=function he(){var e="";var t=n.INSPECT_MAX_BYTES;if(this.length>0){e=this.toString("hex",0,t).match(/.{2}/g).join(" ");if(this.length>t)e+=" ... "}return"<Buffer "+e+">"};l.prototype.compare=function fe(e,t,n,i,r){if(!l.isBuffer(e)){throw new TypeError("Argument must be a Buffer")}if(t===undefined){t=0}if(n===undefined){n=e?e.length:0}if(i===undefined){i=0}if(r===undefined){r=this.length}if(t<0||n>e.length||i<0||r>this.length){throw new RangeError("out of range index")}if(i>=r&&t>=n){return 0}if(i>=r){return-1}if(t>=n){return 1}t>>>=0;n>>>=0;i>>>=0;r>>>=0;if(this===e)return 0;var s=r-i;var o=n-t;var a=Math.min(s,o);var u=this.slice(i,r);var c=e.slice(t,n);for(var h=0;h<a;++h){if(u[h]!==c[h]){s=u[h];o=c[h];break}}if(s<o)return-1;if(o<s)return 1;return 0};
  // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf
  function A(e,t,n,i,r){
  // Empty buffer means no match
  if(e.length===0)return-1;
  // Normalize byteOffset
  if(typeof n==="string"){i=n;n=0}else if(n>2147483647){n=2147483647}else if(n<-2147483648){n=-2147483648}n=+n;// Coerce to Number.
  if(isNaN(n)){
  // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
  n=r?0:e.length-1}
  // Normalize byteOffset: negative offsets start from the end of the buffer
  if(n<0)n=e.length+n;if(n>=e.length){if(r)return-1;else n=e.length-1}else if(n<0){if(r)n=0;else return-1}
  // Normalize val
  if(typeof t==="string"){t=l.from(t,i)}
  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if(l.isBuffer(t)){
  // Special case: looking for empty string/buffer always fails
  if(t.length===0){return-1}return E(e,t,n,i,r)}else if(typeof t==="number"){t=t&255;// Search for a byte value [0-255]
  if(l.TYPED_ARRAY_SUPPORT&&typeof Uint8Array.prototype.indexOf==="function"){if(r){return Uint8Array.prototype.indexOf.call(e,t,n)}else{return Uint8Array.prototype.lastIndexOf.call(e,t,n)}}return E(e,[t],n,i,r)}throw new TypeError("val must be string, number or Buffer")}function E(e,t,n,i,r){var s=1;var o=e.length;var a=t.length;if(i!==undefined){i=String(i).toLowerCase();if(i==="ucs2"||i==="ucs-2"||i==="utf16le"||i==="utf-16le"){if(e.length<2||t.length<2){return-1}s=2;o/=2;a/=2;n/=2}}function u(e,t){if(s===1){return e[t]}else{return e.readUInt16BE(t*s)}}var l;if(r){var c=-1;for(l=n;l<o;l++){if(u(e,l)===u(t,c===-1?0:l-c)){if(c===-1)c=l;if(l-c+1===a)return c*s}else{if(c!==-1)l-=l-c;c=-1}}}else{if(n+a>o)n=o-a;for(l=n;l>=0;l--){var h=true;for(var f=0;f<a;f++){if(u(e,l+f)!==u(t,f)){h=false;break}}if(h)return l}}return-1}l.prototype.includes=function pe(e,t,n){return this.indexOf(e,t,n)!==-1};l.prototype.indexOf=function de(e,t,n){return A(this,e,t,n,true)};l.prototype.lastIndexOf=function ge(e,t,n){return A(this,e,t,n,false)};function C(e,t,n,i){n=Number(n)||0;var r=e.length-n;if(!i){i=r}else{i=Number(i);if(i>r){i=r}}
  // must be an even number of digits
  var s=t.length;if(s%2!==0)throw new TypeError("Invalid hex string");if(i>s/2){i=s/2}for(var o=0;o<i;++o){var a=parseInt(t.substr(o*2,2),16);if(isNaN(a))return o;e[n+o]=a}return o}function S(e,t,n,i){return ee(V(t,e.length-n),e,n,i)}function R(e,t,n,i){return ee(X(t),e,n,i)}function N(e,t,n,i){return R(e,t,n,i)}function _(e,t,n,i){return ee(Q(t),e,n,i)}function T(e,t,n,i){return ee(Z(t,e.length-n),e,n,i)}l.prototype.write=function me(e,t,n,i){
  // Buffer#write(string)
  if(t===undefined){i="utf8";n=this.length;t=0}else if(n===undefined&&typeof t==="string"){i=t;n=this.length;t=0}else if(isFinite(t)){t=t|0;if(isFinite(n)){n=n|0;if(i===undefined)i="utf8"}else{i=n;n=undefined}}else{throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported")}var r=this.length-t;if(n===undefined||n>r)n=r;if(e.length>0&&(n<0||t<0)||t>this.length){throw new RangeError("Attempt to write outside buffer bounds")}if(!i)i="utf8";var s=false;for(;;){switch(i){case"hex":return C(this,e,t,n);case"utf8":case"utf-8":return S(this,e,t,n);case"ascii":return R(this,e,t,n);case"latin1":case"binary":return N(this,e,t,n);case"base64":
  // Warning: maxLength not taken into account in base64Write
  return _(this,e,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return T(this,e,t,n);default:if(s)throw new TypeError("Unknown encoding: "+i);i=(""+i).toLowerCase();s=true}}};l.prototype.toJSON=function ye(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function I(e,t,n){if(t===0&&n===e.length){return i.fromByteArray(e)}else{return i.fromByteArray(e.slice(t,n))}}function x(e,t,n){n=Math.min(e.length,n);var i=[];var r=t;while(r<n){var s=e[r];var o=null;var a=s>239?4:s>223?3:s>191?2:1;if(r+a<=n){var u,l,c,h;switch(a){case 1:if(s<128){o=s}break;case 2:u=e[r+1];if((u&192)===128){h=(s&31)<<6|u&63;if(h>127){o=h}}break;case 3:u=e[r+1];l=e[r+2];if((u&192)===128&&(l&192)===128){h=(s&15)<<12|(u&63)<<6|l&63;if(h>2047&&(h<55296||h>57343)){o=h}}break;case 4:u=e[r+1];l=e[r+2];c=e[r+3];if((u&192)===128&&(l&192)===128&&(c&192)===128){h=(s&15)<<18|(u&63)<<12|(l&63)<<6|c&63;if(h>65535&&h<1114112){o=h}}}}if(o===null){
  // we did not generate a valid codePoint so insert a
  // replacement char (U+FFFD) and advance only 1 byte
  o=65533;a=1}else if(o>65535){
  // encode to utf16 (surrogate pair dance)
  o-=65536;i.push(o>>>10&1023|55296);o=56320|o&1023}i.push(o);r+=a}return M(i)}
  // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety
  var O=4096;function M(e){var t=e.length;if(t<=O){return String.fromCharCode.apply(String,e)}
  // Decode in chunks to avoid "call stack size exceeded".
  var n="";var i=0;while(i<t){n+=String.fromCharCode.apply(String,e.slice(i,i+=O))}return n}function P(e,t,n){var i="";n=Math.min(e.length,n);for(var r=t;r<n;++r){i+=String.fromCharCode(e[r]&127)}return i}function B(e,t,n){var i="";n=Math.min(e.length,n);for(var r=t;r<n;++r){i+=String.fromCharCode(e[r])}return i}function $(e,t,n){var i=e.length;if(!t||t<0)t=0;if(!n||n<0||n>i)n=i;var r="";for(var s=t;s<n;++s){r+=K(e[s])}return r}function U(e,t,n){var i=e.slice(t,n);var r="";for(var s=0;s<i.length;s+=2){r+=String.fromCharCode(i[s]+i[s+1]*256)}return r}l.prototype.slice=function ve(e,t){var n=this.length;e=~~e;t=t===undefined?n:~~t;if(e<0){e+=n;if(e<0)e=0}else if(e>n){e=n}if(t<0){t+=n;if(t<0)t=0}else if(t>n){t=n}if(t<e)t=e;var i;if(l.TYPED_ARRAY_SUPPORT){i=this.subarray(e,t);i.__proto__=l.prototype}else{var r=t-e;i=new l(r,undefined);for(var s=0;s<r;++s){i[s]=this[s+e]}}return i};/*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */
  function D(e,t,n){if(e%1!==0||e<0)throw new RangeError("offset is not uint");if(e+t>n)throw new RangeError("Trying to access beyond buffer length")}l.prototype.readUIntLE=function be(e,t,n){e=e|0;t=t|0;if(!n)D(e,t,this.length);var i=this[e];var r=1;var s=0;while(++s<t&&(r*=256)){i+=this[e+s]*r}return i};l.prototype.readUIntBE=function we(e,t,n){e=e|0;t=t|0;if(!n){D(e,t,this.length)}var i=this[e+--t];var r=1;while(t>0&&(r*=256)){i+=this[e+--t]*r}return i};l.prototype.readUInt8=function ke(e,t){if(!t)D(e,1,this.length);return this[e]};l.prototype.readUInt16LE=function Le(e,t){if(!t)D(e,2,this.length);return this[e]|this[e+1]<<8};l.prototype.readUInt16BE=function Ae(e,t){if(!t)D(e,2,this.length);return this[e]<<8|this[e+1]};l.prototype.readUInt32LE=function Ee(e,t){if(!t)D(e,4,this.length);return(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};l.prototype.readUInt32BE=function Ce(e,t){if(!t)D(e,4,this.length);return this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};l.prototype.readIntLE=function Se(e,t,n){e=e|0;t=t|0;if(!n)D(e,t,this.length);var i=this[e];var r=1;var s=0;while(++s<t&&(r*=256)){i+=this[e+s]*r}r*=128;if(i>=r)i-=Math.pow(2,8*t);return i};l.prototype.readIntBE=function Re(e,t,n){e=e|0;t=t|0;if(!n)D(e,t,this.length);var i=t;var r=1;var s=this[e+--i];while(i>0&&(r*=256)){s+=this[e+--i]*r}r*=128;if(s>=r)s-=Math.pow(2,8*t);return s};l.prototype.readInt8=function Ne(e,t){if(!t)D(e,1,this.length);if(!(this[e]&128))return this[e];return(255-this[e]+1)*-1};l.prototype.readInt16LE=function _e(e,t){if(!t)D(e,2,this.length);var n=this[e]|this[e+1]<<8;return n&32768?n|4294901760:n};l.prototype.readInt16BE=function Te(e,t){if(!t)D(e,2,this.length);var n=this[e+1]|this[e]<<8;return n&32768?n|4294901760:n};l.prototype.readInt32LE=function Ie(e,t){if(!t)D(e,4,this.length);return this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};l.prototype.readInt32BE=function xe(e,t){if(!t)D(e,4,this.length);return this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};l.prototype.readFloatLE=function Oe(e,t){if(!t)D(e,4,this.length);return r.read(this,e,true,23,4)};l.prototype.readFloatBE=function Me(e,t){if(!t)D(e,4,this.length);return r.read(this,e,false,23,4)};l.prototype.readDoubleLE=function Pe(e,t){if(!t)D(e,8,this.length);return r.read(this,e,true,52,8)};l.prototype.readDoubleBE=function Be(e,t){if(!t)D(e,8,this.length);return r.read(this,e,false,52,8)};function j(e,t,n,i,r,s){if(!l.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>r||t<s)throw new RangeError('"value" argument is out of bounds');if(n+i>e.length)throw new RangeError("Index out of range")}l.prototype.writeUIntLE=function $e(e,t,n,i){e=+e;t=t|0;n=n|0;if(!i){var r=Math.pow(2,8*n)-1;j(this,e,t,n,r,0)}var s=1;var o=0;this[t]=e&255;while(++o<n&&(s*=256)){this[t+o]=e/s&255}return t+n};l.prototype.writeUIntBE=function Ue(e,t,n,i){e=+e;t=t|0;n=n|0;if(!i){var r=Math.pow(2,8*n)-1;j(this,e,t,n,r,0)}var s=n-1;var o=1;this[t+s]=e&255;while(--s>=0&&(o*=256)){this[t+s]=e/o&255}return t+n};l.prototype.writeUInt8=function De(e,t,n){e=+e;t=t|0;if(!n)j(this,e,t,1,255,0);if(!l.TYPED_ARRAY_SUPPORT)e=Math.floor(e);this[t]=e&255;return t+1};function F(e,t,n,i){if(t<0)t=65535+t+1;for(var r=0,s=Math.min(e.length-n,2);r<s;++r){e[n+r]=(t&255<<8*(i?r:1-r))>>>(i?r:1-r)*8}}l.prototype.writeUInt16LE=function je(e,t,n){e=+e;t=t|0;if(!n)j(this,e,t,2,65535,0);if(l.TYPED_ARRAY_SUPPORT){this[t]=e&255;this[t+1]=e>>>8}else{F(this,e,t,true)}return t+2};l.prototype.writeUInt16BE=function Fe(e,t,n){e=+e;t=t|0;if(!n)j(this,e,t,2,65535,0);if(l.TYPED_ARRAY_SUPPORT){this[t]=e>>>8;this[t+1]=e&255}else{F(this,e,t,false)}return t+2};function W(e,t,n,i){if(t<0)t=4294967295+t+1;for(var r=0,s=Math.min(e.length-n,4);r<s;++r){e[n+r]=t>>>(i?r:3-r)*8&255}}l.prototype.writeUInt32LE=function We(e,t,n){e=+e;t=t|0;if(!n)j(this,e,t,4,4294967295,0);if(l.TYPED_ARRAY_SUPPORT){this[t+3]=e>>>24;this[t+2]=e>>>16;this[t+1]=e>>>8;this[t]=e&255}else{W(this,e,t,true)}return t+4};l.prototype.writeUInt32BE=function Ye(e,t,n){e=+e;t=t|0;if(!n)j(this,e,t,4,4294967295,0);if(l.TYPED_ARRAY_SUPPORT){this[t]=e>>>24;this[t+1]=e>>>16;this[t+2]=e>>>8;this[t+3]=e&255}else{W(this,e,t,false)}return t+4};l.prototype.writeIntLE=function ze(e,t,n,i){e=+e;t=t|0;if(!i){var r=Math.pow(2,8*n-1);j(this,e,t,n,r-1,-r)}var s=0;var o=1;var a=0;this[t]=e&255;while(++s<n&&(o*=256)){if(e<0&&a===0&&this[t+s-1]!==0){a=1}this[t+s]=(e/o>>0)-a&255}return t+n};l.prototype.writeIntBE=function Ge(e,t,n,i){e=+e;t=t|0;if(!i){var r=Math.pow(2,8*n-1);j(this,e,t,n,r-1,-r)}var s=n-1;var o=1;var a=0;this[t+s]=e&255;while(--s>=0&&(o*=256)){if(e<0&&a===0&&this[t+s+1]!==0){a=1}this[t+s]=(e/o>>0)-a&255}return t+n};l.prototype.writeInt8=function He(e,t,n){e=+e;t=t|0;if(!n)j(this,e,t,1,127,-128);if(!l.TYPED_ARRAY_SUPPORT)e=Math.floor(e);if(e<0)e=255+e+1;this[t]=e&255;return t+1};l.prototype.writeInt16LE=function Je(e,t,n){e=+e;t=t|0;if(!n)j(this,e,t,2,32767,-32768);if(l.TYPED_ARRAY_SUPPORT){this[t]=e&255;this[t+1]=e>>>8}else{F(this,e,t,true)}return t+2};l.prototype.writeInt16BE=function qe(e,t,n){e=+e;t=t|0;if(!n)j(this,e,t,2,32767,-32768);if(l.TYPED_ARRAY_SUPPORT){this[t]=e>>>8;this[t+1]=e&255}else{F(this,e,t,false)}return t+2};l.prototype.writeInt32LE=function Ke(e,t,n){e=+e;t=t|0;if(!n)j(this,e,t,4,2147483647,-2147483648);if(l.TYPED_ARRAY_SUPPORT){this[t]=e&255;this[t+1]=e>>>8;this[t+2]=e>>>16;this[t+3]=e>>>24}else{W(this,e,t,true)}return t+4};l.prototype.writeInt32BE=function Ve(e,t,n){e=+e;t=t|0;if(!n)j(this,e,t,4,2147483647,-2147483648);if(e<0)e=4294967295+e+1;if(l.TYPED_ARRAY_SUPPORT){this[t]=e>>>24;this[t+1]=e>>>16;this[t+2]=e>>>8;this[t+3]=e&255}else{W(this,e,t,false)}return t+4};function Y(e,t,n,i,r,s){if(n+i>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function z(e,t,n,i,s){if(!s){Y(e,t,n,4,3.4028234663852886e38,-3.4028234663852886e38)}r.write(e,t,n,i,23,4);return n+4}l.prototype.writeFloatLE=function Xe(e,t,n){return z(this,e,t,true,n)};l.prototype.writeFloatBE=function Ze(e,t,n){return z(this,e,t,false,n)};function G(e,t,n,i,s){if(!s){Y(e,t,n,8,1.7976931348623157e308,-1.7976931348623157e308)}r.write(e,t,n,i,52,8);return n+8}l.prototype.writeDoubleLE=function Qe(e,t,n){return G(this,e,t,true,n)};l.prototype.writeDoubleBE=function et(e,t,n){return G(this,e,t,false,n)};
  // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
  l.prototype.copy=function tt(e,t,n,i){if(!n)n=0;if(!i&&i!==0)i=this.length;if(t>=e.length)t=e.length;if(!t)t=0;if(i>0&&i<n)i=n;
  // Copy 0 bytes; we're done
  if(i===n)return 0;if(e.length===0||this.length===0)return 0;
  // Fatal error conditions
  if(t<0){throw new RangeError("targetStart out of bounds")}if(n<0||n>=this.length)throw new RangeError("sourceStart out of bounds");if(i<0)throw new RangeError("sourceEnd out of bounds");
  // Are we oob?
  if(i>this.length)i=this.length;if(e.length-t<i-n){i=e.length-t+n}var r=i-n;var s;if(this===e&&n<t&&t<i){
  // descending copy from end
  for(s=r-1;s>=0;--s){e[s+t]=this[s+n]}}else if(r<1e3||!l.TYPED_ARRAY_SUPPORT){
  // ascending copy from start
  for(s=0;s<r;++s){e[s+t]=this[s+n]}}else{Uint8Array.prototype.set.call(e,this.subarray(n,n+r),t)}return r};
  // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])
  l.prototype.fill=function nt(e,t,n,i){
  // Handle string cases:
  if(typeof e==="string"){if(typeof t==="string"){i=t;t=0;n=this.length}else if(typeof n==="string"){i=n;n=this.length}if(e.length===1){var r=e.charCodeAt(0);if(r<256){e=r}}if(i!==undefined&&typeof i!=="string"){throw new TypeError("encoding must be a string")}if(typeof i==="string"&&!l.isEncoding(i)){throw new TypeError("Unknown encoding: "+i)}}else if(typeof e==="number"){e=e&255}
  // Invalid ranges are not set to a default, so can range check early.
  if(t<0||this.length<t||this.length<n){throw new RangeError("Out of range index")}if(n<=t){return this}t=t>>>0;n=n===undefined?this.length:n>>>0;if(!e)e=0;var s;if(typeof e==="number"){for(s=t;s<n;++s){this[s]=e}}else{var o=l.isBuffer(e)?e:V(new l(e,i).toString());var a=o.length;for(s=0;s<n-t;++s){this[s+t]=o[s%a]}}return this};
  // HELPER FUNCTIONS
  // ================
  var H=/[^+\/0-9A-Za-z-_]/g;function J(e){
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  e=q(e).replace(H,"");
  // Node converts strings with length < 2 to ''
  if(e.length<2)return"";
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while(e.length%4!==0){e=e+"="}return e}function q(e){if(e.trim)return e.trim();return e.replace(/^\s+|\s+$/g,"")}function K(e){if(e<16)return"0"+e.toString(16);return e.toString(16)}function V(e,t){t=t||Infinity;var n;var i=e.length;var r=null;var s=[];for(var o=0;o<i;++o){n=e.charCodeAt(o);
  // is surrogate component
  if(n>55295&&n<57344){
  // last char was a lead
  if(!r){
  // no lead yet
  if(n>56319){
  // unexpected trail
  if((t-=3)>-1)s.push(239,191,189);continue}else if(o+1===i){
  // unpaired lead
  if((t-=3)>-1)s.push(239,191,189);continue}
  // valid lead
  r=n;continue}
  // 2 leads in a row
  if(n<56320){if((t-=3)>-1)s.push(239,191,189);r=n;continue}
  // valid surrogate pair
  n=(r-55296<<10|n-56320)+65536}else if(r){
  // valid bmp char, but last char was a lead
  if((t-=3)>-1)s.push(239,191,189)}r=null;
  // encode utf8
  if(n<128){if((t-=1)<0)break;s.push(n)}else if(n<2048){if((t-=2)<0)break;s.push(n>>6|192,n&63|128)}else if(n<65536){if((t-=3)<0)break;s.push(n>>12|224,n>>6&63|128,n&63|128)}else if(n<1114112){if((t-=4)<0)break;s.push(n>>18|240,n>>12&63|128,n>>6&63|128,n&63|128)}else{throw new Error("Invalid code point")}}return s}function X(e){var t=[];for(var n=0;n<e.length;++n){
  // Node's code seems to be doing this and not & 0x7F..
  t.push(e.charCodeAt(n)&255)}return t}function Z(e,t){var n,i,r;var s=[];for(var o=0;o<e.length;++o){if((t-=2)<0)break;n=e.charCodeAt(o);i=n>>8;r=n%256;s.push(r);s.push(i)}return s}function Q(e){return i.toByteArray(J(e))}function ee(e,t,n,i){for(var r=0;r<i;++r){if(r+n>=t.length||r>=e.length)break;t[r+n]=e[r]}return r}function te(e){return e!==e}}).call(this,typeof global!=="undefined"?global:typeof self!=="undefined"?self:typeof window!=="undefined"?window:{})},{"base64-js":7,ieee754:11,isarray:12}],10:[function(e,t,n){
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.
  function i(){this._events=this._events||{};this._maxListeners=this._maxListeners||undefined}t.exports=i;
  // Backwards-compat with node 0.10.x
  i.EventEmitter=i;i.prototype._events=undefined;i.prototype._maxListeners=undefined;
  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  i.defaultMaxListeners=10;
  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  i.prototype.setMaxListeners=function(e){if(!s(e)||e<0||isNaN(e))throw TypeError("n must be a positive number");this._maxListeners=e;return this};i.prototype.emit=function(e){var t,n,i,s,u,l;if(!this._events)this._events={};
  // If there is no 'error' event listener then throw.
  if(e==="error"){if(!this._events.error||o(this._events.error)&&!this._events.error.length){t=arguments[1];if(t instanceof Error){throw t}else{
  // At least give some kind of context to the user
  var c=new Error('Uncaught, unspecified "error" event. ('+t+")");c.context=t;throw c}}}n=this._events[e];if(a(n))return false;if(r(n)){switch(arguments.length){
  // fast cases
  case 1:n.call(this);break;case 2:n.call(this,arguments[1]);break;case 3:n.call(this,arguments[1],arguments[2]);break;
  // slower
  default:s=Array.prototype.slice.call(arguments,1);n.apply(this,s)}}else if(o(n)){s=Array.prototype.slice.call(arguments,1);l=n.slice();i=l.length;for(u=0;u<i;u++)l[u].apply(this,s)}return true};i.prototype.addListener=function(e,t){var n;if(!r(t))throw TypeError("listener must be a function");if(!this._events)this._events={};
  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if(this._events.newListener)this.emit("newListener",e,r(t.listener)?t.listener:t);if(!this._events[e])
  // Optimize the case of one listener. Don't need the extra array object.
  this._events[e]=t;else if(o(this._events[e]))
  // If we've already got an array, just append.
  this._events[e].push(t);else
  // Adding the second element, need to change to array.
  this._events[e]=[this._events[e],t];
  // Check for listener leak
  if(o(this._events[e])&&!this._events[e].warned){if(!a(this._maxListeners)){n=this._maxListeners}else{n=i.defaultMaxListeners}if(n&&n>0&&this._events[e].length>n){this._events[e].warned=true;console.error("(node) warning: possible EventEmitter memory "+"leak detected. %d listeners added. "+"Use emitter.setMaxListeners() to increase limit.",this._events[e].length);if(typeof console.trace==="function"){
  // not supported in IE 10
  console.trace()}}}return this};i.prototype.on=i.prototype.addListener;i.prototype.once=function(e,t){if(!r(t))throw TypeError("listener must be a function");var n=false;function i(){this.removeListener(e,i);if(!n){n=true;t.apply(this,arguments)}}i.listener=t;this.on(e,i);return this};
  // emits a 'removeListener' event iff the listener was removed
  i.prototype.removeListener=function(e,t){var n,i,s,a;if(!r(t))throw TypeError("listener must be a function");if(!this._events||!this._events[e])return this;n=this._events[e];s=n.length;i=-1;if(n===t||r(n.listener)&&n.listener===t){delete this._events[e];if(this._events.removeListener)this.emit("removeListener",e,t)}else if(o(n)){for(a=s;a-- >0;){if(n[a]===t||n[a].listener&&n[a].listener===t){i=a;break}}if(i<0)return this;if(n.length===1){n.length=0;delete this._events[e]}else{n.splice(i,1)}if(this._events.removeListener)this.emit("removeListener",e,t)}return this};i.prototype.removeAllListeners=function(e){var t,n;if(!this._events)return this;
  // not listening for removeListener, no need to emit
  if(!this._events.removeListener){if(arguments.length===0)this._events={};else if(this._events[e])delete this._events[e];return this}
  // emit removeListener for all listeners on all events
  if(arguments.length===0){for(t in this._events){if(t==="removeListener")continue;this.removeAllListeners(t)}this.removeAllListeners("removeListener");this._events={};return this}n=this._events[e];if(r(n)){this.removeListener(e,n)}else if(n){
  // LIFO order
  while(n.length)this.removeListener(e,n[n.length-1])}delete this._events[e];return this};i.prototype.listeners=function(e){var t;if(!this._events||!this._events[e])t=[];else if(r(this._events[e]))t=[this._events[e]];else t=this._events[e].slice();return t};i.prototype.listenerCount=function(e){if(this._events){var t=this._events[e];if(r(t))return 1;else if(t)return t.length}return 0};i.listenerCount=function(e,t){return e.listenerCount(t)};function r(e){return typeof e==="function"}function s(e){return typeof e==="number"}function o(e){return typeof e==="object"&&e!==null}function a(e){return e===void 0}},{}],11:[function(e,t,n){n.read=function(e,t,n,i,r){var s,o;var a=r*8-i-1;var u=(1<<a)-1;var l=u>>1;var c=-7;var h=n?r-1:0;var f=n?-1:1;var p=e[t+h];h+=f;s=p&(1<<-c)-1;p>>=-c;c+=a;for(;c>0;s=s*256+e[t+h],h+=f,c-=8){}o=s&(1<<-c)-1;s>>=-c;c+=i;for(;c>0;o=o*256+e[t+h],h+=f,c-=8){}if(s===0){s=1-l}else if(s===u){return o?NaN:(p?-1:1)*Infinity}else{o=o+Math.pow(2,i);s=s-l}return(p?-1:1)*o*Math.pow(2,s-i)};n.write=function(e,t,n,i,r,s){var o,a,u;var l=s*8-r-1;var c=(1<<l)-1;var h=c>>1;var f=r===23?Math.pow(2,-24)-Math.pow(2,-77):0;var p=i?0:s-1;var d=i?1:-1;var g=t<0||t===0&&1/t<0?1:0;t=Math.abs(t);if(isNaN(t)||t===Infinity){a=isNaN(t)?1:0;o=c}else{o=Math.floor(Math.log(t)/Math.LN2);if(t*(u=Math.pow(2,-o))<1){o--;u*=2}if(o+h>=1){t+=f/u}else{t+=f*Math.pow(2,1-h)}if(t*u>=2){o++;u/=2}if(o+h>=c){a=0;o=c}else if(o+h>=1){a=(t*u-1)*Math.pow(2,r);o=o+h}else{a=t*Math.pow(2,h-1)*Math.pow(2,r);o=0}}for(;r>=8;e[n+p]=a&255,p+=d,a/=256,r-=8){}o=o<<r|a;l+=r;for(;l>0;e[n+p]=o&255,p+=d,o/=256,l-=8){}e[n+p-d]|=g*128}},{}],12:[function(e,t,n){var i={}.toString;t.exports=Array.isArray||function(e){return i.call(e)=="[object Array]"}},{}],13:[function(e,t,n){(function(e){
  // .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
  // backported and transplited with Babel, with backwards-compat fixes
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.
  // resolves . and .. elements in a path array with directory names there
  // must be no slashes, empty elements, or device names (c:\) in the array
  // (so also no leading and trailing slashes - it does not distinguish
  // relative and absolute paths)
  function t(e,t){
  // if the path tries to go above the root, `up` ends up > 0
  var n=0;for(var i=e.length-1;i>=0;i--){var r=e[i];if(r==="."){e.splice(i,1)}else if(r===".."){e.splice(i,1);n++}else if(n){e.splice(i,1);n--}}
  // if the path is allowed to go above the root, restore leading ..s
  if(t){for(;n--;n){e.unshift("..")}}return e}
  // path.resolve([from ...], to)
  // posix version
  n.resolve=function(){var n="",i=false;for(var s=arguments.length-1;s>=-1&&!i;s--){var o=s>=0?arguments[s]:e.cwd();
  // Skip empty and invalid entries
  if(typeof o!=="string"){throw new TypeError("Arguments to path.resolve must be strings")}else if(!o){continue}n=o+"/"+n;i=o.charAt(0)==="/"}
  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)
  // Normalize the path
  n=t(r(n.split("/"),function(e){return!!e}),!i).join("/");return(i?"/":"")+n||"."};
  // path.normalize(path)
  // posix version
  n.normalize=function(e){var i=n.isAbsolute(e),o=s(e,-1)==="/";
  // Normalize the path
  e=t(r(e.split("/"),function(e){return!!e}),!i).join("/");if(!e&&!i){e="."}if(e&&o){e+="/"}return(i?"/":"")+e};
  // posix version
  n.isAbsolute=function(e){return e.charAt(0)==="/"};
  // posix version
  n.join=function(){var e=Array.prototype.slice.call(arguments,0);return n.normalize(r(e,function(e,t){if(typeof e!=="string"){throw new TypeError("Arguments to path.join must be strings")}return e}).join("/"))};
  // path.relative(from, to)
  // posix version
  n.relative=function(e,t){e=n.resolve(e).substr(1);t=n.resolve(t).substr(1);function i(e){var t=0;for(;t<e.length;t++){if(e[t]!=="")break}var n=e.length-1;for(;n>=0;n--){if(e[n]!=="")break}if(t>n)return[];return e.slice(t,n-t+1)}var r=i(e.split("/"));var s=i(t.split("/"));var o=Math.min(r.length,s.length);var a=o;for(var u=0;u<o;u++){if(r[u]!==s[u]){a=u;break}}var l=[];for(var u=a;u<r.length;u++){l.push("..")}l=l.concat(s.slice(a));return l.join("/")};n.sep="/";n.delimiter=":";n.dirname=function(e){if(typeof e!=="string")e=e+"";if(e.length===0)return".";var t=e.charCodeAt(0);var n=t===47;var i=-1;var r=true;for(var s=e.length-1;s>=1;--s){t=e.charCodeAt(s);if(t===47){if(!r){i=s;break}}else{
  // We saw the first non-path separator
  r=false}}if(i===-1)return n?"/":".";if(n&&i===1){
  // return '//';
  // Backwards-compat fix:
  return"/"}return e.slice(0,i)};function i(e){if(typeof e!=="string")e=e+"";var t=0;var n=-1;var i=true;var r;for(r=e.length-1;r>=0;--r){if(e.charCodeAt(r)===47){
  // If we reached a path separator that was not part of a set of path
  // separators at the end of the string, stop now
  if(!i){t=r+1;break}}else if(n===-1){
  // We saw the first non-path separator, mark this as the end of our
  // path component
  i=false;n=r+1}}if(n===-1)return"";return e.slice(t,n)}
  // Uses a mixed approach for backwards-compatibility, as ext behavior changed
  // in new Node.js versions, so only basename() above is backported here
  n.basename=function(e,t){var n=i(e);if(t&&n.substr(-1*t.length)===t){n=n.substr(0,n.length-t.length)}return n};n.extname=function(e){if(typeof e!=="string")e=e+"";var t=-1;var n=0;var i=-1;var r=true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var s=0;for(var o=e.length-1;o>=0;--o){var a=e.charCodeAt(o);if(a===47){
  // If we reached a path separator that was not part of a set of path
  // separators at the end of the string, stop now
  if(!r){n=o+1;break}continue}if(i===-1){
  // We saw the first non-path separator, mark this as the end of our
  // extension
  r=false;i=o+1}if(a===46){
  // If this is our first dot, mark it as the start of our extension
  if(t===-1)t=o;else if(s!==1)s=1}else if(t!==-1){
  // We saw a non-dot and non-path separator before our dot, so we should
  // have a good chance at having a non-empty extension
  s=-1}}if(t===-1||i===-1||
  // We saw a non-dot character immediately before the dot
  s===0||
  // The (right-most) trimmed path component is exactly '..'
  s===1&&t===i-1&&t===n+1){return""}return e.slice(t,i)};function r(e,t){if(e.filter)return e.filter(t);var n=[];for(var i=0;i<e.length;i++){if(t(e[i],i,e))n.push(e[i])}return n}
  // String.prototype.substr - negative index don't work in IE8
  var s="ab".substr(-1)==="b"?function(e,t,n){return e.substr(t,n)}:function(e,t,n){if(t<0)t=e.length+t;return e.substr(t,n)}}).call(this,e("_process"))},{_process:20}],14:[function(e,t,n){
  // Generated by blackpard 1.6.0
  var i,r,s,o,a,u,l={}.toString;i=c(function(e,t){return e.apply(null,t)});r=function(e){return c(e)};s=c(function(e,t,n){return e(n,t)});o=function(e){return function(t){return function(){return e(t(t)).apply(null,arguments)}}(function(t){return function(){return e(t(t)).apply(null,arguments)}})};a=c(function(e,t,n,i){return e(t(n),t(i))});u=function(e){var t;t={};return function(){var n,i,r,s,o,a;i=[];for(r=0,s=arguments.length;r<s;++r){i.push(arguments[r])}n=i;o=function(){var e,t,i,r=[];for(e=0,i=(t=n).length;e<i;++e){a=t[e];r.push(a+l.call(a).slice(8,-1))}return r}().join("");return t[o]=o in t?t[o]:e.apply(null,n)}};t.exports={curry:r,flip:s,fix:o,apply:i,over:a,memoize:u};function c(e,t){var n,i=function(r){return e.length>1?function(){var s=r?r.concat():[];n=t?n||this:this;return s.push.apply(s,arguments)<e.length&&arguments.length?i.call(n,s):e.apply(n,s)}:e};return i()}},{}],15:[function(e,t,n){
  // Generated by blackpard 1.6.0
  var i,r,s,o,a,u,l,c,h,f,p,d,g,m,y,v,b,w,k,L,A,E,C,S,R,N,_,T,I,x,O,M,P,B,$,U,D,j,F,W,Y,z,G,H,J,q,K,V,X,Z,Q,ee,te,ne,ie,re,se,oe,ae,ue,le,ce,he,fe,pe,de,ge,me,ye,ve,be={}.toString;i=we(function(e,t){var n,i,r;for(n=0,i=t.length;n<i;++n){r=t[n];e(r)}return t});r=we(function(e,t){var n,i,r,s=[];for(n=0,i=t.length;n<i;++n){r=t[n];s.push(e(r))}return s});s=function(e){var t,n,i,r=[];for(t=0,n=e.length;t<n;++t){i=e[t];if(i){r.push(i)}}return r};o=we(function(e,t){var n,i,r,s=[];for(n=0,i=t.length;n<i;++n){r=t[n];if(e(r)){s.push(r)}}return s});a=we(function(e,t){var n,i,r,s=[];for(n=0,i=t.length;n<i;++n){r=t[n];if(!e(r)){s.push(r)}}return s});u=we(function(e,t){var n,i;n=ge(e,t);i=t.slice();if(n!=null){i.splice(n,1)}return i});l=we(function(e,t){var n,i,r,s,o;n=[];i=[];for(r=0,s=t.length;r<s;++r){o=t[r];(e(o)?n:i).push(o)}return[n,i]});c=we(function(e,t){var n,i,r;for(n=0,i=t.length;n<i;++n){r=t[n];if(e(r)){return r}}});h=f=function(e){return e[0]};p=function(e){if(!e.length){return}return e.slice(1)};d=function(e){return e[e.length-1]};g=function(e){if(!e.length){return}return e.slice(0,-1)};m=function(e){return!e.length};y=function(e){return e.concat().reverse()};v=function(e){var t,n,i,r;t=[];for(n=0,i=e.length;n<i;++n){r=e[n];if(!ke(r,t)){t.push(r)}}return t};b=we(function(e,t){var n,i,r,s,o,a=[];n=[];for(i=0,r=t.length;i<r;++i){s=t[i];o=e(s);if(ke(o,n)){continue}n.push(o);a.push(s)}return a});w=k=we(function(e,t,n){var i,r,s;for(i=0,r=n.length;i<r;++i){s=n[i];t=e(t,s)}return t});L=A=we(function(e,t){return w(e,t[0],t.slice(1))});E=we(function(e,t,n){var i,r;for(i=n.length-1;i>=0;--i){r=n[i];t=e(r,t)}return t});C=we(function(e,t){return E(e,t[t.length-1],t.slice(0,-1))});S=we(function(e,t){var n,i,r;n=[];i=t;while((r=e(i))!=null){n.push(r[0]);i=r[1]}return n});R=function(e){return[].concat.apply([],e)};N=we(function(e,t){var n;return[].concat.apply([],function(){var i,r,s,o=[];for(i=0,s=(r=t).length;i<s;++i){n=r[i];o.push(e(n))}return o}())});_=function(e){var t;return[].concat.apply([],function(){var n,i,r,s=[];for(n=0,r=(i=e).length;n<r;++n){t=i[n];if(be.call(t).slice(8,-1)==="Array"){s.push(_(t))}else{s.push(t)}}return s}())};T=function(e){var t,n,i,r,s,o,a,u,l,c;n=[];for(i=1,r=arguments.length;i<r;++i){n.push(arguments[i])}t=n;s=[];e:for(i=0,o=e.length;i<o;++i){a=e[i];for(u=0,l=t.length;u<l;++u){c=t[u];if(ke(a,c)){continue e}}s.push(a)}return s};I=function(e){var t,n,i,r,s,o,a,u,l,c;n=[];for(i=1,r=arguments.length;i<r;++i){n.push(arguments[i])}t=n;s=[];e:for(i=0,o=e.length;i<o;++i){a=e[i];for(u=0,l=t.length;u<l;++u){c=t[u];if(!ke(a,c)){continue e}}s.push(a)}return s};x=function(){var e,t,n,i,r,s,o,a,u,l;t=[];for(n=0,i=arguments.length;n<i;++n){t.push(arguments[n])}e=t;r=[];for(n=0,s=e.length;n<s;++n){o=e[n];for(a=0,u=o.length;a<u;++a){l=o[a];if(!ke(l,r)){r.push(l)}}}return r};O=we(function(e,t){var n,i,r,s,o;n={};for(i=0,r=t.length;i<r;++i){s=t[i];o=e(s);if(o in n){n[o]+=1}else{n[o]=1}}return n});M=we(function(e,t){var n,i,r,s,o;n={};for(i=0,r=t.length;i<r;++i){s=t[i];o=e(s);if(o in n){n[o].push(s)}else{n[o]=[s]}}return n});P=function(e){var t,n,i;for(t=0,n=e.length;t<n;++t){i=e[t];if(!i){return false}}return true};B=function(e){var t,n,i;for(t=0,n=e.length;t<n;++t){i=e[t];if(i){return true}}return false};$=we(function(e,t){var n,i,r;for(n=0,i=t.length;n<i;++n){r=t[n];if(e(r)){return true}}return false});U=we(function(e,t){var n,i,r;for(n=0,i=t.length;n<i;++n){r=t[n];if(!e(r)){return false}}return true});D=function(e){return e.concat().sort(function(e,t){if(e>t){return 1}else if(e<t){return-1}else{return 0}})};j=we(function(e,t){return t.concat().sort(e)});F=we(function(e,t){return t.concat().sort(function(t,n){if(e(t)>e(n)){return 1}else if(e(t)<e(n)){return-1}else{return 0}})});W=function(e){var t,n,i,r;t=0;for(n=0,i=e.length;n<i;++n){r=e[n];t+=r}return t};Y=function(e){var t,n,i,r;t=1;for(n=0,i=e.length;n<i;++n){r=e[n];t*=r}return t};z=G=function(e){var t,n,i,r;t=0;for(n=0,i=e.length;n<i;++n){r=e[n];t+=r}return t/e.length};H=function(e){var t,n,i,r,s;t=e[0];for(n=0,r=(i=e.slice(1)).length;n<r;++n){s=i[n];if(s>t){t=s}}return t};J=function(e){var t,n,i,r,s;t=e[0];for(n=0,r=(i=e.slice(1)).length;n<r;++n){s=i[n];if(s<t){t=s}}return t};q=we(function(e,t){var n,i,r,s,o;n=t[0];for(i=0,s=(r=t.slice(1)).length;i<s;++i){o=r[i];if(e(o)>e(n)){n=o}}return n});K=we(function(e,t){var n,i,r,s,o;n=t[0];for(i=0,s=(r=t.slice(1)).length;i<s;++i){o=r[i];if(e(o)<e(n)){n=o}}return n});V=X=we(function(e,t,n){var i,r;i=t;return[t].concat(function(){var t,s,o,a=[];for(t=0,o=(s=n).length;t<o;++t){r=s[t];a.push(i=e(i,r))}return a}())});Z=Q=we(function(e,t){if(!t.length){return}return V(e,t[0],t.slice(1))});ee=we(function(e,t,n){n=n.concat().reverse();return V(e,t,n).reverse()});te=we(function(e,t){if(!t.length){return}t=t.concat().reverse();return V(e,t[0],t.slice(1)).reverse()});ne=we(function(e,t,n){return n.slice(e,t)});ie=we(function(e,t){if(e<=0){return t.slice(0,0)}else{return t.slice(0,e)}});re=we(function(e,t){if(e<=0){return t}else{return t.slice(e)}});se=we(function(e,t){return[ie(e,t),re(e,t)]});oe=we(function(e,t){var n,i;n=t.length;if(!n){return t}i=0;while(i<n&&e(t[i])){i+=1}return t.slice(0,i)});ae=we(function(e,t){var n,i;n=t.length;if(!n){return t}i=0;while(i<n&&e(t[i])){i+=1}return t.slice(i)});ue=we(function(e,t){return[oe(e,t),ae(e,t)]});le=we(function(e,t){return ue(Le(e,Ae),t)});ce=we(function(e,t){var n,i,r,s,o,a;n=[];i=t.length;for(r=0,s=e.length;r<s;++r){o=r;a=e[r];if(o===i){break}n.push([a,t[o]])}return n});he=we(function(e,t,n){var i,r,s,o,a,u;i=[];r=n.length;for(s=0,o=t.length;s<o;++s){a=s;u=t[s];if(a===r){break}i.push(e(u,n[a]))}return i});fe=function(){var e,t,n,i,r,s,o,a,u,l,c,h=[];t=[];for(n=0,i=arguments.length;n<i;++n){t.push(arguments[n])}e=t;r=undefined;for(n=0,s=e.length;n<s;++n){o=e[n];r<=(a=o.length)||(r=a)}for(n=0;n<r;++n){u=n;l=[];for(c=0,s=e.length;c<s;++c){o=e[c];l.push(o[u])}h.push(l)}return h};pe=function(e){var t,n,i,r,s,o,a,u,l,c=[];n=[];for(i=1,r=arguments.length;i<r;++i){n.push(arguments[i])}t=n;s=undefined;for(i=0,o=t.length;i<o;++i){a=t[i];s<=(u=a.length)||(s=u)}for(i=0;i<s;++i){l=i;c.push(e.apply(null,h()))}return c;function h(){var e,n,i,r=[];for(e=0,i=(n=t).length;e<i;++e){a=n[e];r.push(a[l])}return r}};de=we(function(e,t){if(e<0){return t[t.length+e]}else{return t[e]}});ge=we(function(e,t){var n,i,r,s;for(n=0,i=t.length;n<i;++n){r=n;s=t[n];if(s===e){return r}}});me=we(function(e,t){var n,i,r,s,o=[];for(n=0,i=t.length;n<i;++n){r=n;s=t[n];if(s===e){o.push(r)}}return o});ye=we(function(e,t){var n,i,r,s;for(n=0,i=t.length;n<i;++n){r=n;s=t[n];if(e(s)){return r}}});ve=we(function(e,t){var n,i,r,s,o=[];for(n=0,i=t.length;n<i;++n){r=n;s=t[n];if(e(s)){o.push(r)}}return o});t.exports={each:i,map:r,filter:o,compact:s,reject:a,remove:u,partition:l,find:c,head:h,first:f,tail:p,last:d,initial:g,empty:m,reverse:y,difference:T,intersection:I,union:x,countBy:O,groupBy:M,fold:w,fold1:L,foldl:k,foldl1:A,foldr:E,foldr1:C,unfoldr:S,andList:P,orList:B,any:$,all:U,unique:v,uniqueBy:b,sort:D,sortWith:j,sortBy:F,sum:W,product:Y,mean:z,average:G,concat:R,concatMap:N,flatten:_,maximum:H,minimum:J,maximumBy:q,minimumBy:K,scan:V,scan1:Z,scanl:X,scanl1:Q,scanr:ee,scanr1:te,slice:ne,take:ie,drop:re,splitAt:se,takeWhile:oe,dropWhile:ae,span:ue,breakList:le,zip:ce,zipWith:he,zipAll:fe,zipAllWith:pe,at:de,elemIndex:ge,elemIndices:me,findIndex:ye,findIndices:ve};function we(e,t){var n,i=function(r){return e.length>1?function(){var s=r?r.concat():[];n=t?n||this:this;return s.push.apply(s,arguments)<e.length&&arguments.length?i.call(n,s):e.apply(n,s)}:e};return i()}function ke(e,t){var n=-1,i=t.length>>>0;while(++n<i)if(e===t[n])return true;return false}function Le(){var e=arguments;return function(){var t,n;n=e[0].apply(this,arguments);for(t=1;t<e.length;++t){n=e[t](n)}return n}}function Ae(e){return!e}},{}],16:[function(e,t,n){
  // Generated by blackpard 1.6.0
  var i,r,s,o,a,u,l,c,h,f,p,d,g,m,y,v,b,w,k,L,A,E,C,S,R,N,_,T,I,x,O,M;i=P(function(e,t){return e>t?e:t});r=P(function(e,t){return e<t?e:t});s=function(e){return-e};o=Math.abs;a=function(e){if(e<0){return-1}else if(e>0){return 1}else{return 0}};u=P(function(e,t){return~~(e/t)});l=P(function(e,t){return e%t});c=P(function(e,t){return Math.floor(e/t)});h=P(function(e,t){var n;return(e%(n=t)+n)%n});f=function(e){return 1/e};p=Math.PI;d=p*2;g=Math.exp;m=Math.sqrt;y=Math.log;v=P(function(e,t){return Math.pow(e,t)});b=Math.sin;w=Math.tan;k=Math.cos;L=Math.asin;A=Math.acos;E=Math.atan;C=P(function(e,t){return Math.atan2(e,t)});S=function(e){return~~e};R=Math.round;N=Math.ceil;_=Math.floor;T=function(e){return e!==e};I=function(e){return e%2===0};x=function(e){return e%2!==0};O=P(function(e,t){var n;e=Math.abs(e);t=Math.abs(t);while(t!==0){n=e%t;e=t;t=n}return e});M=P(function(e,t){return Math.abs(Math.floor(e/O(e,t)*t))});t.exports={max:i,min:r,negate:s,abs:o,signum:a,quot:u,rem:l,div:c,mod:h,recip:f,pi:p,tau:d,exp:g,sqrt:m,ln:y,pow:v,sin:b,tan:w,cos:k,acos:A,asin:L,atan:E,atan2:C,truncate:S,round:R,ceiling:N,floor:_,isItNaN:T,even:I,odd:x,gcd:O,lcm:M};function P(e,t){var n,i=function(r){return e.length>1?function(){var s=r?r.concat():[];n=t?n||this:this;return s.push.apply(s,arguments)<e.length&&arguments.length?i.call(n,s):e.apply(n,s)}:e};return i()}},{}],17:[function(e,t,n){
  // Generated by blackpard 1.6.0
  var i,r,s,o,a,u,l,c,h,f,p,d,g,m;i=function(e){var t,n,i=[];for(t in e){n=e[t];i.push(n)}return i};r=function(e){var t,n=[];for(t in e){n.push(t)}return n};s=function(e){var t,n,i,r={};for(t=0,n=e.length;t<n;++t){i=e[t];r[i[0]]=i[1]}return r};o=function(e){var t,n,i=[];for(t in e){n=e[t];i.push([t,n])}return i};a=y(function(e,t){var n,i,r,s,o={};for(n=0,i=e.length;n<i;++n){r=n;s=e[n];o[s]=t[r]}return o});u=function(e){var t,n,i,r;t=[];n=[];for(i in e){r=e[i];t.push(i);n.push(r)}return[t,n]};l=function(e){var t;for(t in e){return false}return true};c=y(function(e,t){var n,i;for(n in t){i=t[n];e(i)}return t});h=y(function(e,t){var n,i,r={};for(n in t){i=t[n];r[n]=e(i)}return r});f=function(e){var t,n,i={};for(t in e){n=e[t];if(n){i[t]=n}}return i};p=y(function(e,t){var n,i,r={};for(n in t){i=t[n];if(e(i)){r[n]=i}}return r});d=y(function(e,t){var n,i,r={};for(n in t){i=t[n];if(!e(i)){r[n]=i}}return r});g=y(function(e,t){var n,i,r,s;n={};i={};for(r in t){s=t[r];(e(s)?n:i)[r]=s}return[n,i]});m=y(function(e,t){var n,i;for(n in t){i=t[n];if(e(i)){return i}}});t.exports={values:i,keys:r,pairsToObj:s,objToPairs:o,listsToObj:a,objToLists:u,empty:l,each:c,map:h,filter:p,compact:f,reject:d,partition:g,find:m};function y(e,t){var n,i=function(r){return e.length>1?function(){var s=r?r.concat():[];n=t?n||this:this;return s.push.apply(s,arguments)<e.length&&arguments.length?i.call(n,s):e.apply(n,s)}:e};return i()}},{}],18:[function(e,t,n){
  // Generated by blackpard 1.6.0
  var i,r,s,o,a,u,l,c,h,f,p,d,g;i=m(function(e,t){return t.split(e)});r=m(function(e,t){return t.join(e)});s=function(e){if(!e.length){return[]}return e.split("\n")};o=function(e){return e.join("\n")};a=function(e){if(!e.length){return[]}return e.split(/[ ]+/)};u=function(e){return e.join(" ")};l=function(e){return e.split("")};c=function(e){return e.join("")};h=function(e){return e.split("").reverse().join("")};f=m(function(e,t){var n,i;n="";for(i=0;i<e;++i){n+=t}return n});p=function(e){return e.charAt(0).toUpperCase()+e.slice(1)};d=function(e){return e.replace(/[-_]+(.)?/g,function(e,t){return(t!=null?t:"").toUpperCase()})};g=function(e){return e.replace(/([^-A-Z])([A-Z]+)/g,function(e,t,n){return t+"-"+(n.length>1?n:n.toLowerCase())}).replace(/^([A-Z]+)/,function(e,t){if(t.length>1){return t+"-"}else{return t.toLowerCase()}})};t.exports={split:i,join:r,lines:s,unlines:o,words:a,unwords:u,chars:l,unchars:c,reverse:h,repeat:f,capitalize:p,camelize:d,dasherize:g};function m(e,t){var n,i=function(r){return e.length>1?function(){var s=r?r.concat():[];n=t?n||this:this;return s.push.apply(s,arguments)<e.length&&arguments.length?i.call(n,s):e.apply(n,s)}:e};return i()}},{}],19:[function(e,t,n){
  // Generated by blackpard 1.6.0
  var i,r,s,o,a,u,l,c,h,f={}.toString;i=e("./Func.js");r=e("./List.js");s=e("./Obj.js");o=e("./Str.js");a=e("./Num.js");u=function(e){return e};l=p(function(e,t){return f.call(t).slice(8,-1)===e});c=p(function(e,t){var n,i=[];for(n=0;n<e;++n){i.push(t)}return i});o.empty=r.empty;o.slice=r.slice;o.take=r.take;o.drop=r.drop;o.splitAt=r.splitAt;o.takeWhile=r.takeWhile;o.dropWhile=r.dropWhile;o.span=r.span;o.breakStr=r.breakList;h={Func:i,List:r,Obj:s,Str:o,Num:a,id:u,isType:l,replicate:c};h.each=r.each;h.map=r.map;h.filter=r.filter;h.compact=r.compact;h.reject=r.reject;h.partition=r.partition;h.find=r.find;h.head=r.head;h.first=r.first;h.tail=r.tail;h.last=r.last;h.initial=r.initial;h.empty=r.empty;h.reverse=r.reverse;h.difference=r.difference;h.intersection=r.intersection;h.union=r.union;h.countBy=r.countBy;h.groupBy=r.groupBy;h.fold=r.fold;h.foldl=r.foldl;h.fold1=r.fold1;h.foldl1=r.foldl1;h.foldr=r.foldr;h.foldr1=r.foldr1;h.unfoldr=r.unfoldr;h.andList=r.andList;h.orList=r.orList;h.any=r.any;h.all=r.all;h.unique=r.unique;h.uniqueBy=r.uniqueBy;h.sort=r.sort;h.sortWith=r.sortWith;h.sortBy=r.sortBy;h.sum=r.sum;h.product=r.product;h.mean=r.mean;h.average=r.average;h.concat=r.concat;h.concatMap=r.concatMap;h.flatten=r.flatten;h.maximum=r.maximum;h.minimum=r.minimum;h.maximumBy=r.maximumBy;h.minimumBy=r.minimumBy;h.scan=r.scan;h.scanl=r.scanl;h.scan1=r.scan1;h.scanl1=r.scanl1;h.scanr=r.scanr;h.scanr1=r.scanr1;h.slice=r.slice;h.take=r.take;h.drop=r.drop;h.splitAt=r.splitAt;h.takeWhile=r.takeWhile;h.dropWhile=r.dropWhile;h.span=r.span;h.breakList=r.breakList;h.zip=r.zip;h.zipWith=r.zipWith;h.zipAll=r.zipAll;h.zipAllWith=r.zipAllWith;h.at=r.at;h.elemIndex=r.elemIndex;h.elemIndices=r.elemIndices;h.findIndex=r.findIndex;h.findIndices=r.findIndices;h.apply=i.apply;h.curry=i.curry;h.flip=i.flip;h.fix=i.fix;h.over=i.over;h.split=o.split;h.join=o.join;h.lines=o.lines;h.unlines=o.unlines;h.words=o.words;h.unwords=o.unwords;h.chars=o.chars;h.unchars=o.unchars;h.repeat=o.repeat;h.capitalize=o.capitalize;h.camelize=o.camelize;h.dasherize=o.dasherize;h.values=s.values;h.keys=s.keys;h.pairsToObj=s.pairsToObj;h.objToPairs=s.objToPairs;h.listsToObj=s.listsToObj;h.objToLists=s.objToLists;h.max=a.max;h.min=a.min;h.negate=a.negate;h.abs=a.abs;h.signum=a.signum;h.quot=a.quot;h.rem=a.rem;h.div=a.div;h.mod=a.mod;h.recip=a.recip;h.pi=a.pi;h.tau=a.tau;h.exp=a.exp;h.sqrt=a.sqrt;h.ln=a.ln;h.pow=a.pow;h.sin=a.sin;h.tan=a.tan;h.cos=a.cos;h.acos=a.acos;h.asin=a.asin;h.atan=a.atan;h.atan2=a.atan2;h.truncate=a.truncate;h.round=a.round;h.ceiling=a.ceiling;h.floor=a.floor;h.isItNaN=a.isItNaN;h.even=a.even;h.odd=a.odd;h.gcd=a.gcd;h.lcm=a.lcm;h.VERSION="1.2.1";t.exports=h;function p(e,t){var n,i=function(r){return e.length>1?function(){var s=r?r.concat():[];n=t?n||this:this;return s.push.apply(s,arguments)<e.length&&arguments.length?i.call(n,s):e.apply(n,s)}:e};return i()}},{"./Func.js":14,"./List.js":15,"./Num.js":16,"./Obj.js":17,"./Str.js":18}],20:[function(e,t,n){
  // shim for using process in browser
  var i=t.exports={};
  // cached from whatever global is present so that test runners that stub it
  // don't break things.  But we need to wrap it in a try catch in case it is
  // wrapped in strict mode code which doesn't define any globals.  It's inside a
  // function because try/catches deoptimize in certain engines.
  var r;var s;function o(){throw new Error("setTimeout has not been defined")}function a(){throw new Error("clearTimeout has not been defined")}(function(){try{if(typeof setTimeout==="function"){r=setTimeout}else{r=o}}catch(e){r=o}try{if(typeof clearTimeout==="function"){s=clearTimeout}else{s=a}}catch(e){s=a}})();function u(e){if(r===setTimeout){
  //normal enviroments in sane situations
  return setTimeout(e,0)}
  // if setTimeout wasn't available but was latter defined
  if((r===o||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{
  // when when somebody has screwed with setTimeout but no I.E. maddness
  return r(e,0)}catch(t){try{
  // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
  return r.call(null,e,0)}catch(t){
  // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
  return r.call(this,e,0)}}}function l(e){if(s===clearTimeout){
  //normal enviroments in sane situations
  return clearTimeout(e)}
  // if clearTimeout wasn't available but was latter defined
  if((s===a||!s)&&clearTimeout){s=clearTimeout;return clearTimeout(e)}try{
  // when when somebody has screwed with setTimeout but no I.E. maddness
  return s(e)}catch(t){try{
  // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
  return s.call(null,e)}catch(t){
  // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
  // Some versions of I.E. have different rules for clearTimeout vs setTimeout
  return s.call(this,e)}}}var c=[];var h=false;var f;var p=-1;function d(){if(!h||!f){return}h=false;if(f.length){c=f.concat(c)}else{p=-1}if(c.length){g()}}function g(){if(h){return}var e=u(d);h=true;var t=c.length;while(t){f=c;c=[];while(++p<t){if(f){f[p].run()}}p=-1;t=c.length}f=null;h=false;l(e)}i.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var n=1;n<arguments.length;n++){t[n-1]=arguments[n]}}c.push(new m(e,t));if(c.length===1&&!h){u(g)}};
  // v8 likes predictible objects
  function m(e,t){this.fun=e;this.array=t}m.prototype.run=function(){this.fun.apply(null,this.array)};i.title="browser";i.browser=true;i.env={};i.argv=[];i.version="";// empty string to avoid regexp issues
  i.versions={};function y(){}i.on=y;i.addListener=y;i.once=y;i.off=y;i.removeListener=y;i.removeAllListeners=y;i.emit=y;i.prependListener=y;i.prependOnceListener=y;i.listeners=function(e){return[]};i.binding=function(e){throw new Error("process.binding is not supported")};i.cwd=function(){return"/"};i.chdir=function(e){throw new Error("process.chdir is not supported")};i.umask=function(){return 0}},{}],21:[function(e,t,n){/* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var i=e("./util");var r=Object.prototype.hasOwnProperty;var s=typeof Map!=="undefined";/**
   * A data structure which is a combination of an array and a set. Adding a new
   * member is O(1), testing for membership is O(1), and finding the index of an
   * element is O(1). Removing elements from the set is not supported. Only
   * strings are supported for membership.
   */
  function o(){this._array=[];this._set=s?new Map:Object.create(null)}/**
   * Static method for creating ArraySet instances from an existing array.
   */
  o.fromArray=function a(e,t){var n=new o;for(var i=0,r=e.length;i<r;i++){n.add(e[i],t)}return n};/**
   * Return how many unique items are in this ArraySet. If duplicates have been
   * added, than those do not count towards the size.
   *
   * @returns Number
   */
  o.prototype.size=function u(){return s?this._set.size:Object.getOwnPropertyNames(this._set).length};/**
   * Add the given string to this set.
   *
   * @param String aStr
   */
  o.prototype.add=function l(e,t){var n=s?e:i.toSetString(e);var o=s?this.has(e):r.call(this._set,n);var a=this._array.length;if(!o||t){this._array.push(e)}if(!o){if(s){this._set.set(e,a)}else{this._set[n]=a}}};/**
   * Is the given string a member of this set?
   *
   * @param String aStr
   */
  o.prototype.has=function c(e){if(s){return this._set.has(e)}else{var t=i.toSetString(e);return r.call(this._set,t)}};/**
   * What is the index of the given string in the array?
   *
   * @param String aStr
   */
  o.prototype.indexOf=function h(e){if(s){var t=this._set.get(e);if(t>=0){return t}}else{var n=i.toSetString(e);if(r.call(this._set,n)){return this._set[n]}}throw new Error('"'+e+'" is not in the set.')};/**
   * What is the element at the given index?
   *
   * @param Number aIdx
   */
  o.prototype.at=function f(e){if(e>=0&&e<this._array.length){return this._array[e]}throw new Error("No element indexed by "+e)};/**
   * Returns the array representation of this set (which has the proper indices
   * indicated by indexOf). Note that this is a copy of the internal array used
   * for storing the members so that no one can mess with internal state.
   */
  o.prototype.toArray=function p(){return this._array.slice()};n.ArraySet=o},{"./util":30}],22:[function(e,t,n){/* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   *
   * Based on the Base 64 VLQ implementation in Closure Compiler:
   * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
   *
   * Copyright 2011 The Closure Compiler Authors. All rights reserved.
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions are
   * met:
   *
   *  * Redistributions of source code must retain the above copyright
   *    notice, this list of conditions and the following disclaimer.
   *  * Redistributions in binary form must reproduce the above
   *    copyright notice, this list of conditions and the following
   *    disclaimer in the documentation and/or other materials provided
   *    with the distribution.
   *  * Neither the name of Google Inc. nor the names of its
   *    contributors may be used to endorse or promote products derived
   *    from this software without specific prior written permission.
   *
   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
   * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
   * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  var i=e("./base64");
  // A single base 64 digit can contain 6 bits of data. For the base 64 variable
  // length quantities we use in the source map spec, the first bit is the sign,
  // the next four bits are the actual value, and the 6th bit is the
  // continuation bit. The continuation bit tells us whether there are more
  // digits in this value following this digit.
  //
  //   Continuation
  //   |    Sign
  //   |    |
  //   V    V
  //   101011
  var r=5;
  // binary: 100000
  var s=1<<r;
  // binary: 011111
  var o=s-1;
  // binary: 100000
  var a=s;/**
   * Converts from a two-complement value to a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
   *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
   */
  function u(e){return e<0?(-e<<1)+1:(e<<1)+0}/**
   * Converts to a two-complement value from a value where the sign bit is
   * placed in the least significant bit.  For example, as decimals:
   *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
   *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
   */
  function l(e){var t=(e&1)===1;var n=e>>1;return t?-n:n}/**
   * Returns the base 64 VLQ encoded value.
   */
  n.encode=function c(e){var t="";var n;var s=u(e);do{n=s&o;s>>>=r;if(s>0){
  // There are still more digits in this value, so we must make sure the
  // continuation bit is marked.
  n|=a}t+=i.encode(n)}while(s>0);return t};/**
   * Decodes the next base 64 VLQ value from the given string and returns the
   * value and the rest of the string via the out parameter.
   */
  n.decode=function h(e,t,n){var s=e.length;var u=0;var c=0;var h,f;do{if(t>=s){throw new Error("Expected more digits in base 64 VLQ value.")}f=i.decode(e.charCodeAt(t++));if(f===-1){throw new Error("Invalid base64 digit: "+e.charAt(t-1))}h=!!(f&a);f&=o;u=u+(f<<c);c+=r}while(h);n.value=l(u);n.rest=t}},{"./base64":23}],23:[function(e,t,n){/* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");/**
   * Encode an integer in the range of 0 to 63 to a single base 64 digit.
   */
  n.encode=function(e){if(0<=e&&e<i.length){return i[e]}throw new TypeError("Must be between 0 and 63: "+e)};/**
   * Decode a single base 64 character code digit to an integer. Returns -1 on
   * failure.
   */
  n.decode=function(e){var t=65;// 'A'
  var n=90;// 'Z'
  var i=97;// 'a'
  var r=122;// 'z'
  var s=48;// '0'
  var o=57;// '9'
  var a=43;// '+'
  var u=47;// '/'
  var l=26;var c=52;
  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if(t<=e&&e<=n){return e-t}
  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if(i<=e&&e<=r){return e-i+l}
  // 52 - 61: 0123456789
  if(s<=e&&e<=o){return e-s+c}
  // 62: +
  if(e==a){return 62}
  // 63: /
  if(e==u){return 63}
  // Invalid base64 digit.
  return-1}},{}],24:[function(e,t,n){/* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  n.GREATEST_LOWER_BOUND=1;n.LEAST_UPPER_BOUND=2;/**
   * Recursive implementation of binary search.
   *
   * @param aLow Indices here and lower do not contain the needle.
   * @param aHigh Indices here and higher do not contain the needle.
   * @param aNeedle The element being searched for.
   * @param aHaystack The non-empty array being searched.
   * @param aCompare Function which takes two elements and returns -1, 0, or 1.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   */
  function i(e,t,r,s,o,a){
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var u=Math.floor((t-e)/2)+e;var l=o(r,s[u],true);if(l===0){
  // Found the element we are looking for.
  return u}else if(l>0){
  // Our needle is greater than aHaystack[mid].
  if(t-u>1){
  // The element is in the upper half.
  return i(u,t,r,s,o,a)}
  // The exact needle element was not found in this haystack. Determine if
  // we are in termination case (3) or (2) and return the appropriate thing.
  if(a==n.LEAST_UPPER_BOUND){return t<s.length?t:-1}else{return u}}else{
  // Our needle is less than aHaystack[mid].
  if(u-e>1){
  // The element is in the lower half.
  return i(e,u,r,s,o,a)}
  // we are in termination case (3) or (2) and return the appropriate thing.
  if(a==n.LEAST_UPPER_BOUND){return u}else{return e<0?-1:e}}}/**
   * This is an implementation of binary search which will always try and return
   * the index of the closest element if there is no exact hit. This is because
   * mappings between original and generated line/col pairs are single points,
   * and there is an implicit region between each of them, so a miss just means
   * that you aren't on the very start of a region.
   *
   * @param aNeedle The element you are looking for.
   * @param aHaystack The array that is being searched.
   * @param aCompare A function which takes the needle and an element in the
   *     array and returns -1, 0, or 1 depending on whether the needle is less
   *     than, equal to, or greater than the element, respectively.
   * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
   *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
   */
  n.search=function r(e,t,s,o){if(t.length===0){return-1}var a=i(-1,t.length,e,t,s,o||n.GREATEST_LOWER_BOUND);if(a<0){return-1}
  // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.
  while(a-1>=0){if(s(t[a],t[a-1],true)!==0){break}--a}return a}},{}],25:[function(e,t,n){/* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2014 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var i=e("./util");/**
   * Determine whether mappingB is after mappingA with respect to generated
   * position.
   */
  function r(e,t){
  // Optimized for most common case
  var n=e.generatedLine;var r=t.generatedLine;var s=e.generatedColumn;var o=t.generatedColumn;return r>n||r==n&&o>=s||i.compareByGeneratedPositionsInflated(e,t)<=0}/**
   * A data structure to provide a sorted view of accumulated mappings in a
   * performance conscious manner. It trades a neglibable overhead in general
   * case for a large speedup in case of mappings being added in order.
   */
  function s(){this._array=[];this._sorted=true;
  // Serves as infimum
  this._last={generatedLine:-1,generatedColumn:0}}/**
   * Iterate through internal items. This method takes the same arguments that
   * `Array.prototype.forEach` takes.
   *
   * NOTE: The order of the mappings is NOT guaranteed.
   */
  s.prototype.unsortedForEach=function o(e,t){this._array.forEach(e,t)};/**
   * Add the given source mapping.
   *
   * @param Object aMapping
   */
  s.prototype.add=function a(e){if(r(this._last,e)){this._last=e;this._array.push(e)}else{this._sorted=false;this._array.push(e)}};/**
   * Returns the flat, sorted array of mappings. The mappings are sorted by
   * generated position.
   *
   * WARNING: This method returns internal data without copying, for
   * performance. The return value must NOT be mutated, and should be treated as
   * an immutable borrow. If you want to take ownership, you must make your own
   * copy.
   */
  s.prototype.toArray=function u(){if(!this._sorted){this._array.sort(i.compareByGeneratedPositionsInflated);this._sorted=true}return this._array};n.MappingList=s},{"./util":30}],26:[function(e,t,n){/* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  // It turns out that some (most?) JavaScript engines don't self-host
  // `Array.prototype.sort`. This makes sense because C++ will likely remain
  // faster than JS when doing raw CPU-intensive sorting. However, when using a
  // custom comparator function, calling back and forth between the VM's C++ and
  // JIT'd JS is rather slow *and* loses JIT type information, resulting in
  // worse generated code for the comparator function than would be optimal. In
  // fact, when sorting with a comparator, these costs outweigh the benefits of
  // sorting in C++. By using our own JS-implemented Quick Sort (below), we get
  // a ~3500ms mean speed-up in `bench/bench.html`.
  /**
   * Swap the elements indexed by `x` and `y` in the array `ary`.
   *
   * @param {Array} ary
   *        The array.
   * @param {Number} x
   *        The index of the first item.
   * @param {Number} y
   *        The index of the second item.
   */
  function i(e,t,n){var i=e[t];e[t]=e[n];e[n]=i}/**
   * Returns a random integer within the range `low .. high` inclusive.
   *
   * @param {Number} low
   *        The lower bound on the range.
   * @param {Number} high
   *        The upper bound on the range.
   */
  function r(e,t){return Math.round(e+Math.random()*(t-e))}/**
   * The Quick Sort algorithm.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   * @param {Number} p
   *        Start index of the array
   * @param {Number} r
   *        End index of the array
   */
  function s(e,t,n,o){
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.
  if(n<o){
  // (1) Partitioning.
  //
  // The partitioning chooses a pivot between `p` and `r` and moves all
  // elements that are less than or equal to the pivot to the before it, and
  // all the elements that are greater than it after it. The effect is that
  // once partition is done, the pivot is in the exact place it will be when
  // the array is put in sorted order, and it will not need to be moved
  // again. This runs in O(n) time.
  // Always choose a random pivot so that an input array which is reverse
  // sorted does not cause O(n^2) running time.
  var a=r(n,o);var u=n-1;i(e,a,o);var l=e[o];
  // Immediately after `j` is incremented in this loop, the following hold
  // true:
  //
  //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
  //
  //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.
  for(var c=n;c<o;c++){if(t(e[c],l)<=0){u+=1;i(e,u,c)}}i(e,u+1,c);var h=u+1;
  // (2) Recurse on each half.
  s(e,t,n,h-1);s(e,t,h+1,o)}}/**
   * Sort the given array in-place with the given comparator function.
   *
   * @param {Array} ary
   *        An array to sort.
   * @param {function} comparator
   *        Function to use to compare two items.
   */
  n.quickSort=function(e,t){s(e,t,0,e.length-1)}},{}],27:[function(e,t,n){/* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var i=e("./util");var r=e("./binary-search");var s=e("./array-set").ArraySet;var o=e("./base64-vlq");var a=e("./quick-sort").quickSort;function u(e,t){var n=e;if(typeof e==="string"){n=i.parseSourceMapInput(e)}return n.sections!=null?new h(n,t):new l(n,t)}u.fromSourceMap=function(e,t){return l.fromSourceMap(e,t)};/**
   * The version of the source mapping spec that we are consuming.
   */
  u.prototype._version=3;
  // `__generatedMappings` and `__originalMappings` are arrays that hold the
  // parsed mapping coordinates from the source map's "mappings" attribute. They
  // are lazily instantiated, accessed via the `_generatedMappings` and
  // `_originalMappings` getters respectively, and we only parse the mappings
  // and create these arrays once queried for a source location. We jump through
  // these hoops because there can be many thousands of mappings, and parsing
  // them is expensive, so we only want to do it if we must.
  //
  // Each object in the arrays is of the form:
  //
  //     {
  //       generatedLine: The line number in the generated code,
  //       generatedColumn: The column number in the generated code,
  //       source: The path to the original source file that generated this
  //               chunk of code,
  //       originalLine: The line number in the original source that
  //                     corresponds to this chunk of generated code,
  //       originalColumn: The column number in the original source that
  //                       corresponds to this chunk of generated code,
  //       name: The name of the original symbol which generated this chunk of
  //             code.
  //     }
  //
  // All properties except for `generatedLine` and `generatedColumn` can be
  // `null`.
  //
  // `_generatedMappings` is ordered by the generated positions.
  //
  // `_originalMappings` is ordered by the original positions.
  u.prototype.__generatedMappings=null;Object.defineProperty(u.prototype,"_generatedMappings",{configurable:true,enumerable:true,get:function(){if(!this.__generatedMappings){this._parseMappings(this._mappings,this.sourceRoot)}return this.__generatedMappings}});u.prototype.__originalMappings=null;Object.defineProperty(u.prototype,"_originalMappings",{configurable:true,enumerable:true,get:function(){if(!this.__originalMappings){this._parseMappings(this._mappings,this.sourceRoot)}return this.__originalMappings}});u.prototype._charIsMappingSeparator=function f(e,t){var n=e.charAt(t);return n===";"||n===","};/**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  u.prototype._parseMappings=function p(e,t){throw new Error("Subclasses must implement _parseMappings")};u.GENERATED_ORDER=1;u.ORIGINAL_ORDER=2;u.GREATEST_LOWER_BOUND=1;u.LEAST_UPPER_BOUND=2;/**
   * Iterate over each mapping between an original source/line/column and a
   * generated line/column in this source map.
   *
   * @param Function aCallback
   *        The function that is called with each mapping.
   * @param Object aContext
   *        Optional. If specified, this object will be the value of `this` every
   *        time that `aCallback` is called.
   * @param aOrder
   *        Either `SourceMapConsumer.GENERATED_ORDER` or
   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
   *        iterate over the mappings sorted by the generated file's line/column
   *        order or the original's source/line/column order, respectively. Defaults to
   *        `SourceMapConsumer.GENERATED_ORDER`.
   */
  u.prototype.eachMapping=function d(e,t,n){var r=t||null;var s=n||u.GENERATED_ORDER;var o;switch(s){case u.GENERATED_ORDER:o=this._generatedMappings;break;case u.ORIGINAL_ORDER:o=this._originalMappings;break;default:throw new Error("Unknown order of iteration.")}var a=this.sourceRoot;o.map(function(e){var t=e.source===null?null:this._sources.at(e.source);t=i.computeSourceURL(a,t,this._sourceMapURL);return{source:t,generatedLine:e.generatedLine,generatedColumn:e.generatedColumn,originalLine:e.originalLine,originalColumn:e.originalColumn,name:e.name===null?null:this._names.at(e.name)}},this).forEach(e,r)};/**
   * Returns all generated line and column information for the original source,
   * line, and column provided. If no column is provided, returns all mappings
   * corresponding to a either the line we are searching for or the next
   * closest line that has any mappings. Otherwise, returns all mappings
   * corresponding to the given line and either the column we are searching for
   * or the next closest column that has any offsets.
   *
   * The only argument is an object with the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number is 1-based.
   *   - column: Optional. the column number in the original source.
   *    The column number is 0-based.
   *
   * and an array of objects is returned, each with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *    line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *    The column number is 0-based.
   */
  u.prototype.allGeneratedPositionsFor=function g(e){var t=i.getArg(e,"line");
  // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
  // returns the index of the closest mapping less than the needle. By
  // setting needle.originalColumn to 0, we thus find the last mapping for
  // the given line, provided such a mapping exists.
  var n={source:i.getArg(e,"source"),originalLine:t,originalColumn:i.getArg(e,"column",0)};n.source=this._findSourceIndex(n.source);if(n.source<0){return[]}var s=[];var o=this._findMapping(n,this._originalMappings,"originalLine","originalColumn",i.compareByOriginalPositions,r.LEAST_UPPER_BOUND);if(o>=0){var a=this._originalMappings[o];if(e.column===undefined){var u=a.originalLine;
  // Iterate until either we run out of mappings, or we run into
  // a mapping for a different line than the one we found. Since
  // mappings are sorted, this is guaranteed to find all mappings for
  // the line we found.
  while(a&&a.originalLine===u){s.push({line:i.getArg(a,"generatedLine",null),column:i.getArg(a,"generatedColumn",null),lastColumn:i.getArg(a,"lastGeneratedColumn",null)});a=this._originalMappings[++o]}}else{var l=a.originalColumn;
  // Iterate until either we run out of mappings, or we run into
  // a mapping for a different line than the one we were searching for.
  // Since mappings are sorted, this is guaranteed to find all mappings for
  // the line we are searching for.
  while(a&&a.originalLine===t&&a.originalColumn==l){s.push({line:i.getArg(a,"generatedLine",null),column:i.getArg(a,"generatedColumn",null),lastColumn:i.getArg(a,"lastGeneratedColumn",null)});a=this._originalMappings[++o]}}}return s};n.SourceMapConsumer=u;/**
   * A BasicSourceMapConsumer instance represents a parsed source map which we can
   * query for information about the original file positions by giving it a file
   * position in the generated source.
   *
   * The first parameter is the raw source map (either as a JSON string, or
   * already parsed to an object). According to the spec, source maps have the
   * following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - sources: An array of URLs to the original source files.
   *   - names: An array of identifiers which can be referrenced by individual mappings.
   *   - sourceRoot: Optional. The URL root from which all sources are relative.
   *   - sourcesContent: Optional. An array of contents of the original source files.
   *   - mappings: A string of base64 VLQs which contain the actual mappings.
   *   - file: Optional. The generated file this source map is associated with.
   *
   * Here is an example source map, taken from the source map spec[0]:
   *
   *     {
   *       version : 3,
   *       file: "out.js",
   *       sourceRoot : "",
   *       sources: ["foo.js", "bar.js"],
   *       names: ["src", "maps", "are", "fun"],
   *       mappings: "AA,AB;;ABCDE;"
   *     }
   *
   * The second parameter, if given, is a string whose value is the URL
   * at which the source map was found.  This URL is used to compute the
   * sources array.
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
   */
  function l(e,t){var n=e;if(typeof e==="string"){n=i.parseSourceMapInput(e)}var r=i.getArg(n,"version");var o=i.getArg(n,"sources");
  // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.
  var a=i.getArg(n,"names",[]);var u=i.getArg(n,"sourceRoot",null);var l=i.getArg(n,"sourcesContent",null);var c=i.getArg(n,"mappings");var h=i.getArg(n,"file",null);
  // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.
  if(r!=this._version){throw new Error("Unsupported version: "+r)}if(u){u=i.normalize(u)}o=o.map(String).map(i.normalize).map(function(e){return u&&i.isAbsolute(u)&&i.isAbsolute(e)?i.relative(u,e):e});
  // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.
  this._names=s.fromArray(a.map(String),true);this._sources=s.fromArray(o,true);this._absoluteSources=this._sources.toArray().map(function(e){return i.computeSourceURL(u,e,t)});this.sourceRoot=u;this.sourcesContent=l;this._mappings=c;this._sourceMapURL=t;this.file=h}l.prototype=Object.create(u.prototype);l.prototype.consumer=u;/**
   * Utility function to find the index of a source.  Returns -1 if not
   * found.
   */
  l.prototype._findSourceIndex=function(e){var t=e;if(this.sourceRoot!=null){t=i.relative(this.sourceRoot,t)}if(this._sources.has(t)){return this._sources.indexOf(t)}
  // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.
  var n;for(n=0;n<this._absoluteSources.length;++n){if(this._absoluteSources[n]==e){return n}}return-1};/**
   * Create a BasicSourceMapConsumer from a SourceMapGenerator.
   *
   * @param SourceMapGenerator aSourceMap
   *        The source map that will be consumed.
   * @param String aSourceMapURL
   *        The URL at which the source map can be found (optional)
   * @returns BasicSourceMapConsumer
   */
  l.fromSourceMap=function m(e,t){var n=Object.create(l.prototype);var r=n._names=s.fromArray(e._names.toArray(),true);var o=n._sources=s.fromArray(e._sources.toArray(),true);n.sourceRoot=e._sourceRoot;n.sourcesContent=e._generateSourcesContent(n._sources.toArray(),n.sourceRoot);n.file=e._file;n._sourceMapURL=t;n._absoluteSources=n._sources.toArray().map(function(e){return i.computeSourceURL(n.sourceRoot,e,t)});
  // Because we are modifying the entries (by converting string sources and
  // names to indices into the sources and names ArraySets), we have to make
  // a copy of the entry or else bad things happen. Shared mutable state
  // strikes again! See github issue #191.
  var u=e._mappings.toArray().slice();var h=n.__generatedMappings=[];var f=n.__originalMappings=[];for(var p=0,d=u.length;p<d;p++){var g=u[p];var m=new c;m.generatedLine=g.generatedLine;m.generatedColumn=g.generatedColumn;if(g.source){m.source=o.indexOf(g.source);m.originalLine=g.originalLine;m.originalColumn=g.originalColumn;if(g.name){m.name=r.indexOf(g.name)}f.push(m)}h.push(m)}a(n.__originalMappings,i.compareByOriginalPositions);return n};/**
   * The version of the source mapping spec that we are consuming.
   */
  l.prototype._version=3;/**
   * The list of original sources.
   */
  Object.defineProperty(l.prototype,"sources",{get:function(){return this._absoluteSources.slice()}});/**
   * Provide the JIT with a nice shape / hidden class.
   */
  function c(){this.generatedLine=0;this.generatedColumn=0;this.source=null;this.originalLine=null;this.originalColumn=null;this.name=null}/**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  l.prototype._parseMappings=function y(e,t){var n=1;var r=0;var s=0;var u=0;var l=0;var h=0;var f=e.length;var p=0;var d={};var g={};var m=[];var y=[];var v,b,w,k,L;while(p<f){if(e.charAt(p)===";"){n++;p++;r=0}else if(e.charAt(p)===","){p++}else{v=new c;v.generatedLine=n;
  // Because each offset is encoded relative to the previous one,
  // many segments often have the same encoding. We can exploit this
  // fact by caching the parsed variable length fields of each segment,
  // allowing us to avoid a second parse if we encounter the same
  // segment again.
  for(k=p;k<f;k++){if(this._charIsMappingSeparator(e,k)){break}}b=e.slice(p,k);w=d[b];if(w){p+=b.length}else{w=[];while(p<k){o.decode(e,p,g);L=g.value;p=g.rest;w.push(L)}if(w.length===2){throw new Error("Found a source, but no line and column")}if(w.length===3){throw new Error("Found a source and line, but no column")}d[b]=w}
  // Generated column.
  v.generatedColumn=r+w[0];r=v.generatedColumn;if(w.length>1){
  // Original source.
  v.source=l+w[1];l+=w[1];
  // Original line.
  v.originalLine=s+w[2];s=v.originalLine;
  // Lines are stored 0-based
  v.originalLine+=1;
  // Original column.
  v.originalColumn=u+w[3];u=v.originalColumn;if(w.length>4){
  // Original name.
  v.name=h+w[4];h+=w[4]}}y.push(v);if(typeof v.originalLine==="number"){m.push(v)}}}a(y,i.compareByGeneratedPositionsDeflated);this.__generatedMappings=y;a(m,i.compareByOriginalPositions);this.__originalMappings=m};/**
   * Find the mapping that best matches the hypothetical "needle" mapping that
   * we are searching for in the given "haystack" of mappings.
   */
  l.prototype._findMapping=function v(e,t,n,i,s,o){
  // To return the position we are searching for, we must first find the
  // mapping for the given position and then return the opposite position it
  // points to. Because the mappings are sorted, we can use binary search to
  // find the best mapping.
  if(e[n]<=0){throw new TypeError("Line must be greater than or equal to 1, got "+e[n])}if(e[i]<0){throw new TypeError("Column must be greater than or equal to 0, got "+e[i])}return r.search(e,t,s,o)};/**
   * Compute the last column for each generated mapping. The last column is
   * inclusive.
   */
  l.prototype.computeColumnSpans=function b(){for(var e=0;e<this._generatedMappings.length;++e){var t=this._generatedMappings[e];
  // Mappings do not contain a field for the last generated columnt. We
  // can come up with an optimistic estimate, however, by assuming that
  // mappings are contiguous (i.e. given two consecutive mappings, the
  // first mapping ends where the second one starts).
  if(e+1<this._generatedMappings.length){var n=this._generatedMappings[e+1];if(t.generatedLine===n.generatedLine){t.lastGeneratedColumn=n.generatedColumn-1;continue}}
  // The last mapping for each line spans the entire line.
  t.lastGeneratedColumn=Infinity}};/**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  l.prototype.originalPositionFor=function w(e){var t={generatedLine:i.getArg(e,"line"),generatedColumn:i.getArg(e,"column")};var n=this._findMapping(t,this._generatedMappings,"generatedLine","generatedColumn",i.compareByGeneratedPositionsDeflated,i.getArg(e,"bias",u.GREATEST_LOWER_BOUND));if(n>=0){var r=this._generatedMappings[n];if(r.generatedLine===t.generatedLine){var s=i.getArg(r,"source",null);if(s!==null){s=this._sources.at(s);s=i.computeSourceURL(this.sourceRoot,s,this._sourceMapURL)}var o=i.getArg(r,"name",null);if(o!==null){o=this._names.at(o)}return{source:s,line:i.getArg(r,"originalLine",null),column:i.getArg(r,"originalColumn",null),name:o}}}return{source:null,line:null,column:null,name:null}};/**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  l.prototype.hasContentsOfAllSources=function k(){if(!this.sourcesContent){return false}return this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some(function(e){return e==null})};/**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  l.prototype.sourceContentFor=function L(e,t){if(!this.sourcesContent){return null}var n=this._findSourceIndex(e);if(n>=0){return this.sourcesContent[n]}var r=e;if(this.sourceRoot!=null){r=i.relative(this.sourceRoot,r)}var s;if(this.sourceRoot!=null&&(s=i.urlParse(this.sourceRoot))){
  // XXX: file:// URIs and absolute paths lead to unexpected behavior for
  // many users. We can help them out when they expect file:// URIs to
  // behave like it would if they were running a local HTTP server. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
  var o=r.replace(/^file:\/\//,"");if(s.scheme=="file"&&this._sources.has(o)){return this.sourcesContent[this._sources.indexOf(o)]}if((!s.path||s.path=="/")&&this._sources.has("/"+r)){return this.sourcesContent[this._sources.indexOf("/"+r)]}}
  // This function is used recursively from
  // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
  // don't want to throw if we can't find the source - we just want to
  // return null, so we provide a flag to exit gracefully.
  if(t){return null}else{throw new Error('"'+r+'" is not in the SourceMap.')}};/**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
   *     closest element that is smaller than or greater than the one we are
   *     searching for, respectively, if the exact element cannot be found.
   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  l.prototype.generatedPositionFor=function A(e){var t=i.getArg(e,"source");t=this._findSourceIndex(t);if(t<0){return{line:null,column:null,lastColumn:null}}var n={source:t,originalLine:i.getArg(e,"line"),originalColumn:i.getArg(e,"column")};var r=this._findMapping(n,this._originalMappings,"originalLine","originalColumn",i.compareByOriginalPositions,i.getArg(e,"bias",u.GREATEST_LOWER_BOUND));if(r>=0){var s=this._originalMappings[r];if(s.source===n.source){return{line:i.getArg(s,"generatedLine",null),column:i.getArg(s,"generatedColumn",null),lastColumn:i.getArg(s,"lastGeneratedColumn",null)}}}return{line:null,column:null,lastColumn:null}};n.BasicSourceMapConsumer=l;/**
   * An IndexedSourceMapConsumer instance represents a parsed source map which
   * we can query for information. It differs from BasicSourceMapConsumer in
   * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
   * input.
   *
   * The first parameter is a raw source map (either as a JSON string, or already
   * parsed to an object). According to the spec for indexed source maps, they
   * have the following attributes:
   *
   *   - version: Which version of the source map spec this map is following.
   *   - file: Optional. The generated file this source map is associated with.
   *   - sections: A list of section definitions.
   *
   * Each value under the "sections" field has two fields:
   *   - offset: The offset into the original specified at which this section
   *       begins to apply, defined as an object with a "line" and "column"
   *       field.
   *   - map: A source map definition. This source map could also be indexed,
   *       but doesn't have to be.
   *
   * Instead of the "map" field, it's also possible to have a "url" field
   * specifying a URL to retrieve a source map from, but that's currently
   * unsupported.
   *
   * Here's an example source map, taken from the source map spec[0], but
   * modified to omit a section which uses the "url" field.
   *
   *  {
   *    version : 3,
   *    file: "app.js",
   *    sections: [{
   *      offset: {line:100, column:10},
   *      map: {
   *        version : 3,
   *        file: "section.js",
   *        sources: ["foo.js", "bar.js"],
   *        names: ["src", "maps", "are", "fun"],
   *        mappings: "AAAA,E;;ABCDE;"
   *      }
   *    }],
   *  }
   *
   * The second parameter, if given, is a string whose value is the URL
   * at which the source map was found.  This URL is used to compute the
   * sources array.
   *
   * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
   */
  function h(e,t){var n=e;if(typeof e==="string"){n=i.parseSourceMapInput(e)}var r=i.getArg(n,"version");var o=i.getArg(n,"sections");if(r!=this._version){throw new Error("Unsupported version: "+r)}this._sources=new s;this._names=new s;var a={line:-1,column:0};this._sections=o.map(function(e){if(e.url){
  // The url field will require support for asynchronicity.
  // See https://github.com/mozilla/source-map/issues/16
  throw new Error("Support for url field in sections not implemented.")}var n=i.getArg(e,"offset");var r=i.getArg(n,"line");var s=i.getArg(n,"column");if(r<a.line||r===a.line&&s<a.column){throw new Error("Section offsets must be ordered and non-overlapping.")}a=n;return{generatedOffset:{
  // The offset fields are 0-based, but we use 1-based indices when
  // encoding/decoding from VLQ.
  generatedLine:r+1,generatedColumn:s+1},consumer:new u(i.getArg(e,"map"),t)}})}h.prototype=Object.create(u.prototype);h.prototype.constructor=u;/**
   * The version of the source mapping spec that we are consuming.
   */
  h.prototype._version=3;/**
   * The list of original sources.
   */
  Object.defineProperty(h.prototype,"sources",{get:function(){var e=[];for(var t=0;t<this._sections.length;t++){for(var n=0;n<this._sections[t].consumer.sources.length;n++){e.push(this._sections[t].consumer.sources[n])}}return e}});/**
   * Returns the original source, line, and column information for the generated
   * source's line and column positions provided. The only argument is an object
   * with the following properties:
   *
   *   - line: The line number in the generated source.  The line number
   *     is 1-based.
   *   - column: The column number in the generated source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - source: The original source file, or null.
   *   - line: The line number in the original source, or null.  The
   *     line number is 1-based.
   *   - column: The column number in the original source, or null.  The
   *     column number is 0-based.
   *   - name: The original identifier, or null.
   */
  h.prototype.originalPositionFor=function E(e){var t={generatedLine:i.getArg(e,"line"),generatedColumn:i.getArg(e,"column")};
  // Find the section containing the generated position we're trying to map
  // to an original position.
  var n=r.search(t,this._sections,function(e,t){var n=e.generatedLine-t.generatedOffset.generatedLine;if(n){return n}return e.generatedColumn-t.generatedOffset.generatedColumn});var s=this._sections[n];if(!s){return{source:null,line:null,column:null,name:null}}return s.consumer.originalPositionFor({line:t.generatedLine-(s.generatedOffset.generatedLine-1),column:t.generatedColumn-(s.generatedOffset.generatedLine===t.generatedLine?s.generatedOffset.generatedColumn-1:0),bias:e.bias})};/**
   * Return true if we have the source content for every source in the source
   * map, false otherwise.
   */
  h.prototype.hasContentsOfAllSources=function C(){return this._sections.every(function(e){return e.consumer.hasContentsOfAllSources()})};/**
   * Returns the original source content. The only argument is the url of the
   * original source file. Returns null if no original source content is
   * available.
   */
  h.prototype.sourceContentFor=function S(e,t){for(var n=0;n<this._sections.length;n++){var i=this._sections[n];var r=i.consumer.sourceContentFor(e,true);if(r){return r}}if(t){return null}else{throw new Error('"'+e+'" is not in the SourceMap.')}};/**
   * Returns the generated line and column information for the original source,
   * line, and column positions provided. The only argument is an object with
   * the following properties:
   *
   *   - source: The filename of the original source.
   *   - line: The line number in the original source.  The line number
   *     is 1-based.
   *   - column: The column number in the original source.  The column
   *     number is 0-based.
   *
   * and an object is returned with the following properties:
   *
   *   - line: The line number in the generated source, or null.  The
   *     line number is 1-based. 
   *   - column: The column number in the generated source, or null.
   *     The column number is 0-based.
   */
  h.prototype.generatedPositionFor=function R(e){for(var t=0;t<this._sections.length;t++){var n=this._sections[t];
  // Only consider this section if the requested source is in the list of
  // sources of the consumer.
  if(n.consumer._findSourceIndex(i.getArg(e,"source"))===-1){continue}var r=n.consumer.generatedPositionFor(e);if(r){var s={line:r.line+(n.generatedOffset.generatedLine-1),column:r.column+(n.generatedOffset.generatedLine===r.line?n.generatedOffset.generatedColumn-1:0)};return s}}return{line:null,column:null}};/**
   * Parse the mappings in a string in to a data structure which we can easily
   * query (the ordered arrays in the `this.__generatedMappings` and
   * `this.__originalMappings` properties).
   */
  h.prototype._parseMappings=function N(e,t){this.__generatedMappings=[];this.__originalMappings=[];for(var n=0;n<this._sections.length;n++){var r=this._sections[n];var s=r.consumer._generatedMappings;for(var o=0;o<s.length;o++){var u=s[o];var l=r.consumer._sources.at(u.source);l=i.computeSourceURL(r.consumer.sourceRoot,l,this._sourceMapURL);this._sources.add(l);l=this._sources.indexOf(l);var c=null;if(u.name){c=r.consumer._names.at(u.name);this._names.add(c);c=this._names.indexOf(c)}
  // The mappings coming from the consumer for the section have
  // generated positions relative to the start of the section, so we
  // need to offset them to be relative to the start of the concatenated
  // generated file.
  var h={source:l,generatedLine:u.generatedLine+(r.generatedOffset.generatedLine-1),generatedColumn:u.generatedColumn+(r.generatedOffset.generatedLine===u.generatedLine?r.generatedOffset.generatedColumn-1:0),originalLine:u.originalLine,originalColumn:u.originalColumn,name:c};this.__generatedMappings.push(h);if(typeof h.originalLine==="number"){this.__originalMappings.push(h)}}}a(this.__generatedMappings,i.compareByGeneratedPositionsDeflated);a(this.__originalMappings,i.compareByOriginalPositions)};n.IndexedSourceMapConsumer=h},{"./array-set":21,"./base64-vlq":22,"./binary-search":24,"./quick-sort":26,"./util":30}],28:[function(e,t,n){/* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var i=e("./base64-vlq");var r=e("./util");var s=e("./array-set").ArraySet;var o=e("./mapping-list").MappingList;/**
   * An instance of the SourceMapGenerator represents a source map which is
   * being built incrementally. You may pass an object with the following
   * properties:
   *
   *   - file: The filename of the generated source.
   *   - sourceRoot: A root for all relative URLs in this source map.
   */
  function a(e){if(!e){e={}}this._file=r.getArg(e,"file",null);this._sourceRoot=r.getArg(e,"sourceRoot",null);this._skipValidation=r.getArg(e,"skipValidation",false);this._sources=new s;this._names=new s;this._mappings=new o;this._sourcesContents=null}a.prototype._version=3;/**
   * Creates a new SourceMapGenerator based on a SourceMapConsumer
   *
   * @param aSourceMapConsumer The SourceMap.
   */
  a.fromSourceMap=function u(e){var t=e.sourceRoot;var n=new a({file:e.file,sourceRoot:t});e.eachMapping(function(e){var i={generated:{line:e.generatedLine,column:e.generatedColumn}};if(e.source!=null){i.source=e.source;if(t!=null){i.source=r.relative(t,i.source)}i.original={line:e.originalLine,column:e.originalColumn};if(e.name!=null){i.name=e.name}}n.addMapping(i)});e.sources.forEach(function(i){var s=i;if(t!==null){s=r.relative(t,i)}if(!n._sources.has(s)){n._sources.add(s)}var o=e.sourceContentFor(i);if(o!=null){n.setSourceContent(i,o)}});return n};/**
   * Add a single mapping from original source line and column to the generated
   * source's line and column for this source map being created. The mapping
   * object should have the following properties:
   *
   *   - generated: An object with the generated line and column positions.
   *   - original: An object with the original line and column positions.
   *   - source: The original source file (relative to the sourceRoot).
   *   - name: An optional original token name for this mapping.
   */
  a.prototype.addMapping=function l(e){var t=r.getArg(e,"generated");var n=r.getArg(e,"original",null);var i=r.getArg(e,"source",null);var s=r.getArg(e,"name",null);if(!this._skipValidation){this._validateMapping(t,n,i,s)}if(i!=null){i=String(i);if(!this._sources.has(i)){this._sources.add(i)}}if(s!=null){s=String(s);if(!this._names.has(s)){this._names.add(s)}}this._mappings.add({generatedLine:t.line,generatedColumn:t.column,originalLine:n!=null&&n.line,originalColumn:n!=null&&n.column,source:i,name:s})};/**
   * Set the source content for a source file.
   */
  a.prototype.setSourceContent=function c(e,t){var n=e;if(this._sourceRoot!=null){n=r.relative(this._sourceRoot,n)}if(t!=null){
  // Add the source content to the _sourcesContents map.
  // Create a new _sourcesContents map if the property is null.
  if(!this._sourcesContents){this._sourcesContents=Object.create(null)}this._sourcesContents[r.toSetString(n)]=t}else if(this._sourcesContents){
  // Remove the source file from the _sourcesContents map.
  // If the _sourcesContents map is empty, set the property to null.
  delete this._sourcesContents[r.toSetString(n)];if(Object.keys(this._sourcesContents).length===0){this._sourcesContents=null}}};/**
   * Applies the mappings of a sub-source-map for a specific source file to the
   * source map being generated. Each mapping to the supplied source file is
   * rewritten using the supplied source map. Note: The resolution for the
   * resulting mappings is the minimium of this map and the supplied map.
   *
   * @param aSourceMapConsumer The source map to be applied.
   * @param aSourceFile Optional. The filename of the source file.
   *        If omitted, SourceMapConsumer's file property will be used.
   * @param aSourceMapPath Optional. The dirname of the path to the source map
   *        to be applied. If relative, it is relative to the SourceMapConsumer.
   *        This parameter is needed when the two source maps aren't in the same
   *        directory, and the source map to be applied contains relative source
   *        paths. If so, those relative source paths need to be rewritten
   *        relative to the SourceMapGenerator.
   */
  a.prototype.applySourceMap=function h(e,t,n){var i=t;
  // If aSourceFile is omitted, we will use the file property of the SourceMap
  if(t==null){if(e.file==null){throw new Error("SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, "+'or the source map\'s "file" property. Both were omitted.')}i=e.file}var o=this._sourceRoot;
  // Make "sourceFile" relative if an absolute Url is passed.
  if(o!=null){i=r.relative(o,i)}
  // Applying the SourceMap can add and remove items from the sources and
  // the names array.
  var a=new s;var u=new s;
  // Find mappings for the "sourceFile"
  this._mappings.unsortedForEach(function(t){if(t.source===i&&t.originalLine!=null){
  // Check if it can be mapped by the source map, then update the mapping.
  var s=e.originalPositionFor({line:t.originalLine,column:t.originalColumn});if(s.source!=null){
  // Copy mapping
  t.source=s.source;if(n!=null){t.source=r.join(n,t.source)}if(o!=null){t.source=r.relative(o,t.source)}t.originalLine=s.line;t.originalColumn=s.column;if(s.name!=null){t.name=s.name}}}var l=t.source;if(l!=null&&!a.has(l)){a.add(l)}var c=t.name;if(c!=null&&!u.has(c)){u.add(c)}},this);this._sources=a;this._names=u;
  // Copy sourcesContents of applied map.
  e.sources.forEach(function(t){var i=e.sourceContentFor(t);if(i!=null){if(n!=null){t=r.join(n,t)}if(o!=null){t=r.relative(o,t)}this.setSourceContent(t,i)}},this)};/**
   * A mapping can have one of the three levels of data:
   *
   *   1. Just the generated position.
   *   2. The Generated position, original position, and original source.
   *   3. Generated and original position, original source, as well as a name
   *      token.
   *
   * To maintain consistency, we validate that any new mapping being added falls
   * in to one of these categories.
   */
  a.prototype._validateMapping=function f(e,t,n,i){
  // When aOriginal is truthy but has empty values for .line and .column,
  // it is most likely a programmer error. In this case we throw a very
  // specific error message to try to guide them the right way.
  // For example: https://github.com/Polymer/polymer-bundler/pull/519
  if(t&&typeof t.line!=="number"&&typeof t.column!=="number"){throw new Error("original.line and original.column are not numbers -- you probably meant to omit "+"the original mapping entirely and only map the generated position. If so, pass "+"null for the original mapping instead of an object with empty or null values.")}if(e&&"line"in e&&"column"in e&&e.line>0&&e.column>=0&&!t&&!n&&!i){
  // Case 1.
  return}else if(e&&"line"in e&&"column"in e&&t&&"line"in t&&"column"in t&&e.line>0&&e.column>=0&&t.line>0&&t.column>=0&&n){
  // Cases 2 and 3.
  return}else{throw new Error("Invalid mapping: "+JSON.stringify({generated:e,source:n,original:t,name:i}))}};/**
   * Serialize the accumulated mappings in to the stream of base 64 VLQs
   * specified by the source map format.
   */
  a.prototype._serializeMappings=function p(){var e=0;var t=1;var n=0;var s=0;var o=0;var a=0;var u="";var l;var c;var h;var f;var p=this._mappings.toArray();for(var d=0,g=p.length;d<g;d++){c=p[d];l="";if(c.generatedLine!==t){e=0;while(c.generatedLine!==t){l+=";";t++}}else{if(d>0){if(!r.compareByGeneratedPositionsInflated(c,p[d-1])){continue}l+=","}}l+=i.encode(c.generatedColumn-e);e=c.generatedColumn;if(c.source!=null){f=this._sources.indexOf(c.source);l+=i.encode(f-a);a=f;
  // lines are stored 0-based in SourceMap spec version 3
  l+=i.encode(c.originalLine-1-s);s=c.originalLine-1;l+=i.encode(c.originalColumn-n);n=c.originalColumn;if(c.name!=null){h=this._names.indexOf(c.name);l+=i.encode(h-o);o=h}}u+=l}return u};a.prototype._generateSourcesContent=function d(e,t){return e.map(function(e){if(!this._sourcesContents){return null}if(t!=null){e=r.relative(t,e)}var n=r.toSetString(e);return Object.prototype.hasOwnProperty.call(this._sourcesContents,n)?this._sourcesContents[n]:null},this)};/**
   * Externalize the source map.
   */
  a.prototype.toJSON=function g(){var e={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};if(this._file!=null){e.file=this._file}if(this._sourceRoot!=null){e.sourceRoot=this._sourceRoot}if(this._sourcesContents){e.sourcesContent=this._generateSourcesContent(e.sources,e.sourceRoot)}return e};/**
   * Render the source map being generated to a string.
   */
  a.prototype.toString=function m(){return JSON.stringify(this.toJSON())};n.SourceMapGenerator=a},{"./array-set":21,"./base64-vlq":22,"./mapping-list":25,"./util":30}],29:[function(e,t,n){/* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  var i=e("./source-map-generator").SourceMapGenerator;var r=e("./util");
  // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
  // operating systems these days (capturing the result).
  var s=/(\r?\n)/;
  // Newline character code for charCodeAt() comparisons
  var o=10;
  // Private symbol for identifying `SourceNode`s when multiple versions of
  // the source-map library are loaded. This MUST NOT CHANGE across
  // versions!
  var a="$$$isSourceNode$$$";/**
   * SourceNodes provide a way to abstract over interpolating/concatenating
   * snippets of generated JavaScript source code while maintaining the line and
   * column information associated with the original source code.
   *
   * @param aLine The original line number.
   * @param aColumn The original column number.
   * @param aSource The original source's filename.
   * @param aChunks Optional. An array of strings which are snippets of
   *        generated JS, or other SourceNodes.
   * @param aName The original identifier.
   */
  function u(e,t,n,i,r){this.children=[];this.sourceContents={};this.line=e==null?null:e;this.column=t==null?null:t;this.source=n==null?null:n;this.name=r==null?null:r;this[a]=true;if(i!=null)this.add(i)}/**
   * Creates a SourceNode from generated code and a SourceMapConsumer.
   *
   * @param aGeneratedCode The generated code
   * @param aSourceMapConsumer The SourceMap for the generated code
   * @param aRelativePath Optional. The path that relative sources in the
   *        SourceMapConsumer should be relative to.
   */
  u.fromStringWithSourceMap=function l(e,t,n){
  // The SourceNode we want to fill with the generated code
  // and the SourceMap
  var i=new u;
  // All even indices of this array are one line of the generated code,
  // while all odd indices are the newlines between two adjacent lines
  // (since `REGEX_NEWLINE` captures its match).
  // Processed fragments are accessed by calling `shiftNextLine`.
  var o=e.split(s);var a=0;var l=function(){var e=n();
  // The last line of a file might not have a newline.
  var t=n()||"";return e+t;function n(){return a<o.length?o[a++]:undefined}};
  // We need to remember the position of "remainingLines"
  var c=1,h=0;
  // The generate SourceNodes we need a code range.
  // To extract it current and last mapping is used.
  // Here we store the last mapping.
  var f=null;t.eachMapping(function(e){if(f!==null){
  // We add the code from "lastMapping" to "mapping":
  // First check if there is a new line in between.
  if(c<e.generatedLine){
  // Associate first line with "lastMapping"
  p(f,l());c++;h=0}else{
  // There is no new line in between.
  // Associate the code between "lastGeneratedColumn" and
  // "mapping.generatedColumn" with "lastMapping"
  var t=o[a]||"";var n=t.substr(0,e.generatedColumn-h);o[a]=t.substr(e.generatedColumn-h);h=e.generatedColumn;p(f,n);
  // No more remaining code, continue
  f=e;return}}
  // We add the generated code until the first mapping
  // to the SourceNode without any mapping.
  // Each line is added as separate string.
  while(c<e.generatedLine){i.add(l());c++}if(h<e.generatedColumn){var t=o[a]||"";i.add(t.substr(0,e.generatedColumn));o[a]=t.substr(e.generatedColumn);h=e.generatedColumn}f=e},this);
  // We have processed all mappings.
  if(a<o.length){if(f){
  // Associate the remaining code in the current line with "lastMapping"
  p(f,l())}
  // and add the remaining lines without any mapping
  i.add(o.splice(a).join(""))}
  // Copy sourcesContent into SourceNode
  t.sources.forEach(function(e){var s=t.sourceContentFor(e);if(s!=null){if(n!=null){e=r.join(n,e)}i.setSourceContent(e,s)}});return i;function p(e,t){if(e===null||e.source===undefined){i.add(t)}else{var s=n?r.join(n,e.source):e.source;i.add(new u(e.originalLine,e.originalColumn,s,t,e.name))}}};/**
   * Add a chunk of generated JS to this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  u.prototype.add=function c(e){if(Array.isArray(e)){e.forEach(function(e){this.add(e)},this)}else if(e[a]||typeof e==="string"){if(e){this.children.push(e)}}else{throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e)}return this};/**
   * Add a chunk of generated JS to the beginning of this source node.
   *
   * @param aChunk A string snippet of generated JS code, another instance of
   *        SourceNode, or an array where each member is one of those things.
   */
  u.prototype.prepend=function h(e){if(Array.isArray(e)){for(var t=e.length-1;t>=0;t--){this.prepend(e[t])}}else if(e[a]||typeof e==="string"){this.children.unshift(e)}else{throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e)}return this};/**
   * Walk over the tree of JS snippets in this node and its children. The
   * walking function is called once for each snippet of JS and is passed that
   * snippet and the its original associated source's line/column location.
   *
   * @param aFn The traversal function.
   */
  u.prototype.walk=function f(e){var t;for(var n=0,i=this.children.length;n<i;n++){t=this.children[n];if(t[a]){t.walk(e)}else{if(t!==""){e(t,{source:this.source,line:this.line,column:this.column,name:this.name})}}}};/**
   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
   * each of `this.children`.
   *
   * @param aSep The separator.
   */
  u.prototype.join=function p(e){var t;var n;var i=this.children.length;if(i>0){t=[];for(n=0;n<i-1;n++){t.push(this.children[n]);t.push(e)}t.push(this.children[n]);this.children=t}return this};/**
   * Call String.prototype.replace on the very right-most source snippet. Useful
   * for trimming whitespace from the end of a source node, etc.
   *
   * @param aPattern The pattern to replace.
   * @param aReplacement The thing to replace the pattern with.
   */
  u.prototype.replaceRight=function d(e,t){var n=this.children[this.children.length-1];if(n[a]){n.replaceRight(e,t)}else if(typeof n==="string"){this.children[this.children.length-1]=n.replace(e,t)}else{this.children.push("".replace(e,t))}return this};/**
   * Set the source content for a source file. This will be added to the SourceMapGenerator
   * in the sourcesContent field.
   *
   * @param aSourceFile The filename of the source file
   * @param aSourceContent The content of the source file
   */
  u.prototype.setSourceContent=function g(e,t){this.sourceContents[r.toSetString(e)]=t};/**
   * Walk over the tree of SourceNodes. The walking function is called for each
   * source file content and is passed the filename and source content.
   *
   * @param aFn The traversal function.
   */
  u.prototype.walkSourceContents=function m(e){for(var t=0,n=this.children.length;t<n;t++){if(this.children[t][a]){this.children[t].walkSourceContents(e)}}var i=Object.keys(this.sourceContents);for(var t=0,n=i.length;t<n;t++){e(r.fromSetString(i[t]),this.sourceContents[i[t]])}};/**
   * Return the string representation of this source node. Walks over the tree
   * and concatenates all the various snippets together to one string.
   */
  u.prototype.toString=function y(){var e="";this.walk(function(t){e+=t});return e};/**
   * Returns the string representation of this source node along with a source
   * map.
   */
  u.prototype.toStringWithSourceMap=function v(e){var t={code:"",line:1,column:0};var n=new i(e);var r=false;var s=null;var a=null;var u=null;var l=null;this.walk(function(e,i){t.code+=e;if(i.source!==null&&i.line!==null&&i.column!==null){if(s!==i.source||a!==i.line||u!==i.column||l!==i.name){n.addMapping({source:i.source,original:{line:i.line,column:i.column},generated:{line:t.line,column:t.column},name:i.name})}s=i.source;a=i.line;u=i.column;l=i.name;r=true}else if(r){n.addMapping({generated:{line:t.line,column:t.column}});s=null;r=false}for(var c=0,h=e.length;c<h;c++){if(e.charCodeAt(c)===o){t.line++;t.column=0;
  // Mappings end at eol
  if(c+1===h){s=null;r=false}else if(r){n.addMapping({source:i.source,original:{line:i.line,column:i.column},generated:{line:t.line,column:t.column},name:i.name})}}else{t.column++}}});this.walkSourceContents(function(e,t){n.setSourceContent(e,t)});return{code:t.code,map:n}};n.SourceNode=u},{"./source-map-generator":28,"./util":30}],30:[function(e,t,n){/* -*- Mode: js; js-indent-level: 2; -*- */
  /*
   * Copyright 2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  /**
   * This is a helper function for getting values from parameter/options
   * objects.
   *
   * @param args The object we are extracting values from
   * @param name The name of the property we are getting.
   * @param defaultValue An optional value to return if the property is missing
   * from the object. If this is not specified and the property is missing, an
   * error will be thrown.
   */
  function i(e,t,n){if(t in e){return e[t]}else if(arguments.length===3){return n}else{throw new Error('"'+t+'" is a required argument.')}}n.getArg=i;var r=/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;var s=/^data:.+\,.+$/;function o(e){var t=e.match(r);if(!t){return null}return{scheme:t[1],auth:t[2],host:t[3],port:t[4],path:t[5]}}n.urlParse=o;function a(e){var t="";if(e.scheme){t+=e.scheme+":"}t+="//";if(e.auth){t+=e.auth+"@"}if(e.host){t+=e.host}if(e.port){t+=":"+e.port}if(e.path){t+=e.path}return t}n.urlGenerate=a;/**
   * Normalizes a path, or the path portion of a URL:
   *
   * - Replaces consecutive slashes with one slash.
   * - Removes unnecessary '.' parts.
   * - Removes unnecessary '<dir>/..' parts.
   *
   * Based on code in the Node.js 'path' core module.
   *
   * @param aPath The path or url to normalize.
   */
  function u(e){var t=e;var i=o(e);if(i){if(!i.path){return e}t=i.path}var r=n.isAbsolute(t);var s=t.split(/\/+/);for(var u,l=0,c=s.length-1;c>=0;c--){u=s[c];if(u==="."){s.splice(c,1)}else if(u===".."){l++}else if(l>0){if(u===""){
  // The first part is blank if the path is absolute. Trying to go
  // above the root is a no-op. Therefore we can remove all '..' parts
  // directly after the root.
  s.splice(c+1,l);l=0}else{s.splice(c,2);l--}}}t=s.join("/");if(t===""){t=r?"/":"."}if(i){i.path=t;return a(i)}return t}n.normalize=u;/**
   * Joins two paths/URLs.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be joined with the root.
   *
   * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
   *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
   *   first.
   * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
   *   is updated with the result and aRoot is returned. Otherwise the result
   *   is returned.
   *   - If aPath is absolute, the result is aPath.
   *   - Otherwise the two paths are joined with a slash.
   * - Joining for example 'http://' and 'www.example.com' is also supported.
   */
  function l(e,t){if(e===""){e="."}if(t===""){t="."}var n=o(t);var i=o(e);if(i){e=i.path||"/"}
  // `join(foo, '//www.example.org')`
  if(n&&!n.scheme){if(i){n.scheme=i.scheme}return a(n)}if(n||t.match(s)){return t}
  // `join('http://', 'www.example.com')`
  if(i&&!i.host&&!i.path){i.host=t;return a(i)}var r=t.charAt(0)==="/"?t:u(e.replace(/\/+$/,"")+"/"+t);if(i){i.path=r;return a(i)}return r}n.join=l;n.isAbsolute=function(e){return e.charAt(0)==="/"||r.test(e)};/**
   * Make a path relative to a URL or another path.
   *
   * @param aRoot The root path or URL.
   * @param aPath The path or URL to be made relative to aRoot.
   */
  function c(e,t){if(e===""){e="."}e=e.replace(/\/$/,"");
  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var n=0;while(t.indexOf(e+"/")!==0){var i=e.lastIndexOf("/");if(i<0){return t}
  // If the only part of the root that is left is the scheme (i.e. http://,
  // file:///, etc.), one or more slashes (/), or simply nothing at all, we
  // have exhausted all components, so the path is not relative to the root.
  e=e.slice(0,i);if(e.match(/^([^\/]+:\/)?\/*$/)){return t}++n}
  // Make sure we add a "../" for each component we removed from the root.
  return Array(n+1).join("../")+t.substr(e.length+1)}n.relative=c;var h=function(){var e=Object.create(null);return!("__proto__"in e)}();function f(e){return e}/**
   * Because behavior goes wacky when you set `__proto__` on objects, we
   * have to prefix all the strings in our set with an arbitrary character.
   *
   * See https://github.com/mozilla/source-map/pull/31 and
   * https://github.com/mozilla/source-map/issues/30
   *
   * @param String aStr
   */
  function p(e){if(g(e)){return"$"+e}return e}n.toSetString=h?f:p;function d(e){if(g(e)){return e.slice(1)}return e}n.fromSetString=h?f:d;function g(e){if(!e){return false}var t=e.length;if(t<9){return false}if(e.charCodeAt(t-1)!==95||e.charCodeAt(t-2)!==95||e.charCodeAt(t-3)!==111||e.charCodeAt(t-4)!==116||e.charCodeAt(t-5)!==111||e.charCodeAt(t-6)!==114||e.charCodeAt(t-7)!==112||e.charCodeAt(t-8)!==95||e.charCodeAt(t-9)!==95){return false}for(var n=t-10;n>=0;n--){if(e.charCodeAt(n)!==36){return false}}return true}/**
   * Comparator between two mappings where the original positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same original source/line/column, but different generated
   * line and column the same. Useful when searching for a mapping with a
   * stubbed out mapping.
   */
  function m(e,t,n){var i=v(e.source,t.source);if(i!==0){return i}i=e.originalLine-t.originalLine;if(i!==0){return i}i=e.originalColumn-t.originalColumn;if(i!==0||n){return i}i=e.generatedColumn-t.generatedColumn;if(i!==0){return i}i=e.generatedLine-t.generatedLine;if(i!==0){return i}return v(e.name,t.name)}n.compareByOriginalPositions=m;/**
   * Comparator between two mappings with deflated source and name indices where
   * the generated positions are compared.
   *
   * Optionally pass in `true` as `onlyCompareGenerated` to consider two
   * mappings with the same generated line and column, but different
   * source/name/original line and column the same. Useful when searching for a
   * mapping with a stubbed out mapping.
   */
  function y(e,t,n){var i=e.generatedLine-t.generatedLine;if(i!==0){return i}i=e.generatedColumn-t.generatedColumn;if(i!==0||n){return i}i=v(e.source,t.source);if(i!==0){return i}i=e.originalLine-t.originalLine;if(i!==0){return i}i=e.originalColumn-t.originalColumn;if(i!==0){return i}return v(e.name,t.name)}n.compareByGeneratedPositionsDeflated=y;function v(e,t){if(e===t){return 0}if(e===null){return 1}if(t===null){return-1}if(e>t){return 1}return-1}/**
   * Comparator between two mappings with inflated source and name strings where
   * the generated positions are compared.
   */
  function b(e,t){var n=e.generatedLine-t.generatedLine;if(n!==0){return n}n=e.generatedColumn-t.generatedColumn;if(n!==0){return n}n=v(e.source,t.source);if(n!==0){return n}n=e.originalLine-t.originalLine;if(n!==0){return n}n=e.originalColumn-t.originalColumn;if(n!==0){return n}return v(e.name,t.name)}n.compareByGeneratedPositionsInflated=b;/**
   * Strip any JSON XSSI avoidance prefix from the string (as documented
   * in the source maps specification), and then parse the string as
   * JSON.
   */
  function w(e){return JSON.parse(e.replace(/^\)]}'[^\n]*\n/,""))}n.parseSourceMapInput=w;/**
   * Compute the URL of a source given the the source root, the source's
   * URL, and the source map's URL.
   */
  function k(e,t,n){t=t||"";if(e){
  // This follows what Chrome does.
  if(e[e.length-1]!=="/"&&t[0]!=="/"){e+="/"}
  // The spec says:
  //   Line 4: An optional source root, useful for relocating source
  //   files on a server or removing repeated values in the
  //   sources entry.  This value is prepended to the individual
  //   entries in the source field.
  t=e+t}
  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   sourceRoot, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if(n){var i=o(n);if(!i){throw new Error("sourceMapURL could not be parsed")}if(i.path){
  // Strip the last path component, but keep the "/".
  var r=i.path.lastIndexOf("/");if(r>=0){i.path=i.path.substring(0,r+1)}}t=l(a(i),t)}return u(t)}n.computeSourceURL=k},{}],31:[function(e,t,n){/*
   * Copyright 2009-2011 Mozilla Foundation and contributors
   * Licensed under the New BSD license. See LICENSE.txt or:
   * http://opensource.org/licenses/BSD-3-Clause
   */
  n.SourceMapGenerator=e("./lib/source-map-generator").SourceMapGenerator;n.SourceMapConsumer=e("./lib/source-map-consumer").SourceMapConsumer;n.SourceNode=e("./lib/source-node").SourceNode},{"./lib/source-map-consumer":27,"./lib/source-map-generator":28,"./lib/source-node":29}],blackpard:[function(e,t,n){
  // Generated by blackpard 1.6.1
  var i;i=e("./index");i.stab=function(e,t,n){var r;try{i.run(e,{filename:n,map:"embedded"})}catch(s){r=s}if(typeof t=="function"){t(r)}};i.load=function(e,t){var n;n=new XMLHttpRequest;n.open("GET",e,true);if("overrideMimeType"in n){n.overrideMimeType("text/plain")}n.onreadystatechange=function(){var r;if(n.readyState===4){if((r=n.status)===200||r===0){i.stab(n.responseText,t,e)}else{if(typeof t=="function"){t(Error(e+": "+n.status+" "+n.statusText))}}}};n.send(null);return n};i.go=function(){var e,t,n,r,s,o,a;e=/^(?:text\/|application\/)?ls$/i;t=function(e){e&&setTimeout(function(){throw e})};for(n=0,s=(r=document.getElementsByTagName("script")).length;n<s;++n){o=r[n];if(e.test(o.type)){if(a=o.src){i.load(a,t)}else{i.stab(o.innerHTML,t,o.id)}}}};t.exports=i},{"./index":2}]},{},[]);
  
  (function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.bpMl = {}));
}(this, (function (exports) { 'use strict';

    /**
     * Relu Activation, aka Rectified Linear Unit Activation
     * @description https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
     */
    function activate$3(weight) {
        return Math.max(0, weight);
    }
    /**
     * Relu derivative
     */
    function measure$3(weight, delta) {
        if (weight <= 0) {
            return 0;
        }
        return delta;
    }

    var relu$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        activate: activate$3,
        measure: measure$3
    });

    /**
     * sigmoid activation
     */
    function activate$2(value) {
        return 1 / (1 + Math.exp(-value));
    }
    /**
     * sigmoid derivative
     */
    function measure$2(weight, error) {
        return weight * (1 - weight) * error;
    }

    var sigmoid$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        activate: activate$2,
        measure: measure$2
    });

    /**
     * Hyperbolic tan
     */
    function activate$1(weight) {
        return Math.tanh(weight);
    }
    /**
     * @description grad for z = tanh(x) is (1 - z^2)
     */
    function measure$1(weight, error) {
        return (1 - weight * weight) * error;
    }

    var tanh$2 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        activate: activate$1,
        measure: measure$1
    });

    /**
     * Leaky Relu Activation, aka Leaky Rectified Linear Unit Activation
     * @description https://en.wikipedia.org/wiki/Rectifier_(neural_networks)
     */
    function activate(weight) {
        return weight > 0 ? weight : 0.01 * weight;
    }
    /**
     * Leaky Relu derivative
     */
    function measure(weight, error) {
        return weight > 0 ? error : 0.01 * error;
    }

    var leakyRelu$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        activate: activate,
        measure: measure
    });

    var index$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        relu: relu$2,
        sigmoid: sigmoid$2,
        tanh: tanh$2,
        leakyRelu: leakyRelu$1
    });

    class CrossValidate {
        constructor(initClassifier) {
            this.json = {
                avgs: {
                    error: 0,
                    iterations: 0,
                    testTime: 0,
                    trainTime: 0,
                },
                stats: {
                    total: 0,
                    testSize: 0,
                    trainSize: 0,
                },
                sets: [],
            };
            this.initClassifier = initClassifier;
        }
        testPartition(trainOpts, trainSet, testSet) {
            const classifier = this.initClassifier();
            const beginTrain = Date.now();
            const trainingStats = classifier.train(trainSet, trainOpts);
            const beginTest = Date.now();
            const testStats = classifier.test(testSet);
            const endTest = Date.now();
            return {
                ...testStats,
                trainTime: beginTest - beginTrain,
                testTime: endTest - beginTest,
                iterations: trainingStats.iterations,
                error: trainingStats.error,
                total: testStats.total,
                network: classifier.toJSON(),
            };
        }
        /**
         * Randomize array element order in-place.
         * Using Durstenfeld shuffle algorithm.
         * source: http://stackoverflow.com/a/12646864/1324039
         */
        shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const temp = array[i];
                array[i] = array[j];
                array[j] = temp;
            }
            return array;
        }
        train(data, trainOpts = {}, k = 4) {
            if (data.length < k) {
                throw new Error(`Training set size is too small for ${data.length} k folds of ${k}`);
            }
            this.shuffleArray(data);
            const size = data.length / k;
            const avgs = {
                trainTime: 0,
                testTime: 0,
                iterations: 0,
                error: 0,
            };
            const stats = {
                total: 0,
                testSize: 0,
                trainSize: 0,
            };
            const binaryStats = {
                total: 0,
                testSize: 0,
                trainSize: 0,
                truePos: 0,
                trueNeg: 0,
                falsePos: 0,
                falseNeg: 0,
                precision: 0,
                recall: 0,
                accuracy: 0,
            };
            const results = [];
            let isBinary = null;
            for (let i = 0; i < k; i++) {
                const dclone = data.slice(0);
                const testSet = dclone.splice(i * size, size);
                const trainSet = dclone;
                const result = this.testPartition(trainOpts, trainSet, testSet);
                if (isBinary === null) {
                    isBinary =
                        result.hasOwnProperty('falseNeg') &&
                            result.hasOwnProperty('falsePos') &&
                            result.hasOwnProperty('trueNeg') &&
                            result.hasOwnProperty('truePos');
                    if (isBinary) {
                        Object.assign(stats, binaryStats);
                    }
                }
                avgs.iterations += result.iterations;
                avgs.testTime += result.testTime;
                avgs.trainTime += result.trainTime;
                avgs.error += result.error;
                stats.total += result.total;
                if (CrossValidate.isBinaryStats(stats) &&
                    CrossValidate.isBinaryPartitionResults(result)) {
                    stats.accuracy += result.accuracy;
                    stats.falseNeg += result.falseNeg;
                    stats.falsePos += result.falsePos;
                    stats.precision += result.precision;
                    stats.recall += result.recall;
                    stats.trueNeg += result.trueNeg;
                    stats.truePos += result.truePos;
                }
                results.push(result);
            }
            avgs.error /= k;
            avgs.iterations /= k;
            avgs.testTime /= k;
            avgs.trainTime /= k;
            if (CrossValidate.isBinaryStats(stats)) {
                stats.precision = stats.truePos / (stats.truePos + stats.falsePos);
                stats.recall = stats.truePos / (stats.truePos + stats.falseNeg);
                stats.accuracy = (stats.trueNeg + stats.truePos) / stats.total;
            }
            stats.testSize = size;
            stats.trainSize = data.length - size;
            this.json = {
                avgs: avgs,
                stats: stats,
                sets: results,
            };
            return this.json;
        }
        toNeuralNetwork() {
            return this.fromJSON(this.json);
        }
        toJSON() {
            return this.json;
        }
        fromJSON(crossValidateJson) {
            const winningJSON = crossValidateJson.sets.reduce((prev, cur) => (prev.error < cur.error ? prev : cur));
            return this.initClassifier().fromJSON(winningJSON.network);
        }
    }
    CrossValidate.isBinaryStats = (stats) => {
        return (stats.accuracy !== undefined);
    };
    CrossValidate.isBinaryResults = (stats) => stats.stats.accuracy !== undefined;
    CrossValidate.isBinaryPartitionResults = (stats) => stats.accuracy !==
        undefined;

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    		path: basedir,
    		exports: {},
    		require: function (path, base) {
    			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    		}
    	}, fn(module, module.exports), module.exports;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var gpuBrowser = createCommonjsModule(function (module, exports) {
    /**
     * gpu.js
     * http://gpu.rocks/
     *
     * GPU Accelerated JavaScript
     *
     * @version 2.16.0
     * @date Wed Nov 16 2022 15:48:37 GMT-0500 (Eastern Standard Time)
     *
     * @license MIT
     * The MIT License
     *
     * Copyright (c) 2022 gpu.js Team
     */(function(f){{module.exports=f();}})(function(){return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof commonjsRequire&&commonjsRequire;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t);}return n[i].exports}for(var u="function"==typeof commonjsRequire&&commonjsRequire,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
    (function (global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
      (global = global || self, factory(global.acorn = {}));
    }(this, function (exports) {

      var reservedWords = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      };


      var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";

      var keywords = {
        5: ecma5AndLessKeywords,
        "5module": ecma5AndLessKeywords + " export import",
        6: ecma5AndLessKeywords + " const class extends export import super"
      };

      var keywordRelationalOperator = /^in(stanceof)?$/;


      var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
      var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

      var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
      var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

      nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;


      var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

      var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];

      function isInAstralSet(code, set) {
        var pos = 0x10000;
        for (var i = 0; i < set.length; i += 2) {
          pos += set[i];
          if (pos > code) { return false }
          pos += set[i + 1];
          if (pos >= code) { return true }
        }
      }


      function isIdentifierStart(code, astral) {
        if (code < 65) { return code === 36 }
        if (code < 91) { return true }
        if (code < 97) { return code === 95 }
        if (code < 123) { return true }
        if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
        if (astral === false) { return false }
        return isInAstralSet(code, astralIdentifierStartCodes)
      }


      function isIdentifierChar(code, astral) {
        if (code < 48) { return code === 36 }
        if (code < 58) { return true }
        if (code < 65) { return false }
        if (code < 91) { return true }
        if (code < 97) { return code === 95 }
        if (code < 123) { return true }
        if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
        if (astral === false) { return false }
        return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
      }





      var TokenType = function TokenType(label, conf) {
        if ( conf === void 0 ) conf = {};

        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop || null;
        this.updateContext = null;
      };

      function binop(name, prec) {
        return new TokenType(name, {beforeExpr: true, binop: prec})
      }
      var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};


      var keywords$1 = {};

      function kw(name, options) {
        if ( options === void 0 ) options = {};

        options.keyword = name;
        return keywords$1[name] = new TokenType(name, options)
      }

      var types = {
        num: new TokenType("num", startsExpr),
        regexp: new TokenType("regexp", startsExpr),
        string: new TokenType("string", startsExpr),
        name: new TokenType("name", startsExpr),
        eof: new TokenType("eof"),

        bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
        bracketR: new TokenType("]"),
        braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
        braceR: new TokenType("}"),
        parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
        parenR: new TokenType(")"),
        comma: new TokenType(",", beforeExpr),
        semi: new TokenType(";", beforeExpr),
        colon: new TokenType(":", beforeExpr),
        dot: new TokenType("."),
        question: new TokenType("?", beforeExpr),
        arrow: new TokenType("=>", beforeExpr),
        template: new TokenType("template"),
        invalidTemplate: new TokenType("invalidTemplate"),
        ellipsis: new TokenType("...", beforeExpr),
        backQuote: new TokenType("`", startsExpr),
        dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),


        eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
        assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
        incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
        prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
        logicalOR: binop("||", 1),
        logicalAND: binop("&&", 2),
        bitwiseOR: binop("|", 3),
        bitwiseXOR: binop("^", 4),
        bitwiseAND: binop("&", 5),
        equality: binop("==/!=/===/!==", 6),
        relational: binop("</>/<=/>=", 7),
        bitShift: binop("<</>>/>>>", 8),
        plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
        modulo: binop("%", 10),
        star: binop("*", 10),
        slash: binop("/", 10),
        starstar: new TokenType("**", {beforeExpr: true}),

        _break: kw("break"),
        _case: kw("case", beforeExpr),
        _catch: kw("catch"),
        _continue: kw("continue"),
        _debugger: kw("debugger"),
        _default: kw("default", beforeExpr),
        _do: kw("do", {isLoop: true, beforeExpr: true}),
        _else: kw("else", beforeExpr),
        _finally: kw("finally"),
        _for: kw("for", {isLoop: true}),
        _function: kw("function", startsExpr),
        _if: kw("if"),
        _return: kw("return", beforeExpr),
        _switch: kw("switch"),
        _throw: kw("throw", beforeExpr),
        _try: kw("try"),
        _var: kw("var"),
        _const: kw("const"),
        _while: kw("while", {isLoop: true}),
        _with: kw("with"),
        _new: kw("new", {beforeExpr: true, startsExpr: true}),
        _this: kw("this", startsExpr),
        _super: kw("super", startsExpr),
        _class: kw("class", startsExpr),
        _extends: kw("extends", beforeExpr),
        _export: kw("export"),
        _import: kw("import", startsExpr),
        _null: kw("null", startsExpr),
        _true: kw("true", startsExpr),
        _false: kw("false", startsExpr),
        _in: kw("in", {beforeExpr: true, binop: 7}),
        _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
        _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
        _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
        _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
      };


      var lineBreak = /\r\n?|\n|\u2028|\u2029/;
      var lineBreakG = new RegExp(lineBreak.source, "g");

      function isNewLine(code, ecma2019String) {
        return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))
      }

      var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

      var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;

      var ref = Object.prototype;
      var hasOwnProperty = ref.hasOwnProperty;
      var toString = ref.toString;


      function has(obj, propName) {
        return hasOwnProperty.call(obj, propName)
      }

      var isArray = Array.isArray || (function (obj) { return (
        toString.call(obj) === "[object Array]"
      ); });

      function wordsRegexp(words) {
        return new RegExp("^(?:" + words.replace(/ /g, "|") + ")$")
      }


      var Position = function Position(line, col) {
        this.line = line;
        this.column = col;
      };

      Position.prototype.offset = function offset (n) {
        return new Position(this.line, this.column + n)
      };

      var SourceLocation = function SourceLocation(p, start, end) {
        this.start = start;
        this.end = end;
        if (p.sourceFile !== null) { this.source = p.sourceFile; }
      };


      function getLineInfo(input, offset) {
        for (var line = 1, cur = 0;;) {
          lineBreakG.lastIndex = cur;
          var match = lineBreakG.exec(input);
          if (match && match.index < offset) {
            ++line;
            cur = match.index + match[0].length;
          } else {
            return new Position(line, offset - cur)
          }
        }
      }


      var defaultOptions = {
        ecmaVersion: 10,
        sourceType: "script",
        onInsertedSemicolon: null,
        onTrailingComma: null,
        allowReserved: null,
        allowReturnOutsideFunction: false,
        allowImportExportEverywhere: false,
        allowAwaitOutsideFunction: false,
        allowHashBang: false,
        locations: false,
        onToken: null,
        onComment: null,
        ranges: false,
        program: null,
        sourceFile: null,
        directSourceFile: null,
        preserveParens: false
      };


      function getOptions(opts) {
        var options = {};

        for (var opt in defaultOptions)
          { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }

        if (options.ecmaVersion >= 2015)
          { options.ecmaVersion -= 2009; }

        if (options.allowReserved == null)
          { options.allowReserved = options.ecmaVersion < 5; }

        if (isArray(options.onToken)) {
          var tokens = options.onToken;
          options.onToken = function (token) { return tokens.push(token); };
        }
        if (isArray(options.onComment))
          { options.onComment = pushComment(options, options.onComment); }

        return options
      }

      function pushComment(options, array) {
        return function(block, text, start, end, startLoc, endLoc) {
          var comment = {
            type: block ? "Block" : "Line",
            value: text,
            start: start,
            end: end
          };
          if (options.locations)
            { comment.loc = new SourceLocation(this, startLoc, endLoc); }
          if (options.ranges)
            { comment.range = [start, end]; }
          array.push(comment);
        }
      }

      var
          SCOPE_TOP = 1,
          SCOPE_FUNCTION = 2,
          SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,
          SCOPE_ASYNC = 4,
          SCOPE_GENERATOR = 8,
          SCOPE_ARROW = 16,
          SCOPE_SIMPLE_CATCH = 32,
          SCOPE_SUPER = 64,
          SCOPE_DIRECT_SUPER = 128;

      function functionFlags(async, generator) {
        return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)
      }

      var
          BIND_NONE = 0, 
          BIND_VAR = 1, 
          BIND_LEXICAL = 2, 
          BIND_FUNCTION = 3, 
          BIND_SIMPLE_CATCH = 4, 
          BIND_OUTSIDE = 5; 

      var Parser = function Parser(options, input, startPos) {
        this.options = options = getOptions(options);
        this.sourceFile = options.sourceFile;
        this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === "module" ? "5module" : 5]);
        var reserved = "";
        if (options.allowReserved !== true) {
          for (var v = options.ecmaVersion;; v--)
            { if (reserved = reservedWords[v]) { break } }
          if (options.sourceType === "module") { reserved += " await"; }
        }
        this.reservedWords = wordsRegexp(reserved);
        var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
        this.reservedWordsStrict = wordsRegexp(reservedStrict);
        this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
        this.input = String(input);

        this.containsEsc = false;


        if (startPos) {
          this.pos = startPos;
          this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
          this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
        } else {
          this.pos = this.lineStart = 0;
          this.curLine = 1;
        }

        this.type = types.eof;
        this.value = null;
        this.start = this.end = this.pos;
        this.startLoc = this.endLoc = this.curPosition();

        this.lastTokEndLoc = this.lastTokStartLoc = null;
        this.lastTokStart = this.lastTokEnd = this.pos;

        this.context = this.initialContext();
        this.exprAllowed = true;

        this.inModule = options.sourceType === "module";
        this.strict = this.inModule || this.strictDirective(this.pos);

        this.potentialArrowAt = -1;

        this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
        this.labels = [];
        this.undefinedExports = {};

        if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === "#!")
          { this.skipLineComment(2); }

        this.scopeStack = [];
        this.enterScope(SCOPE_TOP);

        this.regexpState = null;
      };

      var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };

      Parser.prototype.parse = function parse () {
        var node = this.options.program || this.startNode();
        this.nextToken();
        return this.parseTopLevel(node)
      };

      prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };
      prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };
      prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };
      prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };
      prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };
      prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };

      Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };

      Parser.extend = function extend () {
          var plugins = [], len = arguments.length;
          while ( len-- ) plugins[ len ] = arguments[ len ];

        var cls = this;
        for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }
        return cls
      };

      Parser.parse = function parse (input, options) {
        return new this(options, input).parse()
      };

      Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {
        var parser = new this(options, input, pos);
        parser.nextToken();
        return parser.parseExpression()
      };

      Parser.tokenizer = function tokenizer (input, options) {
        return new this(options, input)
      };

      Object.defineProperties( Parser.prototype, prototypeAccessors );

      var pp = Parser.prototype;


      var literal = /^(?:'((?:\\.|[^'])*?)'|"((?:\\.|[^"])*?)")/;
      pp.strictDirective = function(start) {
        for (;;) {
          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          var match = literal.exec(this.input.slice(start));
          if (!match) { return false }
          if ((match[1] || match[2]) === "use strict") { return true }
          start += match[0].length;

          skipWhiteSpace.lastIndex = start;
          start += skipWhiteSpace.exec(this.input)[0].length;
          if (this.input[start] === ";")
            { start++; }
        }
      };


      pp.eat = function(type) {
        if (this.type === type) {
          this.next();
          return true
        } else {
          return false
        }
      };


      pp.isContextual = function(name) {
        return this.type === types.name && this.value === name && !this.containsEsc
      };


      pp.eatContextual = function(name) {
        if (!this.isContextual(name)) { return false }
        this.next();
        return true
      };


      pp.expectContextual = function(name) {
        if (!this.eatContextual(name)) { this.unexpected(); }
      };


      pp.canInsertSemicolon = function() {
        return this.type === types.eof ||
          this.type === types.braceR ||
          lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
      };

      pp.insertSemicolon = function() {
        if (this.canInsertSemicolon()) {
          if (this.options.onInsertedSemicolon)
            { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }
          return true
        }
      };


      pp.semicolon = function() {
        if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }
      };

      pp.afterTrailingComma = function(tokType, notNext) {
        if (this.type === tokType) {
          if (this.options.onTrailingComma)
            { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }
          if (!notNext)
            { this.next(); }
          return true
        }
      };


      pp.expect = function(type) {
        this.eat(type) || this.unexpected();
      };


      pp.unexpected = function(pos) {
        this.raise(pos != null ? pos : this.start, "Unexpected token");
      };

      function DestructuringErrors() {
        this.shorthandAssign =
        this.trailingComma =
        this.parenthesizedAssign =
        this.parenthesizedBind =
        this.doubleProto =
          -1;
      }

      pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {
        if (!refDestructuringErrors) { return }
        if (refDestructuringErrors.trailingComma > -1)
          { this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element"); }
        var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
        if (parens > -1) { this.raiseRecoverable(parens, "Parenthesized pattern"); }
      };

      pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
        if (!refDestructuringErrors) { return false }
        var shorthandAssign = refDestructuringErrors.shorthandAssign;
        var doubleProto = refDestructuringErrors.doubleProto;
        if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }
        if (shorthandAssign >= 0)
          { this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns"); }
        if (doubleProto >= 0)
          { this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property"); }
      };

      pp.checkYieldAwaitInDefaultParams = function() {
        if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))
          { this.raise(this.yieldPos, "Yield expression cannot be a default value"); }
        if (this.awaitPos)
          { this.raise(this.awaitPos, "Await expression cannot be a default value"); }
      };

      pp.isSimpleAssignTarget = function(expr) {
        if (expr.type === "ParenthesizedExpression")
          { return this.isSimpleAssignTarget(expr.expression) }
        return expr.type === "Identifier" || expr.type === "MemberExpression"
      };

      var pp$1 = Parser.prototype;



      pp$1.parseTopLevel = function(node) {
        var exports = {};
        if (!node.body) { node.body = []; }
        while (this.type !== types.eof) {
          var stmt = this.parseStatement(null, true, exports);
          node.body.push(stmt);
        }
        if (this.inModule)
          { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)
            {
              var name = list[i];

              this.raiseRecoverable(this.undefinedExports[name].start, ("Export '" + name + "' is not defined"));
            } }
        this.adaptDirectivePrologue(node.body);
        this.next();
        node.sourceType = this.options.sourceType;
        return this.finishNode(node, "Program")
      };

      var loopLabel = {kind: "loop"}, switchLabel = {kind: "switch"};

      pp$1.isLet = function(context) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let")) { return false }
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 91) { return true } 
        if (context) { return false }

        if (nextCh === 123) { return true } 
        if (isIdentifierStart(nextCh, true)) {
          var pos = next + 1;
          while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }
          var ident = this.input.slice(next, pos);
          if (!keywordRelationalOperator.test(ident)) { return true }
        }
        return false
      };

      pp$1.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
          { return false }

        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length;
        return !lineBreak.test(this.input.slice(this.pos, next)) &&
          this.input.slice(next, next + 8) === "function" &&
          (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))
      };


      pp$1.parseStatement = function(context, topLevel, exports) {
        var starttype = this.type, node = this.startNode(), kind;

        if (this.isLet(context)) {
          starttype = types._var;
          kind = "let";
        }


        switch (starttype) {
        case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)
        case types._debugger: return this.parseDebuggerStatement(node)
        case types._do: return this.parseDoStatement(node)
        case types._for: return this.parseForStatement(node)
        case types._function:
          if ((context && (this.strict || context !== "if" && context !== "label")) && this.options.ecmaVersion >= 6) { this.unexpected(); }
          return this.parseFunctionStatement(node, false, !context)
        case types._class:
          if (context) { this.unexpected(); }
          return this.parseClass(node, true)
        case types._if: return this.parseIfStatement(node)
        case types._return: return this.parseReturnStatement(node)
        case types._switch: return this.parseSwitchStatement(node)
        case types._throw: return this.parseThrowStatement(node)
        case types._try: return this.parseTryStatement(node)
        case types._const: case types._var:
          kind = kind || this.value;
          if (context && kind !== "var") { this.unexpected(); }
          return this.parseVarStatement(node, kind)
        case types._while: return this.parseWhileStatement(node)
        case types._with: return this.parseWithStatement(node)
        case types.braceL: return this.parseBlock(true, node)
        case types.semi: return this.parseEmptyStatement(node)
        case types._export:
        case types._import:
          if (this.options.ecmaVersion > 10 && starttype === types._import) {
            skipWhiteSpace.lastIndex = this.pos;
            var skip = skipWhiteSpace.exec(this.input);
            var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
            if (nextCh === 40) 
              { return this.parseExpressionStatement(node, this.parseExpression()) }
          }

          if (!this.options.allowImportExportEverywhere) {
            if (!topLevel)
              { this.raise(this.start, "'import' and 'export' may only appear at the top level"); }
            if (!this.inModule)
              { this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'"); }
          }
          return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)

        default:
          if (this.isAsyncFunction()) {
            if (context) { this.unexpected(); }
            this.next();
            return this.parseFunctionStatement(node, true, !context)
          }

          var maybeName = this.value, expr = this.parseExpression();
          if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon))
            { return this.parseLabeledStatement(node, maybeName, expr, context) }
          else { return this.parseExpressionStatement(node, expr) }
        }
      };

      pp$1.parseBreakContinueStatement = function(node, keyword) {
        var isBreak = keyword === "break";
        this.next();
        if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }
        else if (this.type !== types.name) { this.unexpected(); }
        else {
          node.label = this.parseIdent();
          this.semicolon();
        }

        var i = 0;
        for (; i < this.labels.length; ++i) {
          var lab = this.labels[i];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === "loop")) { break }
            if (node.label && isBreak) { break }
          }
        }
        if (i === this.labels.length) { this.raise(node.start, "Unsyntactic " + keyword); }
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement")
      };

      pp$1.parseDebuggerStatement = function(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement")
      };

      pp$1.parseDoStatement = function(node) {
        this.next();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("do");
        this.labels.pop();
        this.expect(types._while);
        node.test = this.parseParenExpression();
        if (this.options.ecmaVersion >= 6)
          { this.eat(types.semi); }
        else
          { this.semicolon(); }
        return this.finishNode(node, "DoWhileStatement")
      };


      pp$1.parseForStatement = function(node) {
        this.next();
        var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual("await")) ? this.lastTokStart : -1;
        this.labels.push(loopLabel);
        this.enterScope(0);
        this.expect(types.parenL);
        if (this.type === types.semi) {
          if (awaitAt > -1) { this.unexpected(awaitAt); }
          return this.parseFor(node, null)
        }
        var isLet = this.isLet();
        if (this.type === types._var || this.type === types._const || isLet) {
          var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
          this.next();
          this.parseVar(init$1, true, kind);
          this.finishNode(init$1, "VariableDeclaration");
          if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) && init$1.declarations.length === 1) {
            if (this.options.ecmaVersion >= 9) {
              if (this.type === types._in) {
                if (awaitAt > -1) { this.unexpected(awaitAt); }
              } else { node.await = awaitAt > -1; }
            }
            return this.parseForIn(node, init$1)
          }
          if (awaitAt > -1) { this.unexpected(awaitAt); }
          return this.parseFor(node, init$1)
        }
        var refDestructuringErrors = new DestructuringErrors;
        var init = this.parseExpression(true, refDestructuringErrors);
        if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
          if (this.options.ecmaVersion >= 9) {
            if (this.type === types._in) {
              if (awaitAt > -1) { this.unexpected(awaitAt); }
            } else { node.await = awaitAt > -1; }
          }
          this.toAssignable(init, false, refDestructuringErrors);
          this.checkLVal(init);
          return this.parseForIn(node, init)
        } else {
          this.checkExpressionErrors(refDestructuringErrors, true);
        }
        if (awaitAt > -1) { this.unexpected(awaitAt); }
        return this.parseFor(node, init)
      };

      pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {
        this.next();
        return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)
      };

      pp$1.parseIfStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        node.consequent = this.parseStatement("if");
        node.alternate = this.eat(types._else) ? this.parseStatement("if") : null;
        return this.finishNode(node, "IfStatement")
      };

      pp$1.parseReturnStatement = function(node) {
        if (!this.inFunction && !this.options.allowReturnOutsideFunction)
          { this.raise(this.start, "'return' outside of function"); }
        this.next();


        if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }
        else { node.argument = this.parseExpression(); this.semicolon(); }
        return this.finishNode(node, "ReturnStatement")
      };

      pp$1.parseSwitchStatement = function(node) {
        this.next();
        node.discriminant = this.parseParenExpression();
        node.cases = [];
        this.expect(types.braceL);
        this.labels.push(switchLabel);
        this.enterScope(0);


        var cur;
        for (var sawDefault = false; this.type !== types.braceR;) {
          if (this.type === types._case || this.type === types._default) {
            var isCase = this.type === types._case;
            if (cur) { this.finishNode(cur, "SwitchCase"); }
            node.cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) { this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"); }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(types.colon);
          } else {
            if (!cur) { this.unexpected(); }
            cur.consequent.push(this.parseStatement(null));
          }
        }
        this.exitScope();
        if (cur) { this.finishNode(cur, "SwitchCase"); }
        this.next(); 
        this.labels.pop();
        return this.finishNode(node, "SwitchStatement")
      };

      pp$1.parseThrowStatement = function(node) {
        this.next();
        if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))
          { this.raise(this.lastTokEnd, "Illegal newline after throw"); }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement")
      };


      var empty = [];

      pp$1.parseTryStatement = function(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.type === types._catch) {
          var clause = this.startNode();
          this.next();
          if (this.eat(types.parenL)) {
            clause.param = this.parseBindingAtom();
            var simple = clause.param.type === "Identifier";
            this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);
            this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
            this.expect(types.parenR);
          } else {
            if (this.options.ecmaVersion < 10) { this.unexpected(); }
            clause.param = null;
            this.enterScope(0);
          }
          clause.body = this.parseBlock(false);
          this.exitScope();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer)
          { this.raise(node.start, "Missing catch or finally clause"); }
        return this.finishNode(node, "TryStatement")
      };

      pp$1.parseVarStatement = function(node, kind) {
        this.next();
        this.parseVar(node, false, kind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration")
      };

      pp$1.parseWhileStatement = function(node) {
        this.next();
        node.test = this.parseParenExpression();
        this.labels.push(loopLabel);
        node.body = this.parseStatement("while");
        this.labels.pop();
        return this.finishNode(node, "WhileStatement")
      };

      pp$1.parseWithStatement = function(node) {
        if (this.strict) { this.raise(this.start, "'with' in strict mode"); }
        this.next();
        node.object = this.parseParenExpression();
        node.body = this.parseStatement("with");
        return this.finishNode(node, "WithStatement")
      };

      pp$1.parseEmptyStatement = function(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement")
      };

      pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {
        for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)
          {
          var label = list[i$1];

          if (label.name === maybeName)
            { this.raise(expr.start, "Label '" + maybeName + "' is already declared");
        } }
        var kind = this.type.isLoop ? "loop" : this.type === types._switch ? "switch" : null;
        for (var i = this.labels.length - 1; i >= 0; i--) {
          var label$1 = this.labels[i];
          if (label$1.statementStart === node.start) {
            label$1.statementStart = this.start;
            label$1.kind = kind;
          } else { break }
        }
        this.labels.push({name: maybeName, kind: kind, statementStart: this.start});
        node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
        this.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement")
      };

      pp$1.parseExpressionStatement = function(node, expr) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement")
      };


      pp$1.parseBlock = function(createNewLexicalScope, node) {
        if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;
        if ( node === void 0 ) node = this.startNode();

        node.body = [];
        this.expect(types.braceL);
        if (createNewLexicalScope) { this.enterScope(0); }
        while (!this.eat(types.braceR)) {
          var stmt = this.parseStatement(null);
          node.body.push(stmt);
        }
        if (createNewLexicalScope) { this.exitScope(); }
        return this.finishNode(node, "BlockStatement")
      };


      pp$1.parseFor = function(node, init) {
        node.init = init;
        this.expect(types.semi);
        node.test = this.type === types.semi ? null : this.parseExpression();
        this.expect(types.semi);
        node.update = this.type === types.parenR ? null : this.parseExpression();
        this.expect(types.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, "ForStatement")
      };


      pp$1.parseForIn = function(node, init) {
        var isForIn = this.type === types._in;
        this.next();

        if (
          init.type === "VariableDeclaration" &&
          init.declarations[0].init != null &&
          (
            !isForIn ||
            this.options.ecmaVersion < 8 ||
            this.strict ||
            init.kind !== "var" ||
            init.declarations[0].id.type !== "Identifier"
          )
        ) {
          this.raise(
            init.start,
            ((isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer")
          );
        } else if (init.type === "AssignmentPattern") {
          this.raise(init.start, "Invalid left-hand side in for-loop");
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
        this.expect(types.parenR);
        node.body = this.parseStatement("for");
        this.exitScope();
        this.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement")
      };


      pp$1.parseVar = function(node, isFor, kind) {
        node.declarations = [];
        node.kind = kind;
        for (;;) {
          var decl = this.startNode();
          this.parseVarId(decl, kind);
          if (this.eat(types.eq)) {
            decl.init = this.parseMaybeAssign(isFor);
          } else if (kind === "const" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual("of")))) {
            this.unexpected();
          } else if (decl.id.type !== "Identifier" && !(isFor && (this.type === types._in || this.isContextual("of")))) {
            this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
          } else {
            decl.init = null;
          }
          node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(types.comma)) { break }
        }
        return node
      };

      pp$1.parseVarId = function(decl, kind) {
        decl.id = this.parseBindingAtom();
        this.checkLVal(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
      };

      var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;


      pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {
        this.initFunction(node);
        if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
          if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))
            { this.unexpected(); }
          node.generator = this.eat(types.star);
        }
        if (this.options.ecmaVersion >= 8)
          { node.async = !!isAsync; }

        if (statement & FUNC_STATEMENT) {
          node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();
          if (node.id && !(statement & FUNC_HANGING_STATEMENT))
            { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }
        }

        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(node.async, node.generator));

        if (!(statement & FUNC_STATEMENT))
          { node.id = this.type === types.name ? this.parseIdent() : null; }

        this.parseFunctionParams(node);
        this.parseFunctionBody(node, allowExpressionBody, false);

        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, (statement & FUNC_STATEMENT) ? "FunctionDeclaration" : "FunctionExpression")
      };

      pp$1.parseFunctionParams = function(node) {
        this.expect(types.parenL);
        node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
      };


      pp$1.parseClass = function(node, isStatement) {
        this.next();

        var oldStrict = this.strict;
        this.strict = true;

        this.parseClassId(node, isStatement);
        this.parseClassSuper(node);
        var classBody = this.startNode();
        var hadConstructor = false;
        classBody.body = [];
        this.expect(types.braceL);
        while (!this.eat(types.braceR)) {
          var element = this.parseClassElement(node.superClass !== null);
          if (element) {
            classBody.body.push(element);
            if (element.type === "MethodDefinition" && element.kind === "constructor") {
              if (hadConstructor) { this.raise(element.start, "Duplicate constructor in the same class"); }
              hadConstructor = true;
            }
          }
        }
        node.body = this.finishNode(classBody, "ClassBody");
        this.strict = oldStrict;
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression")
      };

      pp$1.parseClassElement = function(constructorAllowsSuper) {
        var this$1 = this;

        if (this.eat(types.semi)) { return null }

        var method = this.startNode();
        var tryContextual = function (k, noLineBreak) {
          if ( noLineBreak === void 0 ) noLineBreak = false;

          var start = this$1.start, startLoc = this$1.startLoc;
          if (!this$1.eatContextual(k)) { return false }
          if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }
          if (method.key) { this$1.unexpected(); }
          method.computed = false;
          method.key = this$1.startNodeAt(start, startLoc);
          method.key.name = k;
          this$1.finishNode(method.key, "Identifier");
          return false
        };

        method.kind = "method";
        method.static = tryContextual("static");
        var isGenerator = this.eat(types.star);
        var isAsync = false;
        if (!isGenerator) {
          if (this.options.ecmaVersion >= 8 && tryContextual("async", true)) {
            isAsync = true;
            isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
          } else if (tryContextual("get")) {
            method.kind = "get";
          } else if (tryContextual("set")) {
            method.kind = "set";
          }
        }
        if (!method.key) { this.parsePropertyName(method); }
        var key = method.key;
        var allowsDirectSuper = false;
        if (!method.computed && !method.static && (key.type === "Identifier" && key.name === "constructor" ||
            key.type === "Literal" && key.value === "constructor")) {
          if (method.kind !== "method") { this.raise(key.start, "Constructor can't have get/set modifier"); }
          if (isGenerator) { this.raise(key.start, "Constructor can't be a generator"); }
          if (isAsync) { this.raise(key.start, "Constructor can't be an async method"); }
          method.kind = "constructor";
          allowsDirectSuper = constructorAllowsSuper;
        } else if (method.static && key.type === "Identifier" && key.name === "prototype") {
          this.raise(key.start, "Classes may not have a static property named prototype");
        }
        this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);
        if (method.kind === "get" && method.value.params.length !== 0)
          { this.raiseRecoverable(method.value.start, "getter should have no params"); }
        if (method.kind === "set" && method.value.params.length !== 1)
          { this.raiseRecoverable(method.value.start, "setter should have exactly one param"); }
        if (method.kind === "set" && method.value.params[0].type === "RestElement")
          { this.raiseRecoverable(method.value.params[0].start, "Setter cannot use rest params"); }
        return method
      };

      pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
        method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
        return this.finishNode(method, "MethodDefinition")
      };

      pp$1.parseClassId = function(node, isStatement) {
        if (this.type === types.name) {
          node.id = this.parseIdent();
          if (isStatement)
            { this.checkLVal(node.id, BIND_LEXICAL, false); }
        } else {
          if (isStatement === true)
            { this.unexpected(); }
          node.id = null;
        }
      };

      pp$1.parseClassSuper = function(node) {
        node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
      };


      pp$1.parseExport = function(node, exports) {
        this.next();
        if (this.eat(types.star)) {
          this.expectContextual("from");
          if (this.type !== types.string) { this.unexpected(); }
          node.source = this.parseExprAtom();
          this.semicolon();
          return this.finishNode(node, "ExportAllDeclaration")
        }
        if (this.eat(types._default)) { 
          this.checkExport(exports, "default", this.lastTokStart);
          var isAsync;
          if (this.type === types._function || (isAsync = this.isAsyncFunction())) {
            var fNode = this.startNode();
            this.next();
            if (isAsync) { this.next(); }
            node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
          } else if (this.type === types._class) {
            var cNode = this.startNode();
            node.declaration = this.parseClass(cNode, "nullableID");
          } else {
            node.declaration = this.parseMaybeAssign();
            this.semicolon();
          }
          return this.finishNode(node, "ExportDefaultDeclaration")
        }
        if (this.shouldParseExportStatement()) {
          node.declaration = this.parseStatement(null);
          if (node.declaration.type === "VariableDeclaration")
            { this.checkVariableExport(exports, node.declaration.declarations); }
          else
            { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }
          node.specifiers = [];
          node.source = null;
        } else { 
          node.declaration = null;
          node.specifiers = this.parseExportSpecifiers(exports);
          if (this.eatContextual("from")) {
            if (this.type !== types.string) { this.unexpected(); }
            node.source = this.parseExprAtom();
          } else {
            for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
              var spec = list[i];

              this.checkUnreserved(spec.local);
              this.checkLocalExport(spec.local);
            }

            node.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(node, "ExportNamedDeclaration")
      };

      pp$1.checkExport = function(exports, name, pos) {
        if (!exports) { return }
        if (has(exports, name))
          { this.raiseRecoverable(pos, "Duplicate export '" + name + "'"); }
        exports[name] = true;
      };

      pp$1.checkPatternExport = function(exports, pat) {
        var type = pat.type;
        if (type === "Identifier")
          { this.checkExport(exports, pat.name, pat.start); }
        else if (type === "ObjectPattern")
          { for (var i = 0, list = pat.properties; i < list.length; i += 1)
            {
              var prop = list[i];

              this.checkPatternExport(exports, prop);
            } }
        else if (type === "ArrayPattern")
          { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
            var elt = list$1[i$1];

              if (elt) { this.checkPatternExport(exports, elt); }
          } }
        else if (type === "Property")
          { this.checkPatternExport(exports, pat.value); }
        else if (type === "AssignmentPattern")
          { this.checkPatternExport(exports, pat.left); }
        else if (type === "RestElement")
          { this.checkPatternExport(exports, pat.argument); }
        else if (type === "ParenthesizedExpression")
          { this.checkPatternExport(exports, pat.expression); }
      };

      pp$1.checkVariableExport = function(exports, decls) {
        if (!exports) { return }
        for (var i = 0, list = decls; i < list.length; i += 1)
          {
          var decl = list[i];

          this.checkPatternExport(exports, decl.id);
        }
      };

      pp$1.shouldParseExportStatement = function() {
        return this.type.keyword === "var" ||
          this.type.keyword === "const" ||
          this.type.keyword === "class" ||
          this.type.keyword === "function" ||
          this.isLet() ||
          this.isAsyncFunction()
      };


      pp$1.parseExportSpecifiers = function(exports) {
        var nodes = [], first = true;
        this.expect(types.braceL);
        while (!this.eat(types.braceR)) {
          if (!first) {
            this.expect(types.comma);
            if (this.afterTrailingComma(types.braceR)) { break }
          } else { first = false; }

          var node = this.startNode();
          node.local = this.parseIdent(true);
          node.exported = this.eatContextual("as") ? this.parseIdent(true) : node.local;
          this.checkExport(exports, node.exported.name, node.exported.start);
          nodes.push(this.finishNode(node, "ExportSpecifier"));
        }
        return nodes
      };


      pp$1.parseImport = function(node) {
        this.next();
        if (this.type === types.string) {
          node.specifiers = empty;
          node.source = this.parseExprAtom();
        } else {
          node.specifiers = this.parseImportSpecifiers();
          this.expectContextual("from");
          node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();
        }
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration")
      };


      pp$1.parseImportSpecifiers = function() {
        var nodes = [], first = true;
        if (this.type === types.name) {
          var node = this.startNode();
          node.local = this.parseIdent();
          this.checkLVal(node.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node, "ImportDefaultSpecifier"));
          if (!this.eat(types.comma)) { return nodes }
        }
        if (this.type === types.star) {
          var node$1 = this.startNode();
          this.next();
          this.expectContextual("as");
          node$1.local = this.parseIdent();
          this.checkLVal(node$1.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node$1, "ImportNamespaceSpecifier"));
          return nodes
        }
        this.expect(types.braceL);
        while (!this.eat(types.braceR)) {
          if (!first) {
            this.expect(types.comma);
            if (this.afterTrailingComma(types.braceR)) { break }
          } else { first = false; }

          var node$2 = this.startNode();
          node$2.imported = this.parseIdent(true);
          if (this.eatContextual("as")) {
            node$2.local = this.parseIdent();
          } else {
            this.checkUnreserved(node$2.imported);
            node$2.local = node$2.imported;
          }
          this.checkLVal(node$2.local, BIND_LEXICAL);
          nodes.push(this.finishNode(node$2, "ImportSpecifier"));
        }
        return nodes
      };

      pp$1.adaptDirectivePrologue = function(statements) {
        for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
          statements[i].directive = statements[i].expression.raw.slice(1, -1);
        }
      };
      pp$1.isDirectiveCandidate = function(statement) {
        return (
          statement.type === "ExpressionStatement" &&
          statement.expression.type === "Literal" &&
          typeof statement.expression.value === "string" &&
          (this.input[statement.start] === "\"" || this.input[statement.start] === "'")
        )
      };

      var pp$2 = Parser.prototype;


      pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 6 && node) {
          switch (node.type) {
          case "Identifier":
            if (this.inAsync && node.name === "await")
              { this.raise(node.start, "Cannot use 'await' as identifier inside an async function"); }
            break

          case "ObjectPattern":
          case "ArrayPattern":
          case "RestElement":
            break

          case "ObjectExpression":
            node.type = "ObjectPattern";
            if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
            for (var i = 0, list = node.properties; i < list.length; i += 1) {
              var prop = list[i];

            this.toAssignable(prop, isBinding);
              if (
                prop.type === "RestElement" &&
                (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")
              ) {
                this.raise(prop.argument.start, "Unexpected token");
              }
            }
            break

          case "Property":
            if (node.kind !== "init") { this.raise(node.key.start, "Object pattern can't contain getter or setter"); }
            this.toAssignable(node.value, isBinding);
            break

          case "ArrayExpression":
            node.type = "ArrayPattern";
            if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
            this.toAssignableList(node.elements, isBinding);
            break

          case "SpreadElement":
            node.type = "RestElement";
            this.toAssignable(node.argument, isBinding);
            if (node.argument.type === "AssignmentPattern")
              { this.raise(node.argument.start, "Rest elements cannot have a default value"); }
            break

          case "AssignmentExpression":
            if (node.operator !== "=") { this.raise(node.left.end, "Only '=' operator can be used for specifying default value."); }
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isBinding);

          case "AssignmentPattern":
            break

          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isBinding, refDestructuringErrors);
            break

          case "MemberExpression":
            if (!isBinding) { break }

          default:
            this.raise(node.start, "Assigning to rvalue");
          }
        } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }
        return node
      };


      pp$2.toAssignableList = function(exprList, isBinding) {
        var end = exprList.length;
        for (var i = 0; i < end; i++) {
          var elt = exprList[i];
          if (elt) { this.toAssignable(elt, isBinding); }
        }
        if (end) {
          var last = exprList[end - 1];
          if (this.options.ecmaVersion === 6 && isBinding && last && last.type === "RestElement" && last.argument.type !== "Identifier")
            { this.unexpected(last.argument.start); }
        }
        return exprList
      };


      pp$2.parseSpread = function(refDestructuringErrors) {
        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
        return this.finishNode(node, "SpreadElement")
      };

      pp$2.parseRestBinding = function() {
        var node = this.startNode();
        this.next();

        if (this.options.ecmaVersion === 6 && this.type !== types.name)
          { this.unexpected(); }

        node.argument = this.parseBindingAtom();

        return this.finishNode(node, "RestElement")
      };


      pp$2.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6) {
          switch (this.type) {
          case types.bracketL:
            var node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(types.bracketR, true, true);
            return this.finishNode(node, "ArrayPattern")

          case types.braceL:
            return this.parseObj(true)
          }
        }
        return this.parseIdent()
      };

      pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (first) { first = false; }
          else { this.expect(types.comma); }
          if (allowEmpty && this.type === types.comma) {
            elts.push(null);
          } else if (allowTrailingComma && this.afterTrailingComma(close)) {
            break
          } else if (this.type === types.ellipsis) {
            var rest = this.parseRestBinding();
            this.parseBindingListItem(rest);
            elts.push(rest);
            if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
            this.expect(close);
            break
          } else {
            var elem = this.parseMaybeDefault(this.start, this.startLoc);
            this.parseBindingListItem(elem);
            elts.push(elem);
          }
        }
        return elts
      };

      pp$2.parseBindingListItem = function(param) {
        return param
      };


      pp$2.parseMaybeDefault = function(startPos, startLoc, left) {
        left = left || this.parseBindingAtom();
        if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.right = this.parseMaybeAssign();
        return this.finishNode(node, "AssignmentPattern")
      };


      pp$2.checkLVal = function(expr, bindingType, checkClashes) {
        if ( bindingType === void 0 ) bindingType = BIND_NONE;

        switch (expr.type) {
        case "Identifier":
          if (bindingType === BIND_LEXICAL && expr.name === "let")
            { this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name"); }
          if (this.strict && this.reservedWordsStrictBind.test(expr.name))
            { this.raiseRecoverable(expr.start, (bindingType ? "Binding " : "Assigning to ") + expr.name + " in strict mode"); }
          if (checkClashes) {
            if (has(checkClashes, expr.name))
              { this.raiseRecoverable(expr.start, "Argument name clash"); }
            checkClashes[expr.name] = true;
          }
          if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }
          break

        case "MemberExpression":
          if (bindingType) { this.raiseRecoverable(expr.start, "Binding member expression"); }
          break

        case "ObjectPattern":
          for (var i = 0, list = expr.properties; i < list.length; i += 1)
            {
          var prop = list[i];

          this.checkLVal(prop, bindingType, checkClashes);
        }
          break

        case "Property":
          this.checkLVal(expr.value, bindingType, checkClashes);
          break

        case "ArrayPattern":
          for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
            var elem = list$1[i$1];

          if (elem) { this.checkLVal(elem, bindingType, checkClashes); }
          }
          break

        case "AssignmentPattern":
          this.checkLVal(expr.left, bindingType, checkClashes);
          break

        case "RestElement":
          this.checkLVal(expr.argument, bindingType, checkClashes);
          break

        case "ParenthesizedExpression":
          this.checkLVal(expr.expression, bindingType, checkClashes);
          break

        default:
          this.raise(expr.start, (bindingType ? "Binding" : "Assigning to") + " rvalue");
        }
      };


      var pp$3 = Parser.prototype;


      pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {
        if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement")
          { return }
        if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))
          { return }
        var key = prop.key;
        var name;
        switch (key.type) {
        case "Identifier": name = key.name; break
        case "Literal": name = String(key.value); break
        default: return
        }
        var kind = prop.kind;
        if (this.options.ecmaVersion >= 6) {
          if (name === "__proto__" && kind === "init") {
            if (propHash.proto) {
              if (refDestructuringErrors) {
                if (refDestructuringErrors.doubleProto < 0)
                  { refDestructuringErrors.doubleProto = key.start; }
              } else { this.raiseRecoverable(key.start, "Redefinition of __proto__ property"); }
            }
            propHash.proto = true;
          }
          return
        }
        name = "$" + name;
        var other = propHash[name];
        if (other) {
          var redefinition;
          if (kind === "init") {
            redefinition = this.strict && other.init || other.get || other.set;
          } else {
            redefinition = other.init || other[kind];
          }
          if (redefinition)
            { this.raiseRecoverable(key.start, "Redefinition of property"); }
        } else {
          other = propHash[name] = {
            init: false,
            get: false,
            set: false
          };
        }
        other[kind] = true;
      };




      pp$3.parseExpression = function(noIn, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);
        if (this.type === types.comma) {
          var node = this.startNodeAt(startPos, startLoc);
          node.expressions = [expr];
          while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }
          return this.finishNode(node, "SequenceExpression")
        }
        return expr
      };


      pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {
        if (this.isContextual("yield")) {
          if (this.inGenerator) { return this.parseYield(noIn) }
          else { this.exprAllowed = false; }
        }

        var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;
        if (refDestructuringErrors) {
          oldParenAssign = refDestructuringErrors.parenthesizedAssign;
          oldTrailingComma = refDestructuringErrors.trailingComma;
          refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
        } else {
          refDestructuringErrors = new DestructuringErrors;
          ownDestructuringErrors = true;
        }

        var startPos = this.start, startLoc = this.startLoc;
        if (this.type === types.parenL || this.type === types.name)
          { this.potentialArrowAt = this.start; }
        var left = this.parseMaybeConditional(noIn, refDestructuringErrors);
        if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }
        if (this.type.isAssign) {
          var node = this.startNodeAt(startPos, startLoc);
          node.operator = this.value;
          node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;
          if (!ownDestructuringErrors) {
            refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
          }
          if (refDestructuringErrors.shorthandAssign >= node.left.start)
            { refDestructuringErrors.shorthandAssign = -1; } 
          this.checkLVal(left);
          this.next();
          node.right = this.parseMaybeAssign(noIn);
          return this.finishNode(node, "AssignmentExpression")
        } else {
          if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }
        }
        if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }
        if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }
        return left
      };


      pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprOps(noIn, refDestructuringErrors);
        if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
        if (this.eat(types.question)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssign();
          this.expect(types.colon);
          node.alternate = this.parseMaybeAssign(noIn);
          return this.finishNode(node, "ConditionalExpression")
        }
        return expr
      };


      pp$3.parseExprOps = function(noIn, refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseMaybeUnary(refDestructuringErrors, false);
        if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
        return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)
      };


      pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {
        var prec = this.type.binop;
        if (prec != null && (!noIn || this.type !== types._in)) {
          if (prec > minPrec) {
            var logical = this.type === types.logicalOR || this.type === types.logicalAND;
            var op = this.value;
            this.next();
            var startPos = this.start, startLoc = this.startLoc;
            var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);
            var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);
            return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)
          }
        }
        return left
      };

      pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {
        var node = this.startNodeAt(startPos, startLoc);
        node.left = left;
        node.operator = op;
        node.right = right;
        return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression")
      };


      pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {
        var startPos = this.start, startLoc = this.startLoc, expr;
        if (this.isContextual("await") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {
          expr = this.parseAwait();
          sawUnary = true;
        } else if (this.type.prefix) {
          var node = this.startNode(), update = this.type === types.incDec;
          node.operator = this.value;
          node.prefix = true;
          this.next();
          node.argument = this.parseMaybeUnary(null, true);
          this.checkExpressionErrors(refDestructuringErrors, true);
          if (update) { this.checkLVal(node.argument); }
          else if (this.strict && node.operator === "delete" &&
                   node.argument.type === "Identifier")
            { this.raiseRecoverable(node.start, "Deleting local variable in strict mode"); }
          else { sawUnary = true; }
          expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
        } else {
          expr = this.parseExprSubscripts(refDestructuringErrors);
          if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }
          while (this.type.postfix && !this.canInsertSemicolon()) {
            var node$1 = this.startNodeAt(startPos, startLoc);
            node$1.operator = this.value;
            node$1.prefix = false;
            node$1.argument = expr;
            this.checkLVal(expr);
            this.next();
            expr = this.finishNode(node$1, "UpdateExpression");
          }
        }

        if (!sawUnary && this.eat(types.starstar))
          { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), "**", false) }
        else
          { return expr }
      };


      pp$3.parseExprSubscripts = function(refDestructuringErrors) {
        var startPos = this.start, startLoc = this.startLoc;
        var expr = this.parseExprAtom(refDestructuringErrors);
        if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
          { return expr }
        var result = this.parseSubscripts(expr, startPos, startLoc);
        if (refDestructuringErrors && result.type === "MemberExpression") {
          if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }
          if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }
        }
        return result
      };

      pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {
        var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === "Identifier" && base.name === "async" &&
            this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === "async";
        while (true) {
          var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);
          if (element === base || element.type === "ArrowFunctionExpression") { return element }
          base = element;
        }
      };

      pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {
        var computed = this.eat(types.bracketL);
        if (computed || this.eat(types.dot)) {
          var node = this.startNodeAt(startPos, startLoc);
          node.object = base;
          node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== "never");
          node.computed = !!computed;
          if (computed) { this.expect(types.bracketR); }
          base = this.finishNode(node, "MemberExpression");
        } else if (!noCalls && this.eat(types.parenL)) {
          var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
          this.yieldPos = 0;
          this.awaitPos = 0;
          this.awaitIdentPos = 0;
          var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
          if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            if (this.awaitIdentPos > 0)
              { this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"); }
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            this.awaitIdentPos = oldAwaitIdentPos;
            return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)
          }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;
          this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
          var node$1 = this.startNodeAt(startPos, startLoc);
          node$1.callee = base;
          node$1.arguments = exprList;
          base = this.finishNode(node$1, "CallExpression");
        } else if (this.type === types.backQuote) {
          var node$2 = this.startNodeAt(startPos, startLoc);
          node$2.tag = base;
          node$2.quasi = this.parseTemplate({isTagged: true});
          base = this.finishNode(node$2, "TaggedTemplateExpression");
        }
        return base
      };


      pp$3.parseExprAtom = function(refDestructuringErrors) {
        if (this.type === types.slash) { this.readRegexp(); }

        var node, canBeArrow = this.potentialArrowAt === this.start;
        switch (this.type) {
        case types._super:
          if (!this.allowSuper)
            { this.raise(this.start, "'super' keyword outside a method"); }
          node = this.startNode();
          this.next();
          if (this.type === types.parenL && !this.allowDirectSuper)
            { this.raise(node.start, "super() call outside constructor of a subclass"); }
          if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)
            { this.unexpected(); }
          return this.finishNode(node, "Super")

        case types._this:
          node = this.startNode();
          this.next();
          return this.finishNode(node, "ThisExpression")

        case types.name:
          var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
          var id = this.parseIdent(false);
          if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types._function))
            { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }
          if (canBeArrow && !this.canInsertSemicolon()) {
            if (this.eat(types.arrow))
              { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }
            if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types.name && !containsEsc) {
              id = this.parseIdent(false);
              if (this.canInsertSemicolon() || !this.eat(types.arrow))
                { this.unexpected(); }
              return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)
            }
          }
          return id

        case types.regexp:
          var value = this.value;
          node = this.parseLiteral(value.value);
          node.regex = {pattern: value.pattern, flags: value.flags};
          return node

        case types.num: case types.string:
          return this.parseLiteral(this.value)

        case types._null: case types._true: case types._false:
          node = this.startNode();
          node.value = this.type === types._null ? null : this.type === types._true;
          node.raw = this.type.keyword;
          this.next();
          return this.finishNode(node, "Literal")

        case types.parenL:
          var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);
          if (refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))
              { refDestructuringErrors.parenthesizedAssign = start; }
            if (refDestructuringErrors.parenthesizedBind < 0)
              { refDestructuringErrors.parenthesizedBind = start; }
          }
          return expr

        case types.bracketL:
          node = this.startNode();
          this.next();
          node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);
          return this.finishNode(node, "ArrayExpression")

        case types.braceL:
          return this.parseObj(false, refDestructuringErrors)

        case types._function:
          node = this.startNode();
          this.next();
          return this.parseFunction(node, 0)

        case types._class:
          return this.parseClass(this.startNode(), false)

        case types._new:
          return this.parseNew()

        case types.backQuote:
          return this.parseTemplate()

        case types._import:
          if (this.options.ecmaVersion >= 11) {
            return this.parseExprImport()
          } else {
            return this.unexpected()
          }

        default:
          this.unexpected();
        }
      };

      pp$3.parseExprImport = function() {
        var node = this.startNode();
        this.next(); 
        switch (this.type) {
        case types.parenL:
          return this.parseDynamicImport(node)
        default:
          this.unexpected();
        }
      };

      pp$3.parseDynamicImport = function(node) {
        this.next(); 

        node.source = this.parseMaybeAssign();

        if (!this.eat(types.parenR)) {
          var errorPos = this.start;
          if (this.eat(types.comma) && this.eat(types.parenR)) {
            this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
          } else {
            this.unexpected(errorPos);
          }
        }

        return this.finishNode(node, "ImportExpression")
      };

      pp$3.parseLiteral = function(value) {
        var node = this.startNode();
        node.value = value;
        node.raw = this.input.slice(this.start, this.end);
        if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }
        this.next();
        return this.finishNode(node, "Literal")
      };

      pp$3.parseParenExpression = function() {
        this.expect(types.parenL);
        var val = this.parseExpression();
        this.expect(types.parenR);
        return val
      };

      pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {
        var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();

          var innerStartPos = this.start, innerStartLoc = this.startLoc;
          var exprList = [], first = true, lastIsComma = false;
          var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
          this.yieldPos = 0;
          this.awaitPos = 0;
          while (this.type !== types.parenR) {
            first ? first = false : this.expect(types.comma);
            if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {
              lastIsComma = true;
              break
            } else if (this.type === types.ellipsis) {
              spreadStart = this.start;
              exprList.push(this.parseParenItem(this.parseRestBinding()));
              if (this.type === types.comma) { this.raise(this.start, "Comma is not permitted after the rest element"); }
              break
            } else {
              exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
            }
          }
          var innerEndPos = this.start, innerEndLoc = this.startLoc;
          this.expect(types.parenR);

          if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
            this.checkPatternErrors(refDestructuringErrors, false);
            this.checkYieldAwaitInDefaultParams();
            this.yieldPos = oldYieldPos;
            this.awaitPos = oldAwaitPos;
            return this.parseParenArrowList(startPos, startLoc, exprList)
          }

          if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }
          if (spreadStart) { this.unexpected(spreadStart); }
          this.checkExpressionErrors(refDestructuringErrors, true);
          this.yieldPos = oldYieldPos || this.yieldPos;
          this.awaitPos = oldAwaitPos || this.awaitPos;

          if (exprList.length > 1) {
            val = this.startNodeAt(innerStartPos, innerStartLoc);
            val.expressions = exprList;
            this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
          } else {
            val = exprList[0];
          }
        } else {
          val = this.parseParenExpression();
        }

        if (this.options.preserveParens) {
          var par = this.startNodeAt(startPos, startLoc);
          par.expression = val;
          return this.finishNode(par, "ParenthesizedExpression")
        } else {
          return val
        }
      };

      pp$3.parseParenItem = function(item) {
        return item
      };

      pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {
        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)
      };


      var empty$1 = [];

      pp$3.parseNew = function() {
        if (this.containsEsc) { this.raiseRecoverable(this.start, "Escape sequence in keyword new"); }
        var node = this.startNode();
        var meta = this.parseIdent(true);
        if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {
          node.meta = meta;
          var containsEsc = this.containsEsc;
          node.property = this.parseIdent(true);
          if (node.property.name !== "target" || containsEsc)
            { this.raiseRecoverable(node.property.start, "The only valid meta property for new is new.target"); }
          if (!this.inNonArrowFunction())
            { this.raiseRecoverable(node.start, "new.target can only be used in functions"); }
          return this.finishNode(node, "MetaProperty")
        }
        var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;
        node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
        if (isImport && node.callee.type === "ImportExpression") {
          this.raise(startPos, "Cannot use new with import()");
        }
        if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }
        else { node.arguments = empty$1; }
        return this.finishNode(node, "NewExpression")
      };


      pp$3.parseTemplateElement = function(ref) {
        var isTagged = ref.isTagged;

        var elem = this.startNode();
        if (this.type === types.invalidTemplate) {
          if (!isTagged) {
            this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
          }
          elem.value = {
            raw: this.value,
            cooked: null
          };
        } else {
          elem.value = {
            raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
            cooked: this.value
          };
        }
        this.next();
        elem.tail = this.type === types.backQuote;
        return this.finishNode(elem, "TemplateElement")
      };

      pp$3.parseTemplate = function(ref) {
        if ( ref === void 0 ) ref = {};
        var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;

        var node = this.startNode();
        this.next();
        node.expressions = [];
        var curElt = this.parseTemplateElement({isTagged: isTagged});
        node.quasis = [curElt];
        while (!curElt.tail) {
          if (this.type === types.eof) { this.raise(this.pos, "Unterminated template literal"); }
          this.expect(types.dollarBraceL);
          node.expressions.push(this.parseExpression());
          this.expect(types.braceR);
          node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));
        }
        this.next();
        return this.finishNode(node, "TemplateLiteral")
      };

      pp$3.isAsyncProp = function(prop) {
        return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" &&
          (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&
          !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))
      };


      pp$3.parseObj = function(isPattern, refDestructuringErrors) {
        var node = this.startNode(), first = true, propHash = {};
        node.properties = [];
        this.next();
        while (!this.eat(types.braceR)) {
          if (!first) {
            this.expect(types.comma);
            if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }
          } else { first = false; }

          var prop = this.parseProperty(isPattern, refDestructuringErrors);
          if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }
          node.properties.push(prop);
        }
        return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression")
      };

      pp$3.parseProperty = function(isPattern, refDestructuringErrors) {
        var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
        if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {
          if (isPattern) {
            prop.argument = this.parseIdent(false);
            if (this.type === types.comma) {
              this.raise(this.start, "Comma is not permitted after the rest element");
            }
            return this.finishNode(prop, "RestElement")
          }
          if (this.type === types.parenL && refDestructuringErrors) {
            if (refDestructuringErrors.parenthesizedAssign < 0) {
              refDestructuringErrors.parenthesizedAssign = this.start;
            }
            if (refDestructuringErrors.parenthesizedBind < 0) {
              refDestructuringErrors.parenthesizedBind = this.start;
            }
          }
          prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
          if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
            refDestructuringErrors.trailingComma = this.start;
          }
          return this.finishNode(prop, "SpreadElement")
        }
        if (this.options.ecmaVersion >= 6) {
          prop.method = false;
          prop.shorthand = false;
          if (isPattern || refDestructuringErrors) {
            startPos = this.start;
            startLoc = this.startLoc;
          }
          if (!isPattern)
            { isGenerator = this.eat(types.star); }
        }
        var containsEsc = this.containsEsc;
        this.parsePropertyName(prop);
        if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
          isAsync = true;
          isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);
          this.parsePropertyName(prop, refDestructuringErrors);
        } else {
          isAsync = false;
        }
        this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
        return this.finishNode(prop, "Property")
      };

      pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
        if ((isGenerator || isAsync) && this.type === types.colon)
          { this.unexpected(); }

        if (this.eat(types.colon)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
          prop.kind = "init";
        } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {
          if (isPattern) { this.unexpected(); }
          prop.kind = "init";
          prop.method = true;
          prop.value = this.parseMethod(isGenerator, isAsync);
        } else if (!isPattern && !containsEsc &&
                   this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" &&
                   (prop.key.name === "get" || prop.key.name === "set") &&
                   (this.type !== types.comma && this.type !== types.braceR)) {
          if (isGenerator || isAsync) { this.unexpected(); }
          prop.kind = prop.key.name;
          this.parsePropertyName(prop);
          prop.value = this.parseMethod(false);
          var paramCount = prop.kind === "get" ? 0 : 1;
          if (prop.value.params.length !== paramCount) {
            var start = prop.value.start;
            if (prop.kind === "get")
              { this.raiseRecoverable(start, "getter should have no params"); }
            else
              { this.raiseRecoverable(start, "setter should have exactly one param"); }
          } else {
            if (prop.kind === "set" && prop.value.params[0].type === "RestElement")
              { this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params"); }
          }
        } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
          if (isGenerator || isAsync) { this.unexpected(); }
          this.checkUnreserved(prop.key);
          if (prop.key.name === "await" && !this.awaitIdentPos)
            { this.awaitIdentPos = startPos; }
          prop.kind = "init";
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
          } else if (this.type === types.eq && refDestructuringErrors) {
            if (refDestructuringErrors.shorthandAssign < 0)
              { refDestructuringErrors.shorthandAssign = this.start; }
            prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);
          } else {
            prop.value = prop.key;
          }
          prop.shorthand = true;
        } else { this.unexpected(); }
      };

      pp$3.parsePropertyName = function(prop) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(types.bracketL)) {
            prop.computed = true;
            prop.key = this.parseMaybeAssign();
            this.expect(types.bracketR);
            return prop.key
          } else {
            prop.computed = false;
          }
        }
        return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never")
      };


      pp$3.initFunction = function(node) {
        node.id = null;
        if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }
        if (this.options.ecmaVersion >= 8) { node.async = false; }
      };


      pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
        var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

        this.initFunction(node);
        if (this.options.ecmaVersion >= 6)
          { node.generator = isGenerator; }
        if (this.options.ecmaVersion >= 8)
          { node.async = !!isAsync; }

        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;
        this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));

        this.expect(types.parenL);
        node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);
        this.checkYieldAwaitInDefaultParams();
        this.parseFunctionBody(node, false, true);

        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "FunctionExpression")
      };


      pp$3.parseArrowExpression = function(node, params, isAsync) {
        var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;

        this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
        this.initFunction(node);
        if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }

        this.yieldPos = 0;
        this.awaitPos = 0;
        this.awaitIdentPos = 0;

        node.params = this.toAssignableList(params, true);
        this.parseFunctionBody(node, true, false);

        this.yieldPos = oldYieldPos;
        this.awaitPos = oldAwaitPos;
        this.awaitIdentPos = oldAwaitIdentPos;
        return this.finishNode(node, "ArrowFunctionExpression")
      };


      pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {
        var isExpression = isArrowFunction && this.type !== types.braceL;
        var oldStrict = this.strict, useStrict = false;

        if (isExpression) {
          node.body = this.parseMaybeAssign();
          node.expression = true;
          this.checkParams(node, false);
        } else {
          var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
          if (!oldStrict || nonSimple) {
            useStrict = this.strictDirective(this.end);
            if (useStrict && nonSimple)
              { this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list"); }
          }
          var oldLabels = this.labels;
          this.labels = [];
          if (useStrict) { this.strict = true; }

          this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
          node.body = this.parseBlock(false);
          node.expression = false;
          this.adaptDirectivePrologue(node.body.body);
          this.labels = oldLabels;
        }
        this.exitScope();

        if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }
        this.strict = oldStrict;
      };

      pp$3.isSimpleParamList = function(params) {
        for (var i = 0, list = params; i < list.length; i += 1)
          {
          var param = list[i];

          if (param.type !== "Identifier") { return false
        } }
        return true
      };


      pp$3.checkParams = function(node, allowDuplicates) {
        var nameHash = {};
        for (var i = 0, list = node.params; i < list.length; i += 1)
          {
          var param = list[i];

          this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);
        }
      };


      pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
        var elts = [], first = true;
        while (!this.eat(close)) {
          if (!first) {
            this.expect(types.comma);
            if (allowTrailingComma && this.afterTrailingComma(close)) { break }
          } else { first = false; }

          var elt = (void 0);
          if (allowEmpty && this.type === types.comma)
            { elt = null; }
          else if (this.type === types.ellipsis) {
            elt = this.parseSpread(refDestructuringErrors);
            if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)
              { refDestructuringErrors.trailingComma = this.start; }
          } else {
            elt = this.parseMaybeAssign(false, refDestructuringErrors);
          }
          elts.push(elt);
        }
        return elts
      };

      pp$3.checkUnreserved = function(ref) {
        var start = ref.start;
        var end = ref.end;
        var name = ref.name;

        if (this.inGenerator && name === "yield")
          { this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator"); }
        if (this.inAsync && name === "await")
          { this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function"); }
        if (this.keywords.test(name))
          { this.raise(start, ("Unexpected keyword '" + name + "'")); }
        if (this.options.ecmaVersion < 6 &&
          this.input.slice(start, end).indexOf("\\") !== -1) { return }
        var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
        if (re.test(name)) {
          if (!this.inAsync && name === "await")
            { this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function"); }
          this.raiseRecoverable(start, ("The keyword '" + name + "' is reserved"));
        }
      };


      pp$3.parseIdent = function(liberal, isBinding) {
        var node = this.startNode();
        if (this.type === types.name) {
          node.name = this.value;
        } else if (this.type.keyword) {
          node.name = this.type.keyword;

          if ((node.name === "class" || node.name === "function") &&
              (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
            this.context.pop();
          }
        } else {
          this.unexpected();
        }
        this.next(!!liberal);
        this.finishNode(node, "Identifier");
        if (!liberal) {
          this.checkUnreserved(node);
          if (node.name === "await" && !this.awaitIdentPos)
            { this.awaitIdentPos = node.start; }
        }
        return node
      };


      pp$3.parseYield = function(noIn) {
        if (!this.yieldPos) { this.yieldPos = this.start; }

        var node = this.startNode();
        this.next();
        if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {
          node.delegate = false;
          node.argument = null;
        } else {
          node.delegate = this.eat(types.star);
          node.argument = this.parseMaybeAssign(noIn);
        }
        return this.finishNode(node, "YieldExpression")
      };

      pp$3.parseAwait = function() {
        if (!this.awaitPos) { this.awaitPos = this.start; }

        var node = this.startNode();
        this.next();
        node.argument = this.parseMaybeUnary(null, false);
        return this.finishNode(node, "AwaitExpression")
      };

      var pp$4 = Parser.prototype;


      pp$4.raise = function(pos, message) {
        var loc = getLineInfo(this.input, pos);
        message += " (" + loc.line + ":" + loc.column + ")";
        var err = new SyntaxError(message);
        err.pos = pos; err.loc = loc; err.raisedAt = this.pos;
        throw err
      };

      pp$4.raiseRecoverable = pp$4.raise;

      pp$4.curPosition = function() {
        if (this.options.locations) {
          return new Position(this.curLine, this.pos - this.lineStart)
        }
      };

      var pp$5 = Parser.prototype;

      var Scope = function Scope(flags) {
        this.flags = flags;
        this.var = [];
        this.lexical = [];
        this.functions = [];
      };


      pp$5.enterScope = function(flags) {
        this.scopeStack.push(new Scope(flags));
      };

      pp$5.exitScope = function() {
        this.scopeStack.pop();
      };

      pp$5.treatFunctionsAsVarInScope = function(scope) {
        return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)
      };

      pp$5.declareName = function(name, bindingType, pos) {
        var redeclared = false;
        if (bindingType === BIND_LEXICAL) {
          var scope = this.currentScope();
          redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
          scope.lexical.push(name);
          if (this.inModule && (scope.flags & SCOPE_TOP))
            { delete this.undefinedExports[name]; }
        } else if (bindingType === BIND_SIMPLE_CATCH) {
          var scope$1 = this.currentScope();
          scope$1.lexical.push(name);
        } else if (bindingType === BIND_FUNCTION) {
          var scope$2 = this.currentScope();
          if (this.treatFunctionsAsVar)
            { redeclared = scope$2.lexical.indexOf(name) > -1; }
          else
            { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }
          scope$2.functions.push(name);
        } else {
          for (var i = this.scopeStack.length - 1; i >= 0; --i) {
            var scope$3 = this.scopeStack[i];
            if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||
                !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
              redeclared = true;
              break
            }
            scope$3.var.push(name);
            if (this.inModule && (scope$3.flags & SCOPE_TOP))
              { delete this.undefinedExports[name]; }
            if (scope$3.flags & SCOPE_VAR) { break }
          }
        }
        if (redeclared) { this.raiseRecoverable(pos, ("Identifier '" + name + "' has already been declared")); }
      };

      pp$5.checkLocalExport = function(id) {
        if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&
            this.scopeStack[0].var.indexOf(id.name) === -1) {
          this.undefinedExports[id.name] = id;
        }
      };

      pp$5.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1]
      };

      pp$5.currentVarScope = function() {
        for (var i = this.scopeStack.length - 1;; i--) {
          var scope = this.scopeStack[i];
          if (scope.flags & SCOPE_VAR) { return scope }
        }
      };

      pp$5.currentThisScope = function() {
        for (var i = this.scopeStack.length - 1;; i--) {
          var scope = this.scopeStack[i];
          if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }
        }
      };

      var Node = function Node(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        if (parser.options.locations)
          { this.loc = new SourceLocation(parser, loc); }
        if (parser.options.directSourceFile)
          { this.sourceFile = parser.options.directSourceFile; }
        if (parser.options.ranges)
          { this.range = [pos, 0]; }
      };


      var pp$6 = Parser.prototype;

      pp$6.startNode = function() {
        return new Node(this, this.start, this.startLoc)
      };

      pp$6.startNodeAt = function(pos, loc) {
        return new Node(this, pos, loc)
      };


      function finishNodeAt(node, type, pos, loc) {
        node.type = type;
        node.end = pos;
        if (this.options.locations)
          { node.loc.end = loc; }
        if (this.options.ranges)
          { node.range[1] = pos; }
        return node
      }

      pp$6.finishNode = function(node, type) {
        return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)
      };


      pp$6.finishNodeAt = function(node, type, pos, loc) {
        return finishNodeAt.call(this, node, type, pos, loc)
      };


      var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
        this.token = token;
        this.isExpr = !!isExpr;
        this.preserveSpace = !!preserveSpace;
        this.override = override;
        this.generator = !!generator;
      };

      var types$1 = {
        b_stat: new TokContext("{", false),
        b_expr: new TokContext("{", true),
        b_tmpl: new TokContext("${", false),
        p_stat: new TokContext("(", false),
        p_expr: new TokContext("(", true),
        q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
        f_stat: new TokContext("function", false),
        f_expr: new TokContext("function", true),
        f_expr_gen: new TokContext("function", true, false, null, true),
        f_gen: new TokContext("function", false, false, null, true)
      };

      var pp$7 = Parser.prototype;

      pp$7.initialContext = function() {
        return [types$1.b_stat]
      };

      pp$7.braceIsBlock = function(prevType) {
        var parent = this.curContext();
        if (parent === types$1.f_expr || parent === types$1.f_stat)
          { return true }
        if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))
          { return !parent.isExpr }

        if (prevType === types._return || prevType === types.name && this.exprAllowed)
          { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }
        if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)
          { return true }
        if (prevType === types.braceL)
          { return parent === types$1.b_stat }
        if (prevType === types._var || prevType === types._const || prevType === types.name)
          { return false }
        return !this.exprAllowed
      };

      pp$7.inGeneratorContext = function() {
        for (var i = this.context.length - 1; i >= 1; i--) {
          var context = this.context[i];
          if (context.token === "function")
            { return context.generator }
        }
        return false
      };

      pp$7.updateContext = function(prevType) {
        var update, type = this.type;
        if (type.keyword && prevType === types.dot)
          { this.exprAllowed = false; }
        else if (update = type.updateContext)
          { update.call(this, prevType); }
        else
          { this.exprAllowed = type.beforeExpr; }
      };


      types.parenR.updateContext = types.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = true;
          return
        }
        var out = this.context.pop();
        if (out === types$1.b_stat && this.curContext().token === "function") {
          out = this.context.pop();
        }
        this.exprAllowed = !out.isExpr;
      };

      types.braceL.updateContext = function(prevType) {
        this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
        this.exprAllowed = true;
      };

      types.dollarBraceL.updateContext = function() {
        this.context.push(types$1.b_tmpl);
        this.exprAllowed = true;
      };

      types.parenL.updateContext = function(prevType) {
        var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
        this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
        this.exprAllowed = true;
      };

      types.incDec.updateContext = function() {
      };

      types._function.updateContext = types._class.updateContext = function(prevType) {
        if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
            !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&
            !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
          { this.context.push(types$1.f_expr); }
        else
          { this.context.push(types$1.f_stat); }
        this.exprAllowed = false;
      };

      types.backQuote.updateContext = function() {
        if (this.curContext() === types$1.q_tmpl)
          { this.context.pop(); }
        else
          { this.context.push(types$1.q_tmpl); }
        this.exprAllowed = false;
      };

      types.star.updateContext = function(prevType) {
        if (prevType === types._function) {
          var index = this.context.length - 1;
          if (this.context[index] === types$1.f_expr)
            { this.context[index] = types$1.f_expr_gen; }
          else
            { this.context[index] = types$1.f_gen; }
        }
        this.exprAllowed = true;
      };

      types.name.updateContext = function(prevType) {
        var allowed = false;
        if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {
          if (this.value === "of" && !this.exprAllowed ||
              this.value === "yield" && this.inGeneratorContext())
            { allowed = true; }
        }
        this.exprAllowed = allowed;
      };


      var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
      var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
      var ecma11BinaryProperties = ecma10BinaryProperties;
      var unicodeBinaryProperties = {
        9: ecma9BinaryProperties,
        10: ecma10BinaryProperties,
        11: ecma11BinaryProperties
      };

      var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";

      var ecma9ScriptValues = "Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
      var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
      var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
      var unicodeScriptValues = {
        9: ecma9ScriptValues,
        10: ecma10ScriptValues,
        11: ecma11ScriptValues
      };

      var data = {};
      function buildUnicodeData(ecmaVersion) {
        var d = data[ecmaVersion] = {
          binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
          nonBinary: {
            General_Category: wordsRegexp(unicodeGeneralCategoryValues),
            Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
          }
        };
        d.nonBinary.Script_Extensions = d.nonBinary.Script;

        d.nonBinary.gc = d.nonBinary.General_Category;
        d.nonBinary.sc = d.nonBinary.Script;
        d.nonBinary.scx = d.nonBinary.Script_Extensions;
      }
      buildUnicodeData(9);
      buildUnicodeData(10);
      buildUnicodeData(11);

      var pp$8 = Parser.prototype;

      var RegExpValidationState = function RegExpValidationState(parser) {
        this.parser = parser;
        this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "");
        this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];
        this.source = "";
        this.flags = "";
        this.start = 0;
        this.switchU = false;
        this.switchN = false;
        this.pos = 0;
        this.lastIntValue = 0;
        this.lastStringValue = "";
        this.lastAssertionIsQuantifiable = false;
        this.numCapturingParens = 0;
        this.maxBackReference = 0;
        this.groupNames = [];
        this.backReferenceNames = [];
      };

      RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {
        var unicode = flags.indexOf("u") !== -1;
        this.start = start | 0;
        this.source = pattern + "";
        this.flags = flags;
        this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
        this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
      };

      RegExpValidationState.prototype.raise = function raise (message) {
        this.parser.raiseRecoverable(this.start, ("Invalid regular expression: /" + (this.source) + "/: " + message));
      };

      RegExpValidationState.prototype.at = function at (i) {
        var s = this.source;
        var l = s.length;
        if (i >= l) {
          return -1
        }
        var c = s.charCodeAt(i);
        if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {
          return c
        }
        var next = s.charCodeAt(i + 1);
        return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c
      };

      RegExpValidationState.prototype.nextIndex = function nextIndex (i) {
        var s = this.source;
        var l = s.length;
        if (i >= l) {
          return l
        }
        var c = s.charCodeAt(i), next;
        if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||
            (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {
          return i + 1
        }
        return i + 2
      };

      RegExpValidationState.prototype.current = function current () {
        return this.at(this.pos)
      };

      RegExpValidationState.prototype.lookahead = function lookahead () {
        return this.at(this.nextIndex(this.pos))
      };

      RegExpValidationState.prototype.advance = function advance () {
        this.pos = this.nextIndex(this.pos);
      };

      RegExpValidationState.prototype.eat = function eat (ch) {
        if (this.current() === ch) {
          this.advance();
          return true
        }
        return false
      };

      function codePointToString(ch) {
        if (ch <= 0xFFFF) { return String.fromCharCode(ch) }
        ch -= 0x10000;
        return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)
      }

      pp$8.validateRegExpFlags = function(state) {
        var validFlags = state.validFlags;
        var flags = state.flags;

        for (var i = 0; i < flags.length; i++) {
          var flag = flags.charAt(i);
          if (validFlags.indexOf(flag) === -1) {
            this.raise(state.start, "Invalid regular expression flag");
          }
          if (flags.indexOf(flag, i + 1) > -1) {
            this.raise(state.start, "Duplicate regular expression flag");
          }
        }
      };

      pp$8.validateRegExpPattern = function(state) {
        this.regexp_pattern(state);

        if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {
          state.switchN = true;
          this.regexp_pattern(state);
        }
      };

      pp$8.regexp_pattern = function(state) {
        state.pos = 0;
        state.lastIntValue = 0;
        state.lastStringValue = "";
        state.lastAssertionIsQuantifiable = false;
        state.numCapturingParens = 0;
        state.maxBackReference = 0;
        state.groupNames.length = 0;
        state.backReferenceNames.length = 0;

        this.regexp_disjunction(state);

        if (state.pos !== state.source.length) {
          if (state.eat(0x29 )) {
            state.raise("Unmatched ')'");
          }
          if (state.eat(0x5D ) || state.eat(0x7D )) {
            state.raise("Lone quantifier brackets");
          }
        }
        if (state.maxBackReference > state.numCapturingParens) {
          state.raise("Invalid escape");
        }
        for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
          var name = list[i];

          if (state.groupNames.indexOf(name) === -1) {
            state.raise("Invalid named capture referenced");
          }
        }
      };

      pp$8.regexp_disjunction = function(state) {
        this.regexp_alternative(state);
        while (state.eat(0x7C )) {
          this.regexp_alternative(state);
        }

        if (this.regexp_eatQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        if (state.eat(0x7B )) {
          state.raise("Lone quantifier brackets");
        }
      };

      pp$8.regexp_alternative = function(state) {
        while (state.pos < state.source.length && this.regexp_eatTerm(state))
          { }
      };

      pp$8.regexp_eatTerm = function(state) {
        if (this.regexp_eatAssertion(state)) {
          if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
            if (state.switchU) {
              state.raise("Invalid quantifier");
            }
          }
          return true
        }

        if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
          this.regexp_eatQuantifier(state);
          return true
        }

        return false
      };

      pp$8.regexp_eatAssertion = function(state) {
        var start = state.pos;
        state.lastAssertionIsQuantifiable = false;

        if (state.eat(0x5E ) || state.eat(0x24 )) {
          return true
        }

        if (state.eat(0x5C )) {
          if (state.eat(0x42 ) || state.eat(0x62 )) {
            return true
          }
          state.pos = start;
        }

        if (state.eat(0x28 ) && state.eat(0x3F )) {
          var lookbehind = false;
          if (this.options.ecmaVersion >= 9) {
            lookbehind = state.eat(0x3C );
          }
          if (state.eat(0x3D ) || state.eat(0x21 )) {
            this.regexp_disjunction(state);
            if (!state.eat(0x29 )) {
              state.raise("Unterminated group");
            }
            state.lastAssertionIsQuantifiable = !lookbehind;
            return true
          }
        }

        state.pos = start;
        return false
      };

      pp$8.regexp_eatQuantifier = function(state, noError) {
        if ( noError === void 0 ) noError = false;

        if (this.regexp_eatQuantifierPrefix(state, noError)) {
          state.eat(0x3F );
          return true
        }
        return false
      };

      pp$8.regexp_eatQuantifierPrefix = function(state, noError) {
        return (
          state.eat(0x2A ) ||
          state.eat(0x2B ) ||
          state.eat(0x3F ) ||
          this.regexp_eatBracedQuantifier(state, noError)
        )
      };
      pp$8.regexp_eatBracedQuantifier = function(state, noError) {
        var start = state.pos;
        if (state.eat(0x7B )) {
          var min = 0, max = -1;
          if (this.regexp_eatDecimalDigits(state)) {
            min = state.lastIntValue;
            if (state.eat(0x2C ) && this.regexp_eatDecimalDigits(state)) {
              max = state.lastIntValue;
            }
            if (state.eat(0x7D )) {
              if (max !== -1 && max < min && !noError) {
                state.raise("numbers out of order in {} quantifier");
              }
              return true
            }
          }
          if (state.switchU && !noError) {
            state.raise("Incomplete quantifier");
          }
          state.pos = start;
        }
        return false
      };

      pp$8.regexp_eatAtom = function(state) {
        return (
          this.regexp_eatPatternCharacters(state) ||
          state.eat(0x2E ) ||
          this.regexp_eatReverseSolidusAtomEscape(state) ||
          this.regexp_eatCharacterClass(state) ||
          this.regexp_eatUncapturingGroup(state) ||
          this.regexp_eatCapturingGroup(state)
        )
      };
      pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {
        var start = state.pos;
        if (state.eat(0x5C )) {
          if (this.regexp_eatAtomEscape(state)) {
            return true
          }
          state.pos = start;
        }
        return false
      };
      pp$8.regexp_eatUncapturingGroup = function(state) {
        var start = state.pos;
        if (state.eat(0x28 )) {
          if (state.eat(0x3F ) && state.eat(0x3A )) {
            this.regexp_disjunction(state);
            if (state.eat(0x29 )) {
              return true
            }
            state.raise("Unterminated group");
          }
          state.pos = start;
        }
        return false
      };
      pp$8.regexp_eatCapturingGroup = function(state) {
        if (state.eat(0x28 )) {
          if (this.options.ecmaVersion >= 9) {
            this.regexp_groupSpecifier(state);
          } else if (state.current() === 0x3F ) {
            state.raise("Invalid group");
          }
          this.regexp_disjunction(state);
          if (state.eat(0x29 )) {
            state.numCapturingParens += 1;
            return true
          }
          state.raise("Unterminated group");
        }
        return false
      };

      pp$8.regexp_eatExtendedAtom = function(state) {
        return (
          state.eat(0x2E ) ||
          this.regexp_eatReverseSolidusAtomEscape(state) ||
          this.regexp_eatCharacterClass(state) ||
          this.regexp_eatUncapturingGroup(state) ||
          this.regexp_eatCapturingGroup(state) ||
          this.regexp_eatInvalidBracedQuantifier(state) ||
          this.regexp_eatExtendedPatternCharacter(state)
        )
      };

      pp$8.regexp_eatInvalidBracedQuantifier = function(state) {
        if (this.regexp_eatBracedQuantifier(state, true)) {
          state.raise("Nothing to repeat");
        }
        return false
      };

      pp$8.regexp_eatSyntaxCharacter = function(state) {
        var ch = state.current();
        if (isSyntaxCharacter(ch)) {
          state.lastIntValue = ch;
          state.advance();
          return true
        }
        return false
      };
      function isSyntaxCharacter(ch) {
        return (
          ch === 0x24  ||
          ch >= 0x28  && ch <= 0x2B  ||
          ch === 0x2E  ||
          ch === 0x3F  ||
          ch >= 0x5B  && ch <= 0x5E  ||
          ch >= 0x7B  && ch <= 0x7D 
        )
      }

      pp$8.regexp_eatPatternCharacters = function(state) {
        var start = state.pos;
        var ch = 0;
        while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
          state.advance();
        }
        return state.pos !== start
      };

      pp$8.regexp_eatExtendedPatternCharacter = function(state) {
        var ch = state.current();
        if (
          ch !== -1 &&
          ch !== 0x24  &&
          !(ch >= 0x28  && ch <= 0x2B ) &&
          ch !== 0x2E  &&
          ch !== 0x3F  &&
          ch !== 0x5B  &&
          ch !== 0x5E  &&
          ch !== 0x7C 
        ) {
          state.advance();
          return true
        }
        return false
      };

      pp$8.regexp_groupSpecifier = function(state) {
        if (state.eat(0x3F )) {
          if (this.regexp_eatGroupName(state)) {
            if (state.groupNames.indexOf(state.lastStringValue) !== -1) {
              state.raise("Duplicate capture group name");
            }
            state.groupNames.push(state.lastStringValue);
            return
          }
          state.raise("Invalid group");
        }
      };

      pp$8.regexp_eatGroupName = function(state) {
        state.lastStringValue = "";
        if (state.eat(0x3C )) {
          if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E )) {
            return true
          }
          state.raise("Invalid capture group name");
        }
        return false
      };

      pp$8.regexp_eatRegExpIdentifierName = function(state) {
        state.lastStringValue = "";
        if (this.regexp_eatRegExpIdentifierStart(state)) {
          state.lastStringValue += codePointToString(state.lastIntValue);
          while (this.regexp_eatRegExpIdentifierPart(state)) {
            state.lastStringValue += codePointToString(state.lastIntValue);
          }
          return true
        }
        return false
      };

      pp$8.regexp_eatRegExpIdentifierStart = function(state) {
        var start = state.pos;
        var ch = state.current();
        state.advance();

        if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierStart(ch)) {
          state.lastIntValue = ch;
          return true
        }

        state.pos = start;
        return false
      };
      function isRegExpIdentifierStart(ch) {
        return isIdentifierStart(ch, true) || ch === 0x24  || ch === 0x5F 
      }

      pp$8.regexp_eatRegExpIdentifierPart = function(state) {
        var start = state.pos;
        var ch = state.current();
        state.advance();

        if (ch === 0x5C  && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {
          ch = state.lastIntValue;
        }
        if (isRegExpIdentifierPart(ch)) {
          state.lastIntValue = ch;
          return true
        }

        state.pos = start;
        return false
      };
      function isRegExpIdentifierPart(ch) {
        return isIdentifierChar(ch, true) || ch === 0x24  || ch === 0x5F  || ch === 0x200C  || ch === 0x200D 
      }

      pp$8.regexp_eatAtomEscape = function(state) {
        if (
          this.regexp_eatBackReference(state) ||
          this.regexp_eatCharacterClassEscape(state) ||
          this.regexp_eatCharacterEscape(state) ||
          (state.switchN && this.regexp_eatKGroupName(state))
        ) {
          return true
        }
        if (state.switchU) {
          if (state.current() === 0x63 ) {
            state.raise("Invalid unicode escape");
          }
          state.raise("Invalid escape");
        }
        return false
      };
      pp$8.regexp_eatBackReference = function(state) {
        var start = state.pos;
        if (this.regexp_eatDecimalEscape(state)) {
          var n = state.lastIntValue;
          if (state.switchU) {
            if (n > state.maxBackReference) {
              state.maxBackReference = n;
            }
            return true
          }
          if (n <= state.numCapturingParens) {
            return true
          }
          state.pos = start;
        }
        return false
      };
      pp$8.regexp_eatKGroupName = function(state) {
        if (state.eat(0x6B )) {
          if (this.regexp_eatGroupName(state)) {
            state.backReferenceNames.push(state.lastStringValue);
            return true
          }
          state.raise("Invalid named reference");
        }
        return false
      };

      pp$8.regexp_eatCharacterEscape = function(state) {
        return (
          this.regexp_eatControlEscape(state) ||
          this.regexp_eatCControlLetter(state) ||
          this.regexp_eatZero(state) ||
          this.regexp_eatHexEscapeSequence(state) ||
          this.regexp_eatRegExpUnicodeEscapeSequence(state) ||
          (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||
          this.regexp_eatIdentityEscape(state)
        )
      };
      pp$8.regexp_eatCControlLetter = function(state) {
        var start = state.pos;
        if (state.eat(0x63 )) {
          if (this.regexp_eatControlLetter(state)) {
            return true
          }
          state.pos = start;
        }
        return false
      };
      pp$8.regexp_eatZero = function(state) {
        if (state.current() === 0x30  && !isDecimalDigit(state.lookahead())) {
          state.lastIntValue = 0;
          state.advance();
          return true
        }
        return false
      };

      pp$8.regexp_eatControlEscape = function(state) {
        var ch = state.current();
        if (ch === 0x74 ) {
          state.lastIntValue = 0x09; 
          state.advance();
          return true
        }
        if (ch === 0x6E ) {
          state.lastIntValue = 0x0A; 
          state.advance();
          return true
        }
        if (ch === 0x76 ) {
          state.lastIntValue = 0x0B; 
          state.advance();
          return true
        }
        if (ch === 0x66 ) {
          state.lastIntValue = 0x0C; 
          state.advance();
          return true
        }
        if (ch === 0x72 ) {
          state.lastIntValue = 0x0D; 
          state.advance();
          return true
        }
        return false
      };

      pp$8.regexp_eatControlLetter = function(state) {
        var ch = state.current();
        if (isControlLetter(ch)) {
          state.lastIntValue = ch % 0x20;
          state.advance();
          return true
        }
        return false
      };
      function isControlLetter(ch) {
        return (
          (ch >= 0x41  && ch <= 0x5A ) ||
          (ch >= 0x61  && ch <= 0x7A )
        )
      }

      pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {
        var start = state.pos;

        if (state.eat(0x75 )) {
          if (this.regexp_eatFixedHexDigits(state, 4)) {
            var lead = state.lastIntValue;
            if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {
              var leadSurrogateEnd = state.pos;
              if (state.eat(0x5C ) && state.eat(0x75 ) && this.regexp_eatFixedHexDigits(state, 4)) {
                var trail = state.lastIntValue;
                if (trail >= 0xDC00 && trail <= 0xDFFF) {
                  state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
                  return true
                }
              }
              state.pos = leadSurrogateEnd;
              state.lastIntValue = lead;
            }
            return true
          }
          if (
            state.switchU &&
            state.eat(0x7B ) &&
            this.regexp_eatHexDigits(state) &&
            state.eat(0x7D ) &&
            isValidUnicode(state.lastIntValue)
          ) {
            return true
          }
          if (state.switchU) {
            state.raise("Invalid unicode escape");
          }
          state.pos = start;
        }

        return false
      };
      function isValidUnicode(ch) {
        return ch >= 0 && ch <= 0x10FFFF
      }

      pp$8.regexp_eatIdentityEscape = function(state) {
        if (state.switchU) {
          if (this.regexp_eatSyntaxCharacter(state)) {
            return true
          }
          if (state.eat(0x2F )) {
            state.lastIntValue = 0x2F; 
            return true
          }
          return false
        }

        var ch = state.current();
        if (ch !== 0x63  && (!state.switchN || ch !== 0x6B )) {
          state.lastIntValue = ch;
          state.advance();
          return true
        }

        return false
      };

      pp$8.regexp_eatDecimalEscape = function(state) {
        state.lastIntValue = 0;
        var ch = state.current();
        if (ch >= 0x31  && ch <= 0x39 ) {
          do {
            state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );
            state.advance();
          } while ((ch = state.current()) >= 0x30  && ch <= 0x39 )
          return true
        }
        return false
      };

      pp$8.regexp_eatCharacterClassEscape = function(state) {
        var ch = state.current();

        if (isCharacterClassEscape(ch)) {
          state.lastIntValue = -1;
          state.advance();
          return true
        }

        if (
          state.switchU &&
          this.options.ecmaVersion >= 9 &&
          (ch === 0x50  || ch === 0x70 )
        ) {
          state.lastIntValue = -1;
          state.advance();
          if (
            state.eat(0x7B ) &&
            this.regexp_eatUnicodePropertyValueExpression(state) &&
            state.eat(0x7D )
          ) {
            return true
          }
          state.raise("Invalid property name");
        }

        return false
      };
      function isCharacterClassEscape(ch) {
        return (
          ch === 0x64  ||
          ch === 0x44  ||
          ch === 0x73  ||
          ch === 0x53  ||
          ch === 0x77  ||
          ch === 0x57 
        )
      }

      pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {
        var start = state.pos;

        if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D )) {
          var name = state.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(state)) {
            var value = state.lastStringValue;
            this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
            return true
          }
        }
        state.pos = start;

        if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
          var nameOrValue = state.lastStringValue;
          this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
          return true
        }
        return false
      };
      pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
        if (!has(state.unicodeProperties.nonBinary, name))
          { state.raise("Invalid property name"); }
        if (!state.unicodeProperties.nonBinary[name].test(value))
          { state.raise("Invalid property value"); }
      };
      pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
        if (!state.unicodeProperties.binary.test(nameOrValue))
          { state.raise("Invalid property name"); }
      };

      pp$8.regexp_eatUnicodePropertyName = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyNameCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== ""
      };
      function isUnicodePropertyNameCharacter(ch) {
        return isControlLetter(ch) || ch === 0x5F 
      }

      pp$8.regexp_eatUnicodePropertyValue = function(state) {
        var ch = 0;
        state.lastStringValue = "";
        while (isUnicodePropertyValueCharacter(ch = state.current())) {
          state.lastStringValue += codePointToString(ch);
          state.advance();
        }
        return state.lastStringValue !== ""
      };
      function isUnicodePropertyValueCharacter(ch) {
        return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)
      }

      pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
        return this.regexp_eatUnicodePropertyValue(state)
      };

      pp$8.regexp_eatCharacterClass = function(state) {
        if (state.eat(0x5B )) {
          state.eat(0x5E );
          this.regexp_classRanges(state);
          if (state.eat(0x5D )) {
            return true
          }
          state.raise("Unterminated character class");
        }
        return false
      };

      pp$8.regexp_classRanges = function(state) {
        while (this.regexp_eatClassAtom(state)) {
          var left = state.lastIntValue;
          if (state.eat(0x2D ) && this.regexp_eatClassAtom(state)) {
            var right = state.lastIntValue;
            if (state.switchU && (left === -1 || right === -1)) {
              state.raise("Invalid character class");
            }
            if (left !== -1 && right !== -1 && left > right) {
              state.raise("Range out of order in character class");
            }
          }
        }
      };

      pp$8.regexp_eatClassAtom = function(state) {
        var start = state.pos;

        if (state.eat(0x5C )) {
          if (this.regexp_eatClassEscape(state)) {
            return true
          }
          if (state.switchU) {
            var ch$1 = state.current();
            if (ch$1 === 0x63  || isOctalDigit(ch$1)) {
              state.raise("Invalid class escape");
            }
            state.raise("Invalid escape");
          }
          state.pos = start;
        }

        var ch = state.current();
        if (ch !== 0x5D ) {
          state.lastIntValue = ch;
          state.advance();
          return true
        }

        return false
      };

      pp$8.regexp_eatClassEscape = function(state) {
        var start = state.pos;

        if (state.eat(0x62 )) {
          state.lastIntValue = 0x08; 
          return true
        }

        if (state.switchU && state.eat(0x2D )) {
          state.lastIntValue = 0x2D; 
          return true
        }

        if (!state.switchU && state.eat(0x63 )) {
          if (this.regexp_eatClassControlLetter(state)) {
            return true
          }
          state.pos = start;
        }

        return (
          this.regexp_eatCharacterClassEscape(state) ||
          this.regexp_eatCharacterEscape(state)
        )
      };

      pp$8.regexp_eatClassControlLetter = function(state) {
        var ch = state.current();
        if (isDecimalDigit(ch) || ch === 0x5F ) {
          state.lastIntValue = ch % 0x20;
          state.advance();
          return true
        }
        return false
      };

      pp$8.regexp_eatHexEscapeSequence = function(state) {
        var start = state.pos;
        if (state.eat(0x78 )) {
          if (this.regexp_eatFixedHexDigits(state, 2)) {
            return true
          }
          if (state.switchU) {
            state.raise("Invalid escape");
          }
          state.pos = start;
        }
        return false
      };

      pp$8.regexp_eatDecimalDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isDecimalDigit(ch = state.current())) {
          state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 );
          state.advance();
        }
        return state.pos !== start
      };
      function isDecimalDigit(ch) {
        return ch >= 0x30  && ch <= 0x39 
      }

      pp$8.regexp_eatHexDigits = function(state) {
        var start = state.pos;
        var ch = 0;
        state.lastIntValue = 0;
        while (isHexDigit(ch = state.current())) {
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return state.pos !== start
      };
      function isHexDigit(ch) {
        return (
          (ch >= 0x30  && ch <= 0x39 ) ||
          (ch >= 0x41  && ch <= 0x46 ) ||
          (ch >= 0x61  && ch <= 0x66 )
        )
      }
      function hexToInt(ch) {
        if (ch >= 0x41  && ch <= 0x46 ) {
          return 10 + (ch - 0x41 )
        }
        if (ch >= 0x61  && ch <= 0x66 ) {
          return 10 + (ch - 0x61 )
        }
        return ch - 0x30 
      }

      pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {
        if (this.regexp_eatOctalDigit(state)) {
          var n1 = state.lastIntValue;
          if (this.regexp_eatOctalDigit(state)) {
            var n2 = state.lastIntValue;
            if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
              state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;
            } else {
              state.lastIntValue = n1 * 8 + n2;
            }
          } else {
            state.lastIntValue = n1;
          }
          return true
        }
        return false
      };

      pp$8.regexp_eatOctalDigit = function(state) {
        var ch = state.current();
        if (isOctalDigit(ch)) {
          state.lastIntValue = ch - 0x30; 
          state.advance();
          return true
        }
        state.lastIntValue = 0;
        return false
      };
      function isOctalDigit(ch) {
        return ch >= 0x30  && ch <= 0x37 
      }

      pp$8.regexp_eatFixedHexDigits = function(state, length) {
        var start = state.pos;
        state.lastIntValue = 0;
        for (var i = 0; i < length; ++i) {
          var ch = state.current();
          if (!isHexDigit(ch)) {
            state.pos = start;
            return false
          }
          state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
          state.advance();
        }
        return true
      };


      var Token = function Token(p) {
        this.type = p.type;
        this.value = p.value;
        this.start = p.start;
        this.end = p.end;
        if (p.options.locations)
          { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }
        if (p.options.ranges)
          { this.range = [p.start, p.end]; }
      };


      var pp$9 = Parser.prototype;


      pp$9.next = function(ignoreEscapeSequenceInKeyword) {
        if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc)
          { this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword); }
        if (this.options.onToken)
          { this.options.onToken(new Token(this)); }

        this.lastTokEnd = this.end;
        this.lastTokStart = this.start;
        this.lastTokEndLoc = this.endLoc;
        this.lastTokStartLoc = this.startLoc;
        this.nextToken();
      };

      pp$9.getToken = function() {
        this.next();
        return new Token(this)
      };

      if (typeof Symbol !== "undefined")
        { pp$9[Symbol.iterator] = function() {
          var this$1 = this;

          return {
            next: function () {
              var token = this$1.getToken();
              return {
                done: token.type === types.eof,
                value: token
              }
            }
          }
        }; }


      pp$9.curContext = function() {
        return this.context[this.context.length - 1]
      };


      pp$9.nextToken = function() {
        var curContext = this.curContext();
        if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }

        this.start = this.pos;
        if (this.options.locations) { this.startLoc = this.curPosition(); }
        if (this.pos >= this.input.length) { return this.finishToken(types.eof) }

        if (curContext.override) { return curContext.override(this) }
        else { this.readToken(this.fullCharCodeAtPos()); }
      };

      pp$9.readToken = function(code) {
        if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 )
          { return this.readWord() }

        return this.getTokenFromCode(code)
      };

      pp$9.fullCharCodeAtPos = function() {
        var code = this.input.charCodeAt(this.pos);
        if (code <= 0xd7ff || code >= 0xe000) { return code }
        var next = this.input.charCodeAt(this.pos + 1);
        return (code << 10) + next - 0x35fdc00
      };

      pp$9.skipBlockComment = function() {
        var startLoc = this.options.onComment && this.curPosition();
        var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
        if (end === -1) { this.raise(this.pos - 2, "Unterminated comment"); }
        this.pos = end + 2;
        if (this.options.locations) {
          lineBreakG.lastIndex = start;
          var match;
          while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {
            ++this.curLine;
            this.lineStart = match.index + match[0].length;
          }
        }
        if (this.options.onComment)
          { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,
                                 startLoc, this.curPosition()); }
      };

      pp$9.skipLineComment = function(startSkip) {
        var start = this.pos;
        var startLoc = this.options.onComment && this.curPosition();
        var ch = this.input.charCodeAt(this.pos += startSkip);
        while (this.pos < this.input.length && !isNewLine(ch)) {
          ch = this.input.charCodeAt(++this.pos);
        }
        if (this.options.onComment)
          { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,
                                 startLoc, this.curPosition()); }
      };


      pp$9.skipSpace = function() {
        loop: while (this.pos < this.input.length) {
          var ch = this.input.charCodeAt(this.pos);
          switch (ch) {
          case 32: case 160: 
            ++this.pos;
            break
          case 13:
            if (this.input.charCodeAt(this.pos + 1) === 10) {
              ++this.pos;
            }
          case 10: case 8232: case 8233:
            ++this.pos;
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            break
          case 47: 
            switch (this.input.charCodeAt(this.pos + 1)) {
            case 42: 
              this.skipBlockComment();
              break
            case 47:
              this.skipLineComment(2);
              break
            default:
              break loop
            }
            break
          default:
            if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
              ++this.pos;
            } else {
              break loop
            }
          }
        }
      };


      pp$9.finishToken = function(type, val) {
        this.end = this.pos;
        if (this.options.locations) { this.endLoc = this.curPosition(); }
        var prevType = this.type;
        this.type = type;
        this.value = val;

        this.updateContext(prevType);
      };


      pp$9.readToken_dot = function() {
        var next = this.input.charCodeAt(this.pos + 1);
        if (next >= 48 && next <= 57) { return this.readNumber(true) }
        var next2 = this.input.charCodeAt(this.pos + 2);
        if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { 
          this.pos += 3;
          return this.finishToken(types.ellipsis)
        } else {
          ++this.pos;
          return this.finishToken(types.dot)
        }
      };

      pp$9.readToken_slash = function() { 
        var next = this.input.charCodeAt(this.pos + 1);
        if (this.exprAllowed) { ++this.pos; return this.readRegexp() }
        if (next === 61) { return this.finishOp(types.assign, 2) }
        return this.finishOp(types.slash, 1)
      };

      pp$9.readToken_mult_modulo_exp = function(code) { 
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        var tokentype = code === 42 ? types.star : types.modulo;

        if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
          ++size;
          tokentype = types.starstar;
          next = this.input.charCodeAt(this.pos + 2);
        }

        if (next === 61) { return this.finishOp(types.assign, size + 1) }
        return this.finishOp(tokentype, size)
      };

      pp$9.readToken_pipe_amp = function(code) { 
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }
        if (next === 61) { return this.finishOp(types.assign, 2) }
        return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)
      };

      pp$9.readToken_caret = function() { 
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) { return this.finishOp(types.assign, 2) }
        return this.finishOp(types.bitwiseXOR, 1)
      };

      pp$9.readToken_plus_min = function(code) { 
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === code) {
          if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&
              (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
            this.skipLineComment(3);
            this.skipSpace();
            return this.nextToken()
          }
          return this.finishOp(types.incDec, 2)
        }
        if (next === 61) { return this.finishOp(types.assign, 2) }
        return this.finishOp(types.plusMin, 1)
      };

      pp$9.readToken_lt_gt = function(code) { 
        var next = this.input.charCodeAt(this.pos + 1);
        var size = 1;
        if (next === code) {
          size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }
          return this.finishOp(types.bitShift, size)
        }
        if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&
            this.input.charCodeAt(this.pos + 3) === 45) {
          this.skipLineComment(4);
          this.skipSpace();
          return this.nextToken()
        }
        if (next === 61) { size = 2; }
        return this.finishOp(types.relational, size)
      };

      pp$9.readToken_eq_excl = function(code) { 
        var next = this.input.charCodeAt(this.pos + 1);
        if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }
        if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { 
          this.pos += 2;
          return this.finishToken(types.arrow)
        }
        return this.finishOp(code === 61 ? types.eq : types.prefix, 1)
      };

      pp$9.getTokenFromCode = function(code) {
        switch (code) {
        case 46: 
          return this.readToken_dot()

        case 40: ++this.pos; return this.finishToken(types.parenL)
        case 41: ++this.pos; return this.finishToken(types.parenR)
        case 59: ++this.pos; return this.finishToken(types.semi)
        case 44: ++this.pos; return this.finishToken(types.comma)
        case 91: ++this.pos; return this.finishToken(types.bracketL)
        case 93: ++this.pos; return this.finishToken(types.bracketR)
        case 123: ++this.pos; return this.finishToken(types.braceL)
        case 125: ++this.pos; return this.finishToken(types.braceR)
        case 58: ++this.pos; return this.finishToken(types.colon)
        case 63: ++this.pos; return this.finishToken(types.question)

        case 96: 
          if (this.options.ecmaVersion < 6) { break }
          ++this.pos;
          return this.finishToken(types.backQuote)

        case 48: 
          var next = this.input.charCodeAt(this.pos + 1);
          if (next === 120 || next === 88) { return this.readRadixNumber(16) } 
          if (this.options.ecmaVersion >= 6) {
            if (next === 111 || next === 79) { return this.readRadixNumber(8) } 
            if (next === 98 || next === 66) { return this.readRadixNumber(2) } 
          }

        case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: 
          return this.readNumber(false)

        case 34: case 39: 
          return this.readString(code)


        case 47: 
          return this.readToken_slash()

        case 37: case 42: 
          return this.readToken_mult_modulo_exp(code)

        case 124: case 38: 
          return this.readToken_pipe_amp(code)

        case 94: 
          return this.readToken_caret()

        case 43: case 45: 
          return this.readToken_plus_min(code)

        case 60: case 62: 
          return this.readToken_lt_gt(code)

        case 61: case 33: 
          return this.readToken_eq_excl(code)

        case 126: 
          return this.finishOp(types.prefix, 1)
        }

        this.raise(this.pos, "Unexpected character '" + codePointToString$1(code) + "'");
      };

      pp$9.finishOp = function(type, size) {
        var str = this.input.slice(this.pos, this.pos + size);
        this.pos += size;
        return this.finishToken(type, str)
      };

      pp$9.readRegexp = function() {
        var escaped, inClass, start = this.pos;
        for (;;) {
          if (this.pos >= this.input.length) { this.raise(start, "Unterminated regular expression"); }
          var ch = this.input.charAt(this.pos);
          if (lineBreak.test(ch)) { this.raise(start, "Unterminated regular expression"); }
          if (!escaped) {
            if (ch === "[") { inClass = true; }
            else if (ch === "]" && inClass) { inClass = false; }
            else if (ch === "/" && !inClass) { break }
            escaped = ch === "\\";
          } else { escaped = false; }
          ++this.pos;
        }
        var pattern = this.input.slice(start, this.pos);
        ++this.pos;
        var flagsStart = this.pos;
        var flags = this.readWord1();
        if (this.containsEsc) { this.unexpected(flagsStart); }

        var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
        state.reset(start, pattern, flags);
        this.validateRegExpFlags(state);
        this.validateRegExpPattern(state);

        var value = null;
        try {
          value = new RegExp(pattern, flags);
        } catch (e) {
        }

        return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})
      };


      pp$9.readInt = function(radix, len) {
        var start = this.pos, total = 0;
        for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
          var code = this.input.charCodeAt(this.pos), val = (void 0);
          if (code >= 97) { val = code - 97 + 10; } 
          else if (code >= 65) { val = code - 65 + 10; } 
          else if (code >= 48 && code <= 57) { val = code - 48; } 
          else { val = Infinity; }
          if (val >= radix) { break }
          ++this.pos;
          total = total * radix + val;
        }
        if (this.pos === start || len != null && this.pos - start !== len) { return null }

        return total
      };

      pp$9.readRadixNumber = function(radix) {
        var start = this.pos;
        this.pos += 2; 
        var val = this.readInt(radix);
        if (val == null) { this.raise(this.start + 2, "Expected number in radix " + radix); }
        if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
          val = typeof BigInt !== "undefined" ? BigInt(this.input.slice(start, this.pos)) : null;
          ++this.pos;
        } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
        return this.finishToken(types.num, val)
      };


      pp$9.readNumber = function(startsWithDot) {
        var start = this.pos;
        if (!startsWithDot && this.readInt(10) === null) { this.raise(start, "Invalid number"); }
        var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (octal && this.strict) { this.raise(start, "Invalid number"); }
        var next = this.input.charCodeAt(this.pos);
        if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
          var str$1 = this.input.slice(start, this.pos);
          var val$1 = typeof BigInt !== "undefined" ? BigInt(str$1) : null;
          ++this.pos;
          if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }
          return this.finishToken(types.num, val$1)
        }
        if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }
        if (next === 46 && !octal) { 
          ++this.pos;
          this.readInt(10);
          next = this.input.charCodeAt(this.pos);
        }
        if ((next === 69 || next === 101) && !octal) { 
          next = this.input.charCodeAt(++this.pos);
          if (next === 43 || next === 45) { ++this.pos; } 
          if (this.readInt(10) === null) { this.raise(start, "Invalid number"); }
        }
        if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, "Identifier directly after number"); }

        var str = this.input.slice(start, this.pos);
        var val = octal ? parseInt(str, 8) : parseFloat(str);
        return this.finishToken(types.num, val)
      };


      pp$9.readCodePoint = function() {
        var ch = this.input.charCodeAt(this.pos), code;

        if (ch === 123) { 
          if (this.options.ecmaVersion < 6) { this.unexpected(); }
          var codePos = ++this.pos;
          code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
          ++this.pos;
          if (code > 0x10FFFF) { this.invalidStringToken(codePos, "Code point out of bounds"); }
        } else {
          code = this.readHexChar(4);
        }
        return code
      };

      function codePointToString$1(code) {
        if (code <= 0xFFFF) { return String.fromCharCode(code) }
        code -= 0x10000;
        return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)
      }

      pp$9.readString = function(quote) {
        var out = "", chunkStart = ++this.pos;
        for (;;) {
          if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated string constant"); }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === quote) { break }
          if (ch === 92) { 
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(false);
            chunkStart = this.pos;
          } else {
            if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, "Unterminated string constant"); }
            ++this.pos;
          }
        }
        out += this.input.slice(chunkStart, this.pos++);
        return this.finishToken(types.string, out)
      };


      var INVALID_TEMPLATE_ESCAPE_ERROR = {};

      pp$9.tryReadTemplateToken = function() {
        this.inTemplateElement = true;
        try {
          this.readTmplToken();
        } catch (err) {
          if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {
            this.readInvalidTemplateToken();
          } else {
            throw err
          }
        }

        this.inTemplateElement = false;
      };

      pp$9.invalidStringToken = function(position, message) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
          throw INVALID_TEMPLATE_ESCAPE_ERROR
        } else {
          this.raise(position, message);
        }
      };

      pp$9.readTmplToken = function() {
        var out = "", chunkStart = this.pos;
        for (;;) {
          if (this.pos >= this.input.length) { this.raise(this.start, "Unterminated template"); }
          var ch = this.input.charCodeAt(this.pos);
          if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { 
            if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {
              if (ch === 36) {
                this.pos += 2;
                return this.finishToken(types.dollarBraceL)
              } else {
                ++this.pos;
                return this.finishToken(types.backQuote)
              }
            }
            out += this.input.slice(chunkStart, this.pos);
            return this.finishToken(types.template, out)
          }
          if (ch === 92) { 
            out += this.input.slice(chunkStart, this.pos);
            out += this.readEscapedChar(true);
            chunkStart = this.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.pos);
            ++this.pos;
            switch (ch) {
            case 13:
              if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }
            case 10:
              out += "\n";
              break
            default:
              out += String.fromCharCode(ch);
              break
            }
            if (this.options.locations) {
              ++this.curLine;
              this.lineStart = this.pos;
            }
            chunkStart = this.pos;
          } else {
            ++this.pos;
          }
        }
      };

      pp$9.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++) {
          switch (this.input[this.pos]) {
          case "\\":
            ++this.pos;
            break

          case "$":
            if (this.input[this.pos + 1] !== "{") {
              break
            }

          case "`":
            return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))

          }
        }
        this.raise(this.start, "Unterminated template");
      };


      pp$9.readEscapedChar = function(inTemplate) {
        var ch = this.input.charCodeAt(++this.pos);
        ++this.pos;
        switch (ch) {
        case 110: return "\n" 
        case 114: return "\r" 
        case 120: return String.fromCharCode(this.readHexChar(2)) 
        case 117: return codePointToString$1(this.readCodePoint()) 
        case 116: return "\t" 
        case 98: return "\b" 
        case 118: return "\u000b" 
        case 102: return "\f" 
        case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } 
        case 10: 
          if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }
          return ""
        case 56:
        case 57:
          if (inTemplate) {
            var codePos = this.pos - 1;

            this.invalidStringToken(
              codePos,
              "Invalid escape sequence in template string"
            );

            return null
          }
        default:
          if (ch >= 48 && ch <= 55) {
            var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
            var octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            this.pos += octalStr.length - 1;
            ch = this.input.charCodeAt(this.pos);
            if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
              this.invalidStringToken(
                this.pos - 1 - octalStr.length,
                inTemplate
                  ? "Octal literal in template string"
                  : "Octal literal in strict mode"
              );
            }
            return String.fromCharCode(octal)
          }
          if (isNewLine(ch)) {
            return ""
          }
          return String.fromCharCode(ch)
        }
      };


      pp$9.readHexChar = function(len) {
        var codePos = this.pos;
        var n = this.readInt(16, len);
        if (n === null) { this.invalidStringToken(codePos, "Bad character escape sequence"); }
        return n
      };


      pp$9.readWord1 = function() {
        this.containsEsc = false;
        var word = "", first = true, chunkStart = this.pos;
        var astral = this.options.ecmaVersion >= 6;
        while (this.pos < this.input.length) {
          var ch = this.fullCharCodeAtPos();
          if (isIdentifierChar(ch, astral)) {
            this.pos += ch <= 0xffff ? 1 : 2;
          } else if (ch === 92) { 
            this.containsEsc = true;
            word += this.input.slice(chunkStart, this.pos);
            var escStart = this.pos;
            if (this.input.charCodeAt(++this.pos) !== 117) 
              { this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"); }
            ++this.pos;
            var esc = this.readCodePoint();
            if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))
              { this.invalidStringToken(escStart, "Invalid Unicode escape"); }
            word += codePointToString$1(esc);
            chunkStart = this.pos;
          } else {
            break
          }
          first = false;
        }
        return word + this.input.slice(chunkStart, this.pos)
      };


      pp$9.readWord = function() {
        var word = this.readWord1();
        var type = types.name;
        if (this.keywords.test(word)) {
          type = keywords$1[word];
        }
        return this.finishToken(type, word)
      };


      var version = "7.1.0";

      Parser.acorn = {
        Parser: Parser,
        version: version,
        defaultOptions: defaultOptions,
        Position: Position,
        SourceLocation: SourceLocation,
        getLineInfo: getLineInfo,
        Node: Node,
        TokenType: TokenType,
        tokTypes: types,
        keywordTypes: keywords$1,
        TokContext: TokContext,
        tokContexts: types$1,
        isIdentifierChar: isIdentifierChar,
        isIdentifierStart: isIdentifierStart,
        Token: Token,
        isNewLine: isNewLine,
        lineBreak: lineBreak,
        lineBreakG: lineBreakG,
        nonASCIIwhitespace: nonASCIIwhitespace
      };


      function parse(input, options) {
        return Parser.parse(input, options)
      }


      function parseExpressionAt(input, pos, options) {
        return Parser.parseExpressionAt(input, pos, options)
      }


      function tokenizer(input, options) {
        return Parser.tokenizer(input, options)
      }

      exports.Node = Node;
      exports.Parser = Parser;
      exports.Position = Position;
      exports.SourceLocation = SourceLocation;
      exports.TokContext = TokContext;
      exports.Token = Token;
      exports.TokenType = TokenType;
      exports.defaultOptions = defaultOptions;
      exports.getLineInfo = getLineInfo;
      exports.isIdentifierChar = isIdentifierChar;
      exports.isIdentifierStart = isIdentifierStart;
      exports.isNewLine = isNewLine;
      exports.keywordTypes = keywords$1;
      exports.lineBreak = lineBreak;
      exports.lineBreakG = lineBreakG;
      exports.nonASCIIwhitespace = nonASCIIwhitespace;
      exports.parse = parse;
      exports.parseExpressionAt = parseExpressionAt;
      exports.tokContexts = types$1;
      exports.tokTypes = types;
      exports.tokenizer = tokenizer;
      exports.version = version;

      Object.defineProperty(exports, '__esModule', { value: true });

    }));

    },{}],2:[function(require,module,exports){

    },{}],3:[function(require,module,exports){
    function glWiretap(gl, options = {}) {
      const {
        contextName = 'gl',
        throwGetError,
        useTrackablePrimitives,
        readPixelsFile,
        recording = [],
        variables = {},
        onReadPixels,
        onUnrecognizedArgumentLookup,
      } = options;
      const proxy = new Proxy(gl, { get: listen });
      const contextVariables = [];
      const entityNames = {};
      let imageCount = 0;
      let indent = '';
      let readPixelsVariableName;
      return proxy;
      function listen(obj, property) {
        switch (property) {
          case 'addComment': return addComment;
          case 'checkThrowError': return checkThrowError;
          case 'getReadPixelsVariableName': return readPixelsVariableName;
          case 'insertVariable': return insertVariable;
          case 'reset': return reset;
          case 'setIndent': return setIndent;
          case 'toString': return toString;
          case 'getContextVariableName': return getContextVariableName;
        }
        if (typeof gl[property] === 'function') {
          return function() { 
            switch (property) {
              case 'getError':
                if (throwGetError) {
                  recording.push(`${indent}if (${contextName}.getError() !== ${contextName}.NONE) throw new Error('error');`);
                } else {
                  recording.push(`${indent}${contextName}.getError();`); 
                }
                return gl.getError();
              case 'getExtension': {
                const variableName = `${contextName}Variables${contextVariables.length}`;
                recording.push(`${indent}const ${variableName} = ${contextName}.getExtension('${arguments[0]}');`);
                const extension = gl.getExtension(arguments[0]);
                if (extension && typeof extension === 'object') {
                  const tappedExtension = glExtensionWiretap(extension, {
                    getEntity,
                    useTrackablePrimitives,
                    recording,
                    contextName: variableName,
                    contextVariables,
                    variables,
                    indent,
                    onUnrecognizedArgumentLookup,
                  });
                  contextVariables.push(tappedExtension);
                  return tappedExtension;
                } else {
                  contextVariables.push(null);
                }
                return extension;
              }
              case 'readPixels':
                const i = contextVariables.indexOf(arguments[6]);
                let targetVariableName;
                if (i === -1) {
                  const variableName = getVariableName(arguments[6]);
                  if (variableName) {
                    targetVariableName = variableName;
                    recording.push(`${indent}${variableName}`);
                  } else {
                    targetVariableName = `${contextName}Variable${contextVariables.length}`;
                    contextVariables.push(arguments[6]);
                    recording.push(`${indent}const ${targetVariableName} = new ${arguments[6].constructor.name}(${arguments[6].length});`);
                  }
                } else {
                  targetVariableName = `${contextName}Variable${i}`;
                }
                readPixelsVariableName = targetVariableName;
                const argumentAsStrings = [
                  arguments[0],
                  arguments[1],
                  arguments[2],
                  arguments[3],
                  getEntity(arguments[4]),
                  getEntity(arguments[5]),
                  targetVariableName
                ];
                recording.push(`${indent}${contextName}.readPixels(${argumentAsStrings.join(', ')});`);
                if (readPixelsFile) {
                  writePPM(arguments[2], arguments[3]);
                }
                if (onReadPixels) {
                  onReadPixels(targetVariableName, argumentAsStrings);
                }
                return gl.readPixels.apply(gl, arguments);
              case 'drawBuffers':
                recording.push(`${indent}${contextName}.drawBuffers([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup } )}]);`);
                return gl.drawBuffers(arguments[0]);
            }
            let result = gl[property].apply(gl, arguments);
            switch (typeof result) {
              case 'undefined':
                recording.push(`${indent}${methodCallToString(property, arguments)};`);
                return;
              case 'number':
              case 'boolean':
                if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {
                  recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
                  contextVariables.push(result = trackablePrimitive(result));
                  break;
                }
              default:
                if (result === null) {
                  recording.push(`${methodCallToString(property, arguments)};`);
                } else {
                  recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
                }

                contextVariables.push(result);
            }
            return result;
          }
        }
        entityNames[gl[property]] = property;
        return gl[property];
      }
      function toString() {
        return recording.join('\n');
      }
      function reset() {
        while (recording.length > 0) {
          recording.pop();
        }
      }
      function insertVariable(name, value) {
        variables[name] = value;
      }
      function getEntity(value) {
        const name = entityNames[value];
        if (name) {
          return contextName + '.' + name;
        }
        return value;
      }
      function setIndent(spaces) {
        indent = ' '.repeat(spaces);
      }
      function addVariable(value, source) {
        const variableName = `${contextName}Variable${contextVariables.length}`;
        recording.push(`${indent}const ${variableName} = ${source};`);
        contextVariables.push(value);
        return variableName;
      }
      function writePPM(width, height) {
        const sourceVariable = `${contextName}Variable${contextVariables.length}`;
        const imageVariable = `imageDatum${imageCount}`;
        recording.push(`${indent}let ${imageVariable} = ["P3\\n# ${readPixelsFile}.ppm\\n", ${width}, ' ', ${height}, "\\n255\\n"].join("");`);
        recording.push(`${indent}for (let i = 0; i < ${imageVariable}.length; i += 4) {`);
        recording.push(`${indent}  ${imageVariable} += ${sourceVariable}[i] + ' ' + ${sourceVariable}[i + 1] + ' ' + ${sourceVariable}[i + 2] + ' ';`);
        recording.push(`${indent}}`);
        recording.push(`${indent}if (typeof require !== "undefined") {`);
        recording.push(`${indent}  require('fs').writeFileSync('./${readPixelsFile}.ppm', ${imageVariable});`);
        recording.push(`${indent}}`);
        imageCount++;
      }
      function addComment(value) {
        recording.push(`${indent}// ${value}`);
      }
      function checkThrowError() {
        recording.push(`${indent}(() => {
${indent}const error = ${contextName}.getError();
${indent}if (error !== ${contextName}.NONE) {
${indent}  const names = Object.getOwnPropertyNames(gl);
${indent}  for (let i = 0; i < names.length; i++) {
${indent}    const name = names[i];
${indent}    if (${contextName}[name] === error) {
${indent}      throw new Error('${contextName} threw ' + name);
${indent}    }
${indent}  }
${indent}}
${indent}})();`);
      }
      function methodCallToString(method, args) {
        return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;
      }

      function getVariableName(value) {
        if (variables) {
          for (const name in variables) {
            if (variables[name] === value) {
              return name;
            }
          }
        }
        return null;
      }

      function getContextVariableName(value) {
        const i = contextVariables.indexOf(value);
        if (i !== -1) {
          return `${contextName}Variable${i}`;
        }
        return null;
      }
    }

    function glExtensionWiretap(extension, options) {
      const proxy = new Proxy(extension, { get: listen });
      const extensionEntityNames = {};
      const {
        contextName,
        contextVariables,
        getEntity,
        useTrackablePrimitives,
        recording,
        variables,
        indent,
        onUnrecognizedArgumentLookup,
      } = options;
      return proxy;
      function listen(obj, property) {
        if (typeof obj[property] === 'function') {
          return function() {
            switch (property) {
              case 'drawBuffersWEBGL':
                recording.push(`${indent}${contextName}.drawBuffersWEBGL([${argumentsToString(arguments[0], { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })}]);`);
                return extension.drawBuffersWEBGL(arguments[0]);
            }
            let result = extension[property].apply(extension, arguments);
            switch (typeof result) {
              case 'undefined':
                recording.push(`${indent}${methodCallToString(property, arguments)};`);
                return;
              case 'number':
              case 'boolean':
                if (useTrackablePrimitives && contextVariables.indexOf(trackablePrimitive(result)) === -1) {
                  recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
                  contextVariables.push(result = trackablePrimitive(result));
                } else {
                  recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
                  contextVariables.push(result);
                }
                break;
              default:
                if (result === null) {
                  recording.push(`${methodCallToString(property, arguments)};`);
                } else {
                  recording.push(`${indent}const ${contextName}Variable${contextVariables.length} = ${methodCallToString(property, arguments)};`);
                }
                contextVariables.push(result);
            }
            return result;
          };
        }
        extensionEntityNames[extension[property]] = property;
        return extension[property];
      }

      function getExtensionEntity(value) {
        if (extensionEntityNames.hasOwnProperty(value)) {
          return `${contextName}.${extensionEntityNames[value]}`;
        }
        return getEntity(value);
      }

      function methodCallToString(method, args) {
        return `${contextName}.${method}(${argumentsToString(args, { contextName, contextVariables, getEntity: getExtensionEntity, addVariable, variables, onUnrecognizedArgumentLookup })})`;
      }

      function addVariable(value, source) {
        const variableName = `${contextName}Variable${contextVariables.length}`;
        contextVariables.push(value);
        recording.push(`${indent}const ${variableName} = ${source};`);
        return variableName;
      }
    }

    function argumentsToString(args, options) {
      const { variables, onUnrecognizedArgumentLookup } = options;
      return (Array.from(args).map((arg) => {
        const variableName = getVariableName(arg);
        if (variableName) {
          return variableName;
        }
        return argumentToString(arg, options);
      }).join(', '));

      function getVariableName(value) {
        if (variables) {
          for (const name in variables) {
            if (!variables.hasOwnProperty(name)) continue;
            if (variables[name] === value) {
              return name;
            }
          }
        }
        if (onUnrecognizedArgumentLookup) {
          return onUnrecognizedArgumentLookup(value);
        }
        return null;
      }
    }

    function argumentToString(arg, options) {
      const { contextName, contextVariables, getEntity, addVariable, onUnrecognizedArgumentLookup } = options;
      if (typeof arg === 'undefined') {
        return 'undefined';
      }
      if (arg === null) {
        return 'null';
      }
      const i = contextVariables.indexOf(arg);
      if (i > -1) {
        return `${contextName}Variable${i}`;
      }
      switch (arg.constructor.name) {
        case 'String':
          const hasLines = /\n/.test(arg);
          const hasSingleQuotes = /'/.test(arg);
          const hasDoubleQuotes = /"/.test(arg);
          if (hasLines) {
            return '`' + arg + '`';
          } else if (hasSingleQuotes && !hasDoubleQuotes) {
            return '"' + arg + '"';
          } else if (!hasSingleQuotes && hasDoubleQuotes) {
            return "'" + arg + "'";
          } else {
            return '\'' + arg + '\'';
          }
        case 'Number': return getEntity(arg);
        case 'Boolean': return getEntity(arg);
        case 'Array':
          return addVariable(arg, `new ${arg.constructor.name}([${Array.from(arg).join(',')}])`);
        case 'Float32Array':
        case 'Uint8Array':
        case 'Uint16Array':
        case 'Int32Array':
          return addVariable(arg, `new ${arg.constructor.name}(${JSON.stringify(Array.from(arg))})`);
        default:
          if (onUnrecognizedArgumentLookup) {
            const instantiationString = onUnrecognizedArgumentLookup(arg);
            if (instantiationString) {
              return instantiationString;
            }
          }
          throw new Error(`unrecognized argument type ${arg.constructor.name}`);
      }
    }

    function trackablePrimitive(value) {
      return new value.constructor(value);
    }

    if (typeof module !== 'undefined') {
      module.exports = { glWiretap, glExtensionWiretap };
    }

    if (typeof window !== 'undefined') {
      glWiretap.glExtensionWiretap = glExtensionWiretap;
      window.glWiretap = glWiretap;
    }

    },{}],4:[function(require,module,exports){
    function setupArguments(args) {
      const newArguments = new Array(args.length);
      for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if (arg.toArray) {
          newArguments[i] = arg.toArray();
        } else {
          newArguments[i] = arg;
        }
      }
      return newArguments;
    }

    function mock1D() {
      const args = setupArguments(arguments);
      const row = new Float32Array(this.output.x);
      for (let x = 0; x < this.output.x; x++) {
        this.thread.x = x;
        this.thread.y = 0;
        this.thread.z = 0;
        row[x] = this._fn.apply(this, args);
      }
      return row;
    }

    function mock2D() {
      const args = setupArguments(arguments);
      const matrix = new Array(this.output.y);
      for (let y = 0; y < this.output.y; y++) {
        const row = new Float32Array(this.output.x);
        for (let x = 0; x < this.output.x; x++) {
          this.thread.x = x;
          this.thread.y = y;
          this.thread.z = 0;
          row[x] = this._fn.apply(this, args);
        }
        matrix[y] = row;
      }
      return matrix;
    }

    function mock2DGraphical() {
      const args = setupArguments(arguments);
      for (let y = 0; y < this.output.y; y++) {
        for (let x = 0; x < this.output.x; x++) {
          this.thread.x = x;
          this.thread.y = y;
          this.thread.z = 0;
          this._fn.apply(this, args);
        }
      }
    }

    function mock3D() {
      const args = setupArguments(arguments);
      const cube = new Array(this.output.z);
      for (let z = 0; z < this.output.z; z++) {
        const matrix = new Array(this.output.y);
        for (let y = 0; y < this.output.y; y++) {
          const row = new Float32Array(this.output.x);
          for (let x = 0; x < this.output.x; x++) {
            this.thread.x = x;
            this.thread.y = y;
            this.thread.z = z;
            row[x] = this._fn.apply(this, args);
          }
          matrix[y] = row;
        }
        cube[z] = matrix;
      }
      return cube;
    }

    function apiDecorate(kernel) {
      kernel.setOutput = (output) => {
        kernel.output = setupOutput(output);
        if (kernel.graphical) {
          setupGraphical(kernel);
        }
      };
      kernel.toJSON = () => {
        throw new Error('Not usable with gpuMock');
      };
      kernel.setConstants = (flag) => {
        kernel.constants = flag;
        return kernel;
      };
      kernel.setGraphical = (flag) => {
        kernel.graphical = flag;
        return kernel;
      };
      kernel.setCanvas = (flag) => {
        kernel.canvas = flag;
        return kernel;
      };
      kernel.setContext = (flag) => {
        kernel.context = flag;
        return kernel;
      };
      kernel.destroy = () => {};
      kernel.validateSettings = () => {};
      if (kernel.graphical && kernel.output) {
        setupGraphical(kernel);
      }
      kernel.exec = function() {
        return new Promise((resolve, reject) => {
          try {
            resolve(kernel.apply(kernel, arguments));
          } catch(e) {
            reject(e);
          }
        });
      };
      kernel.getPixels = (flip) => {
        const {x, y} = kernel.output;
        return flip ? flipPixels(kernel._imageData.data, x, y) : kernel._imageData.data.slice(0);
      };
      kernel.color = function(r, g, b, a) {
        if (typeof a === 'undefined') {
          a = 1;
        }

        r = Math.floor(r * 255);
        g = Math.floor(g * 255);
        b = Math.floor(b * 255);
        a = Math.floor(a * 255);

        const width = kernel.output.x;
        const height = kernel.output.y;

        const x = kernel.thread.x;
        const y = height - kernel.thread.y - 1;

        const index = x + y * width;

        kernel._colorData[index * 4 + 0] = r;
        kernel._colorData[index * 4 + 1] = g;
        kernel._colorData[index * 4 + 2] = b;
        kernel._colorData[index * 4 + 3] = a;
      };

      const mockMethod = () => kernel;
      const methods = [
        'setWarnVarUsage',
        'setArgumentTypes',
        'setTactic',
        'setOptimizeFloatMemory',
        'setDebug',
        'setLoopMaxIterations',
        'setConstantTypes',
        'setFunctions',
        'setNativeFunctions',
        'setInjectedNative',
        'setPipeline',
        'setPrecision',
        'setOutputToTexture',
        'setImmutable',
        'setStrictIntegers',
        'setDynamicOutput',
        'setHardcodeConstants',
        'setDynamicArguments',
        'setUseLegacyEncoder',
        'setWarnVarUsage',
        'addSubKernel',
      ];
      for (let i = 0; i < methods.length; i++) {
        kernel[methods[i]] = mockMethod;
      }
      return kernel;
    }

    function setupGraphical(kernel) {
      const {x, y} = kernel.output;
      if (kernel.context && kernel.context.createImageData) {
        const data = new Uint8ClampedArray(x * y * 4);
        kernel._imageData = kernel.context.createImageData(x, y);
        kernel._colorData = data;
      } else {
        const data = new Uint8ClampedArray(x * y * 4);
        kernel._imageData = { data };
        kernel._colorData = data;
      }
    }

    function setupOutput(output) {
      let result = null;
      if (output.length) {
        if (output.length === 3) {
          const [x,y,z] = output;
          result = { x, y, z };
        } else if (output.length === 2) {
          const [x,y] = output;
          result = { x, y };
        } else {
          const [x] = output;
          result = { x };
        }
      } else {
        result = output;
      }
      return result;
    }

    function gpuMock(fn, settings = {}) {
      const output = settings.output ? setupOutput(settings.output) : null;
      function kernel() {
        if (kernel.output.z) {
          return mock3D.apply(kernel, arguments);
        } else if (kernel.output.y) {
          if (kernel.graphical) {
            return mock2DGraphical.apply(kernel, arguments);
          }
          return mock2D.apply(kernel, arguments);
        } else {
          return mock1D.apply(kernel, arguments);
        }
      }
      kernel._fn = fn;
      kernel.constants = settings.constants || null;
      kernel.context = settings.context || null;
      kernel.canvas = settings.canvas || null;
      kernel.graphical = settings.graphical || false;
      kernel._imageData = null;
      kernel._colorData = null;
      kernel.output = output;
      kernel.thread = {
        x: 0,
        y: 0,
        z: 0
      };
      return apiDecorate(kernel);
    }

    function flipPixels(pixels, width, height) {
      const halfHeight = height / 2 | 0; 
      const bytesPerRow = width * 4;
      const temp = new Uint8ClampedArray(width * 4);
      const result = pixels.slice(0);
      for (let y = 0; y < halfHeight; ++y) {
        const topOffset = y * bytesPerRow;
        const bottomOffset = (height - y - 1) * bytesPerRow;

        temp.set(result.subarray(topOffset, topOffset + bytesPerRow));

        result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);

        result.set(temp, bottomOffset);
      }
      return result;
    }

    module.exports = {
      gpuMock
    };

    },{}],5:[function(require,module,exports){
    const { utils } = require('./utils');

    function alias(name, source) {
      const fnString = source.toString();
      return new Function(`return function ${ name } (${ utils.getArgumentNamesFromString(fnString).join(', ') }) {
  ${ utils.getFunctionBodyFromString(fnString) }
}`)();
    }

    module.exports = {
      alias
    };
    },{"./utils":114}],6:[function(require,module,exports){
    const { FunctionNode } = require('../function-node');

    class CPUFunctionNode extends FunctionNode {
      astFunction(ast, retArr) {

        if (!this.isRootKernel) {
          retArr.push('function');
          retArr.push(' ');
          retArr.push(this.name);
          retArr.push('(');

          for (let i = 0; i < this.argumentNames.length; ++i) {
            const argumentName = this.argumentNames[i];

            if (i > 0) {
              retArr.push(', ');
            }
            retArr.push('user_');
            retArr.push(argumentName);
          }

          retArr.push(') {\n');
        }

        for (let i = 0; i < ast.body.body.length; ++i) {
          this.astGeneric(ast.body.body[i], retArr);
          retArr.push('\n');
        }

        if (!this.isRootKernel) {
          retArr.push('}\n');
        }
        return retArr;
      }

      astReturnStatement(ast, retArr) {
        const type = this.returnType || this.getType(ast.argument);

        if (!this.returnType) {
          this.returnType = type;
        }

        if (this.isRootKernel) {
          retArr.push(this.leadingReturnStatement);
          this.astGeneric(ast.argument, retArr);
          retArr.push(';\n');
          retArr.push(this.followingReturnStatement);
          retArr.push('continue;\n');
        } else if (this.isSubKernel) {
          retArr.push(`subKernelResult_${ this.name } = `);
          this.astGeneric(ast.argument, retArr);
          retArr.push(';');
          retArr.push(`return subKernelResult_${ this.name };`);
        } else {
          retArr.push('return ');
          this.astGeneric(ast.argument, retArr);
          retArr.push(';');
        }
        return retArr;
      }

      astLiteral(ast, retArr) {

        if (isNaN(ast.value)) {
          throw this.astErrorOutput(
            'Non-numeric literal not supported : ' + ast.value,
            ast
          );
        }

        retArr.push(ast.value);

        return retArr;
      }

      astBinaryExpression(ast, retArr) {
        retArr.push('(');
        this.astGeneric(ast.left, retArr);
        retArr.push(ast.operator);
        this.astGeneric(ast.right, retArr);
        retArr.push(')');
        return retArr;
      }

      astIdentifierExpression(idtNode, retArr) {
        if (idtNode.type !== 'Identifier') {
          throw this.astErrorOutput(
            'IdentifierExpression - not an Identifier',
            idtNode
          );
        }

        switch (idtNode.name) {
          case 'Infinity':
            retArr.push('Infinity');
            break;
          default:
            if (this.constants && this.constants.hasOwnProperty(idtNode.name)) {
              retArr.push('constants_' + idtNode.name);
            } else {
              retArr.push('user_' + idtNode.name);
            }
        }

        return retArr;
      }

      astForStatement(forNode, retArr) {
        if (forNode.type !== 'ForStatement') {
          throw this.astErrorOutput('Invalid for statement', forNode);
        }

        const initArr = [];
        const testArr = [];
        const updateArr = [];
        const bodyArr = [];
        let isSafe = null;

        if (forNode.init) {
          this.pushState('in-for-loop-init');
          this.astGeneric(forNode.init, initArr);
          for (let i = 0; i < initArr.length; i++) {
            if (initArr[i].includes && initArr[i].includes(',')) {
              isSafe = false;
            }
          }
          this.popState('in-for-loop-init');
        } else {
          isSafe = false;
        }

        if (forNode.test) {
          this.astGeneric(forNode.test, testArr);
        } else {
          isSafe = false;
        }

        if (forNode.update) {
          this.astGeneric(forNode.update, updateArr);
        } else {
          isSafe = false;
        }

        if (forNode.body) {
          this.pushState('loop-body');
          this.astGeneric(forNode.body, bodyArr);
          this.popState('loop-body');
        }

        if (isSafe === null) {
          isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
        }

        if (isSafe) {
          retArr.push(`for (${initArr.join('')};${testArr.join('')};${updateArr.join('')}){\n`);
          retArr.push(bodyArr.join(''));
          retArr.push('}\n');
        } else {
          const iVariableName = this.getInternalVariableName('safeI');
          if (initArr.length > 0) {
            retArr.push(initArr.join(''), ';\n');
          }
          retArr.push(`for (let ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
          if (testArr.length > 0) {
            retArr.push(`if (!${testArr.join('')}) break;\n`);
          }
          retArr.push(bodyArr.join(''));
          retArr.push(`\n${updateArr.join('')};`);
          retArr.push('}\n');
        }
        return retArr;
      }

      astWhileStatement(whileNode, retArr) {
        if (whileNode.type !== 'WhileStatement') {
          throw this.astErrorOutput(
            'Invalid while statement',
            whileNode
          );
        }

        retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
        retArr.push('if (');
        this.astGeneric(whileNode.test, retArr);
        retArr.push(') {\n');
        this.astGeneric(whileNode.body, retArr);
        retArr.push('} else {\n');
        retArr.push('break;\n');
        retArr.push('}\n');
        retArr.push('}\n');

        return retArr;
      }

      astDoWhileStatement(doWhileNode, retArr) {
        if (doWhileNode.type !== 'DoWhileStatement') {
          throw this.astErrorOutput(
            'Invalid while statement',
            doWhileNode
          );
        }

        retArr.push('for (let i = 0; i < LOOP_MAX; i++) {');
        this.astGeneric(doWhileNode.body, retArr);
        retArr.push('if (!');
        this.astGeneric(doWhileNode.test, retArr);
        retArr.push(') {\n');
        retArr.push('break;\n');
        retArr.push('}\n');
        retArr.push('}\n');

        return retArr;

      }

      astAssignmentExpression(assNode, retArr) {
        const declaration = this.getDeclaration(assNode.left);
        if (declaration && !declaration.assignable) {
          throw this.astErrorOutput(`Variable ${assNode.left.name} is not assignable here`, assNode);
        }
        this.astGeneric(assNode.left, retArr);
        retArr.push(assNode.operator);
        this.astGeneric(assNode.right, retArr);
        return retArr;
      }

      astBlockStatement(bNode, retArr) {
        if (this.isState('loop-body')) {
          this.pushState('block-body'); 
          for (let i = 0; i < bNode.body.length; i++) {
            this.astGeneric(bNode.body[i], retArr);
          }
          this.popState('block-body');
        } else {
          retArr.push('{\n');
          for (let i = 0; i < bNode.body.length; i++) {
            this.astGeneric(bNode.body[i], retArr);
          }
          retArr.push('}\n');
        }
        return retArr;
      }

      astVariableDeclaration(varDecNode, retArr) {
        retArr.push(`${varDecNode.kind} `);
        const { declarations } = varDecNode;
        for (let i = 0; i < declarations.length; i++) {
          if (i > 0) {
            retArr.push(',');
          }
          const declaration = declarations[i];
          const info = this.getDeclaration(declaration.id);
          if (!info.valueType) {
            info.valueType = this.getType(declaration.init);
          }
          this.astGeneric(declaration, retArr);
        }
        if (!this.isState('in-for-loop-init')) {
          retArr.push(';');
        }
        return retArr;
      }

      astIfStatement(ifNode, retArr) {
        retArr.push('if (');
        this.astGeneric(ifNode.test, retArr);
        retArr.push(')');
        if (ifNode.consequent.type === 'BlockStatement') {
          this.astGeneric(ifNode.consequent, retArr);
        } else {
          retArr.push(' {\n');
          this.astGeneric(ifNode.consequent, retArr);
          retArr.push('\n}\n');
        }

        if (ifNode.alternate) {
          retArr.push('else ');
          if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {
            this.astGeneric(ifNode.alternate, retArr);
          } else {
            retArr.push(' {\n');
            this.astGeneric(ifNode.alternate, retArr);
            retArr.push('\n}\n');
          }
        }
        return retArr;

      }

      astSwitchStatement(ast, retArr) {
        const { discriminant, cases } = ast;
        retArr.push('switch (');
        this.astGeneric(discriminant, retArr);
        retArr.push(') {\n');
        for (let i = 0; i < cases.length; i++) {
          if (cases[i].test === null) {
            retArr.push('default:\n');
            this.astGeneric(cases[i].consequent, retArr);
            if (cases[i].consequent && cases[i].consequent.length > 0) {
              retArr.push('break;\n');
            }
            continue;
          }
          retArr.push('case ');
          this.astGeneric(cases[i].test, retArr);
          retArr.push(':\n');
          if (cases[i].consequent && cases[i].consequent.length > 0) {
            this.astGeneric(cases[i].consequent, retArr);
            retArr.push('break;\n');
          }
        }
        retArr.push('\n}');
      }

      astThisExpression(tNode, retArr) {
        retArr.push('_this');
        return retArr;
      }

      astMemberExpression(mNode, retArr) {
        const {
          signature,
          type,
          property,
          xProperty,
          yProperty,
          zProperty,
          name,
          origin
        } = this.getMemberExpressionDetails(mNode);
        switch (signature) {
          case 'this.thread.value':
            retArr.push(`_this.thread.${ name }`);
            return retArr;
          case 'this.output.value':
            switch (name) {
              case 'x':
                retArr.push('outputX');
                break;
              case 'y':
                retArr.push('outputY');
                break;
              case 'z':
                retArr.push('outputZ');
                break;
              default:
                throw this.astErrorOutput('Unexpected expression', mNode);
            }
            return retArr;
          case 'value':
            throw this.astErrorOutput('Unexpected expression', mNode);
          case 'value[]':
          case 'value[][]':
          case 'value[][][]':
          case 'value.value':
            if (origin === 'Math') {
              retArr.push(Math[name]);
              return retArr;
            }
            switch (property) {
              case 'r':
                retArr.push(`user_${ name }[0]`);
                return retArr;
              case 'g':
                retArr.push(`user_${ name }[1]`);
                return retArr;
              case 'b':
                retArr.push(`user_${ name }[2]`);
                return retArr;
              case 'a':
                retArr.push(`user_${ name }[3]`);
                return retArr;
            }
            break;
          case 'this.constants.value':
          case 'this.constants.value[]':
          case 'this.constants.value[][]':
          case 'this.constants.value[][][]':
            break;
          case 'fn()[]':
            this.astGeneric(mNode.object, retArr);
            retArr.push('[');
            this.astGeneric(mNode.property, retArr);
            retArr.push(']');
            return retArr;
          case 'fn()[][]':
            this.astGeneric(mNode.object.object, retArr);
            retArr.push('[');
            this.astGeneric(mNode.object.property, retArr);
            retArr.push(']');
            retArr.push('[');
            this.astGeneric(mNode.property, retArr);
            retArr.push(']');
            return retArr;
          default:
            throw this.astErrorOutput('Unexpected expression', mNode);
        }

        if (!mNode.computed) {
          switch (type) {
            case 'Number':
            case 'Integer':
            case 'Float':
            case 'Boolean':
              retArr.push(`${origin}_${name}`);
              return retArr;
          }
        }

        const markupName = `${origin}_${name}`;

        switch (type) {
          case 'Array(2)':
          case 'Array(3)':
          case 'Array(4)':
          case 'Matrix(2)':
          case 'Matrix(3)':
          case 'Matrix(4)':
          case 'HTMLImageArray':
          case 'ArrayTexture(1)':
          case 'ArrayTexture(2)':
          case 'ArrayTexture(3)':
          case 'ArrayTexture(4)':
          case 'HTMLImage':
          default:
            let size;
            let isInput;
            if (origin === 'constants') {
              const constant = this.constants[name];
              isInput = this.constantTypes[name] === 'Input';
              size = isInput ? constant.size : null;
            } else {
              isInput = this.isInput(name);
              size = isInput ? this.argumentSizes[this.argumentNames.indexOf(name)] : null;
            }
            retArr.push(`${ markupName }`);
            if (zProperty && yProperty) {
              if (isInput) {
                retArr.push('[(');
                this.astGeneric(zProperty, retArr);
                retArr.push(`*${ this.dynamicArguments ? '(outputY * outputX)' : size[1] * size[0] })+(`);
                this.astGeneric(yProperty, retArr);
                retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);
                this.astGeneric(xProperty, retArr);
                retArr.push(']');
              } else {
                retArr.push('[');
                this.astGeneric(zProperty, retArr);
                retArr.push(']');
                retArr.push('[');
                this.astGeneric(yProperty, retArr);
                retArr.push(']');
                retArr.push('[');
                this.astGeneric(xProperty, retArr);
                retArr.push(']');
              }
            } else if (yProperty) {
              if (isInput) {
                retArr.push('[(');
                this.astGeneric(yProperty, retArr);
                retArr.push(`*${ this.dynamicArguments ? 'outputX' : size[0] })+`);
                this.astGeneric(xProperty, retArr);
                retArr.push(']');
              } else {
                retArr.push('[');
                this.astGeneric(yProperty, retArr);
                retArr.push(']');
                retArr.push('[');
                this.astGeneric(xProperty, retArr);
                retArr.push(']');
              }
            } else if (typeof xProperty !== 'undefined') {
              retArr.push('[');
              this.astGeneric(xProperty, retArr);
              retArr.push(']');
            }
        }
        return retArr;
      }

      astCallExpression(ast, retArr) {
        if (ast.type !== 'CallExpression') {
          throw this.astErrorOutput('Unknown CallExpression', ast);
        }
        let functionName = this.astMemberExpressionUnroll(ast.callee);

        if (this.calledFunctions.indexOf(functionName) < 0) {
          this.calledFunctions.push(functionName);
        }

        this.isAstMathFunction(ast);

        if (this.onFunctionCall) {
          this.onFunctionCall(this.name, functionName, ast.arguments);
        }

        retArr.push(functionName);

        retArr.push('(');
        const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];
        for (let i = 0; i < ast.arguments.length; ++i) {
          const argument = ast.arguments[i];

          let argumentType = this.getType(argument);
          if (!targetTypes[i]) {
            this.triggerImplyArgumentType(functionName, i, argumentType, this);
          }

          if (i > 0) {
            retArr.push(', ');
          }
          this.astGeneric(argument, retArr);
        }
        retArr.push(')');

        return retArr;
      }

      astArrayExpression(arrNode, retArr) {
        const returnType = this.getType(arrNode);
        const arrLen = arrNode.elements.length;
        const elements = [];
        for (let i = 0; i < arrLen; ++i) {
          const element = [];
          this.astGeneric(arrNode.elements[i], element);
          elements.push(element.join(''));
        }
        switch (returnType) {
          case 'Matrix(2)':
          case 'Matrix(3)':
          case 'Matrix(4)':
            retArr.push(`[${elements.join(', ')}]`);
            break;
          default:
            retArr.push(`new Float32Array([${elements.join(', ')}])`);
        }
        return retArr;
      }

      astDebuggerStatement(arrNode, retArr) {
        retArr.push('debugger;');
        return retArr;
      }
    }

    module.exports = {
      CPUFunctionNode
    };
    },{"../function-node":10}],7:[function(require,module,exports){
    const { utils } = require('../../utils');

    function constantsToString(constants, types) {
      const results = [];
      for (const name in types) {
        if (!types.hasOwnProperty(name)) continue;
        const type = types[name];
        const constant = constants[name];
        switch (type) {
          case 'Number':
          case 'Integer':
          case 'Float':
          case 'Boolean':
            results.push(`${name}:${constant}`);
            break;
          case 'Array(2)':
          case 'Array(3)':
          case 'Array(4)':
          case 'Matrix(2)':
          case 'Matrix(3)':
          case 'Matrix(4)':
            results.push(`${name}:new ${constant.constructor.name}(${JSON.stringify(Array.from(constant))})`);
            break;
        }
      }
      return `{ ${ results.join() } }`;
    }

    function cpuKernelString(cpuKernel, name) {
      const header = [];
      const thisProperties = [];
      const beforeReturn = [];

      const useFunctionKeyword = !/^function/.test(cpuKernel.color.toString());

      header.push(
        '  const { context, canvas, constants: incomingConstants } = settings;',
        `  const output = new Int32Array(${JSON.stringify(Array.from(cpuKernel.output))});`,
        `  const _constantTypes = ${JSON.stringify(cpuKernel.constantTypes)};`,
        `  const _constants = ${constantsToString(cpuKernel.constants, cpuKernel.constantTypes)};`
      );

      thisProperties.push(
        '    constants: _constants,',
        '    context,',
        '    output,',
        '    thread: {x: 0, y: 0, z: 0},'
      );

      if (cpuKernel.graphical) {
        header.push(`  const _imageData = context.createImageData(${cpuKernel.output[0]}, ${cpuKernel.output[1]});`);
        header.push(`  const _colorData = new Uint8ClampedArray(${cpuKernel.output[0]} * ${cpuKernel.output[1]} * 4);`);

        const colorFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.color.toString(), {
          thisLookup: (propertyName) => {
            switch (propertyName) {
              case '_colorData':
                return '_colorData';
              case '_imageData':
                return '_imageData';
              case 'output':
                return 'output';
              case 'thread':
                return 'this.thread';
            }
            return JSON.stringify(cpuKernel[propertyName]);
          },
          findDependency: (object, name) => {
            return null;
          }
        });

        const getPixelsFn = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel.getPixels.toString(), {
          thisLookup: (propertyName) => {
            switch (propertyName) {
              case '_colorData':
                return '_colorData';
              case '_imageData':
                return '_imageData';
              case 'output':
                return 'output';
              case 'thread':
                return 'this.thread';
            }
            return JSON.stringify(cpuKernel[propertyName]);
          },
          findDependency: () => {
            return null;
          }
        });

        thisProperties.push(
          '    _imageData,',
          '    _colorData,',
          `    color: ${colorFn},`
        );

        beforeReturn.push(
          `  kernel.getPixels = ${getPixelsFn};`
        );
      }

      const constantTypes = [];
      const constantKeys = Object.keys(cpuKernel.constantTypes);
      for (let i = 0; i < constantKeys.length; i++) {
        constantTypes.push(cpuKernel.constantTypes[constantKeys]);
      }
      if (cpuKernel.argumentTypes.indexOf('HTMLImageArray') !== -1 || constantTypes.indexOf('HTMLImageArray') !== -1) {
        const flattenedImageTo3DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._imageTo3DArray.toString(), {
          doNotDefine: ['canvas'],
          findDependency: (object, name) => {
            if (object === 'this') {
              return (useFunctionKeyword ? 'function ' : '') + cpuKernel[name].toString();
            }
            return null;
          },
          thisLookup: (propertyName) => {
            switch (propertyName) {
              case 'canvas':
                return;
              case 'context':
                return 'context';
            }
          }
        });
        beforeReturn.push(flattenedImageTo3DArray);
        thisProperties.push(`    _mediaTo2DArray,`);
        thisProperties.push(`    _imageTo3DArray,`);
      } else if (cpuKernel.argumentTypes.indexOf('HTMLImage') !== -1 || constantTypes.indexOf('HTMLImage') !== -1) {
        const flattenedImageTo2DArray = utils.flattenFunctionToString((useFunctionKeyword ? 'function ' : '') + cpuKernel._mediaTo2DArray.toString(), {
          findDependency: (object, name) => {
            return null;
          },
          thisLookup: (propertyName) => {
            switch (propertyName) {
              case 'canvas':
                return 'settings.canvas';
              case 'context':
                return 'settings.context';
            }
            throw new Error('unhandled thisLookup');
          }
        });
        beforeReturn.push(flattenedImageTo2DArray);
        thisProperties.push(`    _mediaTo2DArray,`);
      }

      return `function(settings) {
${ header.join('\n') }
  for (const p in _constantTypes) {
    if (!_constantTypes.hasOwnProperty(p)) continue;
    const type = _constantTypes[p];
    switch (type) {
      case 'Number':
      case 'Integer':
      case 'Float':
      case 'Boolean':
      case 'Array(2)':
      case 'Array(3)':
      case 'Array(4)':
      case 'Matrix(2)':
      case 'Matrix(3)':
      case 'Matrix(4)':
        if (incomingConstants.hasOwnProperty(p)) {
          console.warn('constant ' + p + ' of type ' + type + ' cannot be resigned');
        }
        continue;
    }
    if (!incomingConstants.hasOwnProperty(p)) {
      throw new Error('constant ' + p + ' not found');
    }
    _constants[p] = incomingConstants[p];
  }
  const kernel = (function() {
${cpuKernel._kernelString}
  })
    .apply({ ${thisProperties.join('\n')} });
  ${ beforeReturn.join('\n') }
  return kernel;
}`;
    }

    module.exports = {
      cpuKernelString
    };
    },{"../../utils":114}],8:[function(require,module,exports){
    const { Kernel } = require('../kernel');
    const { FunctionBuilder } = require('../function-builder');
    const { CPUFunctionNode } = require('./function-node');
    const { utils } = require('../../utils');
    const { cpuKernelString } = require('./kernel-string');

    class CPUKernel extends Kernel {
      static getFeatures() {
        return this.features;
      }
      static get features() {
        return Object.freeze({
          kernelMap: true,
          isIntegerDivisionAccurate: true
        });
      }
      static get isSupported() {
        return true;
      }
      static isContextMatch(context) {
        return false;
      }
      static get mode() {
        return 'cpu';
      }

      static nativeFunctionArguments() {
        return null;
      }

      static nativeFunctionReturnType() {
        throw new Error(`Looking up native function return type not supported on ${this.name}`);
      }

      static combineKernels(combinedKernel) {
        return combinedKernel;
      }

      static getSignature(kernel, argumentTypes) {
        return 'cpu' + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');
      }

      constructor(source, settings) {
        super(source, settings);
        this.mergeSettings(source.settings || settings);

        this._imageData = null;
        this._colorData = null;
        this._kernelString = null;
        this._prependedString = [];
        this.thread = {
          x: 0,
          y: 0,
          z: 0
        };
        this.translatedSources = null;
      }

      initCanvas() {
        if (typeof document !== 'undefined') {
          return document.createElement('canvas');
        } else if (typeof OffscreenCanvas !== 'undefined') {
          return new OffscreenCanvas(0, 0);
        }
      }

      initContext() {
        if (!this.canvas) return null;
        return this.canvas.getContext('2d');
      }

      initPlugins(settings) {
        return [];
      }

      validateSettings(args) {
        if (!this.output || this.output.length === 0) {
          if (args.length !== 1) {
            throw new Error('Auto output only supported for kernels with only one input');
          }

          const argType = utils.getVariableType(args[0], this.strictIntegers);
          if (argType === 'Array') {
            this.output = utils.getDimensions(argType);
          } else if (argType === 'NumberTexture' || argType === 'ArrayTexture(4)') {
            this.output = args[0].output;
          } else {
            throw new Error('Auto output not supported for input type: ' + argType);
          }
        }

        if (this.graphical) {
          if (this.output.length !== 2) {
            throw new Error('Output must have 2 dimensions on graphical mode');
          }
        }

        this.checkOutput();
      }

      translateSource() {
        this.leadingReturnStatement = this.output.length > 1 ? 'resultX[x] = ' : 'result[x] = ';
        if (this.subKernels) {
          const followingReturnStatement = [];
          for (let i = 0; i < this.subKernels.length; i++) {
            const {
              name
            } = this.subKernels[i];
            followingReturnStatement.push(this.output.length > 1 ? `resultX_${ name }[x] = subKernelResult_${ name };\n` : `result_${ name }[x] = subKernelResult_${ name };\n`);
          }
          this.followingReturnStatement = followingReturnStatement.join('');
        }
        const functionBuilder = FunctionBuilder.fromKernel(this, CPUFunctionNode);
        this.translatedSources = functionBuilder.getPrototypes('kernel');
        if (!this.graphical && !this.returnType) {
          this.returnType = functionBuilder.getKernelResultType();
        }
      }

      build() {
        if (this.built) return;
        this.setupConstants();
        this.setupArguments(arguments);
        this.validateSettings(arguments);
        this.translateSource();

        if (this.graphical) {
          const {
            canvas,
            output
          } = this;
          if (!canvas) {
            throw new Error('no canvas available for using graphical output');
          }
          const width = output[0];
          const height = output[1] || 1;
          canvas.width = width;
          canvas.height = height;
          this._imageData = this.context.createImageData(width, height);
          this._colorData = new Uint8ClampedArray(width * height * 4);
        }

        const kernelString = this.getKernelString();
        this.kernelString = kernelString;

        if (this.debug) {
          console.log('Function output:');
          console.log(kernelString);
        }

        try {
          this.run = new Function([], kernelString).bind(this)();
        } catch (e) {
          console.error('An error occurred compiling the javascript: ', e);
        }
        this.buildSignature(arguments);
        this.built = true;
      }

      color(r, g, b, a) {
        if (typeof a === 'undefined') {
          a = 1;
        }

        r = Math.floor(r * 255);
        g = Math.floor(g * 255);
        b = Math.floor(b * 255);
        a = Math.floor(a * 255);

        const width = this.output[0];
        const height = this.output[1];

        const x = this.thread.x;
        const y = height - this.thread.y - 1;

        const index = x + y * width;

        this._colorData[index * 4 + 0] = r;
        this._colorData[index * 4 + 1] = g;
        this._colorData[index * 4 + 2] = b;
        this._colorData[index * 4 + 3] = a;
      }

      getKernelString() {
        if (this._kernelString !== null) return this._kernelString;

        let kernelThreadString = null;
        let {
          translatedSources
        } = this;
        if (translatedSources.length > 1) {
          translatedSources = translatedSources.filter(fn => {
            if (/^function/.test(fn)) return fn;
            kernelThreadString = fn;
            return false;
          });
        } else {
          kernelThreadString = translatedSources.shift();
        }
        return this._kernelString = `  const LOOP_MAX = ${ this._getLoopMaxString() };
  ${ this.injectedNative || '' }
  const _this = this;
  ${ this._resultKernelHeader() }
  ${ this._processConstants() }
  return (${ this.argumentNames.map(argumentName => 'user_' + argumentName).join(', ') }) => {
    ${ this._prependedString.join('') }
    ${ this._earlyThrows() }
    ${ this._processArguments() }
    ${ this.graphical ? this._graphicalKernelBody(kernelThreadString) : this._resultKernelBody(kernelThreadString) }
    ${ translatedSources.length > 0 ? translatedSources.join('\n') : '' }
  };`;
      }

      toString() {
        return cpuKernelString(this);
      }

      _getLoopMaxString() {
        return (
          this.loopMaxIterations ?
          ` ${ parseInt(this.loopMaxIterations) };` :
          ' 1000;'
        );
      }

      _processConstants() {
        if (!this.constants) return '';

        const result = [];
        for (let p in this.constants) {
          const type = this.constantTypes[p];
          switch (type) {
            case 'HTMLCanvas':
            case 'OffscreenCanvas':
            case 'HTMLImage':
            case 'ImageBitmap':
            case 'ImageData':
            case 'HTMLVideo':
              result.push(`    const constants_${p} = this._mediaTo2DArray(this.constants.${p});\n`);
              break;
            case 'HTMLImageArray':
              result.push(`    const constants_${p} = this._imageTo3DArray(this.constants.${p});\n`);
              break;
            case 'Input':
              result.push(`    const constants_${p} = this.constants.${p}.value;\n`);
              break;
            default:
              result.push(`    const constants_${p} = this.constants.${p};\n`);
          }
        }
        return result.join('');
      }

      _earlyThrows() {
        if (this.graphical) return '';
        if (this.immutable) return '';
        if (!this.pipeline) return '';
        const arrayArguments = [];
        for (let i = 0; i < this.argumentTypes.length; i++) {
          if (this.argumentTypes[i] === 'Array') {
            arrayArguments.push(this.argumentNames[i]);
          }
        }
        if (arrayArguments.length === 0) return '';
        const checks = [];
        for (let i = 0; i < arrayArguments.length; i++) {
          const argumentName = arrayArguments[i];
          const checkSubKernels = this._mapSubKernels(subKernel => `user_${argumentName} === result_${subKernel.name}`).join(' || ');
          checks.push(`user_${argumentName} === result${checkSubKernels ? ` || ${checkSubKernels}` : ''}`);
        }
        return `if (${checks.join(' || ')}) throw new Error('Source and destination arrays are the same.  Use immutable = true');`;
      }

      _processArguments() {
        const result = [];
        for (let i = 0; i < this.argumentTypes.length; i++) {
          const variableName = `user_${this.argumentNames[i]}`;
          switch (this.argumentTypes[i]) {
            case 'HTMLCanvas':
            case 'OffscreenCanvas':
            case 'HTMLImage':
            case 'ImageBitmap':
            case 'ImageData':
            case 'HTMLVideo':
              result.push(`    ${variableName} = this._mediaTo2DArray(${variableName});\n`);
              break;
            case 'HTMLImageArray':
              result.push(`    ${variableName} = this._imageTo3DArray(${variableName});\n`);
              break;
            case 'Input':
              result.push(`    ${variableName} = ${variableName}.value;\n`);
              break;
            case 'ArrayTexture(1)':
            case 'ArrayTexture(2)':
            case 'ArrayTexture(3)':
            case 'ArrayTexture(4)':
            case 'NumberTexture':
            case 'MemoryOptimizedNumberTexture':
              result.push(`
    if (${variableName}.toArray) {
      if (!_this.textureCache) {
        _this.textureCache = [];
        _this.arrayCache = [];
      }
      const textureIndex = _this.textureCache.indexOf(${variableName});
      if (textureIndex !== -1) {
        ${variableName} = _this.arrayCache[textureIndex];
      } else {
        _this.textureCache.push(${variableName});
        ${variableName} = ${variableName}.toArray();
        _this.arrayCache.push(${variableName});
      }
    }`);
              break;
          }
        }
        return result.join('');
      }

      _mediaTo2DArray(media) {
        const canvas = this.canvas;
        const width = media.width > 0 ? media.width : media.videoWidth;
        const height = media.height > 0 ? media.height : media.videoHeight;
        if (canvas.width < width) {
          canvas.width = width;
        }
        if (canvas.height < height) {
          canvas.height = height;
        }
        const ctx = this.context;
        let pixelsData;
        if (media.constructor === ImageData) {
          pixelsData = media.data;
        } else {
          ctx.drawImage(media, 0, 0, width, height);
          pixelsData = ctx.getImageData(0, 0, width, height).data;
        }
        const imageArray = new Array(height);
        let index = 0;
        for (let y = height - 1; y >= 0; y--) {
          const row = imageArray[y] = new Array(width);
          for (let x = 0; x < width; x++) {
            const pixel = new Float32Array(4);
            pixel[0] = pixelsData[index++] / 255; 
            pixel[1] = pixelsData[index++] / 255; 
            pixel[2] = pixelsData[index++] / 255; 
            pixel[3] = pixelsData[index++] / 255; 
            row[x] = pixel;
          }
        }
        return imageArray;
      }

      getPixels(flip) {
        const [width, height] = this.output;
        return flip ? utils.flipPixels(this._imageData.data, width, height) : this._imageData.data.slice(0);
      }

      _imageTo3DArray(images) {
        const imagesArray = new Array(images.length);
        for (let i = 0; i < images.length; i++) {
          imagesArray[i] = this._mediaTo2DArray(images[i]);
        }
        return imagesArray;
      }

      _resultKernelHeader() {
        if (this.graphical) return '';
        if (this.immutable) return '';
        if (!this.pipeline) return '';
        switch (this.output.length) {
          case 1:
            return this._mutableKernel1DResults();
          case 2:
            return this._mutableKernel2DResults();
          case 3:
            return this._mutableKernel3DResults();
        }
      }

      _resultKernelBody(kernelString) {
        switch (this.output.length) {
          case 1:
            return (!this.immutable && this.pipeline ? this._resultMutableKernel1DLoop(kernelString) : this._resultImmutableKernel1DLoop(kernelString)) + this._kernelOutput();
          case 2:
            return (!this.immutable && this.pipeline ? this._resultMutableKernel2DLoop(kernelString) : this._resultImmutableKernel2DLoop(kernelString)) + this._kernelOutput();
          case 3:
            return (!this.immutable && this.pipeline ? this._resultMutableKernel3DLoop(kernelString) : this._resultImmutableKernel3DLoop(kernelString)) + this._kernelOutput();
          default:
            throw new Error('unsupported size kernel');
        }
      }

      _graphicalKernelBody(kernelThreadString) {
        switch (this.output.length) {
          case 2:
            return this._graphicalKernel2DLoop(kernelThreadString) + this._graphicalOutput();
          default:
            throw new Error('unsupported size kernel');
        }
      }

      _graphicalOutput() {
        return `
    this._imageData.data.set(this._colorData);
    this.context.putImageData(this._imageData, 0, 0);
    return;`
      }

      _getKernelResultTypeConstructorString() {
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Number':
          case 'Integer':
          case 'Float':
            return 'Float32Array';
          case 'Array(2)':
          case 'Array(3)':
          case 'Array(4)':
            return 'Array';
          default:
            if (this.graphical) {
              return 'Float32Array';
            }
            throw new Error(`unhandled returnType ${ this.returnType }`);
        }
      }

      _resultImmutableKernel1DLoop(kernelString) {
        const constructorString = this._getKernelResultTypeConstructorString();
        return `  const outputX = _this.output[0];
    const result = new ${constructorString}(outputX);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${ kernelString }
    }`;
      }

      _mutableKernel1DResults() {
        const constructorString = this._getKernelResultTypeConstructorString();
        return `  const outputX = _this.output[0];
    const result = new ${constructorString}(outputX);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new ${constructorString}(outputX);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }`;
      }

      _resultMutableKernel1DLoop(kernelString) {
        return `  const outputX = _this.output[0];
    for (let x = 0; x < outputX; x++) {
      this.thread.x = x;
      this.thread.y = 0;
      this.thread.z = 0;
      ${ kernelString }
    }`;
      }

      _resultImmutableKernel2DLoop(kernelString) {
        const constructorString = this._getKernelResultTypeConstructorString();
        return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y] = new ${constructorString}(outputX);
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
      }

      _mutableKernel2DResults() {
        const constructorString = this._getKernelResultTypeConstructorString();
        return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const result = new Array(outputY);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputY);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let y = 0; y < outputY; y++) {
      const resultX = result[y] = new ${constructorString}(outputX);
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
    }`;
      }

      _resultMutableKernel2DLoop(kernelString) {
        const constructorString = this._getKernelResultTypeConstructorString();
        return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      const resultX = result[y];
      ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = result_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('') }
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
      }

      _graphicalKernel2DLoop(kernelString) {
        return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    for (let y = 0; y < outputY; y++) {
      this.thread.z = 0;
      this.thread.y = y;
      for (let x = 0; x < outputX; x++) {
        this.thread.x = x;
        ${ kernelString }
      }
    }`;
      }

      _resultImmutableKernel3DLoop(kernelString) {
        const constructorString = this._getKernelResultTypeConstructorString();
        return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z] = new Array(outputY);
      ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\n`).join('      ') }
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y] = new ${constructorString}(outputX);
        ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('        ') }
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${ kernelString }
        }
      }
    }`;
      }

      _mutableKernel3DResults() {
        const constructorString = this._getKernelResultTypeConstructorString();
        return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    const result = new Array(outputZ);
    ${ this._mapSubKernels(subKernel => `const result_${ subKernel.name } = new Array(outputZ);\n`).join('    ') }
    ${ this._mapSubKernels(subKernel => `let subKernelResult_${ subKernel.name };\n`).join('    ') }
    for (let z = 0; z < outputZ; z++) {
      const resultY = result[z] = new Array(outputY);
      ${ this._mapSubKernels(subKernel => `const resultY_${ subKernel.name } = result_${subKernel.name}[z] = new Array(outputY);\n`).join('      ') }
      for (let y = 0; y < outputY; y++) {
        const resultX = resultY[y] = new ${constructorString}(outputX);
        ${ this._mapSubKernels(subKernel => `const resultX_${ subKernel.name } = resultY_${subKernel.name}[y] = new ${constructorString}(outputX);\n`).join('        ') }
      }
    }`;
      }

      _resultMutableKernel3DLoop(kernelString) {
        return `  const outputX = _this.output[0];
    const outputY = _this.output[1];
    const outputZ = _this.output[2];
    for (let z = 0; z < outputZ; z++) {
      this.thread.z = z;
      const resultY = result[z];
      for (let y = 0; y < outputY; y++) {
        this.thread.y = y;
        const resultX = resultY[y];
        for (let x = 0; x < outputX; x++) {
          this.thread.x = x;
          ${ kernelString }
        }
      }
    }`;
      }

      _kernelOutput() {
        if (!this.subKernels) {
          return '\n    return result;';
        }
        return `\n    return {
      result: result,
      ${ this.subKernels.map(subKernel => `${ subKernel.property }: result_${ subKernel.name }`).join(',\n      ') }
    };`;
      }

      _mapSubKernels(fn) {
        return this.subKernels === null ? [''] :
          this.subKernels.map(fn);
      }

      destroy(removeCanvasReference) {
        if (removeCanvasReference) {
          delete this.canvas;
        }
      }

      static destroyContext(context) {}

      toJSON() {
        const json = super.toJSON();
        json.functionNodes = FunctionBuilder.fromKernel(this, CPUFunctionNode).toJSON();
        return json;
      }

      setOutput(output) {
        super.setOutput(output);
        const [width, height] = this.output;
        if (this.graphical) {
          this._imageData = this.context.createImageData(width, height);
          this._colorData = new Uint8ClampedArray(width * height * 4);
        }
      }

      prependString(value) {
        if (this._kernelString) throw new Error('Kernel already built');
        this._prependedString.push(value);
      }

      hasPrependString(value) {
        return this._prependedString.indexOf(value) > -1;
      }
    }

    module.exports = {
      CPUKernel
    };
    },{"../../utils":114,"../function-builder":9,"../kernel":36,"./function-node":6,"./kernel-string":7}],9:[function(require,module,exports){
    class FunctionBuilder {
      static fromKernel(kernel, FunctionNode, extraNodeOptions) {
        const {
          kernelArguments,
          kernelConstants,
          argumentNames,
          argumentSizes,
          argumentBitRatios,
          constants,
          constantBitRatios,
          debug,
          loopMaxIterations,
          nativeFunctions,
          output,
          optimizeFloatMemory,
          precision,
          plugins,
          source,
          subKernels,
          functions,
          leadingReturnStatement,
          followingReturnStatement,
          dynamicArguments,
          dynamicOutput,
        } = kernel;

        const argumentTypes = new Array(kernelArguments.length);
        const constantTypes = {};

        for (let i = 0; i < kernelArguments.length; i++) {
          argumentTypes[i] = kernelArguments[i].type;
        }

        for (let i = 0; i < kernelConstants.length; i++) {
          const kernelConstant = kernelConstants[i];
          constantTypes[kernelConstant.name] = kernelConstant.type;
        }

        const needsArgumentType = (functionName, index) => {
          return functionBuilder.needsArgumentType(functionName, index);
        };

        const assignArgumentType = (functionName, index, type) => {
          functionBuilder.assignArgumentType(functionName, index, type);
        };

        const lookupReturnType = (functionName, ast, requestingNode) => {
          return functionBuilder.lookupReturnType(functionName, ast, requestingNode);
        };

        const lookupFunctionArgumentTypes = (functionName) => {
          return functionBuilder.lookupFunctionArgumentTypes(functionName);
        };

        const lookupFunctionArgumentName = (functionName, argumentIndex) => {
          return functionBuilder.lookupFunctionArgumentName(functionName, argumentIndex);
        };

        const lookupFunctionArgumentBitRatio = (functionName, argumentName) => {
          return functionBuilder.lookupFunctionArgumentBitRatio(functionName, argumentName);
        };

        const triggerImplyArgumentType = (functionName, i, argumentType, requestingNode) => {
          functionBuilder.assignArgumentType(functionName, i, argumentType, requestingNode);
        };

        const triggerImplyArgumentBitRatio = (functionName, argumentName, calleeFunctionName, argumentIndex) => {
          functionBuilder.assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex);
        };

        const onFunctionCall = (functionName, calleeFunctionName, args) => {
          functionBuilder.trackFunctionCall(functionName, calleeFunctionName, args);
        };

        const onNestedFunction = (ast, source) => {
          const argumentNames = [];
          for (let i = 0; i < ast.params.length; i++) {
            argumentNames.push(ast.params[i].name);
          }
          const nestedFunction = new FunctionNode(source, Object.assign({}, nodeOptions, {
            returnType: null,
            ast,
            name: ast.id.name,
            argumentNames,
            lookupReturnType,
            lookupFunctionArgumentTypes,
            lookupFunctionArgumentName,
            lookupFunctionArgumentBitRatio,
            needsArgumentType,
            assignArgumentType,
            triggerImplyArgumentType,
            triggerImplyArgumentBitRatio,
            onFunctionCall,
          }));
          nestedFunction.traceFunctionAST(ast);
          functionBuilder.addFunctionNode(nestedFunction);
        };

        const nodeOptions = Object.assign({
          isRootKernel: false,
          onNestedFunction,
          lookupReturnType,
          lookupFunctionArgumentTypes,
          lookupFunctionArgumentName,
          lookupFunctionArgumentBitRatio,
          needsArgumentType,
          assignArgumentType,
          triggerImplyArgumentType,
          triggerImplyArgumentBitRatio,
          onFunctionCall,
          optimizeFloatMemory,
          precision,
          constants,
          constantTypes,
          constantBitRatios,
          debug,
          loopMaxIterations,
          output,
          plugins,
          dynamicArguments,
          dynamicOutput,
        }, extraNodeOptions || {});

        const rootNodeOptions = Object.assign({}, nodeOptions, {
          isRootKernel: true,
          name: 'kernel',
          argumentNames,
          argumentTypes,
          argumentSizes,
          argumentBitRatios,
          leadingReturnStatement,
          followingReturnStatement,
        });

        if (typeof source === 'object' && source.functionNodes) {
          return new FunctionBuilder().fromJSON(source.functionNodes, FunctionNode);
        }

        const rootNode = new FunctionNode(source, rootNodeOptions);

        let functionNodes = null;
        if (functions) {
          functionNodes = functions.map((fn) => new FunctionNode(fn.source, {
            returnType: fn.returnType,
            argumentTypes: fn.argumentTypes,
            output,
            plugins,
            constants,
            constantTypes,
            constantBitRatios,
            optimizeFloatMemory,
            precision,
            lookupReturnType,
            lookupFunctionArgumentTypes,
            lookupFunctionArgumentName,
            lookupFunctionArgumentBitRatio,
            needsArgumentType,
            assignArgumentType,
            triggerImplyArgumentType,
            triggerImplyArgumentBitRatio,
            onFunctionCall,
            onNestedFunction,
          }));
        }

        let subKernelNodes = null;
        if (subKernels) {
          subKernelNodes = subKernels.map((subKernel) => {
            const { name, source } = subKernel;
            return new FunctionNode(source, Object.assign({}, nodeOptions, {
              name,
              isSubKernel: true,
              isRootKernel: false,
            }));
          });
        }

        const functionBuilder = new FunctionBuilder({
          kernel,
          rootNode,
          functionNodes,
          nativeFunctions,
          subKernelNodes
        });

        return functionBuilder;
      }

      constructor(settings) {
        settings = settings || {};
        this.kernel = settings.kernel;
        this.rootNode = settings.rootNode;
        this.functionNodes = settings.functionNodes || [];
        this.subKernelNodes = settings.subKernelNodes || [];
        this.nativeFunctions = settings.nativeFunctions || [];
        this.functionMap = {};
        this.nativeFunctionNames = [];
        this.lookupChain = [];
        this.functionNodeDependencies = {};
        this.functionCalls = {};

        if (this.rootNode) {
          this.functionMap['kernel'] = this.rootNode;
        }

        if (this.functionNodes) {
          for (let i = 0; i < this.functionNodes.length; i++) {
            this.functionMap[this.functionNodes[i].name] = this.functionNodes[i];
          }
        }

        if (this.subKernelNodes) {
          for (let i = 0; i < this.subKernelNodes.length; i++) {
            this.functionMap[this.subKernelNodes[i].name] = this.subKernelNodes[i];
          }
        }

        if (this.nativeFunctions) {
          for (let i = 0; i < this.nativeFunctions.length; i++) {
            const nativeFunction = this.nativeFunctions[i];
            this.nativeFunctionNames.push(nativeFunction.name);
          }
        }
      }

      addFunctionNode(functionNode) {
        if (!functionNode.name) throw new Error('functionNode.name needs set');
        this.functionMap[functionNode.name] = functionNode;
        if (functionNode.isRootKernel) {
          this.rootNode = functionNode;
        }
      }

      traceFunctionCalls(functionName, retList) {
        functionName = functionName || 'kernel';
        retList = retList || [];

        if (this.nativeFunctionNames.indexOf(functionName) > -1) {
          const nativeFunctionIndex = retList.indexOf(functionName);
          if (nativeFunctionIndex === -1) {
            retList.push(functionName);
          } else {
            const dependantNativeFunctionName = retList.splice(nativeFunctionIndex, 1)[0];
            retList.push(dependantNativeFunctionName);
          }
          return retList;
        }

        const functionNode = this.functionMap[functionName];
        if (functionNode) {
          const functionIndex = retList.indexOf(functionName);
          if (functionIndex === -1) {
            retList.push(functionName);
            functionNode.toString(); 
            for (let i = 0; i < functionNode.calledFunctions.length; ++i) {
              this.traceFunctionCalls(functionNode.calledFunctions[i], retList);
            }
          } else {
            const dependantFunctionName = retList.splice(functionIndex, 1)[0];
            retList.push(dependantFunctionName);
          }
        }

        return retList;
      }

      getPrototypeString(functionName) {
        return this.getPrototypes(functionName).join('\n');
      }

      getPrototypes(functionName) {
        if (this.rootNode) {
          this.rootNode.toString();
        }
        if (functionName) {
          return this.getPrototypesFromFunctionNames(this.traceFunctionCalls(functionName, []).reverse());
        }
        return this.getPrototypesFromFunctionNames(Object.keys(this.functionMap));
      }

      getStringFromFunctionNames(functionList) {
        const ret = [];
        for (let i = 0; i < functionList.length; ++i) {
          const node = this.functionMap[functionList[i]];
          if (node) {
            ret.push(this.functionMap[functionList[i]].toString());
          }
        }
        return ret.join('\n');
      }

      getPrototypesFromFunctionNames(functionList) {
        const ret = [];
        for (let i = 0; i < functionList.length; ++i) {
          const functionName = functionList[i];
          const functionIndex = this.nativeFunctionNames.indexOf(functionName);
          if (functionIndex > -1) {
            ret.push(this.nativeFunctions[functionIndex].source);
            continue;
          }
          const node = this.functionMap[functionName];
          if (node) {
            ret.push(node.toString());
          }
        }
        return ret;
      }

      toJSON() {
        return this.traceFunctionCalls(this.rootNode.name).reverse().map(name => {
          const nativeIndex = this.nativeFunctions.indexOf(name);
          if (nativeIndex > -1) {
            return {
              name,
              source: this.nativeFunctions[nativeIndex].source
            };
          } else if (this.functionMap[name]) {
            return this.functionMap[name].toJSON();
          } else {
            throw new Error(`function ${ name } not found`);
          }
        });
      }

      fromJSON(jsonFunctionNodes, FunctionNode) {
        this.functionMap = {};
        for (let i = 0; i < jsonFunctionNodes.length; i++) {
          const jsonFunctionNode = jsonFunctionNodes[i];
          this.functionMap[jsonFunctionNode.settings.name] = new FunctionNode(jsonFunctionNode.ast, jsonFunctionNode.settings);
        }
        return this;
      }

      getString(functionName) {
        if (functionName) {
          return this.getStringFromFunctionNames(this.traceFunctionCalls(functionName).reverse());
        }
        return this.getStringFromFunctionNames(Object.keys(this.functionMap));
      }

      lookupReturnType(functionName, ast, requestingNode) {
        if (ast.type !== 'CallExpression') {
          throw new Error(`expected ast type of "CallExpression", but is ${ ast.type }`);
        }
        if (this._isNativeFunction(functionName)) {
          return this._lookupNativeFunctionReturnType(functionName);
        } else if (this._isFunction(functionName)) {
          const node = this._getFunction(functionName);
          if (node.returnType) {
            return node.returnType;
          } else {
            for (let i = 0; i < this.lookupChain.length; i++) {
              if (this.lookupChain[i].ast === ast) {
                if (node.argumentTypes.length === 0 && ast.arguments.length > 0) {
                  const args = ast.arguments;
                  for (let j = 0; j < args.length; j++) {
                    this.lookupChain.push({
                      name: requestingNode.name,
                      ast: args[i],
                      requestingNode
                    });
                    node.argumentTypes[j] = requestingNode.getType(args[j]);
                    this.lookupChain.pop();
                  }
                  return node.returnType = node.getType(node.getJsAST());
                }

                throw new Error('circlical logic detected!');
              }
            }
            this.lookupChain.push({
              name: requestingNode.name,
              ast,
              requestingNode
            });
            const type = node.getType(node.getJsAST());
            this.lookupChain.pop();
            return node.returnType = type;
          }
        }

        return null;
      }

      _getFunction(functionName) {
        if (!this._isFunction(functionName)) ;
        return this.functionMap[functionName];
      }

      _isFunction(functionName) {
        return Boolean(this.functionMap[functionName]);
      }

      _getNativeFunction(functionName) {
        for (let i = 0; i < this.nativeFunctions.length; i++) {
          if (this.nativeFunctions[i].name === functionName) return this.nativeFunctions[i];
        }
        return null;
      }

      _isNativeFunction(functionName) {
        return Boolean(this._getNativeFunction(functionName));
      }

      _lookupNativeFunctionReturnType(functionName) {
        let nativeFunction = this._getNativeFunction(functionName);
        if (nativeFunction) {
          return nativeFunction.returnType;
        }
        throw new Error(`Native function ${ functionName } not found`);
      }

      lookupFunctionArgumentTypes(functionName) {
        if (this._isNativeFunction(functionName)) {
          return this._getNativeFunction(functionName).argumentTypes;
        } else if (this._isFunction(functionName)) {
          return this._getFunction(functionName).argumentTypes;
        }
        return null;
      }

      lookupFunctionArgumentName(functionName, argumentIndex) {
        return this._getFunction(functionName).argumentNames[argumentIndex];
      }

      lookupFunctionArgumentBitRatio(functionName, argumentName) {
        if (!this._isFunction(functionName)) {
          throw new Error('function not found');
        }
        if (this.rootNode.name === functionName) {
          const i = this.rootNode.argumentNames.indexOf(argumentName);
          if (i !== -1) {
            return this.rootNode.argumentBitRatios[i];
          }
        }
        const node = this._getFunction(functionName);
        const i = node.argumentNames.indexOf(argumentName);
        if (i === -1) {
          throw new Error('argument not found');
        }
        const bitRatio = node.argumentBitRatios[i];
        if (typeof bitRatio !== 'number') {
          throw new Error('argument bit ratio not found');
        }
        return bitRatio;
      }

      needsArgumentType(functionName, i) {
        if (!this._isFunction(functionName)) return false;
        const fnNode = this._getFunction(functionName);
        return !fnNode.argumentTypes[i];
      }

      assignArgumentType(functionName, i, argumentType, requestingNode) {
        if (!this._isFunction(functionName)) return;
        const fnNode = this._getFunction(functionName);
        if (!fnNode.argumentTypes[i]) {
          fnNode.argumentTypes[i] = argumentType;
        }
      }

      assignArgumentBitRatio(functionName, argumentName, calleeFunctionName, argumentIndex) {
        const node = this._getFunction(functionName);
        if (this._isNativeFunction(calleeFunctionName)) return null;
        const calleeNode = this._getFunction(calleeFunctionName);
        const i = node.argumentNames.indexOf(argumentName);
        if (i === -1) {
          throw new Error(`Argument ${argumentName} not found in arguments from function ${functionName}`);
        }
        const bitRatio = node.argumentBitRatios[i];
        if (typeof bitRatio !== 'number') {
          throw new Error(`Bit ratio for argument ${argumentName} not found in function ${functionName}`);
        }
        if (!calleeNode.argumentBitRatios) {
          calleeNode.argumentBitRatios = new Array(calleeNode.argumentNames.length);
        }
        const calleeBitRatio = calleeNode.argumentBitRatios[i];
        if (typeof calleeBitRatio === 'number') {
          if (calleeBitRatio !== bitRatio) {
            throw new Error(`Incompatible bit ratio found at function ${functionName} at argument ${argumentName}`);
          }
          return calleeBitRatio;
        }
        calleeNode.argumentBitRatios[i] = bitRatio;
        return bitRatio;
      }

      trackFunctionCall(functionName, calleeFunctionName, args) {
        if (!this.functionNodeDependencies[functionName]) {
          this.functionNodeDependencies[functionName] = new Set();
          this.functionCalls[functionName] = [];
        }
        this.functionNodeDependencies[functionName].add(calleeFunctionName);
        this.functionCalls[functionName].push(args);
      }

      getKernelResultType() {
        return this.rootNode.returnType || this.rootNode.getType(this.rootNode.ast);
      }

      getSubKernelResultType(index) {
        const subKernelNode = this.subKernelNodes[index];
        let called = false;
        for (let functionCallIndex = 0; functionCallIndex < this.rootNode.functionCalls.length; functionCallIndex++) {
          const functionCall = this.rootNode.functionCalls[functionCallIndex];
          if (functionCall.ast.callee.name === subKernelNode.name) {
            called = true;
          }
        }
        if (!called) {
          throw new Error(`SubKernel ${ subKernelNode.name } never called by kernel`);
        }
        return subKernelNode.returnType || subKernelNode.getType(subKernelNode.getJsAST());
      }

      getReturnTypes() {
        const result = {
          [this.rootNode.name]: this.rootNode.getType(this.rootNode.ast),
        };
        const list = this.traceFunctionCalls(this.rootNode.name);
        for (let i = 0; i < list.length; i++) {
          const functionName = list[i];
          const functionNode = this.functionMap[functionName];
          result[functionName] = functionNode.getType(functionNode.ast);
        }
        return result;
      }
    }

    module.exports = {
      FunctionBuilder
    };
    },{}],10:[function(require,module,exports){
    const acorn = require('acorn');
    const { utils } = require('../utils');
    const { FunctionTracer } = require('./function-tracer');

    class FunctionNode {
      constructor(source, settings) {
        if (!source && !settings.ast) {
          throw new Error('source parameter is missing');
        }
        settings = settings || {};
        this.source = source;
        this.ast = null;
        this.name = typeof source === 'string' ? settings.isRootKernel ?
          'kernel' :
          (settings.name || utils.getFunctionNameFromString(source)) : null;
        this.calledFunctions = [];
        this.constants = {};
        this.constantTypes = {};
        this.constantBitRatios = {};
        this.isRootKernel = false;
        this.isSubKernel = false;
        this.debug = null;
        this.functions = null;
        this.identifiers = null;
        this.contexts = null;
        this.functionCalls = null;
        this.states = [];
        this.needsArgumentType = null;
        this.assignArgumentType = null;
        this.lookupReturnType = null;
        this.lookupFunctionArgumentTypes = null;
        this.lookupFunctionArgumentBitRatio = null;
        this.triggerImplyArgumentType = null;
        this.triggerImplyArgumentBitRatio = null;
        this.onNestedFunction = null;
        this.onFunctionCall = null;
        this.optimizeFloatMemory = null;
        this.precision = null;
        this.loopMaxIterations = null;
        this.argumentNames = (typeof this.source === 'string' ? utils.getArgumentNamesFromString(this.source) : null);
        this.argumentTypes = [];
        this.argumentSizes = [];
        this.argumentBitRatios = null;
        this.returnType = null;
        this.output = [];
        this.plugins = null;
        this.leadingReturnStatement = null;
        this.followingReturnStatement = null;
        this.dynamicOutput = null;
        this.dynamicArguments = null;
        this.strictTypingChecking = false;
        this.fixIntegerDivisionAccuracy = null;

        if (settings) {
          for (const p in settings) {
            if (!settings.hasOwnProperty(p)) continue;
            if (!this.hasOwnProperty(p)) continue;
            this[p] = settings[p];
          }
        }

        this.literalTypes = {};

        this.validate();
        this._string = null;
        this._internalVariableNames = {};
      }

      validate() {
        if (typeof this.source !== 'string' && !this.ast) {
          throw new Error('this.source not a string');
        }

        if (!this.ast && !utils.isFunctionString(this.source)) {
          throw new Error('this.source not a function string');
        }

        if (!this.name) {
          throw new Error('this.name could not be set');
        }

        if (this.argumentTypes.length > 0 && this.argumentTypes.length !== this.argumentNames.length) {
          throw new Error(`argumentTypes count of ${ this.argumentTypes.length } exceeds ${ this.argumentNames.length }`);
        }

        if (this.output.length < 1) {
          throw new Error('this.output is not big enough');
        }
      }

      isIdentifierConstant(name) {
        if (!this.constants) return false;
        return this.constants.hasOwnProperty(name);
      }

      isInput(argumentName) {
        return this.argumentTypes[this.argumentNames.indexOf(argumentName)] === 'Input';
      }

      pushState(state) {
        this.states.push(state);
      }

      popState(state) {
        if (this.state !== state) {
          throw new Error(`Cannot popState ${ state } when in ${ this.state }`);
        }
        this.states.pop();
      }

      isState(state) {
        return this.state === state;
      }

      get state() {
        return this.states[this.states.length - 1];
      }

      astMemberExpressionUnroll(ast) {
        if (ast.type === 'Identifier') {
          return ast.name;
        } else if (ast.type === 'ThisExpression') {
          return 'this';
        }

        if (ast.type === 'MemberExpression') {
          if (ast.object && ast.property) {
            if (ast.object.hasOwnProperty('name') && ast.object.name !== 'Math') {
              return this.astMemberExpressionUnroll(ast.property);
            }

            return (
              this.astMemberExpressionUnroll(ast.object) +
              '.' +
              this.astMemberExpressionUnroll(ast.property)
            );
          }
        }

        if (ast.hasOwnProperty('expressions')) {
          const firstExpression = ast.expressions[0];
          if (firstExpression.type === 'Literal' && firstExpression.value === 0 && ast.expressions.length === 2) {
            return this.astMemberExpressionUnroll(ast.expressions[1]);
          }
        }

        throw this.astErrorOutput('Unknown astMemberExpressionUnroll', ast);
      }

      getJsAST(inParser) {
        if (this.ast) {
          return this.ast;
        }
        if (typeof this.source === 'object') {
          this.traceFunctionAST(this.source);
          return this.ast = this.source;
        }

        inParser = inParser || acorn;
        if (inParser === null) {
          throw new Error('Missing JS to AST parser');
        }

        const ast = Object.freeze(inParser.parse(`const parser_${ this.name } = ${ this.source };`, {
          locations: true
        }));
        const functionAST = ast.body[0].declarations[0].init;
        this.traceFunctionAST(functionAST);

        if (!ast) {
          throw new Error('Failed to parse JS code');
        }

        return this.ast = functionAST;
      }

      traceFunctionAST(ast) {
        const { contexts, declarations, functions, identifiers, functionCalls } = new FunctionTracer(ast);
        this.contexts = contexts;
        this.identifiers = identifiers;
        this.functionCalls = functionCalls;
        this.functions = functions;
        for (let i = 0; i < declarations.length; i++) {
          const declaration = declarations[i];
          const { ast, inForLoopInit, inForLoopTest } = declaration;
          const { init } = ast;
          const dependencies = this.getDependencies(init);
          let valueType = null;

          if (inForLoopInit && inForLoopTest) {
            valueType = 'Integer';
          } else {
            if (init) {
              const realType = this.getType(init);
              switch (realType) {
                case 'Integer':
                case 'Float':
                case 'Number':
                  if (init.type === 'MemberExpression') {
                    valueType = realType;
                  } else {
                    valueType = 'Number';
                  }
                  break;
                case 'LiteralInteger':
                  valueType = 'Number';
                  break;
                default:
                  valueType = realType;
              }
            }
          }
          declaration.valueType = valueType;
          declaration.dependencies = dependencies;
          declaration.isSafe = this.isSafeDependencies(dependencies);
        }

        for (let i = 0; i < functions.length; i++) {
          this.onNestedFunction(functions[i], this.source);
        }
      }

      getDeclaration(ast) {
        for (let i = 0; i < this.identifiers.length; i++) {
          const identifier = this.identifiers[i];
          if (ast === identifier.ast) {
            return identifier.declaration;
          }
        }
        return null;
      }

      getVariableType(ast) {
        if (ast.type !== 'Identifier') {
          throw new Error(`ast of ${ast.type} not "Identifier"`);
        }
        let type = null;
        const argumentIndex = this.argumentNames.indexOf(ast.name);
        if (argumentIndex === -1) {
          const declaration = this.getDeclaration(ast);
          if (declaration) {
            return declaration.valueType;
          }
        } else {
          const argumentType = this.argumentTypes[argumentIndex];
          if (argumentType) {
            type = argumentType;
          }
        }
        if (!type && this.strictTypingChecking) {
          throw new Error(`Declaration of ${name} not found`);
        }
        return type;
      }

      getLookupType(type) {
        if (!typeLookupMap.hasOwnProperty(type)) {
          throw new Error(`unknown typeLookupMap ${ type }`);
        }
        return typeLookupMap[type];
      }

      getConstantType(constantName) {
        if (this.constantTypes[constantName]) {
          const type = this.constantTypes[constantName];
          if (type === 'Float') {
            return 'Number';
          } else {
            return type;
          }
        }
        throw new Error(`Type for constant "${ constantName }" not declared`);
      }

      toString() {
        if (this._string) return this._string;
        return this._string = this.astGeneric(this.getJsAST(), []).join('').trim();
      }

      toJSON() {
        const settings = {
          source: this.source,
          name: this.name,
          constants: this.constants,
          constantTypes: this.constantTypes,
          isRootKernel: this.isRootKernel,
          isSubKernel: this.isSubKernel,
          debug: this.debug,
          output: this.output,
          loopMaxIterations: this.loopMaxIterations,
          argumentNames: this.argumentNames,
          argumentTypes: this.argumentTypes,
          argumentSizes: this.argumentSizes,
          returnType: this.returnType,
          leadingReturnStatement: this.leadingReturnStatement,
          followingReturnStatement: this.followingReturnStatement,
        };

        return {
          ast: this.ast,
          settings
        };
      }

      getType(ast) {
        if (Array.isArray(ast)) {
          return this.getType(ast[ast.length - 1]);
        }
        switch (ast.type) {
          case 'BlockStatement':
            return this.getType(ast.body);
          case 'ArrayExpression':
            const childType = this.getType(ast.elements[0]);
            switch (childType) {
              case 'Array(2)':
              case 'Array(3)':
              case 'Array(4)':
                return `Matrix(${ast.elements.length})`;
            }
            return `Array(${ ast.elements.length })`;
          case 'Literal':
            const literalKey = this.astKey(ast);
            if (this.literalTypes[literalKey]) {
              return this.literalTypes[literalKey];
            }
            if (Number.isInteger(ast.value)) {
              return 'LiteralInteger';
            } else if (ast.value === true || ast.value === false) {
              return 'Boolean';
            } else {
              return 'Number';
            }
            case 'AssignmentExpression':
              return this.getType(ast.left);
            case 'CallExpression':
              if (this.isAstMathFunction(ast)) {
                return 'Number';
              }
              if (!ast.callee || !ast.callee.name) {
                if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[ast.callee.expressions.length - 1].property.name) {
                  const functionName = ast.callee.expressions[ast.callee.expressions.length - 1].property.name;
                  this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
                  return this.lookupReturnType(functionName, ast, this);
                }
                if (this.getVariableSignature(ast.callee, true) === 'this.color') {
                  return null;
                }
                if (ast.callee.type === 'MemberExpression' && ast.callee.object && ast.callee.property && ast.callee.property.name && ast.arguments) {
                  const functionName = ast.callee.property.name;
                  this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
                  return this.lookupReturnType(functionName, ast, this);
                }
                throw this.astErrorOutput('Unknown call expression', ast);
              }
              if (ast.callee && ast.callee.name) {
                const functionName = ast.callee.name;
                this.inferArgumentTypesIfNeeded(functionName, ast.arguments);
                return this.lookupReturnType(functionName, ast, this);
              }
              throw this.astErrorOutput(`Unhandled getType Type "${ ast.type }"`, ast);
            case 'LogicalExpression':
              return 'Boolean';
            case 'BinaryExpression':
              switch (ast.operator) {
                case '%':
                case '/':
                  if (this.fixIntegerDivisionAccuracy) {
                    return 'Number';
                  } else {
                    break;
                  }
                  case '>':
                  case '<':
                    return 'Boolean';
                  case '&':
                  case '|':
                  case '^':
                  case '<<':
                  case '>>':
                  case '>>>':
                    return 'Integer';
              }
              const type = this.getType(ast.left);
              if (this.isState('skip-literal-correction')) return type;
              if (type === 'LiteralInteger') {
                const rightType = this.getType(ast.right);
                if (rightType === 'LiteralInteger') {
                  if (ast.left.value % 1 === 0) {
                    return 'Integer';
                  } else {
                    return 'Float';
                  }
                }
                return rightType;
              }
              return typeLookupMap[type] || type;
            case 'UpdateExpression':
              return this.getType(ast.argument);
            case 'UnaryExpression':
              if (ast.operator === '~') {
                return 'Integer';
              }
              return this.getType(ast.argument);
            case 'VariableDeclaration': {
              const declarations = ast.declarations;
              let lastType;
              for (let i = 0; i < declarations.length; i++) {
                const declaration = declarations[i];
                lastType = this.getType(declaration);
              }
              if (!lastType) {
                throw this.astErrorOutput(`Unable to find type for declaration`, ast);
              }
              return lastType;
            }
            case 'VariableDeclarator':
              const declaration = this.getDeclaration(ast.id);
              if (!declaration) {
                throw this.astErrorOutput(`Unable to find declarator`, ast);
              }

              if (!declaration.valueType) {
                throw this.astErrorOutput(`Unable to find declarator valueType`, ast);
              }

              return declaration.valueType;
            case 'Identifier':
              if (ast.name === 'Infinity') {
                return 'Number';
              }
              if (this.isAstVariable(ast)) {
                const signature = this.getVariableSignature(ast);
                if (signature === 'value') {
                  return this.getCheckVariableType(ast);
                }
              }
              const origin = this.findIdentifierOrigin(ast);
              if (origin && origin.init) {
                return this.getType(origin.init);
              }
              return null;
            case 'ReturnStatement':
              return this.getType(ast.argument);
            case 'MemberExpression':
              if (this.isAstMathFunction(ast)) {
                switch (ast.property.name) {
                  case 'ceil':
                    return 'Integer';
                  case 'floor':
                    return 'Integer';
                  case 'round':
                    return 'Integer';
                }
                return 'Number';
              }
              if (this.isAstVariable(ast)) {
                const variableSignature = this.getVariableSignature(ast);
                switch (variableSignature) {
                  case 'value[]':
                    return this.getLookupType(this.getCheckVariableType(ast.object));
                  case 'value[][]':
                    return this.getLookupType(this.getCheckVariableType(ast.object.object));
                  case 'value[][][]':
                    return this.getLookupType(this.getCheckVariableType(ast.object.object.object));
                  case 'value[][][][]':
                    return this.getLookupType(this.getCheckVariableType(ast.object.object.object.object));
                  case 'value.thread.value':
                  case 'this.thread.value':
                    return 'Integer';
                  case 'this.output.value':
                    return this.dynamicOutput ? 'Integer' : 'LiteralInteger';
                  case 'this.constants.value':
                    return this.getConstantType(ast.property.name);
                  case 'this.constants.value[]':
                    return this.getLookupType(this.getConstantType(ast.object.property.name));
                  case 'this.constants.value[][]':
                    return this.getLookupType(this.getConstantType(ast.object.object.property.name));
                  case 'this.constants.value[][][]':
                    return this.getLookupType(this.getConstantType(ast.object.object.object.property.name));
                  case 'this.constants.value[][][][]':
                    return this.getLookupType(this.getConstantType(ast.object.object.object.object.property.name));
                  case 'fn()[]':
                  case 'fn()[][]':
                  case 'fn()[][][]':
                    return this.getLookupType(this.getType(ast.object));
                  case 'value.value':
                    if (this.isAstMathVariable(ast)) {
                      return 'Number';
                    }
                    switch (ast.property.name) {
                      case 'r':
                      case 'g':
                      case 'b':
                      case 'a':
                        return this.getLookupType(this.getCheckVariableType(ast.object));
                    }
                    case '[][]':
                      return 'Number';
                }
                throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
              }
              throw this.astErrorOutput('Unhandled getType MemberExpression', ast);
            case 'ConditionalExpression':
              return this.getType(ast.consequent);
            case 'FunctionDeclaration':
            case 'FunctionExpression':
              const lastReturn = this.findLastReturn(ast.body);
              if (lastReturn) {
                return this.getType(lastReturn);
              }
              return null;
            case 'IfStatement':
              return this.getType(ast.consequent);
            case 'SequenceExpression':
              return this.getType(ast.expressions[ast.expressions.length - 1]);
            default:
              throw this.astErrorOutput(`Unhandled getType Type "${ ast.type }"`, ast);
        }
      }

      getCheckVariableType(ast) {
        const type = this.getVariableType(ast);
        if (!type) {
          throw this.astErrorOutput(`${ast.type} is not defined`, ast);
        }
        return type;
      }

      inferArgumentTypesIfNeeded(functionName, args) {
        for (let i = 0; i < args.length; i++) {
          if (!this.needsArgumentType(functionName, i)) continue;
          const type = this.getType(args[i]);
          if (!type) {
            throw this.astErrorOutput(`Unable to infer argument ${i}`, args[i]);
          }
          this.assignArgumentType(functionName, i, type);
        }
      }

      isAstMathVariable(ast) {
        const mathProperties = [
          'E',
          'PI',
          'SQRT2',
          'SQRT1_2',
          'LN2',
          'LN10',
          'LOG2E',
          'LOG10E',
        ];
        return ast.type === 'MemberExpression' &&
          ast.object && ast.object.type === 'Identifier' &&
          ast.object.name === 'Math' &&
          ast.property &&
          ast.property.type === 'Identifier' &&
          mathProperties.indexOf(ast.property.name) > -1;
      }

      isAstMathFunction(ast) {
        const mathFunctions = [
          'abs',
          'acos',
          'acosh',
          'asin',
          'asinh',
          'atan',
          'atan2',
          'atanh',
          'cbrt',
          'ceil',
          'clz32',
          'cos',
          'cosh',
          'expm1',
          'exp',
          'floor',
          'fround',
          'imul',
          'log',
          'log2',
          'log10',
          'log1p',
          'max',
          'min',
          'pow',
          'random',
          'round',
          'sign',
          'sin',
          'sinh',
          'sqrt',
          'tan',
          'tanh',
          'trunc',
        ];
        return ast.type === 'CallExpression' &&
          ast.callee &&
          ast.callee.type === 'MemberExpression' &&
          ast.callee.object &&
          ast.callee.object.type === 'Identifier' &&
          ast.callee.object.name === 'Math' &&
          ast.callee.property &&
          ast.callee.property.type === 'Identifier' &&
          mathFunctions.indexOf(ast.callee.property.name) > -1;
      }

      isAstVariable(ast) {
        return ast.type === 'Identifier' || ast.type === 'MemberExpression';
      }

      isSafe(ast) {
        return this.isSafeDependencies(this.getDependencies(ast));
      }

      isSafeDependencies(dependencies) {
        return dependencies && dependencies.every ? dependencies.every(dependency => dependency.isSafe) : true;
      }

      getDependencies(ast, dependencies, isNotSafe) {
        if (!dependencies) {
          dependencies = [];
        }
        if (!ast) return null;
        if (Array.isArray(ast)) {
          for (let i = 0; i < ast.length; i++) {
            this.getDependencies(ast[i], dependencies, isNotSafe);
          }
          return dependencies;
        }
        switch (ast.type) {
          case 'AssignmentExpression':
            this.getDependencies(ast.left, dependencies, isNotSafe);
            this.getDependencies(ast.right, dependencies, isNotSafe);
            return dependencies;
          case 'ConditionalExpression':
            this.getDependencies(ast.test, dependencies, isNotSafe);
            this.getDependencies(ast.alternate, dependencies, isNotSafe);
            this.getDependencies(ast.consequent, dependencies, isNotSafe);
            return dependencies;
          case 'Literal':
            dependencies.push({
              origin: 'literal',
              value: ast.value,
              isSafe: isNotSafe === true ? false : ast.value > -Infinity && ast.value < Infinity && !isNaN(ast.value)
            });
            break;
          case 'VariableDeclarator':
            return this.getDependencies(ast.init, dependencies, isNotSafe);
          case 'Identifier':
            const declaration = this.getDeclaration(ast);
            if (declaration) {
              dependencies.push({
                name: ast.name,
                origin: 'declaration',
                isSafe: isNotSafe ? false : this.isSafeDependencies(declaration.dependencies),
              });
            } else if (this.argumentNames.indexOf(ast.name) > -1) {
              dependencies.push({
                name: ast.name,
                origin: 'argument',
                isSafe: false,
              });
            } else if (this.strictTypingChecking) {
              throw new Error(`Cannot find identifier origin "${ast.name}"`);
            }
            break;
          case 'FunctionDeclaration':
            return this.getDependencies(ast.body.body[ast.body.body.length - 1], dependencies, isNotSafe);
          case 'ReturnStatement':
            return this.getDependencies(ast.argument, dependencies);
          case 'BinaryExpression':
          case 'LogicalExpression':
            isNotSafe = (ast.operator === '/' || ast.operator === '*');
            this.getDependencies(ast.left, dependencies, isNotSafe);
            this.getDependencies(ast.right, dependencies, isNotSafe);
            return dependencies;
          case 'UnaryExpression':
          case 'UpdateExpression':
            return this.getDependencies(ast.argument, dependencies, isNotSafe);
          case 'VariableDeclaration':
            return this.getDependencies(ast.declarations, dependencies, isNotSafe);
          case 'ArrayExpression':
            dependencies.push({
              origin: 'declaration',
              isSafe: true,
            });
            return dependencies;
          case 'CallExpression':
            dependencies.push({
              origin: 'function',
              isSafe: true,
            });
            return dependencies;
          case 'MemberExpression':
            const details = this.getMemberExpressionDetails(ast);
            switch (details.signature) {
              case 'value[]':
                this.getDependencies(ast.object, dependencies, isNotSafe);
                break;
              case 'value[][]':
                this.getDependencies(ast.object.object, dependencies, isNotSafe);
                break;
              case 'value[][][]':
                this.getDependencies(ast.object.object.object, dependencies, isNotSafe);
                break;
              case 'this.output.value':
                if (this.dynamicOutput) {
                  dependencies.push({
                    name: details.name,
                    origin: 'output',
                    isSafe: false,
                  });
                }
                break;
            }
            if (details) {
              if (details.property) {
                this.getDependencies(details.property, dependencies, isNotSafe);
              }
              if (details.xProperty) {
                this.getDependencies(details.xProperty, dependencies, isNotSafe);
              }
              if (details.yProperty) {
                this.getDependencies(details.yProperty, dependencies, isNotSafe);
              }
              if (details.zProperty) {
                this.getDependencies(details.zProperty, dependencies, isNotSafe);
              }
              return dependencies;
            }
            case 'SequenceExpression':
              return this.getDependencies(ast.expressions, dependencies, isNotSafe);
            default:
              throw this.astErrorOutput(`Unhandled type ${ ast.type } in getDependencies`, ast);
        }
        return dependencies;
      }

      getVariableSignature(ast, returnRawValue) {
        if (!this.isAstVariable(ast)) {
          throw new Error(`ast of type "${ ast.type }" is not a variable signature`);
        }
        if (ast.type === 'Identifier') {
          return 'value';
        }
        const signature = [];
        while (true) {
          if (!ast) break;
          if (ast.computed) {
            signature.push('[]');
          } else if (ast.type === 'ThisExpression') {
            signature.unshift('this');
          } else if (ast.property && ast.property.name) {
            if (
              ast.property.name === 'x' ||
              ast.property.name === 'y' ||
              ast.property.name === 'z'
            ) {
              signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');
            } else if (
              ast.property.name === 'constants' ||
              ast.property.name === 'thread' ||
              ast.property.name === 'output'
            ) {
              signature.unshift('.' + ast.property.name);
            } else {
              signature.unshift(returnRawValue ? '.' + ast.property.name : '.value');
            }
          } else if (ast.name) {
            signature.unshift(returnRawValue ? ast.name : 'value');
          } else if (ast.callee && ast.callee.name) {
            signature.unshift(returnRawValue ? ast.callee.name + '()' : 'fn()');
          } else if (ast.elements) {
            signature.unshift('[]');
          } else {
            signature.unshift('unknown');
          }
          ast = ast.object;
        }

        const signatureString = signature.join('');
        if (returnRawValue) {
          return signatureString;
        }

        const allowedExpressions = [
          'value',
          'value[]',
          'value[][]',
          'value[][][]',
          'value[][][][]',
          'value.value',
          'value.thread.value',
          'this.thread.value',
          'this.output.value',
          'this.constants.value',
          'this.constants.value[]',
          'this.constants.value[][]',
          'this.constants.value[][][]',
          'this.constants.value[][][][]',
          'fn()[]',
          'fn()[][]',
          'fn()[][][]',
          '[][]',
        ];
        if (allowedExpressions.indexOf(signatureString) > -1) {
          return signatureString;
        }
        return null;
      }

      build() {
        return this.toString().length > 0;
      }

      astGeneric(ast, retArr) {
        if (ast === null) {
          throw this.astErrorOutput('NULL ast', ast);
        } else {
          if (Array.isArray(ast)) {
            for (let i = 0; i < ast.length; i++) {
              this.astGeneric(ast[i], retArr);
            }
            return retArr;
          }

          switch (ast.type) {
            case 'FunctionDeclaration':
              return this.astFunctionDeclaration(ast, retArr);
            case 'FunctionExpression':
              return this.astFunctionExpression(ast, retArr);
            case 'ReturnStatement':
              return this.astReturnStatement(ast, retArr);
            case 'Literal':
              return this.astLiteral(ast, retArr);
            case 'BinaryExpression':
              return this.astBinaryExpression(ast, retArr);
            case 'Identifier':
              return this.astIdentifierExpression(ast, retArr);
            case 'AssignmentExpression':
              return this.astAssignmentExpression(ast, retArr);
            case 'ExpressionStatement':
              return this.astExpressionStatement(ast, retArr);
            case 'EmptyStatement':
              return this.astEmptyStatement(ast, retArr);
            case 'BlockStatement':
              return this.astBlockStatement(ast, retArr);
            case 'IfStatement':
              return this.astIfStatement(ast, retArr);
            case 'SwitchStatement':
              return this.astSwitchStatement(ast, retArr);
            case 'BreakStatement':
              return this.astBreakStatement(ast, retArr);
            case 'ContinueStatement':
              return this.astContinueStatement(ast, retArr);
            case 'ForStatement':
              return this.astForStatement(ast, retArr);
            case 'WhileStatement':
              return this.astWhileStatement(ast, retArr);
            case 'DoWhileStatement':
              return this.astDoWhileStatement(ast, retArr);
            case 'VariableDeclaration':
              return this.astVariableDeclaration(ast, retArr);
            case 'VariableDeclarator':
              return this.astVariableDeclarator(ast, retArr);
            case 'ThisExpression':
              return this.astThisExpression(ast, retArr);
            case 'SequenceExpression':
              return this.astSequenceExpression(ast, retArr);
            case 'UnaryExpression':
              return this.astUnaryExpression(ast, retArr);
            case 'UpdateExpression':
              return this.astUpdateExpression(ast, retArr);
            case 'LogicalExpression':
              return this.astLogicalExpression(ast, retArr);
            case 'MemberExpression':
              return this.astMemberExpression(ast, retArr);
            case 'CallExpression':
              return this.astCallExpression(ast, retArr);
            case 'ArrayExpression':
              return this.astArrayExpression(ast, retArr);
            case 'DebuggerStatement':
              return this.astDebuggerStatement(ast, retArr);
            case 'ConditionalExpression':
              return this.astConditionalExpression(ast, retArr);
          }

          throw this.astErrorOutput('Unknown ast type : ' + ast.type, ast);
        }
      }
      astErrorOutput(error, ast) {
        if (typeof this.source !== 'string') {
          return new Error(error);
        }

        const debugString = utils.getAstString(this.source, ast);
        const leadingSource = this.source.substr(ast.start);
        const splitLines = leadingSource.split(/\n/);
        const lineBefore = splitLines.length > 0 ? splitLines[splitLines.length - 1] : 0;
        return new Error(`${error} on line ${ splitLines.length }, position ${ lineBefore.length }:\n ${ debugString }`);
      }

      astDebuggerStatement(arrNode, retArr) {
        return retArr;
      }

      astConditionalExpression(ast, retArr) {
        if (ast.type !== 'ConditionalExpression') {
          throw this.astErrorOutput('Not a conditional expression', ast);
        }
        retArr.push('(');
        this.astGeneric(ast.test, retArr);
        retArr.push('?');
        this.astGeneric(ast.consequent, retArr);
        retArr.push(':');
        this.astGeneric(ast.alternate, retArr);
        retArr.push(')');
        return retArr;
      }

      astFunction(ast, retArr) {
        throw new Error(`"astFunction" not defined on ${ this.constructor.name }`);
      }

      astFunctionDeclaration(ast, retArr) {
        if (this.isChildFunction(ast)) {
          return retArr;
        }
        return this.astFunction(ast, retArr);
      }
      astFunctionExpression(ast, retArr) {
        if (this.isChildFunction(ast)) {
          return retArr;
        }
        return this.astFunction(ast, retArr);
      }
      isChildFunction(ast) {
        for (let i = 0; i < this.functions.length; i++) {
          if (this.functions[i] === ast) {
            return true;
          }
        }
        return false;
      }
      astReturnStatement(ast, retArr) {
        return retArr;
      }
      astLiteral(ast, retArr) {
        this.literalTypes[this.astKey(ast)] = 'Number';
        return retArr;
      }
      astBinaryExpression(ast, retArr) {
        return retArr;
      }
      astIdentifierExpression(ast, retArr) {
        return retArr;
      }
      astAssignmentExpression(ast, retArr) {
        return retArr;
      }
      astExpressionStatement(esNode, retArr) {
        this.astGeneric(esNode.expression, retArr);
        retArr.push(';');
        return retArr;
      }
      astEmptyStatement(eNode, retArr) {
        return retArr;
      }
      astBlockStatement(ast, retArr) {
        return retArr;
      }
      astIfStatement(ast, retArr) {
        return retArr;
      }
      astSwitchStatement(ast, retArr) {
        return retArr;
      }
      astBreakStatement(brNode, retArr) {
        retArr.push('break;');
        return retArr;
      }
      astContinueStatement(crNode, retArr) {
        retArr.push('continue;\n');
        return retArr;
      }
      astForStatement(ast, retArr) {
        return retArr;
      }
      astWhileStatement(ast, retArr) {
        return retArr;
      }
      astDoWhileStatement(ast, retArr) {
        return retArr;
      }
      astVariableDeclarator(iVarDecNode, retArr) {
        this.astGeneric(iVarDecNode.id, retArr);
        if (iVarDecNode.init !== null) {
          retArr.push('=');
          this.astGeneric(iVarDecNode.init, retArr);
        }
        return retArr;
      }
      astThisExpression(ast, retArr) {
        return retArr;
      }
      astSequenceExpression(sNode, retArr) {
        const { expressions } = sNode;
        const sequenceResult = [];
        for (let i = 0; i < expressions.length; i++) {
          const expression = expressions[i];
          const expressionResult = [];
          this.astGeneric(expression, expressionResult);
          sequenceResult.push(expressionResult.join(''));
        }
        if (sequenceResult.length > 1) {
          retArr.push('(', sequenceResult.join(','), ')');
        } else {
          retArr.push(sequenceResult[0]);
        }
        return retArr;
      }
      astUnaryExpression(uNode, retArr) {
        const unaryResult = this.checkAndUpconvertBitwiseUnary(uNode, retArr);
        if (unaryResult) {
          return retArr;
        }

        if (uNode.prefix) {
          retArr.push(uNode.operator);
          this.astGeneric(uNode.argument, retArr);
        } else {
          this.astGeneric(uNode.argument, retArr);
          retArr.push(uNode.operator);
        }

        return retArr;
      }

      checkAndUpconvertBitwiseUnary(uNode, retArr) {}

      astUpdateExpression(uNode, retArr) {
        if (uNode.prefix) {
          retArr.push(uNode.operator);
          this.astGeneric(uNode.argument, retArr);
        } else {
          this.astGeneric(uNode.argument, retArr);
          retArr.push(uNode.operator);
        }

        return retArr;
      }
      astLogicalExpression(logNode, retArr) {
        retArr.push('(');
        this.astGeneric(logNode.left, retArr);
        retArr.push(logNode.operator);
        this.astGeneric(logNode.right, retArr);
        retArr.push(')');
        return retArr;
      }
      astMemberExpression(ast, retArr) {
        return retArr;
      }
      astCallExpression(ast, retArr) {
        return retArr;
      }
      astArrayExpression(ast, retArr) {
        return retArr;
      }

      getMemberExpressionDetails(ast) {
        if (ast.type !== 'MemberExpression') {
          throw this.astErrorOutput(`Expression ${ ast.type } not a MemberExpression`, ast);
        }
        let name = null;
        let type = null;
        const variableSignature = this.getVariableSignature(ast);
        switch (variableSignature) {
          case 'value':
            return null;
          case 'value.thread.value':
          case 'this.thread.value':
          case 'this.output.value':
            return {
              signature: variableSignature,
                type: 'Integer',
                name: ast.property.name
            };
          case 'value[]':
            if (typeof ast.object.name !== 'string') {
              throw this.astErrorOutput('Unexpected expression', ast);
            }
            name = ast.object.name;
            return {
              name,
              origin: 'user',
                signature: variableSignature,
                type: this.getVariableType(ast.object),
                xProperty: ast.property
            };
          case 'value[][]':
            if (typeof ast.object.object.name !== 'string') {
              throw this.astErrorOutput('Unexpected expression', ast);
            }
            name = ast.object.object.name;
            return {
              name,
              origin: 'user',
                signature: variableSignature,
                type: this.getVariableType(ast.object.object),
                yProperty: ast.object.property,
                xProperty: ast.property,
            };
          case 'value[][][]':
            if (typeof ast.object.object.object.name !== 'string') {
              throw this.astErrorOutput('Unexpected expression', ast);
            }
            name = ast.object.object.object.name;
            return {
              name,
              origin: 'user',
                signature: variableSignature,
                type: this.getVariableType(ast.object.object.object),
                zProperty: ast.object.object.property,
                yProperty: ast.object.property,
                xProperty: ast.property,
            };
          case 'value[][][][]':
            if (typeof ast.object.object.object.object.name !== 'string') {
              throw this.astErrorOutput('Unexpected expression', ast);
            }
            name = ast.object.object.object.object.name;
            return {
              name,
              origin: 'user',
                signature: variableSignature,
                type: this.getVariableType(ast.object.object.object.object),
                zProperty: ast.object.object.property,
                yProperty: ast.object.property,
                xProperty: ast.property,
            };
          case 'value.value':
            if (typeof ast.property.name !== 'string') {
              throw this.astErrorOutput('Unexpected expression', ast);
            }
            if (this.isAstMathVariable(ast)) {
              name = ast.property.name;
              return {
                name,
                origin: 'Math',
                type: 'Number',
                signature: variableSignature,
              };
            }
            switch (ast.property.name) {
              case 'r':
              case 'g':
              case 'b':
              case 'a':
                name = ast.object.name;
                return {
                  name,
                  property: ast.property.name,
                    origin: 'user',
                    signature: variableSignature,
                    type: 'Number'
                };
              default:
                throw this.astErrorOutput('Unexpected expression', ast);
            }
            case 'this.constants.value':
              if (typeof ast.property.name !== 'string') {
                throw this.astErrorOutput('Unexpected expression', ast);
              }
              name = ast.property.name;
              type = this.getConstantType(name);
              if (!type) {
                throw this.astErrorOutput('Constant has no type', ast);
              }
              return {
                name,
                type,
                origin: 'constants',
                  signature: variableSignature,
              };
            case 'this.constants.value[]':
              if (typeof ast.object.property.name !== 'string') {
                throw this.astErrorOutput('Unexpected expression', ast);
              }
              name = ast.object.property.name;
              type = this.getConstantType(name);
              if (!type) {
                throw this.astErrorOutput('Constant has no type', ast);
              }
              return {
                name,
                type,
                origin: 'constants',
                  signature: variableSignature,
                  xProperty: ast.property,
              };
            case 'this.constants.value[][]': {
              if (typeof ast.object.object.property.name !== 'string') {
                throw this.astErrorOutput('Unexpected expression', ast);
              }
              name = ast.object.object.property.name;
              type = this.getConstantType(name);
              if (!type) {
                throw this.astErrorOutput('Constant has no type', ast);
              }
              return {
                name,
                type,
                origin: 'constants',
                signature: variableSignature,
                yProperty: ast.object.property,
                xProperty: ast.property,
              };
            }
            case 'this.constants.value[][][]': {
              if (typeof ast.object.object.object.property.name !== 'string') {
                throw this.astErrorOutput('Unexpected expression', ast);
              }
              name = ast.object.object.object.property.name;
              type = this.getConstantType(name);
              if (!type) {
                throw this.astErrorOutput('Constant has no type', ast);
              }
              return {
                name,
                type,
                origin: 'constants',
                signature: variableSignature,
                zProperty: ast.object.object.property,
                yProperty: ast.object.property,
                xProperty: ast.property,
              };
            }
            case 'fn()[]':
            case 'fn()[][]':
            case '[][]':
              return {
                signature: variableSignature,
                  property: ast.property,
              };
            default:
              throw this.astErrorOutput('Unexpected expression', ast);
        }
      }

      findIdentifierOrigin(astToFind) {
        const stack = [this.ast];

        while (stack.length > 0) {
          const atNode = stack[0];
          if (atNode.type === 'VariableDeclarator' && atNode.id && atNode.id.name && atNode.id.name === astToFind.name) {
            return atNode;
          }
          stack.shift();
          if (atNode.argument) {
            stack.push(atNode.argument);
          } else if (atNode.body) {
            stack.push(atNode.body);
          } else if (atNode.declarations) {
            stack.push(atNode.declarations);
          } else if (Array.isArray(atNode)) {
            for (let i = 0; i < atNode.length; i++) {
              stack.push(atNode[i]);
            }
          }
        }
        return null;
      }

      findLastReturn(ast) {
        const stack = [ast || this.ast];

        while (stack.length > 0) {
          const atNode = stack.pop();
          if (atNode.type === 'ReturnStatement') {
            return atNode;
          }
          if (atNode.type === 'FunctionDeclaration') {
            continue;
          }
          if (atNode.argument) {
            stack.push(atNode.argument);
          } else if (atNode.body) {
            stack.push(atNode.body);
          } else if (atNode.declarations) {
            stack.push(atNode.declarations);
          } else if (Array.isArray(atNode)) {
            for (let i = 0; i < atNode.length; i++) {
              stack.push(atNode[i]);
            }
          } else if (atNode.consequent) {
            stack.push(atNode.consequent);
          } else if (atNode.cases) {
            stack.push(atNode.cases);
          }
        }
        return null;
      }

      getInternalVariableName(name) {
        if (!this._internalVariableNames.hasOwnProperty(name)) {
          this._internalVariableNames[name] = 0;
        }
        this._internalVariableNames[name]++;
        if (this._internalVariableNames[name] === 1) {
          return name;
        }
        return name + this._internalVariableNames[name];
      }

      astKey(ast, separator = ',') {
        if (!ast.start || !ast.end) throw new Error('AST start and end needed');
        return `${ast.start}${separator}${ast.end}`;
      }
    }

    const typeLookupMap = {
      'Number': 'Number',
      'Float': 'Float',
      'Integer': 'Integer',
      'Array': 'Number',
      'Array(2)': 'Number',
      'Array(3)': 'Number',
      'Array(4)': 'Number',
      'Matrix(2)': 'Number',
      'Matrix(3)': 'Number',
      'Matrix(4)': 'Number',
      'Array2D': 'Number',
      'Array3D': 'Number',
      'Input': 'Number',
      'HTMLCanvas': 'Array(4)',
      'OffscreenCanvas': 'Array(4)',
      'HTMLImage': 'Array(4)',
      'ImageBitmap': 'Array(4)',
      'ImageData': 'Array(4)',
      'HTMLVideo': 'Array(4)',
      'HTMLImageArray': 'Array(4)',
      'NumberTexture': 'Number',
      'MemoryOptimizedNumberTexture': 'Number',
      'Array1D(2)': 'Array(2)',
      'Array1D(3)': 'Array(3)',
      'Array1D(4)': 'Array(4)',
      'Array2D(2)': 'Array(2)',
      'Array2D(3)': 'Array(3)',
      'Array2D(4)': 'Array(4)',
      'Array3D(2)': 'Array(2)',
      'Array3D(3)': 'Array(3)',
      'Array3D(4)': 'Array(4)',
      'ArrayTexture(1)': 'Number',
      'ArrayTexture(2)': 'Array(2)',
      'ArrayTexture(3)': 'Array(3)',
      'ArrayTexture(4)': 'Array(4)',
    };

    module.exports = {
      FunctionNode
    };
    },{"../utils":114,"./function-tracer":11,"acorn":1}],11:[function(require,module,exports){
    const { utils } = require('../utils');

    function last(array) {
      return array.length > 0 ? array[array.length - 1] : null;
    }

    const states = {
      trackIdentifiers: 'trackIdentifiers',
      memberExpression: 'memberExpression',
      inForLoopInit: 'inForLoopInit'
    };

    class FunctionTracer {
      constructor(ast) {
        this.runningContexts = [];
        this.functionContexts = [];
        this.contexts = [];
        this.functionCalls = [];
        this.declarations = [];
        this.identifiers = [];
        this.functions = [];
        this.returnStatements = [];
        this.trackedIdentifiers = null;
        this.states = [];
        this.newFunctionContext();
        this.scan(ast);
      }

      isState(state) {
        return this.states[this.states.length - 1] === state;
      }

      hasState(state) {
        return this.states.indexOf(state) > -1;
      }

      pushState(state) {
        this.states.push(state);
      }

      popState(state) {
        if (this.isState(state)) {
          this.states.pop();
        } else {
          throw new Error(`Cannot pop the non-active state "${state}"`);
        }
      }

      get currentFunctionContext() {
        return last(this.functionContexts);
      }

      get currentContext() {
        return last(this.runningContexts);
      }

      newFunctionContext() {
        const newContext = { '@contextType': 'function' };
        this.contexts.push(newContext);
        this.functionContexts.push(newContext);
      }

      newContext(run) {
        const newContext = Object.assign({ '@contextType': 'const/let' }, this.currentContext);
        this.contexts.push(newContext);
        this.runningContexts.push(newContext);
        run();
        const { currentFunctionContext } = this;
        for (const p in currentFunctionContext) {
          if (!currentFunctionContext.hasOwnProperty(p) || newContext.hasOwnProperty(p)) continue;
          newContext[p] = currentFunctionContext[p];
        }
        this.runningContexts.pop();
        return newContext;
      }

      useFunctionContext(run) {
        const functionContext = last(this.functionContexts);
        this.runningContexts.push(functionContext);
        run();
        this.runningContexts.pop();
      }

      getIdentifiers(run) {
        const trackedIdentifiers = this.trackedIdentifiers = [];
        this.pushState(states.trackIdentifiers);
        run();
        this.trackedIdentifiers = null;
        this.popState(states.trackIdentifiers);
        return trackedIdentifiers;
      }

      getDeclaration(name) {
        const { currentContext, currentFunctionContext, runningContexts } = this;
        const declaration = currentContext[name] || currentFunctionContext[name] || null;

        if (
          !declaration &&
          currentContext === currentFunctionContext &&
          runningContexts.length > 0
        ) {
          const previousRunningContext = runningContexts[runningContexts.length - 2];
          if (previousRunningContext[name]) {
            return previousRunningContext[name];
          }
        }

        return declaration;
      }

      scan(ast) {
        if (!ast) return;
        if (Array.isArray(ast)) {
          for (let i = 0; i < ast.length; i++) {
            this.scan(ast[i]);
          }
          return;
        }
        switch (ast.type) {
          case 'Program':
            this.useFunctionContext(() => {
              this.scan(ast.body);
            });
            break;
          case 'BlockStatement':
            this.newContext(() => {
              this.scan(ast.body);
            });
            break;
          case 'AssignmentExpression':
          case 'LogicalExpression':
            this.scan(ast.left);
            this.scan(ast.right);
            break;
          case 'BinaryExpression':
            this.scan(ast.left);
            this.scan(ast.right);
            break;
          case 'UpdateExpression':
            if (ast.operator === '++') {
              const declaration = this.getDeclaration(ast.argument.name);
              if (declaration) {
                declaration.suggestedType = 'Integer';
              }
            }
            this.scan(ast.argument);
            break;
          case 'UnaryExpression':
            this.scan(ast.argument);
            break;
          case 'VariableDeclaration':
            if (ast.kind === 'var') {
              this.useFunctionContext(() => {
                ast.declarations = utils.normalizeDeclarations(ast);
                this.scan(ast.declarations);
              });
            } else {
              ast.declarations = utils.normalizeDeclarations(ast);
              this.scan(ast.declarations);
            }
            break;
          case 'VariableDeclarator': {
            const { currentContext } = this;
            const inForLoopInit = this.hasState(states.inForLoopInit);
            const declaration = {
              ast: ast,
              context: currentContext,
              name: ast.id.name,
              origin: 'declaration',
              inForLoopInit,
              inForLoopTest: null,
              assignable: currentContext === this.currentFunctionContext || (!inForLoopInit && !currentContext.hasOwnProperty(ast.id.name)),
              suggestedType: null,
              valueType: null,
              dependencies: null,
              isSafe: null,
            };
            if (!currentContext[ast.id.name]) {
              currentContext[ast.id.name] = declaration;
            }
            this.declarations.push(declaration);
            this.scan(ast.id);
            this.scan(ast.init);
            break;
          }
          case 'FunctionExpression':
          case 'FunctionDeclaration':
            if (this.runningContexts.length === 0) {
              this.scan(ast.body);
            } else {
              this.functions.push(ast);
            }
            break;
          case 'IfStatement':
            this.scan(ast.test);
            this.scan(ast.consequent);
            if (ast.alternate) this.scan(ast.alternate);
            break;
          case 'ForStatement': {
            let testIdentifiers;
            const context = this.newContext(() => {
              this.pushState(states.inForLoopInit);
              this.scan(ast.init);
              this.popState(states.inForLoopInit);

              testIdentifiers = this.getIdentifiers(() => {
                this.scan(ast.test);
              });

              this.scan(ast.update);
              this.newContext(() => {
                this.scan(ast.body);
              });
            });

            if (testIdentifiers) {
              for (const p in context) {
                if (p === '@contextType') continue;
                if (testIdentifiers.indexOf(p) > -1) {
                  context[p].inForLoopTest = true;
                }
              }
            }
            break;
          }
          case 'DoWhileStatement':
          case 'WhileStatement':
            this.newContext(() => {
              this.scan(ast.body);
              this.scan(ast.test);
            });
            break;
          case 'Identifier': {
            if (this.isState(states.trackIdentifiers)) {
              this.trackedIdentifiers.push(ast.name);
            }
            this.identifiers.push({
              context: this.currentContext,
              declaration: this.getDeclaration(ast.name),
              ast,
            });
            break;
          }
          case 'ReturnStatement':
            this.returnStatements.push(ast);
            this.scan(ast.argument);
            break;
          case 'MemberExpression':
            this.pushState(states.memberExpression);
            this.scan(ast.object);
            this.scan(ast.property);
            this.popState(states.memberExpression);
            break;
          case 'ExpressionStatement':
            this.scan(ast.expression);
            break;
          case 'SequenceExpression':
            this.scan(ast.expressions);
            break;
          case 'CallExpression':
            this.functionCalls.push({
              context: this.currentContext,
              ast,
            });
            this.scan(ast.arguments);
            break;
          case 'ArrayExpression':
            this.scan(ast.elements);
            break;
          case 'ConditionalExpression':
            this.scan(ast.test);
            this.scan(ast.alternate);
            this.scan(ast.consequent);
            break;
          case 'SwitchStatement':
            this.scan(ast.discriminant);
            this.scan(ast.cases);
            break;
          case 'SwitchCase':
            this.scan(ast.test);
            this.scan(ast.consequent);
            break;

          case 'ThisExpression':
          case 'Literal':
          case 'DebuggerStatement':
          case 'EmptyStatement':
          case 'BreakStatement':
          case 'ContinueStatement':
            break;
          default:
            throw new Error(`unhandled type "${ast.type}"`);
        }
      }
    }

    module.exports = {
      FunctionTracer,
    };
    },{"../utils":114}],12:[function(require,module,exports){
    const { glWiretap } = require('gl-wiretap');
    const { utils } = require('../../utils');

    function toStringWithoutUtils(fn) {
      return fn.toString()
        .replace('=>', '')
        .replace(/^function /, '')
        .replace(/utils[.]/g, '/*utils.*/');
    }

    function glKernelString(Kernel, args, originKernel, setupContextString, destroyContextString) {
      if (!originKernel.built) {
        originKernel.build.apply(originKernel, args);
      }
      args = args ? Array.from(args).map(arg => {
        switch (typeof arg) {
          case 'boolean':
            return new Boolean(arg);
          case 'number':
            return new Number(arg);
          default:
            return arg;
        }
      }) : null;
      const postResult = [];
      const context = glWiretap(originKernel.context, {
        useTrackablePrimitives: true,
        onReadPixels: (targetName) => {
          if (kernel.subKernels) {
            if (!subKernelsResultVariableSetup) {
              postResult.push(`    const result = { result: ${getRenderString(targetName, kernel)} };`);
              subKernelsResultVariableSetup = true;
            } else {
              const property = kernel.subKernels[subKernelsResultIndex++].property;
              postResult.push(`    result${isNaN(property) ? '.' + property : `[${property}]`} = ${getRenderString(targetName, kernel)};`);
            }
            if (subKernelsResultIndex === kernel.subKernels.length) {
              postResult.push('    return result;');
            }
            return;
          }
          if (targetName) {
            postResult.push(`    return ${getRenderString(targetName, kernel)};`);
          } else {
            postResult.push(`    return null;`);
          }
        },
        onUnrecognizedArgumentLookup: (argument) => {
          const argumentName = findKernelValue(argument, kernel.kernelArguments, [], context);
          if (argumentName) {
            return argumentName;
          }
          const constantName = findKernelValue(argument, kernel.kernelConstants, constants ? Object.keys(constants).map(key => constants[key]) : [], context);
          if (constantName) {
            return constantName;
          }
          return null;
        }
      });
      let subKernelsResultVariableSetup = false;
      let subKernelsResultIndex = 0;
      const {
        source,
        canvas,
        output,
        pipeline,
        graphical,
        loopMaxIterations,
        constants,
        optimizeFloatMemory,
        precision,
        fixIntegerDivisionAccuracy,
        functions,
        nativeFunctions,
        subKernels,
        immutable,
        argumentTypes,
        constantTypes,
        kernelArguments,
        kernelConstants,
        tactic,
      } = originKernel;
      const kernel = new Kernel(source, {
        canvas,
        context,
        checkContext: false,
        output,
        pipeline,
        graphical,
        loopMaxIterations,
        constants,
        optimizeFloatMemory,
        precision,
        fixIntegerDivisionAccuracy,
        functions,
        nativeFunctions,
        subKernels,
        immutable,
        argumentTypes,
        constantTypes,
        tactic,
      });
      let result = [];
      context.setIndent(2);
      kernel.build.apply(kernel, args);
      result.push(context.toString());
      context.reset();

      kernel.kernelArguments.forEach((kernelArgument, i) => {
        switch (kernelArgument.type) {
          case 'Integer':
          case 'Boolean':
          case 'Number':
          case 'Float':
          case 'Array':
          case 'Array(2)':
          case 'Array(3)':
          case 'Array(4)':
          case 'HTMLCanvas':
          case 'HTMLImage':
          case 'HTMLVideo':
            context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);
            break;
          case 'HTMLImageArray':
            for (let imageIndex = 0; imageIndex < args[i].length; imageIndex++) {
              const arg = args[i];
              context.insertVariable(`uploadValue_${kernelArgument.name}[${imageIndex}]`, arg[imageIndex]);
            }
            break;
          case 'Input':
            context.insertVariable(`uploadValue_${kernelArgument.name}`, kernelArgument.uploadValue);
            break;
          case 'MemoryOptimizedNumberTexture':
          case 'NumberTexture':
          case 'Array1D(2)':
          case 'Array1D(3)':
          case 'Array1D(4)':
          case 'Array2D(2)':
          case 'Array2D(3)':
          case 'Array2D(4)':
          case 'Array3D(2)':
          case 'Array3D(3)':
          case 'Array3D(4)':
          case 'ArrayTexture(1)':
          case 'ArrayTexture(2)':
          case 'ArrayTexture(3)':
          case 'ArrayTexture(4)':
            context.insertVariable(`uploadValue_${kernelArgument.name}`, args[i].texture);
            break;
          default:
            throw new Error(`unhandled kernelArgumentType insertion for glWiretap of type ${kernelArgument.type}`);
        }
      });
      result.push('/** start of injected functions **/');
      result.push(`function ${toStringWithoutUtils(utils.flattenTo)}`);
      result.push(`function ${toStringWithoutUtils(utils.flatten2dArrayTo)}`);
      result.push(`function ${toStringWithoutUtils(utils.flatten3dArrayTo)}`);
      result.push(`function ${toStringWithoutUtils(utils.flatten4dArrayTo)}`);
      result.push(`function ${toStringWithoutUtils(utils.isArray)}`);
      if (kernel.renderOutput !== kernel.renderTexture && kernel.formatValues) {
        result.push(
          `  const renderOutput = function ${toStringWithoutUtils(kernel.formatValues)};`
        );
      }
      result.push('/** end of injected functions **/');
      result.push(`  const innerKernel = function (${kernel.kernelArguments.map(kernelArgument => kernelArgument.varName).join(', ')}) {`);
      context.setIndent(4);
      kernel.run.apply(kernel, args);
      if (kernel.renderKernels) {
        kernel.renderKernels();
      } else if (kernel.renderOutput) {
        kernel.renderOutput();
      }
      result.push('    /** start setup uploads for kernel values **/');
      kernel.kernelArguments.forEach(kernelArgument => {
        result.push('    ' + kernelArgument.getStringValueHandler().split('\n').join('\n    '));
      });
      result.push('    /** end setup uploads for kernel values **/');
      result.push(context.toString());
      if (kernel.renderOutput === kernel.renderTexture) {
        context.reset();
        const framebufferName = context.getContextVariableName(kernel.framebuffer);
        if (kernel.renderKernels) {
          const results = kernel.renderKernels();
          const textureName = context.getContextVariableName(kernel.texture.texture);
          result.push(`    return {
      result: {
        texture: ${ textureName },
        type: '${ results.result.type }',
        toArray: ${ getToArrayString(results.result, textureName, framebufferName) }
      },`);
          const { subKernels, mappedTextures } = kernel;
          for (let i = 0; i < subKernels.length; i++) {
            const texture = mappedTextures[i];
            const subKernel = subKernels[i];
            const subKernelResult = results[subKernel.property];
            const subKernelTextureName = context.getContextVariableName(texture.texture);
            result.push(`
      ${subKernel.property}: {
        texture: ${ subKernelTextureName },
        type: '${ subKernelResult.type }',
        toArray: ${ getToArrayString(subKernelResult, subKernelTextureName, framebufferName) }
      },`);
          }
          result.push(`    };`);
        } else {
          const rendered = kernel.renderOutput();
          const textureName = context.getContextVariableName(kernel.texture.texture);
          result.push(`    return {
        texture: ${ textureName },
        type: '${ rendered.type }',
        toArray: ${ getToArrayString(rendered, textureName, framebufferName) }
      };`);
        }
      }
      result.push(`    ${destroyContextString ? '\n' + destroyContextString + '    ': ''}`);
      result.push(postResult.join('\n'));
      result.push('  };');
      if (kernel.graphical) {
        result.push(getGetPixelsString(kernel));
        result.push(`  innerKernel.getPixels = getPixels;`);
      }
      result.push('  return innerKernel;');

      let constantsUpload = [];
      kernelConstants.forEach((kernelConstant) => {
        constantsUpload.push(`${kernelConstant.getStringValueHandler()}`);
      });
      return `function kernel(settings) {
  const { context, constants } = settings;
  ${constantsUpload.join('')}
  ${setupContextString ? setupContextString : ''}
${result.join('\n')}
}`;
    }

    function getRenderString(targetName, kernel) {
      const readBackValue = kernel.precision === 'single' ? targetName : `new Float32Array(${targetName}.buffer)`;
      if (kernel.output[2]) {
        return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]}, ${kernel.output[2]})`;
      }
      if (kernel.output[1]) {
        return `renderOutput(${readBackValue}, ${kernel.output[0]}, ${kernel.output[1]})`;
      }

      return `renderOutput(${readBackValue}, ${kernel.output[0]})`;
    }

    function getGetPixelsString(kernel) {
      const getPixels = kernel.getPixels.toString();
      const useFunctionKeyword = !/^function/.test(getPixels);
      return utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ getPixels }`, {
        findDependency: (object, name) => {
          if (object === 'utils') {
            return `const ${name} = ${utils[name].toString()};`;
          }
          return null;
        },
        thisLookup: (property) => {
          if (property === 'context') {
            return null;
          }
          if (kernel.hasOwnProperty(property)) {
            return JSON.stringify(kernel[property]);
          }
          throw new Error(`unhandled thisLookup ${ property }`);
        }
      });
    }

    function getToArrayString(kernelResult, textureName, framebufferName) {
      const toArray = kernelResult.toArray.toString();
      const useFunctionKeyword = !/^function/.test(toArray);
      const flattenedFunctions = utils.flattenFunctionToString(`${useFunctionKeyword ? 'function ' : ''}${ toArray }`, {
        findDependency: (object, name) => {
          if (object === 'utils') {
            return `const ${name} = ${utils[name].toString()};`;
          } else if (object === 'this') {
            if (name === 'framebuffer') {
              return '';
            }
            return `${useFunctionKeyword ? 'function ' : ''}${kernelResult[name].toString()}`;
          } else {
            throw new Error('unhandled fromObject');
          }
        },
        thisLookup: (property, isDeclaration) => {
          if (property === 'texture') {
            return textureName;
          }
          if (property === 'context') {
            if (isDeclaration) return null;
            return 'gl';
          }
          if (kernelResult.hasOwnProperty(property)) {
            return JSON.stringify(kernelResult[property]);
          }
          throw new Error(`unhandled thisLookup ${ property }`);
        }
      });
      return `() => {
  function framebuffer() { return ${framebufferName}; };
  ${flattenedFunctions}
  return toArray();
  }`;
    }

    function findKernelValue(argument, kernelValues, values, context, uploadedValues) {
      if (argument === null) return null;
      if (kernelValues === null) return null;
      switch (typeof argument) {
        case 'boolean':
        case 'number':
          return null;
      }
      if (
        typeof HTMLImageElement !== 'undefined' &&
        argument instanceof HTMLImageElement
      ) {
        for (let i = 0; i < kernelValues.length; i++) {
          const kernelValue = kernelValues[i];
          if (kernelValue.type !== 'HTMLImageArray' && kernelValue) continue;
          if (kernelValue.uploadValue !== argument) continue;
          const variableIndex = values[i].indexOf(argument);
          if (variableIndex === -1) continue;
          const variableName = `uploadValue_${kernelValue.name}[${variableIndex}]`;
          context.insertVariable(variableName, argument);
          return variableName;
        }
      }

      for (let i = 0; i < kernelValues.length; i++) {
        const kernelValue = kernelValues[i];
        if (argument !== kernelValue.uploadValue) continue;
        const variable = `uploadValue_${kernelValue.name}`;
        context.insertVariable(variable, kernelValue);
        return variable;
      }
      return null;
    }

    module.exports = {
      glKernelString
    };
    },{"../../utils":114,"gl-wiretap":3}],13:[function(require,module,exports){
    const { Kernel } = require('../kernel');
    const { utils } = require('../../utils');
    const { GLTextureArray2Float } = require('./texture/array-2-float');
    const { GLTextureArray2Float2D } = require('./texture/array-2-float-2d');
    const { GLTextureArray2Float3D } = require('./texture/array-2-float-3d');
    const { GLTextureArray3Float } = require('./texture/array-3-float');
    const { GLTextureArray3Float2D } = require('./texture/array-3-float-2d');
    const { GLTextureArray3Float3D } = require('./texture/array-3-float-3d');
    const { GLTextureArray4Float } = require('./texture/array-4-float');
    const { GLTextureArray4Float2D } = require('./texture/array-4-float-2d');
    const { GLTextureArray4Float3D } = require('./texture/array-4-float-3d');
    const { GLTextureFloat } = require('./texture/float');
    const { GLTextureFloat2D } = require('./texture/float-2d');
    const { GLTextureFloat3D } = require('./texture/float-3d');
    const { GLTextureMemoryOptimized } = require('./texture/memory-optimized');
    const { GLTextureMemoryOptimized2D } = require('./texture/memory-optimized-2d');
    const { GLTextureMemoryOptimized3D } = require('./texture/memory-optimized-3d');
    const { GLTextureUnsigned } = require('./texture/unsigned');
    const { GLTextureUnsigned2D } = require('./texture/unsigned-2d');
    const { GLTextureUnsigned3D } = require('./texture/unsigned-3d');
    const { GLTextureGraphical } = require('./texture/graphical');

    class GLKernel extends Kernel {
      static get mode() {
        return 'gpu';
      }

      static getIsFloatRead() {
        const kernelString = `function kernelFunction() {
      return 1;
    }`;
        const kernel = new this(kernelString, {
          context: this.testContext,
          canvas: this.testCanvas,
          validate: false,
          output: [1],
          precision: 'single',
          returnType: 'Number',
          tactic: 'speed',
        });
        kernel.build();
        kernel.run();
        const result = kernel.renderOutput();
        kernel.destroy(true);
        return result[0] === 1;
      }

      static getIsIntegerDivisionAccurate() {
        function kernelFunction(v1, v2) {
          return v1[this.thread.x] / v2[this.thread.x];
        }
        const kernel = new this(kernelFunction.toString(), {
          context: this.testContext,
          canvas: this.testCanvas,
          validate: false,
          output: [2],
          returnType: 'Number',
          precision: 'unsigned',
          tactic: 'speed',
        });
        const args = [
          [6, 6030401],
          [3, 3991]
        ];
        kernel.build.apply(kernel, args);
        kernel.run.apply(kernel, args);
        const result = kernel.renderOutput();
        kernel.destroy(true);
        return result[0] === 2 && result[1] === 1511;
      }

      static getIsSpeedTacticSupported() {
        function kernelFunction(value) {
          return value[this.thread.x];
        }
        const kernel = new this(kernelFunction.toString(), {
          context: this.testContext,
          canvas: this.testCanvas,
          validate: false,
          output: [4],
          returnType: 'Number',
          precision: 'unsigned',
          tactic: 'speed',
        });
        const args = [
          [0, 1, 2, 3]
        ];
        kernel.build.apply(kernel, args);
        kernel.run.apply(kernel, args);
        const result = kernel.renderOutput();
        kernel.destroy(true);
        return Math.round(result[0]) === 0 && Math.round(result[1]) === 1 && Math.round(result[2]) === 2 && Math.round(result[3]) === 3;
      }

      static get testCanvas() {
        throw new Error(`"testCanvas" not defined on ${ this.name }`);
      }

      static get testContext() {
        throw new Error(`"testContext" not defined on ${ this.name }`);
      }

      static getFeatures() {
        const gl = this.testContext;
        const isDrawBuffers = this.getIsDrawBuffers();
        return Object.freeze({
          isFloatRead: this.getIsFloatRead(),
          isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
          isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
          isTextureFloat: this.getIsTextureFloat(),
          isDrawBuffers,
          kernelMap: isDrawBuffers,
          channelCount: this.getChannelCount(),
          maxTextureSize: this.getMaxTextureSize(),
          lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),
          lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),
          mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),
          mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),
          highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),
          highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),
        });
      }

      static setupFeatureChecks() {
        throw new Error(`"setupFeatureChecks" not defined on ${ this.name }`);
      }

      static getSignature(kernel, argumentTypes) {
        return kernel.getVariablePrecisionString() + (argumentTypes.length > 0 ? ':' + argumentTypes.join(',') : '');
      }

      setFixIntegerDivisionAccuracy(fix) {
        this.fixIntegerDivisionAccuracy = fix;
        return this;
      }

      setPrecision(flag) {
        this.precision = flag;
        return this;
      }

      setFloatTextures(flag) {
        utils.warnDeprecated('method', 'setFloatTextures', 'setOptimizeFloatMemory');
        this.floatTextures = flag;
        return this;
      }

      static nativeFunctionArguments(source) {
        const argumentTypes = [];
        const argumentNames = [];
        const states = [];
        const isStartingVariableName = /^[a-zA-Z_]/;
        const isVariableChar = /[a-zA-Z_0-9]/;
        let i = 0;
        let argumentName = null;
        let argumentType = null;
        while (i < source.length) {
          const char = source[i];
          const nextChar = source[i + 1];
          const state = states.length > 0 ? states[states.length - 1] : null;

          if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '*') {
            states.push('MULTI_LINE_COMMENT');
            i += 2;
            continue;
          } else if (state === 'MULTI_LINE_COMMENT' && char === '*' && nextChar === '/') {
            states.pop();
            i += 2;
            continue;
          }

          else if (state === 'FUNCTION_ARGUMENTS' && char === '/' && nextChar === '/') {
            states.push('COMMENT');
            i += 2;
            continue;
          } else if (state === 'COMMENT' && char === '\n') {
            states.pop();
            i++;
            continue;
          }

          else if (state === null && char === '(') {
            states.push('FUNCTION_ARGUMENTS');
            i++;
            continue;
          } else if (state === 'FUNCTION_ARGUMENTS') {
            if (char === ')') {
              states.pop();
              break;
            }
            if (char === 'f' && nextChar === 'l' && source[i + 2] === 'o' && source[i + 3] === 'a' && source[i + 4] === 't' && source[i + 5] === ' ') {
              states.push('DECLARE_VARIABLE');
              argumentType = 'float';
              argumentName = '';
              i += 6;
              continue;
            } else if (char === 'i' && nextChar === 'n' && source[i + 2] === 't' && source[i + 3] === ' ') {
              states.push('DECLARE_VARIABLE');
              argumentType = 'int';
              argumentName = '';
              i += 4;
              continue;
            } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '2' && source[i + 4] === ' ') {
              states.push('DECLARE_VARIABLE');
              argumentType = 'vec2';
              argumentName = '';
              i += 5;
              continue;
            } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '3' && source[i + 4] === ' ') {
              states.push('DECLARE_VARIABLE');
              argumentType = 'vec3';
              argumentName = '';
              i += 5;
              continue;
            } else if (char === 'v' && nextChar === 'e' && source[i + 2] === 'c' && source[i + 3] === '4' && source[i + 4] === ' ') {
              states.push('DECLARE_VARIABLE');
              argumentType = 'vec4';
              argumentName = '';
              i += 5;
              continue;
            }
          }

          else if (state === 'DECLARE_VARIABLE') {
            if (argumentName === '') {
              if (char === ' ') {
                i++;
                continue;
              }
              if (!isStartingVariableName.test(char)) {
                throw new Error('variable name is not expected string');
              }
            }
            argumentName += char;
            if (!isVariableChar.test(nextChar)) {
              states.pop();
              argumentNames.push(argumentName);
              argumentTypes.push(typeMap[argumentType]);
            }
          }

          i++;
        }
        if (states.length > 0) {
          throw new Error('GLSL function was not parsable');
        }
        return {
          argumentNames,
          argumentTypes,
        };
      }

      static nativeFunctionReturnType(source) {
        return typeMap[source.match(/int|float|vec[2-4]/)[0]];
      }

      static combineKernels(combinedKernel, lastKernel) {
        combinedKernel.apply(null, arguments);
        const {
          texSize,
          context,
          threadDim
        } = lastKernel.texSize;
        let result;
        if (lastKernel.precision === 'single') {
          const w = texSize[0];
          const h = Math.ceil(texSize[1] / 4);
          result = new Float32Array(w * h * 4 * 4);
          context.readPixels(0, 0, w, h * 4, context.RGBA, context.FLOAT, result);
        } else {
          const bytes = new Uint8Array(texSize[0] * texSize[1] * 4);
          context.readPixels(0, 0, texSize[0], texSize[1], context.RGBA, context.UNSIGNED_BYTE, bytes);
          result = new Float32Array(bytes.buffer);
        }

        result = result.subarray(0, threadDim[0] * threadDim[1] * threadDim[2]);

        if (lastKernel.output.length === 1) {
          return result;
        } else if (lastKernel.output.length === 2) {
          return utils.splitArray(result, lastKernel.output[0]);
        } else if (lastKernel.output.length === 3) {
          const cube = utils.splitArray(result, lastKernel.output[0] * lastKernel.output[1]);
          return cube.map(function(x) {
            return utils.splitArray(x, lastKernel.output[0]);
          });
        }
      }

      constructor(source, settings) {
        super(source, settings);
        this.transferValues = null;
        this.formatValues = null;
        this.TextureConstructor = null;
        this.renderOutput = null;
        this.renderRawOutput = null;
        this.texSize = null;
        this.translatedSource = null;
        this.compiledFragmentShader = null;
        this.compiledVertexShader = null;
        this.switchingKernels = null;
        this._textureSwitched = null;
        this._mappedTextureSwitched = null;
      }

      checkTextureSize() {
        const { features } = this.constructor;
        if (this.texSize[0] > features.maxTextureSize || this.texSize[1] > features.maxTextureSize) {
          throw new Error(`Texture size [${this.texSize[0]},${this.texSize[1]}] generated by kernel is larger than supported size [${features.maxTextureSize},${features.maxTextureSize}]`);
        }
      }

      translateSource() {
        throw new Error(`"translateSource" not defined on ${this.constructor.name}`);
      }

      pickRenderStrategy(args) {
        if (this.graphical) {
          this.renderRawOutput = this.readPackedPixelsToUint8Array;
          this.transferValues = (pixels) => pixels;
          this.TextureConstructor = GLTextureGraphical;
          return null;
        }
        if (this.precision === 'unsigned') {
          this.renderRawOutput = this.readPackedPixelsToUint8Array;
          this.transferValues = this.readPackedPixelsToFloat32Array;
          if (this.pipeline) {
            this.renderOutput = this.renderTexture;
            if (this.subKernels !== null) {
              this.renderKernels = this.renderKernelsToTextures;
            }
            switch (this.returnType) {
              case 'LiteralInteger':
              case 'Float':
              case 'Number':
              case 'Integer':
                if (this.output[2] > 0) {
                  this.TextureConstructor = GLTextureUnsigned3D;
                  return null;
                } else if (this.output[1] > 0) {
                  this.TextureConstructor = GLTextureUnsigned2D;
                  return null;
                } else {
                  this.TextureConstructor = GLTextureUnsigned;
                  return null;
                }
                case 'Array(2)':
                case 'Array(3)':
                case 'Array(4)':
                  return this.requestFallback(args);
            }
          } else {
            if (this.subKernels !== null) {
              this.renderKernels = this.renderKernelsToArrays;
            }
            switch (this.returnType) {
              case 'LiteralInteger':
              case 'Float':
              case 'Number':
              case 'Integer':
                this.renderOutput = this.renderValues;
                if (this.output[2] > 0) {
                  this.TextureConstructor = GLTextureUnsigned3D;
                  this.formatValues = utils.erect3DPackedFloat;
                  return null;
                } else if (this.output[1] > 0) {
                  this.TextureConstructor = GLTextureUnsigned2D;
                  this.formatValues = utils.erect2DPackedFloat;
                  return null;
                } else {
                  this.TextureConstructor = GLTextureUnsigned;
                  this.formatValues = utils.erectPackedFloat;
                  return null;
                }
                case 'Array(2)':
                case 'Array(3)':
                case 'Array(4)':
                  return this.requestFallback(args);
            }
          }
        } else if (this.precision === 'single') {
          this.renderRawOutput = this.readFloatPixelsToFloat32Array;
          this.transferValues = this.readFloatPixelsToFloat32Array;
          if (this.pipeline) {
            this.renderOutput = this.renderTexture;
            if (this.subKernels !== null) {
              this.renderKernels = this.renderKernelsToTextures;
            }
            switch (this.returnType) {
              case 'LiteralInteger':
              case 'Float':
              case 'Number':
              case 'Integer': {
                if (this.optimizeFloatMemory) {
                  if (this.output[2] > 0) {
                    this.TextureConstructor = GLTextureMemoryOptimized3D;
                    return null;
                  } else if (this.output[1] > 0) {
                    this.TextureConstructor = GLTextureMemoryOptimized2D;
                    return null;
                  } else {
                    this.TextureConstructor = GLTextureMemoryOptimized;
                    return null;
                  }
                } else {
                  if (this.output[2] > 0) {
                    this.TextureConstructor = GLTextureFloat3D;
                    return null;
                  } else if (this.output[1] > 0) {
                    this.TextureConstructor = GLTextureFloat2D;
                    return null;
                  } else {
                    this.TextureConstructor = GLTextureFloat;
                    return null;
                  }
                }
              }
              case 'Array(2)': {
                if (this.output[2] > 0) {
                  this.TextureConstructor = GLTextureArray2Float3D;
                  return null;
                } else if (this.output[1] > 0) {
                  this.TextureConstructor = GLTextureArray2Float2D;
                  return null;
                } else {
                  this.TextureConstructor = GLTextureArray2Float;
                  return null;
                }
              }
              case 'Array(3)': {
                if (this.output[2] > 0) {
                  this.TextureConstructor = GLTextureArray3Float3D;
                  return null;
                } else if (this.output[1] > 0) {
                  this.TextureConstructor = GLTextureArray3Float2D;
                  return null;
                } else {
                  this.TextureConstructor = GLTextureArray3Float;
                  return null;
                }
              }
              case 'Array(4)': {
                if (this.output[2] > 0) {
                  this.TextureConstructor = GLTextureArray4Float3D;
                  return null;
                } else if (this.output[1] > 0) {
                  this.TextureConstructor = GLTextureArray4Float2D;
                  return null;
                } else {
                  this.TextureConstructor = GLTextureArray4Float;
                  return null;
                }
              }
            }
          }
          this.renderOutput = this.renderValues;
          if (this.subKernels !== null) {
            this.renderKernels = this.renderKernelsToArrays;
          }
          if (this.optimizeFloatMemory) {
            switch (this.returnType) {
              case 'LiteralInteger':
              case 'Float':
              case 'Number':
              case 'Integer': {
                if (this.output[2] > 0) {
                  this.TextureConstructor = GLTextureMemoryOptimized3D;
                  this.formatValues = utils.erectMemoryOptimized3DFloat;
                  return null;
                } else if (this.output[1] > 0) {
                  this.TextureConstructor = GLTextureMemoryOptimized2D;
                  this.formatValues = utils.erectMemoryOptimized2DFloat;
                  return null;
                } else {
                  this.TextureConstructor = GLTextureMemoryOptimized;
                  this.formatValues = utils.erectMemoryOptimizedFloat;
                  return null;
                }
              }
              case 'Array(2)': {
                if (this.output[2] > 0) {
                  this.TextureConstructor = GLTextureArray2Float3D;
                  this.formatValues = utils.erect3DArray2;
                  return null;
                } else if (this.output[1] > 0) {
                  this.TextureConstructor = GLTextureArray2Float2D;
                  this.formatValues = utils.erect2DArray2;
                  return null;
                } else {
                  this.TextureConstructor = GLTextureArray2Float;
                  this.formatValues = utils.erectArray2;
                  return null;
                }
              }
              case 'Array(3)': {
                if (this.output[2] > 0) {
                  this.TextureConstructor = GLTextureArray3Float3D;
                  this.formatValues = utils.erect3DArray3;
                  return null;
                } else if (this.output[1] > 0) {
                  this.TextureConstructor = GLTextureArray3Float2D;
                  this.formatValues = utils.erect2DArray3;
                  return null;
                } else {
                  this.TextureConstructor = GLTextureArray3Float;
                  this.formatValues = utils.erectArray3;
                  return null;
                }
              }
              case 'Array(4)': {
                if (this.output[2] > 0) {
                  this.TextureConstructor = GLTextureArray4Float3D;
                  this.formatValues = utils.erect3DArray4;
                  return null;
                } else if (this.output[1] > 0) {
                  this.TextureConstructor = GLTextureArray4Float2D;
                  this.formatValues = utils.erect2DArray4;
                  return null;
                } else {
                  this.TextureConstructor = GLTextureArray4Float;
                  this.formatValues = utils.erectArray4;
                  return null;
                }
              }
            }
          } else {
            switch (this.returnType) {
              case 'LiteralInteger':
              case 'Float':
              case 'Number':
              case 'Integer': {
                if (this.output[2] > 0) {
                  this.TextureConstructor = GLTextureFloat3D;
                  this.formatValues = utils.erect3DFloat;
                  return null;
                } else if (this.output[1] > 0) {
                  this.TextureConstructor = GLTextureFloat2D;
                  this.formatValues = utils.erect2DFloat;
                  return null;
                } else {
                  this.TextureConstructor = GLTextureFloat;
                  this.formatValues = utils.erectFloat;
                  return null;
                }
              }
              case 'Array(2)': {
                if (this.output[2] > 0) {
                  this.TextureConstructor = GLTextureArray2Float3D;
                  this.formatValues = utils.erect3DArray2;
                  return null;
                } else if (this.output[1] > 0) {
                  this.TextureConstructor = GLTextureArray2Float2D;
                  this.formatValues = utils.erect2DArray2;
                  return null;
                } else {
                  this.TextureConstructor = GLTextureArray2Float;
                  this.formatValues = utils.erectArray2;
                  return null;
                }
              }
              case 'Array(3)': {
                if (this.output[2] > 0) {
                  this.TextureConstructor = GLTextureArray3Float3D;
                  this.formatValues = utils.erect3DArray3;
                  return null;
                } else if (this.output[1] > 0) {
                  this.TextureConstructor = GLTextureArray3Float2D;
                  this.formatValues = utils.erect2DArray3;
                  return null;
                } else {
                  this.TextureConstructor = GLTextureArray3Float;
                  this.formatValues = utils.erectArray3;
                  return null;
                }
              }
              case 'Array(4)': {
                if (this.output[2] > 0) {
                  this.TextureConstructor = GLTextureArray4Float3D;
                  this.formatValues = utils.erect3DArray4;
                  return null;
                } else if (this.output[1] > 0) {
                  this.TextureConstructor = GLTextureArray4Float2D;
                  this.formatValues = utils.erect2DArray4;
                  return null;
                } else {
                  this.TextureConstructor = GLTextureArray4Float;
                  this.formatValues = utils.erectArray4;
                  return null;
                }
              }
            }
          }
        } else {
          throw new Error(`unhandled precision of "${this.precision}"`);
        }

        throw new Error(`unhandled return type "${this.returnType}"`);
      }

      getKernelString() {
        throw new Error(`abstract method call`);
      }

      getMainResultTexture() {
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Float':
          case 'Integer':
          case 'Number':
            return this.getMainResultNumberTexture();
          case 'Array(2)':
            return this.getMainResultArray2Texture();
          case 'Array(3)':
            return this.getMainResultArray3Texture();
          case 'Array(4)':
            return this.getMainResultArray4Texture();
          default:
            throw new Error(`unhandled returnType type ${ this.returnType }`);
        }
      }

      getMainResultKernelNumberTexture() {
        throw new Error(`abstract method call`);
      }
      getMainResultSubKernelNumberTexture() {
        throw new Error(`abstract method call`);
      }
      getMainResultKernelArray2Texture() {
        throw new Error(`abstract method call`);
      }
      getMainResultSubKernelArray2Texture() {
        throw new Error(`abstract method call`);
      }
      getMainResultKernelArray3Texture() {
        throw new Error(`abstract method call`);
      }
      getMainResultSubKernelArray3Texture() {
        throw new Error(`abstract method call`);
      }
      getMainResultKernelArray4Texture() {
        throw new Error(`abstract method call`);
      }
      getMainResultSubKernelArray4Texture() {
        throw new Error(`abstract method call`);
      }
      getMainResultGraphical() {
        throw new Error(`abstract method call`);
      }
      getMainResultMemoryOptimizedFloats() {
        throw new Error(`abstract method call`);
      }
      getMainResultPackedPixels() {
        throw new Error(`abstract method call`);
      }

      getMainResultString() {
        if (this.graphical) {
          return this.getMainResultGraphical();
        } else if (this.precision === 'single') {
          if (this.optimizeFloatMemory) {
            return this.getMainResultMemoryOptimizedFloats();
          }
          return this.getMainResultTexture();
        } else {
          return this.getMainResultPackedPixels();
        }
      }

      getMainResultNumberTexture() {
        return utils.linesToString(this.getMainResultKernelNumberTexture()) +
          utils.linesToString(this.getMainResultSubKernelNumberTexture());
      }

      getMainResultArray2Texture() {
        return utils.linesToString(this.getMainResultKernelArray2Texture()) +
          utils.linesToString(this.getMainResultSubKernelArray2Texture());
      }

      getMainResultArray3Texture() {
        return utils.linesToString(this.getMainResultKernelArray3Texture()) +
          utils.linesToString(this.getMainResultSubKernelArray3Texture());
      }

      getMainResultArray4Texture() {
        return utils.linesToString(this.getMainResultKernelArray4Texture()) +
          utils.linesToString(this.getMainResultSubKernelArray4Texture());
      }

      getFloatTacticDeclaration() {
        const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);
        return `precision ${variablePrecision} float;\n`;
      }

      getIntTacticDeclaration() {
        return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic, true)} int;\n`;
      }

      getSampler2DTacticDeclaration() {
        return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2D;\n`;
      }

      getSampler2DArrayTacticDeclaration() {
        return `precision ${this.getVariablePrecisionString(this.texSize, this.tactic)} sampler2DArray;\n`;
      }

      renderTexture() {
        return this.immutable ? this.texture.clone() : this.texture;
      }
      readPackedPixelsToUint8Array() {
        if (this.precision !== 'unsigned') throw new Error('Requires this.precision to be "unsigned"');
        const {
          texSize,
          context: gl
        } = this;
        const result = new Uint8Array(texSize[0] * texSize[1] * 4);
        gl.readPixels(0, 0, texSize[0], texSize[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
        return result;
      }

      readPackedPixelsToFloat32Array() {
        return new Float32Array(this.readPackedPixelsToUint8Array().buffer);
      }

      readFloatPixelsToFloat32Array() {
        if (this.precision !== 'single') throw new Error('Requires this.precision to be "single"');
        const {
          texSize,
          context: gl
        } = this;
        const w = texSize[0];
        const h = texSize[1];
        const result = new Float32Array(w * h * 4);
        gl.readPixels(0, 0, w, h, gl.RGBA, gl.FLOAT, result);
        return result;
      }

      getPixels(flip) {
        const {
          context: gl,
          output
        } = this;
        const [width, height] = output;
        const pixels = new Uint8Array(width * height * 4);
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
        return new Uint8ClampedArray((flip ? pixels : utils.flipPixels(pixels, width, height)).buffer);
      }

      renderKernelsToArrays() {
        const result = {
          result: this.renderOutput(),
        };
        for (let i = 0; i < this.subKernels.length; i++) {
          result[this.subKernels[i].property] = this.mappedTextures[i].toArray();
        }
        return result;
      }

      renderKernelsToTextures() {
        const result = {
          result: this.renderOutput(),
        };
        if (this.immutable) {
          for (let i = 0; i < this.subKernels.length; i++) {
            result[this.subKernels[i].property] = this.mappedTextures[i].clone();
          }
        } else {
          for (let i = 0; i < this.subKernels.length; i++) {
            result[this.subKernels[i].property] = this.mappedTextures[i];
          }
        }
        return result;
      }

      resetSwitchingKernels() {
        const existingValue = this.switchingKernels;
        this.switchingKernels = null;
        return existingValue;
      }

      setOutput(output) {
        const newOutput = this.toKernelOutput(output);
        if (this.program) {
          if (!this.dynamicOutput) {
            throw new Error('Resizing a kernel with dynamicOutput: false is not possible');
          }
          const newThreadDim = [newOutput[0], newOutput[1] || 1, newOutput[2] || 1];
          const newTexSize = utils.getKernelTextureSize({
            optimizeFloatMemory: this.optimizeFloatMemory,
            precision: this.precision,
          }, newThreadDim);
          const oldTexSize = this.texSize;
          if (oldTexSize) {
            const oldPrecision = this.getVariablePrecisionString(oldTexSize, this.tactic);
            const newPrecision = this.getVariablePrecisionString(newTexSize, this.tactic);
            if (oldPrecision !== newPrecision) {
              if (this.debug) {
                console.warn('Precision requirement changed, asking GPU instance to recompile');
              }
              this.switchKernels({
                type: 'outputPrecisionMismatch',
                precision: newPrecision,
                needed: output
              });
              return;
            }
          }
          this.output = newOutput;
          this.threadDim = newThreadDim;
          this.texSize = newTexSize;
          const { context: gl } = this;
          gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
          this.updateMaxTexSize();
          this.framebuffer.width = this.texSize[0];
          this.framebuffer.height = this.texSize[1];
          gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
          this.canvas.width = this.maxTexSize[0];
          this.canvas.height = this.maxTexSize[1];
          if (this.texture) {
            this.texture.delete();
          }
          this.texture = null;
          this._setupOutputTexture();
          if (this.mappedTextures && this.mappedTextures.length > 0) {
            for (let i = 0; i < this.mappedTextures.length; i++) {
              this.mappedTextures[i].delete();
            }
            this.mappedTextures = null;
            this._setupSubOutputTextures();
          }
        } else {
          this.output = newOutput;
        }
        return this;
      }
      renderValues() {
        return this.formatValues(
          this.transferValues(),
          this.output[0],
          this.output[1],
          this.output[2]
        );
      }
      switchKernels(reason) {
        if (this.switchingKernels) {
          this.switchingKernels.push(reason);
        } else {
          this.switchingKernels = [reason];
        }
      }
      getVariablePrecisionString(textureSize = this.texSize, tactic = this.tactic, isInt = false) {
        if (!tactic) {
          if (!this.constructor.features.isSpeedTacticSupported) return 'highp';
          const low = this.constructor.features[isInt ? 'lowIntPrecision' : 'lowFloatPrecision'];
          const medium = this.constructor.features[isInt ? 'mediumIntPrecision' : 'mediumFloatPrecision'];
          const high = this.constructor.features[isInt ? 'highIntPrecision' : 'highFloatPrecision'];
          const requiredSize = Math.log2(textureSize[0] * textureSize[1]);
          if (requiredSize <= low.rangeMax) {
            return 'lowp';
          } else if (requiredSize <= medium.rangeMax) {
            return 'mediump';
          } else if (requiredSize <= high.rangeMax) {
            return 'highp';
          } else {
            throw new Error(`The required size exceeds that of the ability of your system`);
          }
        }
        switch (tactic) {
          case 'speed':
            return 'lowp';
          case 'balanced':
            return 'mediump';
          case 'precision':
            return 'highp';
          default:
            throw new Error(`Unknown tactic "${tactic}" use "speed", "balanced", "precision", or empty for auto`);
        }
      }

      updateTextureArgumentRefs(kernelValue, arg) {
        if (!this.immutable) return;
        if (this.texture.texture === arg.texture) {
          const { prevArg } = kernelValue;
          if (prevArg) {
            if (prevArg.texture._refs === 1) {
              this.texture.delete();
              this.texture = prevArg.clone();
              this._textureSwitched = true;
            }
            prevArg.delete();
          }
          kernelValue.prevArg = arg.clone();
        } else if (this.mappedTextures && this.mappedTextures.length > 0) {
          const { mappedTextures } = this;
          for (let i = 0; i < mappedTextures.length; i++) {
            const mappedTexture = mappedTextures[i];
            if (mappedTexture.texture === arg.texture) {
              const { prevArg } = kernelValue;
              if (prevArg) {
                if (prevArg.texture._refs === 1) {
                  mappedTexture.delete();
                  mappedTextures[i] = prevArg.clone();
                  this._mappedTextureSwitched[i] = true;
                }
                prevArg.delete();
              }
              kernelValue.prevArg = arg.clone();
              return;
            }
          }
        }
      }

      onActivate(previousKernel) {
        this._textureSwitched = true;
        this.texture = previousKernel.texture;
        if (this.mappedTextures) {
          for (let i = 0; i < this.mappedTextures.length; i++) {
            this._mappedTextureSwitched[i] = true;
          }
          this.mappedTextures = previousKernel.mappedTextures;
        }
      }

      initCanvas() {}
    }

    const typeMap = {
      int: 'Integer',
      float: 'Number',
      vec2: 'Array(2)',
      vec3: 'Array(3)',
      vec4: 'Array(4)',
    };

    module.exports = {
      GLKernel
    };
    },{"../../utils":114,"../kernel":36,"./texture/array-2-float":16,"./texture/array-2-float-2d":14,"./texture/array-2-float-3d":15,"./texture/array-3-float":19,"./texture/array-3-float-2d":17,"./texture/array-3-float-3d":18,"./texture/array-4-float":22,"./texture/array-4-float-2d":20,"./texture/array-4-float-3d":21,"./texture/float":25,"./texture/float-2d":23,"./texture/float-3d":24,"./texture/graphical":26,"./texture/memory-optimized":30,"./texture/memory-optimized-2d":28,"./texture/memory-optimized-3d":29,"./texture/unsigned":33,"./texture/unsigned-2d":31,"./texture/unsigned-3d":32}],14:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTextureFloat } = require('./float');

    class GLTextureArray2Float2D extends GLTextureFloat {
      constructor(settings) {
        super(settings);
        this.type = 'ArrayTexture(2)';
      }
      toArray() {
        return utils.erect2DArray2(this.renderValues(), this.output[0], this.output[1]);
      }
    }

    module.exports = {
      GLTextureArray2Float2D
    };
    },{"../../../utils":114,"./float":25}],15:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTextureFloat } = require('./float');

    class GLTextureArray2Float3D extends GLTextureFloat {
      constructor(settings) {
        super(settings);
        this.type = 'ArrayTexture(2)';
      }
      toArray() {
        return utils.erect3DArray2(this.renderValues(), this.output[0], this.output[1], this.output[2]);
      }
    }

    module.exports = {
      GLTextureArray2Float3D
    };
    },{"../../../utils":114,"./float":25}],16:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTextureFloat } = require('./float');

    class GLTextureArray2Float extends GLTextureFloat {
      constructor(settings) {
        super(settings);
        this.type = 'ArrayTexture(2)';
      }
      toArray() {
        return utils.erectArray2(this.renderValues(), this.output[0], this.output[1]);
      }
    }

    module.exports = {
      GLTextureArray2Float
    };
    },{"../../../utils":114,"./float":25}],17:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTextureFloat } = require('./float');

    class GLTextureArray3Float2D extends GLTextureFloat {
      constructor(settings) {
        super(settings);
        this.type = 'ArrayTexture(3)';
      }
      toArray() {
        return utils.erect2DArray3(this.renderValues(), this.output[0], this.output[1]);
      }
    }

    module.exports = {
      GLTextureArray3Float2D
    };
    },{"../../../utils":114,"./float":25}],18:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTextureFloat } = require('./float');

    class GLTextureArray3Float3D extends GLTextureFloat {
      constructor(settings) {
        super(settings);
        this.type = 'ArrayTexture(3)';
      }
      toArray() {
        return utils.erect3DArray3(this.renderValues(), this.output[0], this.output[1], this.output[2]);
      }
    }

    module.exports = {
      GLTextureArray3Float3D
    };
    },{"../../../utils":114,"./float":25}],19:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTextureFloat } = require('./float');

    class GLTextureArray3Float extends GLTextureFloat {
      constructor(settings) {
        super(settings);
        this.type = 'ArrayTexture(3)';
      }
      toArray() {
        return utils.erectArray3(this.renderValues(), this.output[0]);
      }
    }

    module.exports = {
      GLTextureArray3Float
    };
    },{"../../../utils":114,"./float":25}],20:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTextureFloat } = require('./float');

    class GLTextureArray4Float2D extends GLTextureFloat {
      constructor(settings) {
        super(settings);
        this.type = 'ArrayTexture(4)';
      }
      toArray() {
        return utils.erect2DArray4(this.renderValues(), this.output[0], this.output[1]);
      }
    }

    module.exports = {
      GLTextureArray4Float2D
    };
    },{"../../../utils":114,"./float":25}],21:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTextureFloat } = require('./float');

    class GLTextureArray4Float3D extends GLTextureFloat {
      constructor(settings) {
        super(settings);
        this.type = 'ArrayTexture(4)';
      }
      toArray() {
        return utils.erect3DArray4(this.renderValues(), this.output[0], this.output[1], this.output[2]);
      }
    }

    module.exports = {
      GLTextureArray4Float3D
    };
    },{"../../../utils":114,"./float":25}],22:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTextureFloat } = require('./float');

    class GLTextureArray4Float extends GLTextureFloat {
      constructor(settings) {
        super(settings);
        this.type = 'ArrayTexture(4)';
      }
      toArray() {
        return utils.erectArray4(this.renderValues(), this.output[0]);
      }
    }

    module.exports = {
      GLTextureArray4Float
    };
    },{"../../../utils":114,"./float":25}],23:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTextureFloat } = require('./float');

    class GLTextureFloat2D extends GLTextureFloat {
      constructor(settings) {
        super(settings);
        this.type = 'ArrayTexture(1)';
      }
      toArray() {
        return utils.erect2DFloat(this.renderValues(), this.output[0], this.output[1]);
      }
    }

    module.exports = {
      GLTextureFloat2D
    };
    },{"../../../utils":114,"./float":25}],24:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTextureFloat } = require('./float');

    class GLTextureFloat3D extends GLTextureFloat {
      constructor(settings) {
        super(settings);
        this.type = 'ArrayTexture(1)';
      }
      toArray() {
        return utils.erect3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
      }
    }

    module.exports = {
      GLTextureFloat3D
    };
    },{"../../../utils":114,"./float":25}],25:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTexture } = require('./index');

    class GLTextureFloat extends GLTexture {
      get textureType() {
        return this.context.FLOAT;
      }
      constructor(settings) {
        super(settings);
        this.type = 'ArrayTexture(1)';
      }
      renderRawOutput() {
        const gl = this.context;
        const size = this.size;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          gl.TEXTURE_2D,
          this.texture,
          0
        );
        const result = new Float32Array(size[0] * size[1] * 4);
        gl.readPixels(0, 0, size[0], size[1], gl.RGBA, gl.FLOAT, result);
        return result;
      }
      renderValues() {
        if (this._deleted) return null;
        return this.renderRawOutput();
      }
      toArray() {
        return utils.erectFloat(this.renderValues(), this.output[0]);
      }
    }

    module.exports = {
      GLTextureFloat
    };
    },{"../../../utils":114,"./index":27}],26:[function(require,module,exports){
    const { GLTextureUnsigned } = require('./unsigned');

    class GLTextureGraphical extends GLTextureUnsigned {
      constructor(settings) {
        super(settings);
        this.type = 'ArrayTexture(4)';
      }
      toArray() {
        return this.renderValues();
      }
    }

    module.exports = {
      GLTextureGraphical
    };
    },{"./unsigned":33}],27:[function(require,module,exports){
    const { Texture } = require('../../../texture');

    class GLTexture extends Texture {
      get textureType() {
        throw new Error(`"textureType" not implemented on ${ this.name }`);
      }

      clone() {
        return new this.constructor(this);
      }

      beforeMutate() {
        if (this.texture._refs > 1) {
          this.newTexture();
          return true;
        }
        return false;
      }

      cloneTexture() {
        this.texture._refs--;
        const { context: gl, size, texture, kernel } = this;
        if (kernel.debug) {
          console.warn('cloning internal texture');
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
        selectTexture(gl, texture);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        const target = gl.createTexture();
        selectTexture(gl, target);
        gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
        gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 0, 0, size[0], size[1]);
        target._refs = 1;
        this.texture = target;
      }

      newTexture() {
        this.texture._refs--;
        const gl = this.context;
        const size = this.size;
        const kernel = this.kernel;
        if (kernel.debug) {
          console.warn('new internal texture');
        }
        const target = gl.createTexture();
        selectTexture(gl, target);
        gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
        target._refs = 1;
        this.texture = target;
      }

      clear() {
        if (this.texture._refs) {
          this.texture._refs--;
          const gl = this.context;
          const target = this.texture = gl.createTexture();
          selectTexture(gl, target);
          const size = this.size;
          target._refs = 1;
          gl.texImage2D(gl.TEXTURE_2D, 0, this.internalFormat, size[0], size[1], 0, this.textureFormat, this.textureType, null);
        }
        const { context: gl, texture } = this;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
        gl.bindTexture(gl.TEXTURE_2D, texture);
        selectTexture(gl, texture);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        gl.clearColor(0, 0, 0, 0);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      }

      delete() {
        if (this._deleted) return;
        this._deleted = true;
        if (this.texture._refs) {
          this.texture._refs--;
          if (this.texture._refs) return;
        }
        this.context.deleteTexture(this.texture);
      }

      framebuffer() {
        if (!this._framebuffer) {
          this._framebuffer = this.kernel.getRawValueFramebuffer(this.size[0], this.size[1]);
        }
        return this._framebuffer;
      }
    }

    function selectTexture(gl, texture) {
      gl.activeTexture(gl.TEXTURE15);
      gl.bindTexture(gl.TEXTURE_2D, texture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    }

    module.exports = { GLTexture };
    },{"../../../texture":113}],28:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTextureFloat } = require('./float');

    class GLTextureMemoryOptimized2D extends GLTextureFloat {
      constructor(settings) {
        super(settings);
        this.type = 'MemoryOptimizedNumberTexture';
      }
      toArray() {
        return utils.erectMemoryOptimized2DFloat(this.renderValues(), this.output[0], this.output[1]);
      }
    }

    module.exports = {
      GLTextureMemoryOptimized2D
    };
    },{"../../../utils":114,"./float":25}],29:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTextureFloat } = require('./float');

    class GLTextureMemoryOptimized3D extends GLTextureFloat {
      constructor(settings) {
        super(settings);
        this.type = 'MemoryOptimizedNumberTexture';
      }
      toArray() {
        return utils.erectMemoryOptimized3DFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
      }
    }

    module.exports = {
      GLTextureMemoryOptimized3D
    };
    },{"../../../utils":114,"./float":25}],30:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTextureFloat } = require('./float');

    class GLTextureMemoryOptimized extends GLTextureFloat {
      constructor(settings) {
        super(settings);
        this.type = 'MemoryOptimizedNumberTexture';
      }
      toArray() {
        return utils.erectMemoryOptimizedFloat(this.renderValues(), this.output[0]);
      }
    }

    module.exports = {
      GLTextureMemoryOptimized
    };
    },{"../../../utils":114,"./float":25}],31:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTextureUnsigned } = require('./unsigned');

    class GLTextureUnsigned2D extends GLTextureUnsigned {
      constructor(settings) {
        super(settings);
        this.type = 'NumberTexture';
      }
      toArray() {
        return utils.erect2DPackedFloat(this.renderValues(), this.output[0], this.output[1]);
      }
    }

    module.exports = {
      GLTextureUnsigned2D
    };
    },{"../../../utils":114,"./unsigned":33}],32:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTextureUnsigned } = require('./unsigned');

    class GLTextureUnsigned3D extends GLTextureUnsigned {
      constructor(settings) {
        super(settings);
        this.type = 'NumberTexture';
      }
      toArray() {
        return utils.erect3DPackedFloat(this.renderValues(), this.output[0], this.output[1], this.output[2]);
      }
    }

    module.exports = {
      GLTextureUnsigned3D
    };
    },{"../../../utils":114,"./unsigned":33}],33:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { GLTexture } = require('./index');

    class GLTextureUnsigned extends GLTexture {
      get textureType() {
        return this.context.UNSIGNED_BYTE;
      }
      constructor(settings) {
        super(settings);
        this.type = 'NumberTexture';
      }
      renderRawOutput() {
        const { context: gl } = this;
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer());
        gl.framebufferTexture2D(
          gl.FRAMEBUFFER,
          gl.COLOR_ATTACHMENT0,
          gl.TEXTURE_2D,
          this.texture,
          0
        );
        const result = new Uint8Array(this.size[0] * this.size[1] * 4);
        gl.readPixels(0, 0, this.size[0], this.size[1], gl.RGBA, gl.UNSIGNED_BYTE, result);
        return result;
      }
      renderValues() {
        if (this._deleted) return null;
        return new Float32Array(this.renderRawOutput().buffer);
      }
      toArray() {
        return utils.erectPackedFloat(this.renderValues(), this.output[0]);
      }
    }

    module.exports = {
      GLTextureUnsigned
    };
    },{"../../../utils":114,"./index":27}],34:[function(require,module,exports){
    const getContext = require('gl');
    const { WebGLKernel } = require('../web-gl/kernel');
    const { glKernelString } = require('../gl/kernel-string');

    let isSupported = null;
    let testCanvas = null;
    let testContext = null;
    let testExtensions = null;
    let features = null;

    class HeadlessGLKernel extends WebGLKernel {
      static get isSupported() {
        if (isSupported !== null) return isSupported;
        this.setupFeatureChecks();
        isSupported = testContext !== null;
        return isSupported;
      }

      static setupFeatureChecks() {
        testCanvas = null;
        testExtensions = null;
        if (typeof getContext !== 'function') return;
        try { 
          testContext = getContext(2, 2, {
            preserveDrawingBuffer: true
          });
          if (!testContext || !testContext.getExtension) return;
          testExtensions = {
            STACKGL_resize_drawingbuffer: testContext.getExtension('STACKGL_resize_drawingbuffer'),
            STACKGL_destroy_context: testContext.getExtension('STACKGL_destroy_context'),
            OES_texture_float: testContext.getExtension('OES_texture_float'),
            OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
            OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
            WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),
            WEBGL_color_buffer_float: testContext.getExtension('WEBGL_color_buffer_float'),
          };
          features = this.getFeatures();
        } catch (e) {
          console.warn(e);
        }
      }

      static isContextMatch(context) {
        try {
          return context.getParameter(context.RENDERER) === 'ANGLE';
        } catch (e) {
          return false;
        }
      }

      static getIsTextureFloat() {
        return Boolean(testExtensions.OES_texture_float);
      }

      static getIsDrawBuffers() {
        return Boolean(testExtensions.WEBGL_draw_buffers);
      }

      static getChannelCount() {
        return testExtensions.WEBGL_draw_buffers ?
          testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :
          1;
      }

      static getMaxTextureSize() {
        return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
      }

      static get testCanvas() {
        return testCanvas;
      }

      static get testContext() {
        return testContext;
      }

      static get features() {
        return features;
      }

      initCanvas() {
        return {};
      }

      initContext() {
        return getContext(2, 2, {
          preserveDrawingBuffer: true
        });
      }

      initExtensions() {
        this.extensions = {
          STACKGL_resize_drawingbuffer: this.context.getExtension('STACKGL_resize_drawingbuffer'),
          STACKGL_destroy_context: this.context.getExtension('STACKGL_destroy_context'),
          OES_texture_float: this.context.getExtension('OES_texture_float'),
          OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
          OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
          WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
        };
      }

      build() {
        super.build.apply(this, arguments);
        if (!this.fallbackRequested) {
          this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
        }
      }

      destroyExtensions() {
        this.extensions.STACKGL_resize_drawingbuffer = null;
        this.extensions.STACKGL_destroy_context = null;
        this.extensions.OES_texture_float = null;
        this.extensions.OES_texture_float_linear = null;
        this.extensions.OES_element_index_uint = null;
        this.extensions.WEBGL_draw_buffers = null;
      }

      static destroyContext(context) {
        const extension = context.getExtension('STACKGL_destroy_context');
        if (extension && extension.destroy) {
          extension.destroy();
        }
      }

      toString() {
        const setupContextString = `const gl = context || require('gl')(1, 1);\n`;
        const destroyContextString = `    if (!context) { gl.getExtension('STACKGL_destroy_context').destroy(); }\n`;
        return glKernelString(this.constructor, arguments, this, setupContextString, destroyContextString);
      }

      setOutput(output) {
        super.setOutput(output);
        if (this.graphical && this.extensions.STACKGL_resize_drawingbuffer) {
          this.extensions.STACKGL_resize_drawingbuffer.resize(this.maxTexSize[0], this.maxTexSize[1]);
        }
        return this;
      }
    }

    module.exports = {
      HeadlessGLKernel
    };
    },{"../gl/kernel-string":12,"../web-gl/kernel":70,"gl":2}],35:[function(require,module,exports){
    class KernelValue {
      constructor(value, settings) {
        const {
          name,
          kernel,
          context,
          checkContext,
          onRequestContextHandle,
          onUpdateValueMismatch,
          origin,
          strictIntegers,
          type,
          tactic,
        } = settings;
        if (!name) {
          throw new Error('name not set');
        }
        if (!type) {
          throw new Error('type not set');
        }
        if (!origin) {
          throw new Error('origin not set');
        }
        if (origin !== 'user' && origin !== 'constants') {
          throw new Error(`origin must be "user" or "constants" value is "${ origin }"`);
        }
        if (!onRequestContextHandle) {
          throw new Error('onRequestContextHandle is not set');
        }
        this.name = name;
        this.origin = origin;
        this.tactic = tactic;
        this.varName = origin === 'constants' ? `constants.${name}` : name;
        this.kernel = kernel;
        this.strictIntegers = strictIntegers;
        this.type = value.type || type;
        this.size = value.size || null;
        this.index = null;
        this.context = context;
        this.checkContext = checkContext !== null && checkContext !== undefined ? checkContext : true;
        this.contextHandle = null;
        this.onRequestContextHandle = onRequestContextHandle;
        this.onUpdateValueMismatch = onUpdateValueMismatch;
        this.forceUploadEachRun = null;
      }

      get id() {
        return `${this.origin}_${name}`;
      }

      getSource() {
        throw new Error(`"getSource" not defined on ${ this.constructor.name }`);
      }

      updateValue(value) {
        throw new Error(`"updateValue" not defined on ${ this.constructor.name }`);
      }
    }

    module.exports = {
      KernelValue
    };
    },{}],36:[function(require,module,exports){
    const { utils } = require('../utils');
    const { Input } = require('../input');

    class Kernel {
      static get isSupported() {
        throw new Error(`"isSupported" not implemented on ${ this.name }`);
      }

      static isContextMatch(context) {
        throw new Error(`"isContextMatch" not implemented on ${ this.name }`);
      }

      static getFeatures() {
        throw new Error(`"getFeatures" not implemented on ${ this.name }`);
      }

      static destroyContext(context) {
        throw new Error(`"destroyContext" called on ${ this.name }`);
      }

      static nativeFunctionArguments() {
        throw new Error(`"nativeFunctionArguments" called on ${ this.name }`);
      }

      static nativeFunctionReturnType() {
        throw new Error(`"nativeFunctionReturnType" called on ${ this.name }`);
      }

      static combineKernels() {
        throw new Error(`"combineKernels" called on ${ this.name }`);
      }

      constructor(source, settings) {
        if (typeof source !== 'object') {
          if (typeof source !== 'string') {
            throw new Error('source not a string');
          }
          if (!utils.isFunctionString(source)) {
            throw new Error('source not a function string');
          }
        }
        this.useLegacyEncoder = false;
        this.fallbackRequested = false;
        this.onRequestFallback = null;

        this.argumentNames = typeof source === 'string' ? utils.getArgumentNamesFromString(source) : null;
        this.argumentTypes = null;
        this.argumentSizes = null;
        this.argumentBitRatios = null;
        this.kernelArguments = null;
        this.kernelConstants = null;
        this.forceUploadKernelConstants = null;


        this.source = source;

        this.output = null;

        this.debug = false;

        this.graphical = false;

        this.loopMaxIterations = 0;

        this.constants = null;

        this.constantTypes = null;

        this.constantBitRatios = null;

        this.dynamicArguments = false;

        this.dynamicOutput = false;

        this.canvas = null;

        this.context = null;

        this.checkContext = null;

        this.gpu = null;

        this.functions = null;

        this.nativeFunctions = null;

        this.injectedNative = null;

        this.subKernels = null;

        this.validate = true;

        this.immutable = false;

        this.pipeline = false;

        this.precision = null;

        this.tactic = null;

        this.plugins = null;

        this.returnType = null;
        this.leadingReturnStatement = null;
        this.followingReturnStatement = null;
        this.optimizeFloatMemory = null;
        this.strictIntegers = false;
        this.fixIntegerDivisionAccuracy = null;
        this.built = false;
        this.signature = null;
      }

      mergeSettings(settings) {
        for (let p in settings) {
          if (!settings.hasOwnProperty(p) || !this.hasOwnProperty(p)) continue;
          switch (p) {
            case 'output':
              if (!Array.isArray(settings.output)) {
                this.setOutput(settings.output); 
                continue;
              }
              break;
            case 'functions':
              this.functions = [];
              for (let i = 0; i < settings.functions.length; i++) {
                this.addFunction(settings.functions[i]);
              }
              continue;
            case 'graphical':
              if (settings[p] && !settings.hasOwnProperty('precision')) {
                this.precision = 'unsigned';
              }
              this[p] = settings[p];
              continue;
            case 'nativeFunctions':
              if (!settings.nativeFunctions) continue;
              this.nativeFunctions = [];
              for (let i = 0; i < settings.nativeFunctions.length; i++) {
                const s = settings.nativeFunctions[i];
                const { name, source } = s;
                this.addNativeFunction(name, source, s);
              }
              continue;
          }
          this[p] = settings[p];
        }

        if (!this.canvas) this.canvas = this.initCanvas();
        if (!this.context) this.context = this.initContext();
        if (!this.plugins) this.plugins = this.initPlugins(settings);
      }
      build() {
        throw new Error(`"build" not defined on ${ this.constructor.name }`);
      }

      run() {
        throw new Error(`"run" not defined on ${ this.constructor.name }`)
      }

      initCanvas() {
        throw new Error(`"initCanvas" not defined on ${ this.constructor.name }`);
      }

      initContext() {
        throw new Error(`"initContext" not defined on ${ this.constructor.name }`);
      }

      initPlugins(settings) {
        throw new Error(`"initPlugins" not defined on ${ this.constructor.name }`);
      }

      addFunction(source, settings = {}) {
        if (source.name && source.source && source.argumentTypes && 'returnType' in source) {
          this.functions.push(source);
        } else if ('settings' in source && 'source' in source) {
          this.functions.push(this.functionToIGPUFunction(source.source, source.settings));
        } else if (typeof source === 'string' || typeof source === 'function') {
          this.functions.push(this.functionToIGPUFunction(source, settings));
        } else {
          throw new Error(`function not properly defined`);
        }
        return this;
      }

      addNativeFunction(name, source, settings = {}) {
        const { argumentTypes, argumentNames } = settings.argumentTypes ?
          splitArgumentTypes(settings.argumentTypes) :
          this.constructor.nativeFunctionArguments(source) || {};
        this.nativeFunctions.push({
          name,
          source,
          settings,
          argumentTypes,
          argumentNames,
          returnType: settings.returnType || this.constructor.nativeFunctionReturnType(source)
        });
        return this;
      }

      setupArguments(args) {
        this.kernelArguments = [];
        if (!this.argumentTypes) {
          if (!this.argumentTypes) {
            this.argumentTypes = [];
            for (let i = 0; i < args.length; i++) {
              const argType = utils.getVariableType(args[i], this.strictIntegers);
              const type = argType === 'Integer' ? 'Number' : argType;
              this.argumentTypes.push(type);
              this.kernelArguments.push({
                type
              });
            }
          }
        } else {
          for (let i = 0; i < this.argumentTypes.length; i++) {
            this.kernelArguments.push({
              type: this.argumentTypes[i]
            });
          }
        }

        this.argumentSizes = new Array(args.length);
        this.argumentBitRatios = new Int32Array(args.length);

        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          this.argumentSizes[i] = arg.constructor === Input ? arg.size : null;
          this.argumentBitRatios[i] = this.getBitRatio(arg);
        }

        if (this.argumentNames.length !== args.length) {
          throw new Error(`arguments are miss-aligned`);
        }
      }

      setupConstants() {
        this.kernelConstants = [];
        let needsConstantTypes = this.constantTypes === null;
        if (needsConstantTypes) {
          this.constantTypes = {};
        }
        this.constantBitRatios = {};
        if (this.constants) {
          for (let name in this.constants) {
            if (needsConstantTypes) {
              const type = utils.getVariableType(this.constants[name], this.strictIntegers);
              this.constantTypes[name] = type;
              this.kernelConstants.push({
                name,
                type
              });
            } else {
              this.kernelConstants.push({
                name,
                type: this.constantTypes[name]
              });
            }
            this.constantBitRatios[name] = this.getBitRatio(this.constants[name]);
          }
        }
      }

      setOptimizeFloatMemory(flag) {
        this.optimizeFloatMemory = flag;
        return this;
      }

      toKernelOutput(output) {
        if (output.hasOwnProperty('x')) {
          if (output.hasOwnProperty('y')) {
            if (output.hasOwnProperty('z')) {
              return [output.x, output.y, output.z];
            } else {
              return [output.x, output.y];
            }
          } else {
            return [output.x];
          }
        } else {
          return output;
        }
      }

      setOutput(output) {
        this.output = this.toKernelOutput(output);
        return this;
      }

      setDebug(flag) {
        this.debug = flag;
        return this;
      }

      setGraphical(flag) {
        this.graphical = flag;
        this.precision = 'unsigned';
        return this;
      }

      setLoopMaxIterations(max) {
        this.loopMaxIterations = max;
        return this;
      }

      setConstants(constants) {
        this.constants = constants;
        return this;
      }

      setConstantTypes(constantTypes) {
        this.constantTypes = constantTypes;
        return this;
      }

      setFunctions(functions) {
        for (let i = 0; i < functions.length; i++) {
          this.addFunction(functions[i]);
        }
        return this;
      }

      setNativeFunctions(nativeFunctions) {
        for (let i = 0; i < nativeFunctions.length; i++) {
          const settings = nativeFunctions[i];
          const { name, source } = settings;
          this.addNativeFunction(name, source, settings);
        }
        return this;
      }

      setInjectedNative(injectedNative) {
        this.injectedNative = injectedNative;
        return this;
      }

      setPipeline(flag) {
        this.pipeline = flag;
        return this;
      }

      setPrecision(flag) {
        this.precision = flag;
        return this;
      }

      setDimensions(flag) {
        utils.warnDeprecated('method', 'setDimensions', 'setOutput');
        this.output = flag;
        return this;
      }

      setOutputToTexture(flag) {
        utils.warnDeprecated('method', 'setOutputToTexture', 'setPipeline');
        this.pipeline = flag;
        return this;
      }

      setImmutable(flag) {
        this.immutable = flag;
        return this;
      }

      setCanvas(canvas) {
        this.canvas = canvas;
        return this;
      }

      setStrictIntegers(flag) {
        this.strictIntegers = flag;
        return this;
      }

      setDynamicOutput(flag) {
        this.dynamicOutput = flag;
        return this;
      }

      setHardcodeConstants(flag) {
        utils.warnDeprecated('method', 'setHardcodeConstants');
        this.setDynamicOutput(flag);
        this.setDynamicArguments(flag);
        return this;
      }

      setDynamicArguments(flag) {
        this.dynamicArguments = flag;
        return this;
      }

      setUseLegacyEncoder(flag) {
        this.useLegacyEncoder = flag;
        return this;
      }

      setWarnVarUsage(flag) {
        utils.warnDeprecated('method', 'setWarnVarUsage');
        return this;
      }

      getCanvas() {
        utils.warnDeprecated('method', 'getCanvas');
        return this.canvas;
      }

      getWebGl() {
        utils.warnDeprecated('method', 'getWebGl');
        return this.context;
      }

      setContext(context) {
        this.context = context;
        return this;
      }

      setArgumentTypes(argumentTypes) {
        if (Array.isArray(argumentTypes)) {
          this.argumentTypes = argumentTypes;
        } else {
          this.argumentTypes = [];
          for (const p in argumentTypes) {
            if (!argumentTypes.hasOwnProperty(p)) continue;
            const argumentIndex = this.argumentNames.indexOf(p);
            if (argumentIndex === -1) throw new Error(`unable to find argument ${ p }`);
            this.argumentTypes[argumentIndex] = argumentTypes[p];
          }
        }
        return this;
      }

      setTactic(tactic) {
        this.tactic = tactic;
        return this;
      }

      requestFallback(args) {
        if (!this.onRequestFallback) {
          throw new Error(`"onRequestFallback" not defined on ${ this.constructor.name }`);
        }
        this.fallbackRequested = true;
        return this.onRequestFallback(args);
      }

      validateSettings() {
        throw new Error(`"validateSettings" not defined on ${ this.constructor.name }`);
      }

      addSubKernel(subKernel) {
        if (this.subKernels === null) {
          this.subKernels = [];
        }
        if (!subKernel.source) throw new Error('subKernel missing "source" property');
        if (!subKernel.property && isNaN(subKernel.property)) throw new Error('subKernel missing "property" property');
        if (!subKernel.name) throw new Error('subKernel missing "name" property');
        this.subKernels.push(subKernel);
        return this;
      }

      destroy(removeCanvasReferences) {
        throw new Error(`"destroy" called on ${ this.constructor.name }`);
      }

      getBitRatio(value) {
        if (this.precision === 'single') {
          return 4;
        } else if (Array.isArray(value[0])) {
          return this.getBitRatio(value[0]);
        } else if (value.constructor === Input) {
          return this.getBitRatio(value.value);
        }
        switch (value.constructor) {
          case Uint8ClampedArray:
          case Uint8Array:
          case Int8Array:
            return 1;
          case Uint16Array:
          case Int16Array:
            return 2;
          case Float32Array:
          case Int32Array:
          default:
            return 4;
        }
      }

      getPixels(flip) {
        throw new Error(`"getPixels" called on ${ this.constructor.name }`);
      }

      checkOutput() {
        if (!this.output || !utils.isArray(this.output)) throw new Error('kernel.output not an array');
        if (this.output.length < 1) throw new Error('kernel.output is empty, needs at least 1 value');
        for (let i = 0; i < this.output.length; i++) {
          if (isNaN(this.output[i]) || this.output[i] < 1) {
            throw new Error(`${ this.constructor.name }.output[${ i }] incorrectly defined as \`${ this.output[i] }\`, needs to be numeric, and greater than 0`);
          }
        }
      }

      prependString(value) {
        throw new Error(`"prependString" called on ${ this.constructor.name }`);
      }

      hasPrependString(value) {
        throw new Error(`"hasPrependString" called on ${ this.constructor.name }`);
      }

      toJSON() {
        return {
          settings: {
            output: this.output,
            pipeline: this.pipeline,
            argumentNames: this.argumentNames,
            argumentsTypes: this.argumentTypes,
            constants: this.constants,
            pluginNames: this.plugins ? this.plugins.map(plugin => plugin.name) : null,
            returnType: this.returnType,
          }
        };
      }

      buildSignature(args) {
        const Constructor = this.constructor;
        this.signature = Constructor.getSignature(this, Constructor.getArgumentTypes(this, args));
      }

      static getArgumentTypes(kernel, args) {
        const argumentTypes = new Array(args.length);
        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          const type = kernel.argumentTypes[i];
          if (arg.type) {
            argumentTypes[i] = arg.type;
          } else {
            switch (type) {
              case 'Number':
              case 'Integer':
              case 'Float':
              case 'ArrayTexture(1)':
                argumentTypes[i] = utils.getVariableType(arg);
                break;
              default:
                argumentTypes[i] = type;
            }
          }
        }
        return argumentTypes;
      }

      static getSignature(kernel, argumentTypes) {
        throw new Error(`"getSignature" not implemented on ${ this.name }`);
      }

      functionToIGPUFunction(source, settings = {}) {
        if (typeof source !== 'string' && typeof source !== 'function') throw new Error('source not a string or function');
        const sourceString = typeof source === 'string' ? source : source.toString();
        let argumentTypes = [];

        if (Array.isArray(settings.argumentTypes)) {
          argumentTypes = settings.argumentTypes;
        } else if (typeof settings.argumentTypes === 'object') {
          argumentTypes = utils.getArgumentNamesFromString(sourceString)
            .map(name => settings.argumentTypes[name]) || [];
        } else {
          argumentTypes = settings.argumentTypes || [];
        }

        return {
          name: utils.getFunctionNameFromString(sourceString) || null,
          source: sourceString,
          argumentTypes,
          returnType: settings.returnType || null,
        };
      }

      onActivate(previousKernel) {}
    }

    function splitArgumentTypes(argumentTypesObject) {
      const argumentNames = Object.keys(argumentTypesObject);
      const argumentTypes = [];
      for (let i = 0; i < argumentNames.length; i++) {
        const argumentName = argumentNames[i];
        argumentTypes.push(argumentTypesObject[argumentName]);
      }
      return { argumentTypes, argumentNames };
    }

    module.exports = {
      Kernel
    };
    },{"../input":110,"../utils":114}],37:[function(require,module,exports){
    const fragmentShader = `__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

varying vec2 vTexCoord;

float acosh(float x) {
  return log(x + sqrt(x * x - 1.0));
}

float sinh(float x) {
  return (pow(${Math.E}, x) - pow(${Math.E}, -x)) / 2.0;
}

float asinh(float x) {
  return log(x + sqrt(x * x + 1.0));
}

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float atanh(float x) {
  x = (x + 1.0) / (x - 1.0);
  if (x < 0.0) {
    return 0.5 * log(-x);
  }
  return 0.5 * log(x);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float cosh(float x) {
  return (pow(${Math.E}, x) + pow(${Math.E}, -x)) / 2.0; 
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float tanh(float x) {
  float e = exp(2.0 * x);
  return (e - 1.0) / (e + 1.0);
}

float trunc(float x) {
  if (x >= 0.0) {
    return floor(x); 
  } else {
    return ceil(x);
  }
}

vec4 _round(vec4 x) {
  return floor(x + 0.5);
}

float _round(float x) {
  return floor(x + 0.5);
}

const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x / y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY\'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(_round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(_round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  if (channel == 0) return texel.r * 255.0 + texel.g * 65280.0;
  if (channel == 1) return texel.b * 255.0 + texel.a * 65280.0;
  return 0.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  if (channel == 0) return texel.r * 255.0;
  if (channel == 1) return texel.g * 255.0;
  if (channel == 2) return texel.b * 255.0;
  if (channel == 3) return texel.a * 255.0;
  return 0.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return texel.r;
  if (channel == 1) return texel.g;
  if (channel == 2) return texel.b;
  if (channel == 3) return texel.a;
  return 0.0;
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture2D(tex, st / vec2(texSize));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture2D(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));
  
  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture2D(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture2D(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

void color(sampler2D image) {
  actualColor = texture2D(image, vTexCoord);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;

    module.exports = {
      fragmentShader
    };
    },{}],38:[function(require,module,exports){
    const { utils } = require('../../utils');
    const { FunctionNode } = require('../function-node');

    class WebGLFunctionNode extends FunctionNode {
      constructor(source, settings) {
        super(source, settings);
        if (settings && settings.hasOwnProperty('fixIntegerDivisionAccuracy')) {
          this.fixIntegerDivisionAccuracy = settings.fixIntegerDivisionAccuracy;
        }
      }

      astConditionalExpression(ast, retArr) {
        if (ast.type !== 'ConditionalExpression') {
          throw this.astErrorOutput('Not a conditional expression', ast);
        }
        const consequentType = this.getType(ast.consequent);
        const alternateType = this.getType(ast.alternate);
        if (consequentType === null && alternateType === null) {
          retArr.push('if (');
          this.astGeneric(ast.test, retArr);
          retArr.push(') {');
          this.astGeneric(ast.consequent, retArr);
          retArr.push(';');
          retArr.push('} else {');
          this.astGeneric(ast.alternate, retArr);
          retArr.push(';');
          retArr.push('}');
          return retArr;
        }
        retArr.push('(');
        this.astGeneric(ast.test, retArr);
        retArr.push('?');
        this.astGeneric(ast.consequent, retArr);
        retArr.push(':');
        this.astGeneric(ast.alternate, retArr);
        retArr.push(')');
        return retArr;
      }

      astFunction(ast, retArr) {
        if (this.isRootKernel) {
          retArr.push('void');
        } else {
          if (!this.returnType) {
            const lastReturn = this.findLastReturn();
            if (lastReturn) {
              this.returnType = this.getType(ast.body);
              if (this.returnType === 'LiteralInteger') {
                this.returnType = 'Number';
              }
            }
          }

          const { returnType } = this;
          if (!returnType) {
            retArr.push('void');
          } else {
            const type = typeMap[returnType];
            if (!type) {
              throw new Error(`unknown type ${returnType}`);
            }
            retArr.push(type);
          }
        }
        retArr.push(' ');
        retArr.push(this.name);
        retArr.push('(');

        if (!this.isRootKernel) {
          for (let i = 0; i < this.argumentNames.length; ++i) {
            const argumentName = this.argumentNames[i];

            if (i > 0) {
              retArr.push(', ');
            }
            let argumentType = this.argumentTypes[this.argumentNames.indexOf(argumentName)];
            if (!argumentType) {
              throw this.astErrorOutput(`Unknown argument ${argumentName} type`, ast);
            }
            if (argumentType === 'LiteralInteger') {
              this.argumentTypes[i] = argumentType = 'Number';
            }
            const type = typeMap[argumentType];
            if (!type) {
              throw this.astErrorOutput('Unexpected expression', ast);
            }
            const name = utils.sanitizeName(argumentName);
            if (type === 'sampler2D' || type === 'sampler2DArray') {
              retArr.push(`${type} user_${name},ivec2 user_${name}Size,ivec3 user_${name}Dim`);
            } else {
              retArr.push(`${type} user_${name}`);
            }
          }
        }

        retArr.push(') {\n');

        for (let i = 0; i < ast.body.body.length; ++i) {
          this.astGeneric(ast.body.body[i], retArr);
          retArr.push('\n');
        }

        retArr.push('}\n');
        return retArr;
      }

      astReturnStatement(ast, retArr) {
        if (!ast.argument) throw this.astErrorOutput('Unexpected return statement', ast);
        this.pushState('skip-literal-correction');
        const type = this.getType(ast.argument);
        this.popState('skip-literal-correction');

        const result = [];

        if (!this.returnType) {
          if (type === 'LiteralInteger' || type === 'Integer') {
            this.returnType = 'Number';
          } else {
            this.returnType = type;
          }
        }

        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Number':
          case 'Float':
            switch (type) {
              case 'Integer':
                result.push('float(');
                this.astGeneric(ast.argument, result);
                result.push(')');
                break;
              case 'LiteralInteger':
                this.castLiteralToFloat(ast.argument, result);

                if (this.getType(ast) === 'Integer') {
                  result.unshift('float(');
                  result.push(')');
                }
                break;
              default:
                this.astGeneric(ast.argument, result);
            }
            break;
          case 'Integer':
            switch (type) {
              case 'Float':
              case 'Number':
                this.castValueToInteger(ast.argument, result);
                break;
              case 'LiteralInteger':
                this.castLiteralToInteger(ast.argument, result);
                break;
              default:
                this.astGeneric(ast.argument, result);
            }
            break;
          case 'Array(4)':
          case 'Array(3)':
          case 'Array(2)':
          case 'Matrix(2)':
          case 'Matrix(3)':
          case 'Matrix(4)':
          case 'Input':
            this.astGeneric(ast.argument, result);
            break;
          default:
            throw this.astErrorOutput(`unhandled return type ${this.returnType}`, ast);
        }

        if (this.isRootKernel) {
          retArr.push(`kernelResult = ${ result.join('') };`);
          retArr.push('return;');
        } else if (this.isSubKernel) {
          retArr.push(`subKernelResult_${ this.name } = ${ result.join('') };`);
          retArr.push(`return subKernelResult_${ this.name };`);
        } else {
          retArr.push(`return ${ result.join('') };`);
        }
        return retArr;
      }

      astLiteral(ast, retArr) {
        if (isNaN(ast.value)) {
          throw this.astErrorOutput(
            'Non-numeric literal not supported : ' + ast.value,
            ast
          );
        }

        const key = this.astKey(ast);
        if (Number.isInteger(ast.value)) {
          if (this.isState('casting-to-integer') || this.isState('building-integer')) {
            this.literalTypes[key] = 'Integer';
            retArr.push(`${ast.value}`);
          } else if (this.isState('casting-to-float') || this.isState('building-float')) {
            this.literalTypes[key] = 'Number';
            retArr.push(`${ast.value}.0`);
          } else {
            this.literalTypes[key] = 'Number';
            retArr.push(`${ast.value}.0`);
          }
        } else if (this.isState('casting-to-integer') || this.isState('building-integer')) {
          this.literalTypes[key] = 'Integer';
          retArr.push(Math.round(ast.value));
        } else {
          this.literalTypes[key] = 'Number';
          retArr.push(`${ast.value}`);
        }
        return retArr;
      }

      astBinaryExpression(ast, retArr) {
        if (this.checkAndUpconvertOperator(ast, retArr)) {
          return retArr;
        }

        if (this.fixIntegerDivisionAccuracy && ast.operator === '/') {
          retArr.push('divWithIntCheck(');
          this.pushState('building-float');
          switch (this.getType(ast.left)) {
            case 'Integer':
              this.castValueToFloat(ast.left, retArr);
              break;
            case 'LiteralInteger':
              this.castLiteralToFloat(ast.left, retArr);
              break;
            default:
              this.astGeneric(ast.left, retArr);
          }
          retArr.push(', ');
          switch (this.getType(ast.right)) {
            case 'Integer':
              this.castValueToFloat(ast.right, retArr);
              break;
            case 'LiteralInteger':
              this.castLiteralToFloat(ast.right, retArr);
              break;
            default:
              this.astGeneric(ast.right, retArr);
          }
          this.popState('building-float');
          retArr.push(')');
          return retArr;
        }

        retArr.push('(');
        const leftType = this.getType(ast.left) || 'Number';
        const rightType = this.getType(ast.right) || 'Number';
        if (!leftType || !rightType) {
          throw this.astErrorOutput(`Unhandled binary expression`, ast);
        }
        const key = leftType + ' & ' + rightType;
        switch (key) {
          case 'Integer & Integer':
            this.pushState('building-integer');
            this.astGeneric(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.astGeneric(ast.right, retArr);
            this.popState('building-integer');
            break;
          case 'Number & Float':
          case 'Float & Number':
          case 'Float & Float':
          case 'Number & Number':
            this.pushState('building-float');
            this.astGeneric(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.astGeneric(ast.right, retArr);
            this.popState('building-float');
            break;
          case 'LiteralInteger & LiteralInteger':
            if (this.isState('casting-to-integer') || this.isState('building-integer')) {
              this.pushState('building-integer');
              this.astGeneric(ast.left, retArr);
              retArr.push(operatorMap[ast.operator] || ast.operator);
              this.astGeneric(ast.right, retArr);
              this.popState('building-integer');
            } else {
              this.pushState('building-float');
              this.castLiteralToFloat(ast.left, retArr);
              retArr.push(operatorMap[ast.operator] || ast.operator);
              this.castLiteralToFloat(ast.right, retArr);
              this.popState('building-float');
            }
            break;

          case 'Integer & Float':
          case 'Integer & Number':
            if (ast.operator === '>' || ast.operator === '<' && ast.right.type === 'Literal') {
              if (!Number.isInteger(ast.right.value)) {
                this.pushState('building-float');
                this.castValueToFloat(ast.left, retArr);
                retArr.push(operatorMap[ast.operator] || ast.operator);
                this.astGeneric(ast.right, retArr);
                this.popState('building-float');
                break;
              }
            }
            this.pushState('building-integer');
            this.astGeneric(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.pushState('casting-to-integer');
            if (ast.right.type === 'Literal') {
              const literalResult = [];
              this.astGeneric(ast.right, literalResult);
              const literalType = this.getType(ast.right);
              if (literalType === 'Integer') {
                retArr.push(literalResult.join(''));
              } else {
                throw this.astErrorOutput(`Unhandled binary expression with literal`, ast);
              }
            } else {
              retArr.push('int(');
              this.astGeneric(ast.right, retArr);
              retArr.push(')');
            }
            this.popState('casting-to-integer');
            this.popState('building-integer');
            break;
          case 'Integer & LiteralInteger':
            this.pushState('building-integer');
            this.astGeneric(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.castLiteralToInteger(ast.right, retArr);
            this.popState('building-integer');
            break;

          case 'Number & Integer':
            this.pushState('building-float');
            this.astGeneric(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.castValueToFloat(ast.right, retArr);
            this.popState('building-float');
            break;
          case 'Float & LiteralInteger':
          case 'Number & LiteralInteger':
            this.pushState('building-float');
            this.astGeneric(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.castLiteralToFloat(ast.right, retArr);
            this.popState('building-float');
            break;
          case 'LiteralInteger & Float':
          case 'LiteralInteger & Number':
            if (this.isState('casting-to-integer')) {
              this.pushState('building-integer');
              this.castLiteralToInteger(ast.left, retArr);
              retArr.push(operatorMap[ast.operator] || ast.operator);
              this.castValueToInteger(ast.right, retArr);
              this.popState('building-integer');
            } else {
              this.pushState('building-float');
              this.astGeneric(ast.left, retArr);
              retArr.push(operatorMap[ast.operator] || ast.operator);
              this.pushState('casting-to-float');
              this.astGeneric(ast.right, retArr);
              this.popState('casting-to-float');
              this.popState('building-float');
            }
            break;
          case 'LiteralInteger & Integer':
            this.pushState('building-integer');
            this.castLiteralToInteger(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.astGeneric(ast.right, retArr);
            this.popState('building-integer');
            break;

          case 'Boolean & Boolean':
            this.pushState('building-boolean');
            this.astGeneric(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.astGeneric(ast.right, retArr);
            this.popState('building-boolean');
            break;

          case 'Float & Integer':
            this.pushState('building-float');
            this.astGeneric(ast.left, retArr);
            retArr.push(operatorMap[ast.operator] || ast.operator);
            this.castValueToFloat(ast.right, retArr);
            this.popState('building-float');
            break;

          default:
            throw this.astErrorOutput(`Unhandled binary expression between ${key}`, ast);
        }
        retArr.push(')');

        return retArr;
      }

      checkAndUpconvertOperator(ast, retArr) {
        const bitwiseResult = this.checkAndUpconvertBitwiseOperators(ast, retArr);
        if (bitwiseResult) {
          return bitwiseResult;
        }
        const upconvertableOperators = {
          '%': this.fixIntegerDivisionAccuracy ? 'integerCorrectionModulo' : 'modulo',
          '**': 'pow',
        };
        const foundOperator = upconvertableOperators[ast.operator];
        if (!foundOperator) return null;
        retArr.push(foundOperator);
        retArr.push('(');
        switch (this.getType(ast.left)) {
          case 'Integer':
            this.castValueToFloat(ast.left, retArr);
            break;
          case 'LiteralInteger':
            this.castLiteralToFloat(ast.left, retArr);
            break;
          default:
            this.astGeneric(ast.left, retArr);
        }
        retArr.push(',');
        switch (this.getType(ast.right)) {
          case 'Integer':
            this.castValueToFloat(ast.right, retArr);
            break;
          case 'LiteralInteger':
            this.castLiteralToFloat(ast.right, retArr);
            break;
          default:
            this.astGeneric(ast.right, retArr);
        }
        retArr.push(')');
        return retArr;
      }

      checkAndUpconvertBitwiseOperators(ast, retArr) {
        const upconvertableOperators = {
          '&': 'bitwiseAnd',
          '|': 'bitwiseOr',
          '^': 'bitwiseXOR',
          '<<': 'bitwiseZeroFillLeftShift',
          '>>': 'bitwiseSignedRightShift',
          '>>>': 'bitwiseZeroFillRightShift',
        };
        const foundOperator = upconvertableOperators[ast.operator];
        if (!foundOperator) return null;
        retArr.push(foundOperator);
        retArr.push('(');
        const leftType = this.getType(ast.left);
        switch (leftType) {
          case 'Number':
          case 'Float':
            this.castValueToInteger(ast.left, retArr);
            break;
          case 'LiteralInteger':
            this.castLiteralToInteger(ast.left, retArr);
            break;
          default:
            this.astGeneric(ast.left, retArr);
        }
        retArr.push(',');
        const rightType = this.getType(ast.right);
        switch (rightType) {
          case 'Number':
          case 'Float':
            this.castValueToInteger(ast.right, retArr);
            break;
          case 'LiteralInteger':
            this.castLiteralToInteger(ast.right, retArr);
            break;
          default:
            this.astGeneric(ast.right, retArr);
        }
        retArr.push(')');
        return retArr;
      }

      checkAndUpconvertBitwiseUnary(ast, retArr) {
        const upconvertableOperators = {
          '~': 'bitwiseNot',
        };
        const foundOperator = upconvertableOperators[ast.operator];
        if (!foundOperator) return null;
        retArr.push(foundOperator);
        retArr.push('(');
        switch (this.getType(ast.argument)) {
          case 'Number':
          case 'Float':
            this.castValueToInteger(ast.argument, retArr);
            break;
          case 'LiteralInteger':
            this.castLiteralToInteger(ast.argument, retArr);
            break;
          default:
            this.astGeneric(ast.argument, retArr);
        }
        retArr.push(')');
        return retArr;
      }

      castLiteralToInteger(ast, retArr) {
        this.pushState('casting-to-integer');
        this.astGeneric(ast, retArr);
        this.popState('casting-to-integer');
        return retArr;
      }

      castLiteralToFloat(ast, retArr) {
        this.pushState('casting-to-float');
        this.astGeneric(ast, retArr);
        this.popState('casting-to-float');
        return retArr;
      }

      castValueToInteger(ast, retArr) {
        this.pushState('casting-to-integer');
        retArr.push('int(');
        this.astGeneric(ast, retArr);
        retArr.push(')');
        this.popState('casting-to-integer');
        return retArr;
      }

      castValueToFloat(ast, retArr) {
        this.pushState('casting-to-float');
        retArr.push('float(');
        this.astGeneric(ast, retArr);
        retArr.push(')');
        this.popState('casting-to-float');
        return retArr;
      }

      astIdentifierExpression(idtNode, retArr) {
        if (idtNode.type !== 'Identifier') {
          throw this.astErrorOutput('IdentifierExpression - not an Identifier', idtNode);
        }

        const type = this.getType(idtNode);

        const name = utils.sanitizeName(idtNode.name);
        if (idtNode.name === 'Infinity') {
          retArr.push('3.402823466e+38');
        } else if (type === 'Boolean') {
          if (this.argumentNames.indexOf(name) > -1) {
            retArr.push(`bool(user_${name})`);
          } else {
            retArr.push(`user_${name}`);
          }
        } else {
          retArr.push(`user_${name}`);
        }

        return retArr;
      }

      astForStatement(forNode, retArr) {
        if (forNode.type !== 'ForStatement') {
          throw this.astErrorOutput('Invalid for statement', forNode);
        }

        const initArr = [];
        const testArr = [];
        const updateArr = [];
        const bodyArr = [];
        let isSafe = null;

        if (forNode.init) {
          const { declarations } = forNode.init;
          if (declarations.length > 1) {
            isSafe = false;
          }
          this.astGeneric(forNode.init, initArr);
          for (let i = 0; i < declarations.length; i++) {
            if (declarations[i].init && declarations[i].init.type !== 'Literal') {
              isSafe = false;
            }
          }
        } else {
          isSafe = false;
        }

        if (forNode.test) {
          this.astGeneric(forNode.test, testArr);
        } else {
          isSafe = false;
        }

        if (forNode.update) {
          this.astGeneric(forNode.update, updateArr);
        } else {
          isSafe = false;
        }

        if (forNode.body) {
          this.pushState('loop-body');
          this.astGeneric(forNode.body, bodyArr);
          this.popState('loop-body');
        }

        if (isSafe === null) {
          isSafe = this.isSafe(forNode.init) && this.isSafe(forNode.test);
        }

        if (isSafe) {
          const initString = initArr.join('');
          const initNeedsSemiColon = initString[initString.length - 1] !== ';';
          retArr.push(`for (${initString}${initNeedsSemiColon ? ';' : ''}${testArr.join('')};${updateArr.join('')}){\n`);
          retArr.push(bodyArr.join(''));
          retArr.push('}\n');
        } else {
          const iVariableName = this.getInternalVariableName('safeI');
          if (initArr.length > 0) {
            retArr.push(initArr.join(''), '\n');
          }
          retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
          if (testArr.length > 0) {
            retArr.push(`if (!${testArr.join('')}) break;\n`);
          }
          retArr.push(bodyArr.join(''));
          retArr.push(`\n${updateArr.join('')};`);
          retArr.push('}\n');
        }
        return retArr;
      }

      astWhileStatement(whileNode, retArr) {
        if (whileNode.type !== 'WhileStatement') {
          throw this.astErrorOutput('Invalid while statement', whileNode);
        }

        const iVariableName = this.getInternalVariableName('safeI');
        retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
        retArr.push('if (!');
        this.astGeneric(whileNode.test, retArr);
        retArr.push(') break;\n');
        this.astGeneric(whileNode.body, retArr);
        retArr.push('}\n');

        return retArr;
      }

      astDoWhileStatement(doWhileNode, retArr) {
        if (doWhileNode.type !== 'DoWhileStatement') {
          throw this.astErrorOutput('Invalid while statement', doWhileNode);
        }

        const iVariableName = this.getInternalVariableName('safeI');
        retArr.push(`for (int ${iVariableName}=0;${iVariableName}<LOOP_MAX;${iVariableName}++){\n`);
        this.astGeneric(doWhileNode.body, retArr);
        retArr.push('if (!');
        this.astGeneric(doWhileNode.test, retArr);
        retArr.push(') break;\n');
        retArr.push('}\n');

        return retArr;
      }


      astAssignmentExpression(assNode, retArr) {
        if (assNode.operator === '%=') {
          this.astGeneric(assNode.left, retArr);
          retArr.push('=');
          retArr.push('mod(');
          this.astGeneric(assNode.left, retArr);
          retArr.push(',');
          this.astGeneric(assNode.right, retArr);
          retArr.push(')');
        } else if (assNode.operator === '**=') {
          this.astGeneric(assNode.left, retArr);
          retArr.push('=');
          retArr.push('pow(');
          this.astGeneric(assNode.left, retArr);
          retArr.push(',');
          this.astGeneric(assNode.right, retArr);
          retArr.push(')');
        } else {
          const leftType = this.getType(assNode.left);
          const rightType = this.getType(assNode.right);
          this.astGeneric(assNode.left, retArr);
          retArr.push(assNode.operator);
          if (leftType !== 'Integer' && rightType === 'Integer') {
            retArr.push('float(');
            this.astGeneric(assNode.right, retArr);
            retArr.push(')');
          } else {
            this.astGeneric(assNode.right, retArr);
          }
          return retArr;
        }
      }

      astBlockStatement(bNode, retArr) {
        if (this.isState('loop-body')) {
          this.pushState('block-body'); 
          for (let i = 0; i < bNode.body.length; i++) {
            this.astGeneric(bNode.body[i], retArr);
          }
          this.popState('block-body');
        } else {
          retArr.push('{\n');
          for (let i = 0; i < bNode.body.length; i++) {
            this.astGeneric(bNode.body[i], retArr);
          }
          retArr.push('}\n');
        }
        return retArr;
      }

      astVariableDeclaration(varDecNode, retArr) {
        const declarations = varDecNode.declarations;
        if (!declarations || !declarations[0] || !declarations[0].init) {
          throw this.astErrorOutput('Unexpected expression', varDecNode);
        }
        const result = [];
        let lastType = null;
        const declarationSets = [];
        let declarationSet = [];
        for (let i = 0; i < declarations.length; i++) {
          const declaration = declarations[i];
          const init = declaration.init;
          const info = this.getDeclaration(declaration.id);
          const actualType = this.getType(declaration.init);
          let type = actualType;
          if (type === 'LiteralInteger') {
            if (info.suggestedType === 'Integer') {
              type = 'Integer';
            } else {
              type = 'Number';
            }
          }
          const markupType = typeMap[type];
          if (!markupType) {
            throw this.astErrorOutput(`Markup type ${ type } not handled`, varDecNode);
          }
          const declarationResult = [];
          if (actualType === 'Integer' && type === 'Integer') {
            info.valueType = 'Number';
            if (i === 0 || lastType === null) {
              declarationResult.push('float ');
            } else if (type !== lastType) {
              throw new Error('Unhandled declaration');
            }
            lastType = type;
            declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);
            declarationResult.push('float(');
            this.astGeneric(init, declarationResult);
            declarationResult.push(')');
          } else {
            info.valueType = type;
            if (i === 0 || lastType === null) {
              declarationResult.push(`${markupType} `);
            } else if (type !== lastType) {
              declarationSets.push(declarationSet.join(','));
              declarationSet = [];
              declarationResult.push(`${markupType} `);
            }
            lastType = type;
            declarationResult.push(`user_${utils.sanitizeName(declaration.id.name)}=`);
            if (actualType === 'Number' && type === 'Integer') {
              if (init.left && init.left.type === 'Literal') {
                this.astGeneric(init, declarationResult);
              } else {
                declarationResult.push('int(');
                this.astGeneric(init, declarationResult);
                declarationResult.push(')');
              }
            } else if (actualType === 'LiteralInteger' && type === 'Integer') {
              this.castLiteralToInteger(init, declarationResult);
            } else {
              this.astGeneric(init, declarationResult);
            }
          }
          declarationSet.push(declarationResult.join(''));
        }

        if (declarationSet.length > 0) {
          declarationSets.push(declarationSet.join(','));
        }

        result.push(declarationSets.join(';'));

        retArr.push(result.join(''));
        retArr.push(';');
        return retArr;
      }

      astIfStatement(ifNode, retArr) {
        retArr.push('if (');
        this.astGeneric(ifNode.test, retArr);
        retArr.push(')');
        if (ifNode.consequent.type === 'BlockStatement') {
          this.astGeneric(ifNode.consequent, retArr);
        } else {
          retArr.push(' {\n');
          this.astGeneric(ifNode.consequent, retArr);
          retArr.push('\n}\n');
        }

        if (ifNode.alternate) {
          retArr.push('else ');
          if (ifNode.alternate.type === 'BlockStatement' || ifNode.alternate.type === 'IfStatement') {
            this.astGeneric(ifNode.alternate, retArr);
          } else {
            retArr.push(' {\n');
            this.astGeneric(ifNode.alternate, retArr);
            retArr.push('\n}\n');
          }
        }
        return retArr;
      }

      astSwitchStatement(ast, retArr) {
        if (ast.type !== 'SwitchStatement') {
          throw this.astErrorOutput('Invalid switch statement', ast);
        }
        const { discriminant, cases } = ast;
        const type = this.getType(discriminant);
        const varName = `switchDiscriminant${this.astKey(ast, '_')}`;
        switch (type) {
          case 'Float':
          case 'Number':
            retArr.push(`float ${varName} = `);
            this.astGeneric(discriminant, retArr);
            retArr.push(';\n');
            break;
          case 'Integer':
            retArr.push(`int ${varName} = `);
            this.astGeneric(discriminant, retArr);
            retArr.push(';\n');
            break;
        }
        if (cases.length === 1 && !cases[0].test) {
          this.astGeneric(cases[0].consequent, retArr);
          return retArr;
        }

        let fallingThrough = false;
        let defaultResult = [];
        let movingDefaultToEnd = false;
        let pastFirstIf = false;
        for (let i = 0; i < cases.length; i++) {
          if (!cases[i].test) {
            if (cases.length > i + 1) {
              movingDefaultToEnd = true;
              this.astGeneric(cases[i].consequent, defaultResult);
              continue;
            } else {
              retArr.push(' else {\n');
            }
          } else {
            if (i === 0 || !pastFirstIf) {
              pastFirstIf = true;
              retArr.push(`if (${varName} == `);
            } else {
              if (fallingThrough) {
                retArr.push(`${varName} == `);
                fallingThrough = false;
              } else {
                retArr.push(` else if (${varName} == `);
              }
            }
            if (type === 'Integer') {
              const testType = this.getType(cases[i].test);
              switch (testType) {
                case 'Number':
                case 'Float':
                  this.castValueToInteger(cases[i].test, retArr);
                  break;
                case 'LiteralInteger':
                  this.castLiteralToInteger(cases[i].test, retArr);
                  break;
              }
            } else if (type === 'Float') {
              const testType = this.getType(cases[i].test);
              switch (testType) {
                case 'LiteralInteger':
                  this.castLiteralToFloat(cases[i].test, retArr);
                  break;
                case 'Integer':
                  this.castValueToFloat(cases[i].test, retArr);
                  break;
              }
            } else {
              throw new Error('unhanlded');
            }
            if (!cases[i].consequent || cases[i].consequent.length === 0) {
              fallingThrough = true;
              retArr.push(' || ');
              continue;
            }
            retArr.push(`) {\n`);
          }
          this.astGeneric(cases[i].consequent, retArr);
          retArr.push('\n}');
        }
        if (movingDefaultToEnd) {
          retArr.push(' else {');
          retArr.push(defaultResult.join(''));
          retArr.push('}');
        }
        return retArr;
      }

      astThisExpression(tNode, retArr) {
        retArr.push('this');
        return retArr;
      }

      astMemberExpression(mNode, retArr) {
        const {
          property,
          name,
          signature,
          origin,
          type,
          xProperty,
          yProperty,
          zProperty
        } = this.getMemberExpressionDetails(mNode);
        switch (signature) {
          case 'value.thread.value':
          case 'this.thread.value':
            if (name !== 'x' && name !== 'y' && name !== 'z') {
              throw this.astErrorOutput('Unexpected expression, expected `this.thread.x`, `this.thread.y`, or `this.thread.z`', mNode);
            }
            retArr.push(`threadId.${name}`);
            return retArr;
          case 'this.output.value':
            if (this.dynamicOutput) {
              switch (name) {
                case 'x':
                  if (this.isState('casting-to-float')) {
                    retArr.push('float(uOutputDim.x)');
                  } else {
                    retArr.push('uOutputDim.x');
                  }
                  break;
                case 'y':
                  if (this.isState('casting-to-float')) {
                    retArr.push('float(uOutputDim.y)');
                  } else {
                    retArr.push('uOutputDim.y');
                  }
                  break;
                case 'z':
                  if (this.isState('casting-to-float')) {
                    retArr.push('float(uOutputDim.z)');
                  } else {
                    retArr.push('uOutputDim.z');
                  }
                  break;
                default:
                  throw this.astErrorOutput('Unexpected expression', mNode);
              }
            } else {
              switch (name) {
                case 'x':
                  if (this.isState('casting-to-integer')) {
                    retArr.push(this.output[0]);
                  } else {
                    retArr.push(this.output[0], '.0');
                  }
                  break;
                case 'y':
                  if (this.isState('casting-to-integer')) {
                    retArr.push(this.output[1]);
                  } else {
                    retArr.push(this.output[1], '.0');
                  }
                  break;
                case 'z':
                  if (this.isState('casting-to-integer')) {
                    retArr.push(this.output[2]);
                  } else {
                    retArr.push(this.output[2], '.0');
                  }
                  break;
                default:
                  throw this.astErrorOutput('Unexpected expression', mNode);
              }
            }
            return retArr;
          case 'value':
            throw this.astErrorOutput('Unexpected expression', mNode);
          case 'value[]':
          case 'value[][]':
          case 'value[][][]':
          case 'value[][][][]':
          case 'value.value':
            if (origin === 'Math') {
              retArr.push(Math[name]);
              return retArr;
            }
            const cleanName = utils.sanitizeName(name);
            switch (property) {
              case 'r':
                retArr.push(`user_${ cleanName }.r`);
                return retArr;
              case 'g':
                retArr.push(`user_${ cleanName }.g`);
                return retArr;
              case 'b':
                retArr.push(`user_${ cleanName }.b`);
                return retArr;
              case 'a':
                retArr.push(`user_${ cleanName }.a`);
                return retArr;
            }
            break;
          case 'this.constants.value':
            if (typeof xProperty === 'undefined') {
              switch (type) {
                case 'Array(2)':
                case 'Array(3)':
                case 'Array(4)':
                  retArr.push(`constants_${ utils.sanitizeName(name) }`);
                  return retArr;
              }
            }
            case 'this.constants.value[]':
            case 'this.constants.value[][]':
            case 'this.constants.value[][][]':
            case 'this.constants.value[][][][]':
              break;
            case 'fn()[]':
              this.astCallExpression(mNode.object, retArr);
              retArr.push('[');
              retArr.push(this.memberExpressionPropertyMarkup(property));
              retArr.push(']');
              return retArr;
            case 'fn()[][]':
              this.astCallExpression(mNode.object.object, retArr);
              retArr.push('[');
              retArr.push(this.memberExpressionPropertyMarkup(mNode.object.property));
              retArr.push(']');
              retArr.push('[');
              retArr.push(this.memberExpressionPropertyMarkup(mNode.property));
              retArr.push(']');
              return retArr;
            case '[][]':
              this.astArrayExpression(mNode.object, retArr);
              retArr.push('[');
              retArr.push(this.memberExpressionPropertyMarkup(property));
              retArr.push(']');
              return retArr;
            default:
              throw this.astErrorOutput('Unexpected expression', mNode);
        }

        if (mNode.computed === false) {
          switch (type) {
            case 'Number':
            case 'Integer':
            case 'Float':
            case 'Boolean':
              retArr.push(`${origin}_${utils.sanitizeName(name)}`);
              return retArr;
          }
        }

        const markupName = `${origin}_${utils.sanitizeName(name)}`;

        switch (type) {
          case 'Array(2)':
          case 'Array(3)':
          case 'Array(4)':
            this.astGeneric(mNode.object, retArr);
            retArr.push('[');
            retArr.push(this.memberExpressionPropertyMarkup(xProperty));
            retArr.push(']');
            break;
          case 'HTMLImageArray':
            retArr.push(`getImage3D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
            this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
            retArr.push(')');
            break;
          case 'ArrayTexture(1)':
            retArr.push(`getFloatFromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
            this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
            retArr.push(')');
            break;
          case 'Array1D(2)':
          case 'Array2D(2)':
          case 'Array3D(2)':
            retArr.push(`getMemoryOptimizedVec2(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
            this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
            retArr.push(')');
            break;
          case 'ArrayTexture(2)':
            retArr.push(`getVec2FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
            this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
            retArr.push(')');
            break;
          case 'Array1D(3)':
          case 'Array2D(3)':
          case 'Array3D(3)':
            retArr.push(`getMemoryOptimizedVec3(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
            this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
            retArr.push(')');
            break;
          case 'ArrayTexture(3)':
            retArr.push(`getVec3FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
            this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
            retArr.push(')');
            break;
          case 'Array1D(4)':
          case 'Array2D(4)':
          case 'Array3D(4)':
            retArr.push(`getMemoryOptimizedVec4(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
            this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
            retArr.push(')');
            break;
          case 'ArrayTexture(4)':
          case 'HTMLCanvas':
          case 'OffscreenCanvas':
          case 'HTMLImage':
          case 'ImageBitmap':
          case 'ImageData':
          case 'HTMLVideo':
            retArr.push(`getVec4FromSampler2D(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
            this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
            retArr.push(')');
            break;
          case 'NumberTexture':
          case 'Array':
          case 'Array2D':
          case 'Array3D':
          case 'Array4D':
          case 'Input':
          case 'Number':
          case 'Float':
          case 'Integer':
            if (this.precision === 'single') {
              retArr.push(`getMemoryOptimized32(${markupName}, ${markupName}Size, ${markupName}Dim, `);
              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
              retArr.push(')');
            } else {
              const bitRatio = (origin === 'user' ?
                this.lookupFunctionArgumentBitRatio(this.name, name) :
                this.constantBitRatios[name]
              );
              switch (bitRatio) {
                case 1:
                  retArr.push(`get8(${markupName}, ${markupName}Size, ${markupName}Dim, `);
                  break;
                case 2:
                  retArr.push(`get16(${markupName}, ${markupName}Size, ${markupName}Dim, `);
                  break;
                case 4:
                case 0:
                  retArr.push(`get32(${markupName}, ${markupName}Size, ${markupName}Dim, `);
                  break;
                default:
                  throw new Error(`unhandled bit ratio of ${bitRatio}`);
              }
              this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
              retArr.push(')');
            }
            break;
          case 'MemoryOptimizedNumberTexture':
            retArr.push(`getMemoryOptimized32(${ markupName }, ${ markupName }Size, ${ markupName }Dim, `);
            this.memberExpressionXYZ(xProperty, yProperty, zProperty, retArr);
            retArr.push(')');
            break;
          case 'Matrix(2)':
          case 'Matrix(3)':
          case 'Matrix(4)':
            retArr.push(`${markupName}[${this.memberExpressionPropertyMarkup(yProperty)}]`);
            if (yProperty) {
              retArr.push(`[${this.memberExpressionPropertyMarkup(xProperty)}]`);
            }
            break;
          default:
            throw new Error(`unhandled member expression "${ type }"`);
        }
        return retArr;
      }

      astCallExpression(ast, retArr) {
        if (!ast.callee) {
          throw this.astErrorOutput('Unknown CallExpression', ast);
        }

        let functionName = null;
        const isMathFunction = this.isAstMathFunction(ast);

        if (isMathFunction || (ast.callee.object && ast.callee.object.type === 'ThisExpression')) {
          functionName = ast.callee.property.name;
        }
        else if (ast.callee.type === 'SequenceExpression' && ast.callee.expressions[0].type === 'Literal' && !isNaN(ast.callee.expressions[0].raw)) {
          functionName = ast.callee.expressions[1].property.name;
        } else {
          functionName = ast.callee.name;
        }

        if (!functionName) {
          throw this.astErrorOutput(`Unhandled function, couldn't find name`, ast);
        }

        switch (functionName) {
          case 'pow':
            functionName = '_pow';
            break;
          case 'round':
            functionName = '_round';
            break;
        }

        if (this.calledFunctions.indexOf(functionName) < 0) {
          this.calledFunctions.push(functionName);
        }

        if (functionName === 'random' && this.plugins && this.plugins.length > 0) {
          for (let i = 0; i < this.plugins.length; i++) {
            const plugin = this.plugins[i];
            if (plugin.functionMatch === 'Math.random()' && plugin.functionReplace) {
              retArr.push(plugin.functionReplace);
              return retArr;
            }
          }
        }

        if (this.onFunctionCall) {
          this.onFunctionCall(this.name, functionName, ast.arguments);
        }

        retArr.push(functionName);

        retArr.push('(');

        if (isMathFunction) {
          for (let i = 0; i < ast.arguments.length; ++i) {
            const argument = ast.arguments[i];
            const argumentType = this.getType(argument);
            if (i > 0) {
              retArr.push(', ');
            }

            switch (argumentType) {
              case 'Integer':
                this.castValueToFloat(argument, retArr);
                break;
              default:
                this.astGeneric(argument, retArr);
                break;
            }
          }
        } else {
          const targetTypes = this.lookupFunctionArgumentTypes(functionName) || [];
          for (let i = 0; i < ast.arguments.length; ++i) {
            const argument = ast.arguments[i];
            let targetType = targetTypes[i];
            if (i > 0) {
              retArr.push(', ');
            }
            const argumentType = this.getType(argument);
            if (!targetType) {
              this.triggerImplyArgumentType(functionName, i, argumentType, this);
              targetType = argumentType;
            }
            switch (argumentType) {
              case 'Boolean':
                this.astGeneric(argument, retArr);
                continue;
              case 'Number':
              case 'Float':
                if (targetType === 'Integer') {
                  retArr.push('int(');
                  this.astGeneric(argument, retArr);
                  retArr.push(')');
                  continue;
                } else if (targetType === 'Number' || targetType === 'Float') {
                  this.astGeneric(argument, retArr);
                  continue;
                } else if (targetType === 'LiteralInteger') {
                  this.castLiteralToFloat(argument, retArr);
                  continue;
                }
                break;
              case 'Integer':
                if (targetType === 'Number' || targetType === 'Float') {
                  retArr.push('float(');
                  this.astGeneric(argument, retArr);
                  retArr.push(')');
                  continue;
                } else if (targetType === 'Integer') {
                  this.astGeneric(argument, retArr);
                  continue;
                }
                break;
              case 'LiteralInteger':
                if (targetType === 'Integer') {
                  this.castLiteralToInteger(argument, retArr);
                  continue;
                } else if (targetType === 'Number' || targetType === 'Float') {
                  this.castLiteralToFloat(argument, retArr);
                  continue;
                } else if (targetType === 'LiteralInteger') {
                  this.astGeneric(argument, retArr);
                  continue;
                }
                break;
              case 'Array(2)':
              case 'Array(3)':
              case 'Array(4)':
                if (targetType === argumentType) {
                  if (argument.type === 'Identifier') {
                    retArr.push(`user_${utils.sanitizeName(argument.name)}`);
                  } else if (argument.type === 'ArrayExpression' || argument.type === 'MemberExpression' || argument.type === 'CallExpression') {
                    this.astGeneric(argument, retArr);
                  } else {
                    throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);
                  }
                  continue;
                }
                break;
              case 'HTMLCanvas':
              case 'OffscreenCanvas':
              case 'HTMLImage':
              case 'ImageBitmap':
              case 'ImageData':
              case 'HTMLImageArray':
              case 'HTMLVideo':
              case 'ArrayTexture(1)':
              case 'ArrayTexture(2)':
              case 'ArrayTexture(3)':
              case 'ArrayTexture(4)':
              case 'Array':
              case 'Input':
                if (targetType === argumentType) {
                  if (argument.type !== 'Identifier') throw this.astErrorOutput(`Unhandled argument type ${ argument.type }`, ast);
                  this.triggerImplyArgumentBitRatio(this.name, argument.name, functionName, i);
                  const name = utils.sanitizeName(argument.name);
                  retArr.push(`user_${name},user_${name}Size,user_${name}Dim`);
                  continue;
                }
                break;
            }
            throw this.astErrorOutput(`Unhandled argument combination of ${ argumentType } and ${ targetType } for argument named "${ argument.name }"`, ast);
          }
        }
        retArr.push(')');

        return retArr;
      }

      astArrayExpression(arrNode, retArr) {
        const returnType = this.getType(arrNode);

        const arrLen = arrNode.elements.length;

        switch (returnType) {
          case 'Matrix(2)':
          case 'Matrix(3)':
          case 'Matrix(4)':
            retArr.push(`mat${arrLen}(`);
            break;
          default:
            retArr.push(`vec${arrLen}(`);
        }
        for (let i = 0; i < arrLen; ++i) {
          if (i > 0) {
            retArr.push(', ');
          }
          const subNode = arrNode.elements[i];
          this.astGeneric(subNode, retArr);
        }
        retArr.push(')');

        return retArr;
      }

      memberExpressionXYZ(x, y, z, retArr) {
        if (z) {
          retArr.push(this.memberExpressionPropertyMarkup(z), ', ');
        } else {
          retArr.push('0, ');
        }
        if (y) {
          retArr.push(this.memberExpressionPropertyMarkup(y), ', ');
        } else {
          retArr.push('0, ');
        }
        retArr.push(this.memberExpressionPropertyMarkup(x));
        return retArr;
      }

      memberExpressionPropertyMarkup(property) {
        if (!property) {
          throw new Error('Property not set');
        }
        const type = this.getType(property);
        const result = [];
        switch (type) {
          case 'Number':
          case 'Float':
            this.castValueToInteger(property, result);
            break;
          case 'LiteralInteger':
            this.castLiteralToInteger(property, result);
            break;
          default:
            this.astGeneric(property, result);
        }
        return result.join('');
      }
    }

    const typeMap = {
      'Array': 'sampler2D',
      'Array(2)': 'vec2',
      'Array(3)': 'vec3',
      'Array(4)': 'vec4',
      'Matrix(2)': 'mat2',
      'Matrix(3)': 'mat3',
      'Matrix(4)': 'mat4',
      'Array2D': 'sampler2D',
      'Array3D': 'sampler2D',
      'Boolean': 'bool',
      'Float': 'float',
      'Input': 'sampler2D',
      'Integer': 'int',
      'Number': 'float',
      'LiteralInteger': 'float',
      'NumberTexture': 'sampler2D',
      'MemoryOptimizedNumberTexture': 'sampler2D',
      'ArrayTexture(1)': 'sampler2D',
      'ArrayTexture(2)': 'sampler2D',
      'ArrayTexture(3)': 'sampler2D',
      'ArrayTexture(4)': 'sampler2D',
      'HTMLVideo': 'sampler2D',
      'HTMLCanvas': 'sampler2D',
      'OffscreenCanvas': 'sampler2D',
      'HTMLImage': 'sampler2D',
      'ImageBitmap': 'sampler2D',
      'ImageData': 'sampler2D',
      'HTMLImageArray': 'sampler2DArray',
    };

    const operatorMap = {
      '===': '==',
      '!==': '!='
    };

    module.exports = {
      WebGLFunctionNode
    };
    },{"../../utils":114,"../function-node":10}],39:[function(require,module,exports){
    const { WebGLKernelValueBoolean } = require('./kernel-value/boolean');
    const { WebGLKernelValueFloat } = require('./kernel-value/float');
    const { WebGLKernelValueInteger } = require('./kernel-value/integer');

    const { WebGLKernelValueHTMLImage } = require('./kernel-value/html-image');
    const { WebGLKernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');

    const { WebGLKernelValueHTMLVideo } = require('./kernel-value/html-video');
    const { WebGLKernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');

    const { WebGLKernelValueSingleInput } = require('./kernel-value/single-input');
    const { WebGLKernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');

    const { WebGLKernelValueUnsignedInput } = require('./kernel-value/unsigned-input');
    const { WebGLKernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');

    const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');
    const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');

    const { WebGLKernelValueNumberTexture } = require('./kernel-value/number-texture');
    const { WebGLKernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');

    const { WebGLKernelValueSingleArray } = require('./kernel-value/single-array');
    const { WebGLKernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');

    const { WebGLKernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');
    const { WebGLKernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');

    const { WebGLKernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');
    const { WebGLKernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');

    const { WebGLKernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');
    const { WebGLKernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');

    const { WebGLKernelValueArray2 } = require('./kernel-value/array2');
    const { WebGLKernelValueArray3 } = require('./kernel-value/array3');
    const { WebGLKernelValueArray4 } = require('./kernel-value/array4');

    const { WebGLKernelValueUnsignedArray } = require('./kernel-value/unsigned-array');
    const { WebGLKernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');

    const kernelValueMaps = {
      unsigned: {
        dynamic: {
          'Boolean': WebGLKernelValueBoolean,
          'Integer': WebGLKernelValueInteger,
          'Float': WebGLKernelValueFloat,
          'Array': WebGLKernelValueDynamicUnsignedArray,
          'Array(2)': WebGLKernelValueArray2,
          'Array(3)': WebGLKernelValueArray3,
          'Array(4)': WebGLKernelValueArray4,
          'Array1D(2)': false,
          'Array1D(3)': false,
          'Array1D(4)': false,
          'Array2D(2)': false,
          'Array2D(3)': false,
          'Array2D(4)': false,
          'Array3D(2)': false,
          'Array3D(3)': false,
          'Array3D(4)': false,
          'Input': WebGLKernelValueDynamicUnsignedInput,
          'NumberTexture': WebGLKernelValueDynamicNumberTexture,
          'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,
          'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,
          'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,
          'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,
          'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
          'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,
          'OffscreenCanvas': WebGLKernelValueDynamicHTMLImage,
          'HTMLImage': WebGLKernelValueDynamicHTMLImage,
          'ImageBitmap': WebGLKernelValueDynamicHTMLImage,
          'ImageData': WebGLKernelValueDynamicHTMLImage,
          'HTMLImageArray': false,
          'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,
        },
        static: {
          'Boolean': WebGLKernelValueBoolean,
          'Float': WebGLKernelValueFloat,
          'Integer': WebGLKernelValueInteger,
          'Array': WebGLKernelValueUnsignedArray,
          'Array(2)': WebGLKernelValueArray2,
          'Array(3)': WebGLKernelValueArray3,
          'Array(4)': WebGLKernelValueArray4,
          'Array1D(2)': false,
          'Array1D(3)': false,
          'Array1D(4)': false,
          'Array2D(2)': false,
          'Array2D(3)': false,
          'Array2D(4)': false,
          'Array3D(2)': false,
          'Array3D(3)': false,
          'Array3D(4)': false,
          'Input': WebGLKernelValueUnsignedInput,
          'NumberTexture': WebGLKernelValueNumberTexture,
          'ArrayTexture(1)': WebGLKernelValueNumberTexture,
          'ArrayTexture(2)': WebGLKernelValueNumberTexture,
          'ArrayTexture(3)': WebGLKernelValueNumberTexture,
          'ArrayTexture(4)': WebGLKernelValueNumberTexture,
          'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,
          'HTMLCanvas': WebGLKernelValueHTMLImage,
          'OffscreenCanvas': WebGLKernelValueHTMLImage,
          'HTMLImage': WebGLKernelValueHTMLImage,
          'ImageBitmap': WebGLKernelValueHTMLImage,
          'ImageData': WebGLKernelValueHTMLImage,
          'HTMLImageArray': false,
          'HTMLVideo': WebGLKernelValueHTMLVideo,
        }
      },
      single: {
        dynamic: {
          'Boolean': WebGLKernelValueBoolean,
          'Integer': WebGLKernelValueInteger,
          'Float': WebGLKernelValueFloat,
          'Array': WebGLKernelValueDynamicSingleArray,
          'Array(2)': WebGLKernelValueArray2,
          'Array(3)': WebGLKernelValueArray3,
          'Array(4)': WebGLKernelValueArray4,
          'Array1D(2)': WebGLKernelValueDynamicSingleArray1DI,
          'Array1D(3)': WebGLKernelValueDynamicSingleArray1DI,
          'Array1D(4)': WebGLKernelValueDynamicSingleArray1DI,
          'Array2D(2)': WebGLKernelValueDynamicSingleArray2DI,
          'Array2D(3)': WebGLKernelValueDynamicSingleArray2DI,
          'Array2D(4)': WebGLKernelValueDynamicSingleArray2DI,
          'Array3D(2)': WebGLKernelValueDynamicSingleArray3DI,
          'Array3D(3)': WebGLKernelValueDynamicSingleArray3DI,
          'Array3D(4)': WebGLKernelValueDynamicSingleArray3DI,
          'Input': WebGLKernelValueDynamicSingleInput,
          'NumberTexture': WebGLKernelValueDynamicNumberTexture,
          'ArrayTexture(1)': WebGLKernelValueDynamicNumberTexture,
          'ArrayTexture(2)': WebGLKernelValueDynamicNumberTexture,
          'ArrayTexture(3)': WebGLKernelValueDynamicNumberTexture,
          'ArrayTexture(4)': WebGLKernelValueDynamicNumberTexture,
          'MemoryOptimizedNumberTexture': WebGLKernelValueDynamicMemoryOptimizedNumberTexture,
          'HTMLCanvas': WebGLKernelValueDynamicHTMLImage,
          'OffscreenCanvas': WebGLKernelValueDynamicHTMLImage,
          'HTMLImage': WebGLKernelValueDynamicHTMLImage,
          'ImageBitmap': WebGLKernelValueDynamicHTMLImage,
          'ImageData': WebGLKernelValueDynamicHTMLImage,
          'HTMLImageArray': false,
          'HTMLVideo': WebGLKernelValueDynamicHTMLVideo,
        },
        static: {
          'Boolean': WebGLKernelValueBoolean,
          'Float': WebGLKernelValueFloat,
          'Integer': WebGLKernelValueInteger,
          'Array': WebGLKernelValueSingleArray,
          'Array(2)': WebGLKernelValueArray2,
          'Array(3)': WebGLKernelValueArray3,
          'Array(4)': WebGLKernelValueArray4,
          'Array1D(2)': WebGLKernelValueSingleArray1DI,
          'Array1D(3)': WebGLKernelValueSingleArray1DI,
          'Array1D(4)': WebGLKernelValueSingleArray1DI,
          'Array2D(2)': WebGLKernelValueSingleArray2DI,
          'Array2D(3)': WebGLKernelValueSingleArray2DI,
          'Array2D(4)': WebGLKernelValueSingleArray2DI,
          'Array3D(2)': WebGLKernelValueSingleArray3DI,
          'Array3D(3)': WebGLKernelValueSingleArray3DI,
          'Array3D(4)': WebGLKernelValueSingleArray3DI,
          'Input': WebGLKernelValueSingleInput,
          'NumberTexture': WebGLKernelValueNumberTexture,
          'ArrayTexture(1)': WebGLKernelValueNumberTexture,
          'ArrayTexture(2)': WebGLKernelValueNumberTexture,
          'ArrayTexture(3)': WebGLKernelValueNumberTexture,
          'ArrayTexture(4)': WebGLKernelValueNumberTexture,
          'MemoryOptimizedNumberTexture': WebGLKernelValueMemoryOptimizedNumberTexture,
          'HTMLCanvas': WebGLKernelValueHTMLImage,
          'OffscreenCanvas': WebGLKernelValueHTMLImage,
          'HTMLImage': WebGLKernelValueHTMLImage,
          'ImageBitmap': WebGLKernelValueHTMLImage,
          'ImageData': WebGLKernelValueHTMLImage,
          'HTMLImageArray': false,
          'HTMLVideo': WebGLKernelValueHTMLVideo,
        }
      },
    };

    function lookupKernelValueType(type, dynamic, precision, value) {
      if (!type) {
        throw new Error('type missing');
      }
      if (!dynamic) {
        throw new Error('dynamic missing');
      }
      if (!precision) {
        throw new Error('precision missing');
      }
      if (value.type) {
        type = value.type;
      }
      const types = kernelValueMaps[precision][dynamic];
      if (types[type] === false) {
        return null;
      } else if (types[type] === undefined) {
        throw new Error(`Could not find a KernelValue for ${ type }`);
      }
      return types[type];
    }

    module.exports = {
      lookupKernelValueType,
      kernelValueMaps,
    };
    },{"./kernel-value/array2":41,"./kernel-value/array3":42,"./kernel-value/array4":43,"./kernel-value/boolean":44,"./kernel-value/dynamic-html-image":45,"./kernel-value/dynamic-html-video":46,"./kernel-value/dynamic-memory-optimized-number-texture":47,"./kernel-value/dynamic-number-texture":48,"./kernel-value/dynamic-single-array":49,"./kernel-value/dynamic-single-array1d-i":50,"./kernel-value/dynamic-single-array2d-i":51,"./kernel-value/dynamic-single-array3d-i":52,"./kernel-value/dynamic-single-input":53,"./kernel-value/dynamic-unsigned-array":54,"./kernel-value/dynamic-unsigned-input":55,"./kernel-value/float":56,"./kernel-value/html-image":57,"./kernel-value/html-video":58,"./kernel-value/integer":60,"./kernel-value/memory-optimized-number-texture":61,"./kernel-value/number-texture":62,"./kernel-value/single-array":63,"./kernel-value/single-array1d-i":64,"./kernel-value/single-array2d-i":65,"./kernel-value/single-array3d-i":66,"./kernel-value/single-input":67,"./kernel-value/unsigned-array":68,"./kernel-value/unsigned-input":69}],40:[function(require,module,exports){
    const { WebGLKernelValue } = require('./index');
    const { Input } = require('../../../input');

    class WebGLKernelArray extends WebGLKernelValue {
      checkSize(width, height) {
        if (!this.kernel.validate) return;
        const { maxTextureSize } = this.kernel.constructor.features;
        if (width > maxTextureSize || height > maxTextureSize) {
          if (width > height) {
            throw new Error(`Argument texture width of ${width} larger than maximum size of ${maxTextureSize} for your GPU`);
          } else if (width < height) {
            throw new Error(`Argument texture height of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);
          } else {
            throw new Error(`Argument texture height and width of ${height} larger than maximum size of ${maxTextureSize} for your GPU`);
          }
        }
      }

      setup() {
        this.requestTexture();
        this.setupTexture();
        this.defineTexture();
      }

      requestTexture() {
        this.texture = this.onRequestTexture();
      }

      defineTexture() {
        const { context: gl } = this;
        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      }

      setupTexture() {
        this.contextHandle = this.onRequestContextHandle();
        this.index = this.onRequestIndex();
        this.dimensionsId = this.id + 'Dim';
        this.sizeId = this.id + 'Size';
      }

      getBitRatio(value) {
        if (Array.isArray(value[0])) {
          return this.getBitRatio(value[0]);
        } else if (value.constructor === Input) {
          return this.getBitRatio(value.value);
        }
        switch (value.constructor) {
          case Uint8ClampedArray:
          case Uint8Array:
          case Int8Array:
            return 1;
          case Uint16Array:
          case Int16Array:
            return 2;
          case Float32Array:
          case Int32Array:
          default:
            return 4;
        }
      }

      destroy() {
        if (this.prevArg) {
          this.prevArg.delete();
        }
        this.context.deleteTexture(this.texture);
      }
    }

    module.exports = {
      WebGLKernelArray
    };
    },{"../../../input":110,"./index":59}],41:[function(require,module,exports){
    const { WebGLKernelValue } = require('./index');

    class WebGLKernelValueArray2 extends WebGLKernelValue {
      constructor(value, settings) {
        super(value, settings);
        this.uploadValue = value;
      }
      getSource(value) {
        if (this.origin === 'constants') {
          return `const vec2 ${this.id} = vec2(${value[0]},${value[1]});\n`;
        }
        return `uniform vec2 ${this.id};\n`;
      }

      getStringValueHandler() {
        if (this.origin === 'constants') return '';
        return `const uploadValue_${this.name} = ${this.varName};\n`;
      }

      updateValue(value) {
        if (this.origin === 'constants') return;
        this.kernel.setUniform2fv(this.id, this.uploadValue = value);
      }
    }

    module.exports = {
      WebGLKernelValueArray2
    };
    },{"./index":59}],42:[function(require,module,exports){
    const { WebGLKernelValue } = require('./index');

    class WebGLKernelValueArray3 extends WebGLKernelValue {
      constructor(value, settings) {
        super(value, settings);
        this.uploadValue = value;
      }
      getSource(value) {
        if (this.origin === 'constants') {
          return `const vec3 ${this.id} = vec3(${value[0]},${value[1]},${value[2]});\n`;
        }
        return `uniform vec3 ${this.id};\n`;
      }

      getStringValueHandler() {
        if (this.origin === 'constants') return '';
        return `const uploadValue_${this.name} = ${this.varName};\n`;
      }

      updateValue(value) {
        if (this.origin === 'constants') return;
        this.kernel.setUniform3fv(this.id, this.uploadValue = value);
      }
    }

    module.exports = {
      WebGLKernelValueArray3
    };
    },{"./index":59}],43:[function(require,module,exports){
    const { WebGLKernelValue } = require('./index');

    class WebGLKernelValueArray4 extends WebGLKernelValue {
      constructor(value, settings) {
        super(value, settings);
        this.uploadValue = value;
      }
      getSource(value) {
        if (this.origin === 'constants') {
          return `const vec4 ${this.id} = vec4(${value[0]},${value[1]},${value[2]},${value[3]});\n`;
        }
        return `uniform vec4 ${this.id};\n`;
      }

      getStringValueHandler() {
        if (this.origin === 'constants') return '';
        return `const uploadValue_${this.name} = ${this.varName};\n`;
      }

      updateValue(value) {
        if (this.origin === 'constants') return;
        this.kernel.setUniform4fv(this.id, this.uploadValue = value);
      }
    }

    module.exports = {
      WebGLKernelValueArray4
    };
    },{"./index":59}],44:[function(require,module,exports){
    require('../../../utils');
    const { WebGLKernelValue } = require('./index');

    class WebGLKernelValueBoolean extends WebGLKernelValue {
      constructor(value, settings) {
        super(value, settings);
        this.uploadValue = value;
      }
      getSource(value) {
        if (this.origin === 'constants') {
          return `const bool ${this.id} = ${value};\n`;
        }
        return `uniform bool ${this.id};\n`;
      }

      getStringValueHandler() {
        return `const uploadValue_${this.name} = ${this.varName};\n`;
      }

      updateValue(value) {
        if (this.origin === 'constants') return;
        this.kernel.setUniform1i(this.id, this.uploadValue = value);
      }
    }

    module.exports = {
      WebGLKernelValueBoolean
    };
    },{"../../../utils":114,"./index":59}],45:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueHTMLImage } = require('./html-image');

    class WebGLKernelValueDynamicHTMLImage extends WebGLKernelValueHTMLImage {
      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `uniform ivec2 ${this.sizeId}`,
          `uniform ivec3 ${this.dimensionsId}`,
        ]);
      }

      updateValue(value) {
        const { width, height } = value;
        this.checkSize(width, height);
        this.dimensions = [width, height, 1];
        this.textureSize = [width, height];
        this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
        this.kernel.setUniform2iv(this.sizeId, this.textureSize);
        super.updateValue(value);
      }
    }

    module.exports = {
      WebGLKernelValueDynamicHTMLImage
    };
    },{"../../../utils":114,"./html-image":57}],46:[function(require,module,exports){
    const { WebGLKernelValueDynamicHTMLImage } = require('./dynamic-html-image');

    class WebGLKernelValueDynamicHTMLVideo extends WebGLKernelValueDynamicHTMLImage {}

    module.exports = {
      WebGLKernelValueDynamicHTMLVideo
    };
    },{"./dynamic-html-image":45}],47:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('./memory-optimized-number-texture');

    class WebGLKernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {
      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `uniform ivec2 ${this.sizeId}`,
          `uniform ivec3 ${this.dimensionsId}`,
        ]);
      }

      updateValue(inputTexture) {
        this.dimensions = inputTexture.dimensions;
        this.checkSize(inputTexture.size[0], inputTexture.size[1]);
        this.textureSize = inputTexture.size;
        this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
        this.kernel.setUniform2iv(this.sizeId, this.textureSize);
        super.updateValue(inputTexture);
      }
    }

    module.exports = {
      WebGLKernelValueDynamicMemoryOptimizedNumberTexture
    };
    },{"../../../utils":114,"./memory-optimized-number-texture":61}],48:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueNumberTexture } = require('./number-texture');

    class WebGLKernelValueDynamicNumberTexture extends WebGLKernelValueNumberTexture {
      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `uniform ivec2 ${this.sizeId}`,
          `uniform ivec3 ${this.dimensionsId}`,
        ]);
      }

      updateValue(value) {
        this.dimensions = value.dimensions;
        this.checkSize(value.size[0], value.size[1]);
        this.textureSize = value.size;
        this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
        this.kernel.setUniform2iv(this.sizeId, this.textureSize);
        super.updateValue(value);
      }
    }

    module.exports = {
      WebGLKernelValueDynamicNumberTexture
    };
    },{"../../../utils":114,"./number-texture":62}],49:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueSingleArray } = require('./single-array');

    class WebGLKernelValueDynamicSingleArray extends WebGLKernelValueSingleArray {
      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `uniform ivec2 ${this.sizeId}`,
          `uniform ivec3 ${this.dimensionsId}`,
        ]);
      }

      updateValue(value) {
        this.dimensions = utils.getDimensions(value, true);
        this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
        this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
        this.checkSize(this.textureSize[0], this.textureSize[1]);
        this.uploadValue = new Float32Array(this.uploadArrayLength);
        this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
        this.kernel.setUniform2iv(this.sizeId, this.textureSize);
        super.updateValue(value);
      }
    }

    module.exports = {
      WebGLKernelValueDynamicSingleArray
    };
    },{"../../../utils":114,"./single-array":63}],50:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueSingleArray1DI } = require('./single-array1d-i');

    class WebGLKernelValueDynamicSingleArray1DI extends WebGLKernelValueSingleArray1DI {
      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `uniform ivec2 ${this.sizeId}`,
          `uniform ivec3 ${this.dimensionsId}`,
        ]);
      }

      updateValue(value) {
        this.setShape(value);
        this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
        this.kernel.setUniform2iv(this.sizeId, this.textureSize);
        super.updateValue(value);
      }
    }

    module.exports = {
      WebGLKernelValueDynamicSingleArray1DI
    };
    },{"../../../utils":114,"./single-array1d-i":64}],51:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueSingleArray2DI } = require('./single-array2d-i');

    class WebGLKernelValueDynamicSingleArray2DI extends WebGLKernelValueSingleArray2DI {
      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `uniform ivec2 ${this.sizeId}`,
          `uniform ivec3 ${this.dimensionsId}`,
        ]);
      }

      updateValue(value) {
        this.setShape(value);
        this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
        this.kernel.setUniform2iv(this.sizeId, this.textureSize);
        super.updateValue(value);
      }
    }

    module.exports = {
      WebGLKernelValueDynamicSingleArray2DI
    };
    },{"../../../utils":114,"./single-array2d-i":65}],52:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueSingleArray3DI } = require('./single-array3d-i');

    class WebGLKernelValueDynamicSingleArray3DI extends WebGLKernelValueSingleArray3DI {
      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `uniform ivec2 ${this.sizeId}`,
          `uniform ivec3 ${this.dimensionsId}`,
        ]);
      }

      updateValue(value) {
        this.setShape(value);
        this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
        this.kernel.setUniform2iv(this.sizeId, this.textureSize);
        super.updateValue(value);
      }
    }

    module.exports = {
      WebGLKernelValueDynamicSingleArray3DI
    };
    },{"../../../utils":114,"./single-array3d-i":66}],53:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueSingleInput } = require('./single-input');

    class WebGLKernelValueDynamicSingleInput extends WebGLKernelValueSingleInput {
      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `uniform ivec2 ${this.sizeId}`,
          `uniform ivec3 ${this.dimensionsId}`,
        ]);
      }

      updateValue(value) {
        let [w, h, d] = value.size;
        this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
        this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
        this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
        this.checkSize(this.textureSize[0], this.textureSize[1]);
        this.uploadValue = new Float32Array(this.uploadArrayLength);
        this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
        this.kernel.setUniform2iv(this.sizeId, this.textureSize);
        super.updateValue(value);
      }
    }

    module.exports = {
      WebGLKernelValueDynamicSingleInput
    };
    },{"../../../utils":114,"./single-input":67}],54:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueUnsignedArray } = require('./unsigned-array');

    class WebGLKernelValueDynamicUnsignedArray extends WebGLKernelValueUnsignedArray {
      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `uniform ivec2 ${this.sizeId}`,
          `uniform ivec3 ${this.dimensionsId}`,
        ]);
      }

      updateValue(value) {
        this.dimensions = utils.getDimensions(value, true);
        this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
        this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
        this.checkSize(this.textureSize[0], this.textureSize[1]);
        const Type = this.getTransferArrayType(value);
        this.preUploadValue = new Type(this.uploadArrayLength);
        this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
        this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
        this.kernel.setUniform2iv(this.sizeId, this.textureSize);
        super.updateValue(value);
      }
    }

    module.exports = {
      WebGLKernelValueDynamicUnsignedArray
    };
    },{"../../../utils":114,"./unsigned-array":68}],55:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueUnsignedInput } = require('./unsigned-input');

    class WebGLKernelValueDynamicUnsignedInput extends WebGLKernelValueUnsignedInput {
      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `uniform ivec2 ${this.sizeId}`,
          `uniform ivec3 ${this.dimensionsId}`,
        ]);
      }

      updateValue(value) {
        let [w, h, d] = value.size;
        this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
        this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
        this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
        this.checkSize(this.textureSize[0], this.textureSize[1]);
        const Type = this.getTransferArrayType(value.value);
        this.preUploadValue = new Type(this.uploadArrayLength);
        this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
        this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
        this.kernel.setUniform2iv(this.sizeId, this.textureSize);
        super.updateValue(value);
      }
    }

    module.exports = {
      WebGLKernelValueDynamicUnsignedInput
    };
    },{"../../../utils":114,"./unsigned-input":69}],56:[function(require,module,exports){
    require('../../../utils');
    const { WebGLKernelValue } = require('./index');

    class WebGLKernelValueFloat extends WebGLKernelValue {
      constructor(value, settings) {
        super(value, settings);
        this.uploadValue = value;
      }
      getStringValueHandler() {
        return `const uploadValue_${this.name} = ${this.varName};\n`;
      }
      getSource(value) {
        if (this.origin === 'constants') {
          if (Number.isInteger(value)) {
            return `const float ${this.id} = ${value}.0;\n`;
          }
          return `const float ${this.id} = ${value};\n`;
        }
        return `uniform float ${this.id};\n`;
      }

      updateValue(value) {
        if (this.origin === 'constants') return;
        this.kernel.setUniform1f(this.id, this.uploadValue = value);
      }
    }

    module.exports = {
      WebGLKernelValueFloat
    };
    },{"../../../utils":114,"./index":59}],57:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelArray } = require('./array');

    class WebGLKernelValueHTMLImage extends WebGLKernelArray {
      constructor(value, settings) {
        super(value, settings);
        const { width, height } = value;
        this.checkSize(width, height);
        this.dimensions = [width, height, 1];
        this.textureSize = [width, height];
        this.uploadValue = value;
      }

      getStringValueHandler() {
        return `const uploadValue_${this.name} = ${this.varName};\n`;
      }

      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
          `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
        ]);
      }

      updateValue(inputImage) {
        if (inputImage.constructor !== this.initialValueConstructor) {
          this.onUpdateValueMismatch(inputImage.constructor);
          return;
        }
        const { context: gl } = this;
        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue = inputImage);
        this.kernel.setUniform1i(this.id, this.index);
      }
    }

    module.exports = {
      WebGLKernelValueHTMLImage
    };
    },{"../../../utils":114,"./array":40}],58:[function(require,module,exports){
    const { WebGLKernelValueHTMLImage } = require('./html-image');

    class WebGLKernelValueHTMLVideo extends WebGLKernelValueHTMLImage {}

    module.exports = {
      WebGLKernelValueHTMLVideo
    };
    },{"./html-image":57}],59:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { KernelValue } = require('../../kernel-value');

    class WebGLKernelValue extends KernelValue {
      constructor(value, settings) {
        super(value, settings);
        this.dimensionsId = null;
        this.sizeId = null;
        this.initialValueConstructor = value.constructor;
        this.onRequestTexture = settings.onRequestTexture;
        this.onRequestIndex = settings.onRequestIndex;
        this.uploadValue = null;
        this.textureSize = null;
        this.bitRatio = null;
        this.prevArg = null;
      }

      get id() {
        return `${this.origin}_${utils.sanitizeName(this.name)}`;
      }

      setup() {}

      getTransferArrayType(value) {
        if (Array.isArray(value[0])) {
          return this.getTransferArrayType(value[0]);
        }
        switch (value.constructor) {
          case Array:
          case Int32Array:
          case Int16Array:
          case Int8Array:
            return Float32Array;
          case Uint8ClampedArray:
          case Uint8Array:
          case Uint16Array:
          case Uint32Array:
          case Float32Array:
          case Float64Array:
            return value.constructor;
        }
        console.warn('Unfamiliar constructor type.  Will go ahead and use, but likley this may result in a transfer of zeros');
        return value.constructor;
      }

      getStringValueHandler() {
        throw new Error(`"getStringValueHandler" not implemented on ${this.constructor.name}`);
      }

      getVariablePrecisionString() {
        return this.kernel.getVariablePrecisionString(this.textureSize || undefined, this.tactic || undefined);
      }

      destroy() {}
    }

    module.exports = {
      WebGLKernelValue
    };
    },{"../../../utils":114,"../../kernel-value":35}],60:[function(require,module,exports){
    require('../../../utils');
    const { WebGLKernelValue } = require('./index');

    class WebGLKernelValueInteger extends WebGLKernelValue {
      constructor(value, settings) {
        super(value, settings);
        this.uploadValue = value;
      }
      getStringValueHandler() {
        return `const uploadValue_${this.name} = ${this.varName};\n`;
      }
      getSource(value) {
        if (this.origin === 'constants') {
          return `const int ${this.id} = ${ parseInt(value) };\n`;
        }
        return `uniform int ${this.id};\n`;
      }

      updateValue(value) {
        if (this.origin === 'constants') return;
        this.kernel.setUniform1i(this.id, this.uploadValue = value);
      }
    }

    module.exports = {
      WebGLKernelValueInteger
    };
    },{"../../../utils":114,"./index":59}],61:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelArray } = require('./array');

    const sameError = `Source and destination textures are the same.  Use immutable = true and manually cleanup kernel output texture memory with texture.delete()`;

    class WebGLKernelValueMemoryOptimizedNumberTexture extends WebGLKernelArray {
      constructor(value, settings) {
        super(value, settings);
        const [width, height] = value.size;
        this.checkSize(width, height);
        this.dimensions = value.dimensions;
        this.textureSize = value.size;
        this.uploadValue = value.texture;
        this.forceUploadEachRun = true;
      }

      setup() {
        this.setupTexture();
      }

      getStringValueHandler() {
        return `const uploadValue_${this.name} = ${this.varName}.texture;\n`;
      }

      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
          `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
        ]);
      }

      updateValue(inputTexture) {
        if (inputTexture.constructor !== this.initialValueConstructor) {
          this.onUpdateValueMismatch(inputTexture.constructor);
          return;
        }
        if (this.checkContext && inputTexture.context !== this.context) {
          throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
        }

        const { kernel, context: gl } = this;
        if (kernel.pipeline) {
          if (kernel.immutable) {
            kernel.updateTextureArgumentRefs(this, inputTexture);
          } else {
            if (kernel.texture && kernel.texture.texture === inputTexture.texture) {
              throw new Error(sameError);
            } else if (kernel.mappedTextures) {
              const { mappedTextures } = kernel;
              for (let i = 0; i < mappedTextures.length; i++) {
                if (mappedTextures[i].texture === inputTexture.texture) {
                  throw new Error(sameError);
                }
              }
            }
          }
        }

        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);
        this.kernel.setUniform1i(this.id, this.index);
      }
    }

    module.exports = {
      WebGLKernelValueMemoryOptimizedNumberTexture,
      sameError
    };
    },{"../../../utils":114,"./array":40}],62:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelArray } = require('./array');
    const { sameError } = require('./memory-optimized-number-texture');

    class WebGLKernelValueNumberTexture extends WebGLKernelArray {
      constructor(value, settings) {
        super(value, settings);
        const [width, height] = value.size;
        this.checkSize(width, height);
        const { size: textureSize, dimensions } = value;
        this.bitRatio = this.getBitRatio(value);
        this.dimensions = dimensions;
        this.textureSize = textureSize;
        this.uploadValue = value.texture;
        this.forceUploadEachRun = true;
      }

      setup() {
        this.setupTexture();
      }

      getStringValueHandler() {
        return `const uploadValue_${this.name} = ${this.varName}.texture;\n`;
      }

      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
          `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
        ]);
      }

      updateValue(inputTexture) {
        if (inputTexture.constructor !== this.initialValueConstructor) {
          this.onUpdateValueMismatch(inputTexture.constructor);
          return;
        }
        if (this.checkContext && inputTexture.context !== this.context) {
          throw new Error(`Value ${this.name} (${this.type}) must be from same context`);
        }

        const { kernel, context: gl } = this;
        if (kernel.pipeline) {
          if (kernel.immutable) {
            kernel.updateTextureArgumentRefs(this, inputTexture);
          } else {
            if (kernel.texture && kernel.texture.texture === inputTexture.texture) {
              throw new Error(sameError);
            } else if (kernel.mappedTextures) {
              const { mappedTextures } = kernel;
              for (let i = 0; i < mappedTextures.length; i++) {
                if (mappedTextures[i].texture === inputTexture.texture) {
                  throw new Error(sameError);
                }
              }
            }
          }
        }

        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D, this.uploadValue = inputTexture.texture);
        this.kernel.setUniform1i(this.id, this.index);
      }
    }

    module.exports = {
      WebGLKernelValueNumberTexture
    };
    },{"../../../utils":114,"./array":40,"./memory-optimized-number-texture":61}],63:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelArray } = require('./array');

    class WebGLKernelValueSingleArray extends WebGLKernelArray {
      constructor(value, settings) {
        super(value, settings);
        this.bitRatio = 4;
        this.dimensions = utils.getDimensions(value, true);
        this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
        this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
        this.checkSize(this.textureSize[0], this.textureSize[1]);
        this.uploadValue = new Float32Array(this.uploadArrayLength);
      }

      getStringValueHandler() {
        return utils.linesToString([
          `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
          `flattenTo(${this.varName}, uploadValue_${this.name})`,
        ]);
      }

      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
          `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
        ]);
      }

      updateValue(value) {
        if (value.constructor !== this.initialValueConstructor) {
          this.onUpdateValueMismatch(value.constructor);
          return;
        }
        const { context: gl } = this;
        utils.flattenTo(value, this.uploadValue);
        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
        this.kernel.setUniform1i(this.id, this.index);
      }
    }

    module.exports = {
      WebGLKernelValueSingleArray
    };
    },{"../../../utils":114,"./array":40}],64:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelArray } = require('./array');

    class WebGLKernelValueSingleArray1DI extends WebGLKernelArray {
      constructor(value, settings) {
        super(value, settings);
        this.bitRatio = 4;
        this.setShape(value);
      }

      setShape(value) {
        const valueDimensions = utils.getDimensions(value, true);
        this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
        this.dimensions = new Int32Array([valueDimensions[1], 1, 1]);
        this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
        this.checkSize(this.textureSize[0], this.textureSize[1]);
        this.uploadValue = new Float32Array(this.uploadArrayLength);
      }

      getStringValueHandler() {
        return utils.linesToString([
          `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
          `flattenTo(${this.varName}, uploadValue_${this.name})`,
        ]);
      }

      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
          `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
        ]);
      }

      updateValue(value) {
        if (value.constructor !== this.initialValueConstructor) {
          this.onUpdateValueMismatch(value.constructor);
          return;
        }
        const { context: gl } = this;
        utils.flatten2dArrayTo(value, this.uploadValue);
        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
        this.kernel.setUniform1i(this.id, this.index);
      }
    }

    module.exports = {
      WebGLKernelValueSingleArray1DI
    };
    },{"../../../utils":114,"./array":40}],65:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelArray } = require('./array');

    class WebGLKernelValueSingleArray2DI extends WebGLKernelArray {
      constructor(value, settings) {
        super(value, settings);
        this.bitRatio = 4;
        this.setShape(value);
      }

      setShape(value) {
        const valueDimensions = utils.getDimensions(value, true);
        this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
        this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], 1]);
        this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
        this.checkSize(this.textureSize[0], this.textureSize[1]);
        this.uploadValue = new Float32Array(this.uploadArrayLength);
      }

      getStringValueHandler() {
        return utils.linesToString([
          `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
          `flattenTo(${this.varName}, uploadValue_${this.name})`,
        ]);
      }

      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
          `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
        ]);
      }

      updateValue(value) {
        if (value.constructor !== this.initialValueConstructor) {
          this.onUpdateValueMismatch(value.constructor);
          return;
        }
        const { context: gl } = this;
        utils.flatten3dArrayTo(value, this.uploadValue);
        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
        this.kernel.setUniform1i(this.id, this.index);
      }
    }

    module.exports = {
      WebGLKernelValueSingleArray2DI
    };
    },{"../../../utils":114,"./array":40}],66:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelArray } = require('./array');

    class WebGLKernelValueSingleArray3DI extends WebGLKernelArray {
      constructor(value, settings) {
        super(value, settings);
        this.bitRatio = 4;
        this.setShape(value);
      }

      setShape(value) {
        const valueDimensions = utils.getDimensions(value, true);
        this.textureSize = utils.getMemoryOptimizedFloatTextureSize(valueDimensions, this.bitRatio);
        this.dimensions = new Int32Array([valueDimensions[1], valueDimensions[2], valueDimensions[3]]);
        this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
        this.checkSize(this.textureSize[0], this.textureSize[1]);
        this.uploadValue = new Float32Array(this.uploadArrayLength);
      }

      getStringValueHandler() {
        return utils.linesToString([
          `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
          `flattenTo(${this.varName}, uploadValue_${this.name})`,
        ]);
      }

      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
          `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
        ]);
      }

      updateValue(value) {
        if (value.constructor !== this.initialValueConstructor) {
          this.onUpdateValueMismatch(value.constructor);
          return;
        }
        const { context: gl } = this;
        utils.flatten4dArrayTo(value, this.uploadValue);
        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
        this.kernel.setUniform1i(this.id, this.index);
      }
    }

    module.exports = {
      WebGLKernelValueSingleArray3DI
    };
    },{"../../../utils":114,"./array":40}],67:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelArray } = require('./array');

    class WebGLKernelValueSingleInput extends WebGLKernelArray {
      constructor(value, settings) {
        super(value, settings);
        this.bitRatio = 4;
        let [w, h, d] = value.size;
        this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
        this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
        this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
        this.checkSize(this.textureSize[0], this.textureSize[1]);
        this.uploadValue = new Float32Array(this.uploadArrayLength);
      }

      getStringValueHandler() {
        return utils.linesToString([
          `const uploadValue_${this.name} = new Float32Array(${this.uploadArrayLength})`,
          `flattenTo(${this.varName}.value, uploadValue_${this.name})`,
        ]);
      }

      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
          `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
        ]);
      }

      updateValue(input) {
        if (input.constructor !== this.initialValueConstructor) {
          this.onUpdateValueMismatch(input.constructor);
          return;
        }
        const { context: gl } = this;
        utils.flattenTo(input.value, this.uploadValue);
        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
        this.kernel.setUniform1i(this.id, this.index);
      }
    }

    module.exports = {
      WebGLKernelValueSingleInput
    };
    },{"../../../utils":114,"./array":40}],68:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelArray } = require('./array');

    class WebGLKernelValueUnsignedArray extends WebGLKernelArray {
      constructor(value, settings) {
        super(value, settings);
        this.bitRatio = this.getBitRatio(value);
        this.dimensions = utils.getDimensions(value, true);
        this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
        this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
        this.checkSize(this.textureSize[0], this.textureSize[1]);
        this.TranserArrayType = this.getTransferArrayType(value);
        this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);
        this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
      }

      getStringValueHandler() {
        return utils.linesToString([
          `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,
          `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,
          `flattenTo(${this.varName}, preUploadValue_${this.name})`,
        ]);
      }

      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
          `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
        ]);
      }

      updateValue(value) {
        if (value.constructor !== this.initialValueConstructor) {
          this.onUpdateValueMismatch(value.constructor);
          return;
        }
        const { context: gl } = this;
        utils.flattenTo(value, this.preUploadValue);
        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);
        this.kernel.setUniform1i(this.id, this.index);
      }
    }

    module.exports = {
      WebGLKernelValueUnsignedArray
    };
    },{"../../../utils":114,"./array":40}],69:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelArray } = require('./array');

    class WebGLKernelValueUnsignedInput extends WebGLKernelArray {
      constructor(value, settings) {
        super(value, settings);
        this.bitRatio = this.getBitRatio(value);
        const [w, h, d] = value.size;
        this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
        this.textureSize = utils.getMemoryOptimizedPackedTextureSize(this.dimensions, this.bitRatio);
        this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * (4 / this.bitRatio);
        this.checkSize(this.textureSize[0], this.textureSize[1]);
        this.TranserArrayType = this.getTransferArrayType(value.value);
        this.preUploadValue = new this.TranserArrayType(this.uploadArrayLength);
        this.uploadValue = new Uint8Array(this.preUploadValue.buffer);
      }

      getStringValueHandler() {
        return utils.linesToString([
          `const preUploadValue_${this.name} = new ${this.TranserArrayType.name}(${this.uploadArrayLength})`,
          `const uploadValue_${this.name} = new Uint8Array(preUploadValue_${this.name}.buffer)`,
          `flattenTo(${this.varName}.value, preUploadValue_${this.name})`,
        ]);
      }

      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
          `ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
        ]);
      }

      updateValue(input) {
        if (input.constructor !== this.initialValueConstructor) {
          this.onUpdateValueMismatch(value.constructor);
          return;
        }
        const { context: gl } = this;
        utils.flattenTo(input.value, this.preUploadValue);
        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, this.uploadValue);
        this.kernel.setUniform1i(this.id, this.index);
      }
    }

    module.exports = {
      WebGLKernelValueUnsignedInput
    };
    },{"../../../utils":114,"./array":40}],70:[function(require,module,exports){
    const { GLKernel } = require('../gl/kernel');
    const { FunctionBuilder } = require('../function-builder');
    const { WebGLFunctionNode } = require('./function-node');
    const { utils } = require('../../utils');
    const mrud = require('../../plugins/math-random-uniformly-distributed');
    const { fragmentShader } = require('./fragment-shader');
    const { vertexShader } = require('./vertex-shader');
    const { glKernelString } = require('../gl/kernel-string');
    const { lookupKernelValueType } = require('./kernel-value-maps');

    let isSupported = null;
    let testCanvas = null;
    let testContext = null;
    let testExtensions = null;
    let features = null;

    const plugins = [mrud];
    const canvases = [];
    const maxTexSizes = {};


    class WebGLKernel extends GLKernel {
      static get isSupported() {
        if (isSupported !== null) {
          return isSupported;
        }
        this.setupFeatureChecks();
        isSupported = this.isContextMatch(testContext);
        return isSupported;
      }

      static setupFeatureChecks() {
        if (typeof document !== 'undefined') {
          testCanvas = document.createElement('canvas');
        } else if (typeof OffscreenCanvas !== 'undefined') {
          testCanvas = new OffscreenCanvas(0, 0);
        }
        if (!testCanvas) return;
        testContext = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
        if (!testContext || !testContext.getExtension) return;
        testExtensions = {
          OES_texture_float: testContext.getExtension('OES_texture_float'),
          OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
          OES_element_index_uint: testContext.getExtension('OES_element_index_uint'),
          WEBGL_draw_buffers: testContext.getExtension('WEBGL_draw_buffers'),
        };
        features = this.getFeatures();
      }

      static isContextMatch(context) {
        if (typeof WebGLRenderingContext !== 'undefined') {
          return context instanceof WebGLRenderingContext;
        }
        return false;
      }

      static getIsTextureFloat() {
        return Boolean(testExtensions.OES_texture_float);
      }

      static getIsDrawBuffers() {
        return Boolean(testExtensions.WEBGL_draw_buffers);
      }

      static getChannelCount() {
        return testExtensions.WEBGL_draw_buffers ?
          testContext.getParameter(testExtensions.WEBGL_draw_buffers.MAX_DRAW_BUFFERS_WEBGL) :
          1;
      }

      static getMaxTextureSize() {
        return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
      }

      static lookupKernelValueType(type, dynamic, precision, value) {
        return lookupKernelValueType(type, dynamic, precision, value);
      }

      static get testCanvas() {
        return testCanvas;
      }

      static get testContext() {
        return testContext;
      }

      static get features() {
        return features;
      }

      static get fragmentShader() {
        return fragmentShader;
      }

      static get vertexShader() {
        return vertexShader;
      }

      constructor(source, settings) {
        super(source, settings);
        this.program = null;
        this.pipeline = settings.pipeline;
        this.endianness = utils.systemEndianness();
        this.extensions = {};
        this.argumentTextureCount = 0;
        this.constantTextureCount = 0;
        this.fragShader = null;
        this.vertShader = null;
        this.drawBuffersMap = null;

        this.maxTexSize = null;
        this.onRequestSwitchKernel = null;

        this.texture = null;
        this.mappedTextures = null;
        this.mergeSettings(source.settings || settings);

        this.threadDim = null;
        this.framebuffer = null;
        this.buffer = null;

        this.textureCache = [];
        this.programUniformLocationCache = {};
        this.uniform1fCache = {};
        this.uniform1iCache = {};
        this.uniform2fCache = {};
        this.uniform2fvCache = {};
        this.uniform2ivCache = {};
        this.uniform3fvCache = {};
        this.uniform3ivCache = {};
        this.uniform4fvCache = {};
        this.uniform4ivCache = {};
      }

      initCanvas() {
        if (typeof document !== 'undefined') {
          const canvas = document.createElement('canvas');
          canvas.width = 2;
          canvas.height = 2;
          return canvas;
        } else if (typeof OffscreenCanvas !== 'undefined') {
          return new OffscreenCanvas(0, 0);
        }
      }

      initContext() {
        const settings = {
          alpha: false,
          depth: false,
          antialias: false
        };
        return this.canvas.getContext('webgl', settings) || this.canvas.getContext('experimental-webgl', settings);
      }

      initPlugins(settings) {
        const pluginsToUse = [];
        const { source } = this;
        if (typeof source === 'string') {
          for (let i = 0; i < plugins.length; i++) {
            const plugin = plugins[i];
            if (source.match(plugin.functionMatch)) {
              pluginsToUse.push(plugin);
            }
          }
        } else if (typeof source === 'object') {
          if (settings.pluginNames) { 
            for (let i = 0; i < plugins.length; i++) {
              const plugin = plugins[i];
              const usePlugin = settings.pluginNames.some(pluginName => pluginName === plugin.name);
              if (usePlugin) {
                pluginsToUse.push(plugin);
              }
            }
          }
        }
        return pluginsToUse;
      }

      initExtensions() {
        this.extensions = {
          OES_texture_float: this.context.getExtension('OES_texture_float'),
          OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
          OES_element_index_uint: this.context.getExtension('OES_element_index_uint'),
          WEBGL_draw_buffers: this.context.getExtension('WEBGL_draw_buffers'),
          WEBGL_color_buffer_float: this.context.getExtension('WEBGL_color_buffer_float'),
        };
      }

      validateSettings(args) {
        if (!this.validate) {
          this.texSize = utils.getKernelTextureSize({
            optimizeFloatMemory: this.optimizeFloatMemory,
            precision: this.precision,
          }, this.output);
          return;
        }

        const { features } = this.constructor;

        if (this.optimizeFloatMemory === true && !features.isTextureFloat) {
          throw new Error('Float textures are not supported');
        } else if (this.precision === 'single' && !features.isFloatRead) {
          throw new Error('Single precision not supported');
        } else if (!this.graphical && this.precision === null && features.isTextureFloat) {
          this.precision = features.isFloatRead ? 'single' : 'unsigned';
        }

        if (this.subKernels && this.subKernels.length > 0 && !this.extensions.WEBGL_draw_buffers) {
          throw new Error('could not instantiate draw buffers extension');
        }

        if (this.fixIntegerDivisionAccuracy === null) {
          this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
        } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
          this.fixIntegerDivisionAccuracy = false;
        }

        this.checkOutput();

        if (!this.output || this.output.length === 0) {
          if (args.length !== 1) {
            throw new Error('Auto output only supported for kernels with only one input');
          }

          const argType = utils.getVariableType(args[0], this.strictIntegers);
          switch (argType) {
            case 'Array':
              this.output = utils.getDimensions(argType);
              break;
            case 'NumberTexture':
            case 'MemoryOptimizedNumberTexture':
            case 'ArrayTexture(1)':
            case 'ArrayTexture(2)':
            case 'ArrayTexture(3)':
            case 'ArrayTexture(4)':
              this.output = args[0].output;
              break;
            default:
              throw new Error('Auto output not supported for input type: ' + argType);
          }
        }

        if (this.graphical) {
          if (this.output.length !== 2) {
            throw new Error('Output must have 2 dimensions on graphical mode');
          }

          if (this.precision === 'precision') {
            this.precision = 'unsigned';
            console.warn('Cannot use graphical mode and single precision at the same time');
          }

          this.texSize = utils.clone(this.output);
          return;
        } else if (this.precision === null && features.isTextureFloat) {
          this.precision = 'single';
        }

        this.texSize = utils.getKernelTextureSize({
          optimizeFloatMemory: this.optimizeFloatMemory,
          precision: this.precision,
        }, this.output);

        this.checkTextureSize();
      }

      updateMaxTexSize() {
        const { texSize, canvas } = this;
        if (this.maxTexSize === null) {
          let canvasIndex = canvases.indexOf(canvas);
          if (canvasIndex === -1) {
            canvasIndex = canvases.length;
            canvases.push(canvas);
            maxTexSizes[canvasIndex] = [texSize[0], texSize[1]];
          }
          this.maxTexSize = maxTexSizes[canvasIndex];
        }
        if (this.maxTexSize[0] < texSize[0]) {
          this.maxTexSize[0] = texSize[0];
        }
        if (this.maxTexSize[1] < texSize[1]) {
          this.maxTexSize[1] = texSize[1];
        }
      }

      setupArguments(args) {
        this.kernelArguments = [];
        this.argumentTextureCount = 0;
        const needsArgumentTypes = this.argumentTypes === null;
        if (needsArgumentTypes) {
          this.argumentTypes = [];
        }
        this.argumentSizes = [];
        this.argumentBitRatios = [];

        if (args.length < this.argumentNames.length) {
          throw new Error('not enough arguments for kernel');
        } else if (args.length > this.argumentNames.length) {
          throw new Error('too many arguments for kernel');
        }

        const { context: gl } = this;
        let textureIndexes = 0;

        const onRequestTexture = () => {
          return this.createTexture();
        };
        const onRequestIndex = () => {
          return this.constantTextureCount + textureIndexes++;
        };
        const onUpdateValueMismatch = (constructor) => {
          this.switchKernels({
            type: 'argumentMismatch',
            needed: constructor
          });
        };
        const onRequestContextHandle = () => {
          return gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount++;
        };

        for (let index = 0; index < args.length; index++) {
          const value = args[index];
          const name = this.argumentNames[index];
          let type;
          if (needsArgumentTypes) {
            type = utils.getVariableType(value, this.strictIntegers);
            this.argumentTypes.push(type);
          } else {
            type = this.argumentTypes[index];
          }
          const KernelValue = this.constructor.lookupKernelValueType(type, this.dynamicArguments ? 'dynamic' : 'static', this.precision, args[index]);
          if (KernelValue === null) {
            return this.requestFallback(args);
          }
          const kernelArgument = new KernelValue(value, {
            name,
            type,
            tactic: this.tactic,
            origin: 'user',
            context: gl,
            checkContext: this.checkContext,
            kernel: this,
            strictIntegers: this.strictIntegers,
            onRequestTexture,
            onRequestIndex,
            onUpdateValueMismatch,
            onRequestContextHandle,
          });
          this.kernelArguments.push(kernelArgument);
          kernelArgument.setup();
          this.argumentSizes.push(kernelArgument.textureSize);
          this.argumentBitRatios[index] = kernelArgument.bitRatio;
        }
      }

      createTexture() {
        const texture = this.context.createTexture();
        this.textureCache.push(texture);
        return texture;
      }

      setupConstants(args) {
        const { context: gl } = this;
        this.kernelConstants = [];
        this.forceUploadKernelConstants = [];
        let needsConstantTypes = this.constantTypes === null;
        if (needsConstantTypes) {
          this.constantTypes = {};
        }
        this.constantBitRatios = {};
        let textureIndexes = 0;
        for (const name in this.constants) {
          const value = this.constants[name];
          let type;
          if (needsConstantTypes) {
            type = utils.getVariableType(value, this.strictIntegers);
            this.constantTypes[name] = type;
          } else {
            type = this.constantTypes[name];
          }
          const KernelValue = this.constructor.lookupKernelValueType(type, 'static', this.precision, value);
          if (KernelValue === null) {
            return this.requestFallback(args);
          }
          const kernelValue = new KernelValue(value, {
            name,
            type,
            tactic: this.tactic,
            origin: 'constants',
            context: this.context,
            checkContext: this.checkContext,
            kernel: this,
            strictIntegers: this.strictIntegers,
            onRequestTexture: () => {
              return this.createTexture();
            },
            onRequestIndex: () => {
              return textureIndexes++;
            },
            onRequestContextHandle: () => {
              return gl.TEXTURE0 + this.constantTextureCount++;
            }
          });
          this.constantBitRatios[name] = kernelValue.bitRatio;
          this.kernelConstants.push(kernelValue);
          kernelValue.setup();
          if (kernelValue.forceUploadEachRun) {
            this.forceUploadKernelConstants.push(kernelValue);
          }
        }
      }

      build() {
        if (this.built) return;
        this.initExtensions();
        this.validateSettings(arguments);
        this.setupConstants(arguments);
        if (this.fallbackRequested) return;
        this.setupArguments(arguments);
        if (this.fallbackRequested) return;
        this.updateMaxTexSize();
        this.translateSource();
        const failureResult = this.pickRenderStrategy(arguments);
        if (failureResult) {
          return failureResult;
        }
        const { texSize, context: gl, canvas } = this;
        gl.enable(gl.SCISSOR_TEST);
        if (this.pipeline && this.precision === 'single') {
          gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
          canvas.width = this.maxTexSize[0];
          canvas.height = this.maxTexSize[1];
        } else {
          gl.viewport(0, 0, this.maxTexSize[0], this.maxTexSize[1]);
          canvas.width = this.maxTexSize[0];
          canvas.height = this.maxTexSize[1];
        }
        const threadDim = this.threadDim = Array.from(this.output);
        while (threadDim.length < 3) {
          threadDim.push(1);
        }

        const compiledVertexShader = this.getVertexShader(arguments);
        const vertShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertShader, compiledVertexShader);
        gl.compileShader(vertShader);
        this.vertShader = vertShader;

        const compiledFragmentShader = this.getFragmentShader(arguments);
        const fragShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragShader, compiledFragmentShader);
        gl.compileShader(fragShader);
        this.fragShader = fragShader;

        if (this.debug) {
          console.log('GLSL Shader Output:');
          console.log(compiledFragmentShader);
        }

        if (!gl.getShaderParameter(vertShader, gl.COMPILE_STATUS)) {
          throw new Error('Error compiling vertex shader: ' + gl.getShaderInfoLog(vertShader));
        }
        if (!gl.getShaderParameter(fragShader, gl.COMPILE_STATUS)) {
          throw new Error('Error compiling fragment shader: ' + gl.getShaderInfoLog(fragShader));
        }

        const program = this.program = gl.createProgram();
        gl.attachShader(program, vertShader);
        gl.attachShader(program, fragShader);
        gl.linkProgram(program);
        this.framebuffer = gl.createFramebuffer();
        this.framebuffer.width = texSize[0];
        this.framebuffer.height = texSize[1];
        this.rawValueFramebuffers = {};

        const vertices = new Float32Array([-1, -1,
          1, -1, -1, 1,
          1, 1
        ]);
        const texCoords = new Float32Array([
          0, 0,
          1, 0,
          0, 1,
          1, 1
        ]);

        const texCoordOffset = vertices.byteLength;

        let buffer = this.buffer;
        if (!buffer) {
          buffer = this.buffer = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
          gl.bufferData(gl.ARRAY_BUFFER, vertices.byteLength + texCoords.byteLength, gl.STATIC_DRAW);
        } else {
          gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        }

        gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);
        gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);

        const aPosLoc = gl.getAttribLocation(this.program, 'aPos');
        gl.enableVertexAttribArray(aPosLoc);
        gl.vertexAttribPointer(aPosLoc, 2, gl.FLOAT, false, 0, 0);
        const aTexCoordLoc = gl.getAttribLocation(this.program, 'aTexCoord');
        gl.enableVertexAttribArray(aTexCoordLoc);
        gl.vertexAttribPointer(aTexCoordLoc, 2, gl.FLOAT, false, 0, texCoordOffset);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);

        let i = 0;
        gl.useProgram(this.program);
        for (let p in this.constants) {
          this.kernelConstants[i++].updateValue(this.constants[p]);
        }

        this._setupOutputTexture();
        if (
          this.subKernels !== null &&
          this.subKernels.length > 0
        ) {
          this._mappedTextureSwitched = {};
          this._setupSubOutputTextures();
        }
        this.buildSignature(arguments);
        this.built = true;
      }

      translateSource() {
        const functionBuilder = FunctionBuilder.fromKernel(this, WebGLFunctionNode, {
          fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
        });
        this.translatedSource = functionBuilder.getPrototypeString('kernel');
        this.setupReturnTypes(functionBuilder);
      }

      setupReturnTypes(functionBuilder) {
        if (!this.graphical && !this.returnType) {
          this.returnType = functionBuilder.getKernelResultType();
        }

        if (this.subKernels && this.subKernels.length > 0) {
          for (let i = 0; i < this.subKernels.length; i++) {
            const subKernel = this.subKernels[i];
            if (!subKernel.returnType) {
              subKernel.returnType = functionBuilder.getSubKernelResultType(i);
            }
          }
        }
      }

      run() {
        const { kernelArguments, texSize, forceUploadKernelConstants, context: gl } = this;

        gl.useProgram(this.program);
        gl.scissor(0, 0, texSize[0], texSize[1]);
        if (this.dynamicOutput) {
          this.setUniform3iv('uOutputDim', new Int32Array(this.threadDim));
          this.setUniform2iv('uTexSize', texSize);
        }

        this.setUniform2f('ratio', texSize[0] / this.maxTexSize[0], texSize[1] / this.maxTexSize[1]);

        for (let i = 0; i < forceUploadKernelConstants.length; i++) {
          const constant = forceUploadKernelConstants[i];
          constant.updateValue(this.constants[constant.name]);
          if (this.switchingKernels) return;
        }
        for (let i = 0; i < kernelArguments.length; i++) {
          kernelArguments[i].updateValue(arguments[i]);
          if (this.switchingKernels) return;
        }

        if (this.plugins) {
          for (let i = 0; i < this.plugins.length; i++) {
            const plugin = this.plugins[i];
            if (plugin.onBeforeRun) {
              plugin.onBeforeRun(this);
            }
          }
        }

        if (this.graphical) {
          if (this.pipeline) {
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
            if (this.immutable) {
              this._replaceOutputTexture();
            }
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            return this.immutable ? this.texture.clone() : this.texture;
          }
          gl.bindRenderbuffer(gl.RENDERBUFFER, null);
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
          return;
        }

        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        if (this.immutable) {
          this._replaceOutputTexture();
        }

        if (this.subKernels !== null) {
          if (this.immutable) {
            this._replaceSubOutputTextures();
          }
          this.drawBuffers();
        }

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      }

      drawBuffers() {
        this.extensions.WEBGL_draw_buffers.drawBuffersWEBGL(this.drawBuffersMap);
      }

      getInternalFormat() {
        return this.context.RGBA;
      }
      getTextureFormat() {
        const { context: gl } = this;
        switch (this.getInternalFormat()) {
          case gl.RGBA:
            return gl.RGBA;
          default:
            throw new Error('Unknown internal format');
        }
      }

      _replaceOutputTexture() {
        if (this.texture.beforeMutate() || this._textureSwitched) {
          const gl = this.context;
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
          this._textureSwitched = false;
        }
      }

      _setupOutputTexture() {
        const gl = this.context;
        const texSize = this.texSize;
        if (this.texture) {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
          return;
        }
        const texture = this.createTexture();
        gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        const format = this.getInternalFormat();
        if (this.precision === 'single') {
          gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);
        }
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        this.texture = new this.TextureConstructor({
          texture,
          size: texSize,
          dimensions: this.threadDim,
          output: this.output,
          context: this.context,
          internalFormat: this.getInternalFormat(),
          textureFormat: this.getTextureFormat(),
          kernel: this,
        });
      }

      _replaceSubOutputTextures() {
        const gl = this.context;
        for (let i = 0; i < this.mappedTextures.length; i++) {
          const mappedTexture = this.mappedTextures[i];
          if (mappedTexture.beforeMutate() || this._mappedTextureSwitched[i]) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, mappedTexture.texture, 0);
            this._mappedTextureSwitched[i] = false;
          }
        }
      }

      _setupSubOutputTextures() {
        const gl = this.context;
        if (this.mappedTextures) {
          for (let i = 0; i < this.subKernels.length; i++) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);
          }
          return;
        }
        const texSize = this.texSize;
        this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
        this.mappedTextures = [];
        for (let i = 0; i < this.subKernels.length; i++) {
          const texture = this.createTexture();
          this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
          gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          if (this.precision === 'single') {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.FLOAT, null);
          } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          }
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);

          this.mappedTextures.push(new this.TextureConstructor({
            texture,
            size: texSize,
            dimensions: this.threadDim,
            output: this.output,
            context: this.context,
            internalFormat: this.getInternalFormat(),
            textureFormat: this.getTextureFormat(),
            kernel: this,
          }));
        }
      }

      setUniform1f(name, value) {
        if (this.uniform1fCache.hasOwnProperty(name)) {
          const cache = this.uniform1fCache[name];
          if (value === cache) {
            return;
          }
        }
        this.uniform1fCache[name] = value;
        const loc = this.getUniformLocation(name);
        this.context.uniform1f(loc, value);
      }

      setUniform1i(name, value) {
        if (this.uniform1iCache.hasOwnProperty(name)) {
          const cache = this.uniform1iCache[name];
          if (value === cache) {
            return;
          }
        }
        this.uniform1iCache[name] = value;
        const loc = this.getUniformLocation(name);
        this.context.uniform1i(loc, value);
      }

      setUniform2f(name, value1, value2) {
        if (this.uniform2fCache.hasOwnProperty(name)) {
          const cache = this.uniform2fCache[name];
          if (
            value1 === cache[0] &&
            value2 === cache[1]
          ) {
            return;
          }
        }
        this.uniform2fCache[name] = [value1, value2];
        const loc = this.getUniformLocation(name);
        this.context.uniform2f(loc, value1, value2);
      }

      setUniform2fv(name, value) {
        if (this.uniform2fvCache.hasOwnProperty(name)) {
          const cache = this.uniform2fvCache[name];
          if (
            value[0] === cache[0] &&
            value[1] === cache[1]
          ) {
            return;
          }
        }
        this.uniform2fvCache[name] = value;
        const loc = this.getUniformLocation(name);
        this.context.uniform2fv(loc, value);
      }

      setUniform2iv(name, value) {
        if (this.uniform2ivCache.hasOwnProperty(name)) {
          const cache = this.uniform2ivCache[name];
          if (
            value[0] === cache[0] &&
            value[1] === cache[1]
          ) {
            return;
          }
        }
        this.uniform2ivCache[name] = value;
        const loc = this.getUniformLocation(name);
        this.context.uniform2iv(loc, value);
      }

      setUniform3fv(name, value) {
        if (this.uniform3fvCache.hasOwnProperty(name)) {
          const cache = this.uniform3fvCache[name];
          if (
            value[0] === cache[0] &&
            value[1] === cache[1] &&
            value[2] === cache[2]
          ) {
            return;
          }
        }
        this.uniform3fvCache[name] = value;
        const loc = this.getUniformLocation(name);
        this.context.uniform3fv(loc, value);
      }

      setUniform3iv(name, value) {
        if (this.uniform3ivCache.hasOwnProperty(name)) {
          const cache = this.uniform3ivCache[name];
          if (
            value[0] === cache[0] &&
            value[1] === cache[1] &&
            value[2] === cache[2]
          ) {
            return;
          }
        }
        this.uniform3ivCache[name] = value;
        const loc = this.getUniformLocation(name);
        this.context.uniform3iv(loc, value);
      }

      setUniform4fv(name, value) {
        if (this.uniform4fvCache.hasOwnProperty(name)) {
          const cache = this.uniform4fvCache[name];
          if (
            value[0] === cache[0] &&
            value[1] === cache[1] &&
            value[2] === cache[2] &&
            value[3] === cache[3]
          ) {
            return;
          }
        }
        this.uniform4fvCache[name] = value;
        const loc = this.getUniformLocation(name);
        this.context.uniform4fv(loc, value);
      }

      setUniform4iv(name, value) {
        if (this.uniform4ivCache.hasOwnProperty(name)) {
          const cache = this.uniform4ivCache[name];
          if (
            value[0] === cache[0] &&
            value[1] === cache[1] &&
            value[2] === cache[2] &&
            value[3] === cache[3]
          ) {
            return;
          }
        }
        this.uniform4ivCache[name] = value;
        const loc = this.getUniformLocation(name);
        this.context.uniform4iv(loc, value);
      }

      getUniformLocation(name) {
        if (this.programUniformLocationCache.hasOwnProperty(name)) {
          return this.programUniformLocationCache[name];
        }
        return this.programUniformLocationCache[name] = this.context.getUniformLocation(this.program, name);
      }

      _getFragShaderArtifactMap(args) {
        return {
          HEADER: this._getHeaderString(),
          LOOP_MAX: this._getLoopMaxString(),
          PLUGINS: this._getPluginsString(),
          CONSTANTS: this._getConstantsString(),
          DECODE32_ENDIANNESS: this._getDecode32EndiannessString(),
          ENCODE32_ENDIANNESS: this._getEncode32EndiannessString(),
          DIVIDE_WITH_INTEGER_CHECK: this._getDivideWithIntegerCheckString(),
          INJECTED_NATIVE: this._getInjectedNative(),
          MAIN_CONSTANTS: this._getMainConstantsString(),
          MAIN_ARGUMENTS: this._getMainArgumentsString(args),
          KERNEL: this.getKernelString(),
          MAIN_RESULT: this.getMainResultString(),
          FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
          INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
          SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
          SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),
        };
      }

      _getVertShaderArtifactMap(args) {
        return {
          FLOAT_TACTIC_DECLARATION: this.getFloatTacticDeclaration(),
          INT_TACTIC_DECLARATION: this.getIntTacticDeclaration(),
          SAMPLER_2D_TACTIC_DECLARATION: this.getSampler2DTacticDeclaration(),
          SAMPLER_2D_ARRAY_TACTIC_DECLARATION: this.getSampler2DArrayTacticDeclaration(),
        };
      }

      _getHeaderString() {
        return (
          this.subKernels !== null ?
          '#extension GL_EXT_draw_buffers : require\n' :
          ''
        );
      }

      _getLoopMaxString() {
        return (
          this.loopMaxIterations ?
          ` ${parseInt(this.loopMaxIterations)};\n` :
          ' 1000;\n'
        );
      }

      _getPluginsString() {
        if (!this.plugins) return '\n';
        return this.plugins.map(plugin => plugin.source && this.source.match(plugin.functionMatch) ? plugin.source : '').join('\n');
      }

      _getConstantsString() {
        const result = [];
        const { threadDim, texSize } = this;
        if (this.dynamicOutput) {
          result.push(
            'uniform ivec3 uOutputDim',
            'uniform ivec2 uTexSize'
          );
        } else {
          result.push(
            `ivec3 uOutputDim = ivec3(${threadDim[0]}, ${threadDim[1]}, ${threadDim[2]})`,
            `ivec2 uTexSize = ivec2(${texSize[0]}, ${texSize[1]})`
          );
        }
        return utils.linesToString(result);
      }

      _getTextureCoordinate() {
        const subKernels = this.subKernels;
        if (subKernels === null || subKernels.length < 1) {
          return 'varying vec2 vTexCoord;\n';
        } else {
          return 'out vec2 vTexCoord;\n';
        }
      }

      _getDecode32EndiannessString() {
        return (
          this.endianness === 'LE' ?
          '' :
          '  texel.rgba = texel.abgr;\n'
        );
      }

      _getEncode32EndiannessString() {
        return (
          this.endianness === 'LE' ?
          '' :
          '  texel.rgba = texel.abgr;\n'
        );
      }

      _getDivideWithIntegerCheckString() {
        return this.fixIntegerDivisionAccuracy ?
          `float divWithIntCheck(float x, float y) {
  if (floor(x) == x && floor(y) == y && integerMod(x, y) == 0.0) {
    return float(int(x) / int(y));
  }
  return x / y;
}

float integerCorrectionModulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -(number - (divisor * floor(divWithIntCheck(number, divisor))));
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return number - (divisor * floor(divWithIntCheck(number, divisor)));
}` :
          '';
      }

      _getMainArgumentsString(args) {
        const results = [];
        const { argumentNames } = this;
        for (let i = 0; i < argumentNames.length; i++) {
          results.push(this.kernelArguments[i].getSource(args[i]));
        }
        return results.join('');
      }

      _getInjectedNative() {
        return this.injectedNative || '';
      }

      _getMainConstantsString() {
        const result = [];
        const { constants } = this;
        if (constants) {
          let i = 0;
          for (const name in constants) {
            if (!this.constants.hasOwnProperty(name)) continue;
            result.push(this.kernelConstants[i++].getSource(this.constants[name]));
          }
        }
        return result.join('');
      }

      getRawValueFramebuffer(width, height) {
        if (!this.rawValueFramebuffers[width]) {
          this.rawValueFramebuffers[width] = {};
        }
        if (!this.rawValueFramebuffers[width][height]) {
          const framebuffer = this.context.createFramebuffer();
          framebuffer.width = width;
          framebuffer.height = height;
          this.rawValueFramebuffers[width][height] = framebuffer;
        }
        return this.rawValueFramebuffers[width][height];
      }

      getKernelResultDeclaration() {
        switch (this.returnType) {
          case 'Array(2)':
            return 'vec2 kernelResult';
          case 'Array(3)':
            return 'vec3 kernelResult';
          case 'Array(4)':
            return 'vec4 kernelResult';
          case 'LiteralInteger':
          case 'Float':
          case 'Number':
          case 'Integer':
            return 'float kernelResult';
          default:
            if (this.graphical) {
              return 'float kernelResult';
            } else {
              throw new Error(`unrecognized output type "${ this.returnType }"`);
            }
        }
      }
      getKernelString() {
        const result = [this.getKernelResultDeclaration()];
        const { subKernels } = this;
        if (subKernels !== null) {
          switch (this.returnType) {
            case 'Number':
            case 'Float':
            case 'Integer':
              for (let i = 0; i < subKernels.length; i++) {
                const subKernel = subKernels[i];
                result.push(
                  subKernel.returnType === 'Integer' ?
                  `int subKernelResult_${ subKernel.name } = 0` :
                  `float subKernelResult_${ subKernel.name } = 0.0`
                );
              }
              break;
            case 'Array(2)':
              for (let i = 0; i < subKernels.length; i++) {
                result.push(
                  `vec2 subKernelResult_${ subKernels[i].name }`
                );
              }
              break;
            case 'Array(3)':
              for (let i = 0; i < subKernels.length; i++) {
                result.push(
                  `vec3 subKernelResult_${ subKernels[i].name }`
                );
              }
              break;
            case 'Array(4)':
              for (let i = 0; i < subKernels.length; i++) {
                result.push(
                  `vec4 subKernelResult_${ subKernels[i].name }`
                );
              }
              break;
          }
        }

        return utils.linesToString(result) + this.translatedSource;
      }

      getMainResultGraphical() {
        return utils.linesToString([
          '  threadId = indexTo3D(index, uOutputDim)',
          '  kernel()',
          '  gl_FragColor = actualColor',
        ]);
      }

      getMainResultPackedPixels() {
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Number':
          case 'Integer':
          case 'Float':
            return this.getMainResultKernelPackedPixels() +
              this.getMainResultSubKernelPackedPixels();
          default:
            throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
        }
      }

      getMainResultKernelPackedPixels() {
        return utils.linesToString([
          '  threadId = indexTo3D(index, uOutputDim)',
          '  kernel()',
          `  gl_FragData[0] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`
        ]);
      }

      getMainResultSubKernelPackedPixels() {
        const result = [];
        if (!this.subKernels) return '';
        for (let i = 0; i < this.subKernels.length; i++) {
          const subKernel = this.subKernels[i];
          if (subKernel.returnType === 'Integer') {
            result.push(
              `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`
            );
          } else {
            result.push(
              `  gl_FragData[${i + 1}] = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`
            );
          }
        }
        return utils.linesToString(result);
      }

      getMainResultMemoryOptimizedFloats() {
        const result = [
          '  index *= 4',
        ];

        switch (this.returnType) {
          case 'Number':
          case 'Integer':
          case 'Float':
            const channels = ['r', 'g', 'b', 'a'];
            for (let i = 0; i < channels.length; i++) {
              const channel = channels[i];
              this.getMainResultKernelMemoryOptimizedFloats(result, channel);
              this.getMainResultSubKernelMemoryOptimizedFloats(result, channel);
              if (i + 1 < channels.length) {
                result.push('  index += 1');
              }
            }
            break;
          default:
            throw new Error(`optimized output only usable with Numbers, ${this.returnType} specified`);
        }

        return utils.linesToString(result);
      }

      getMainResultKernelMemoryOptimizedFloats(result, channel) {
        result.push(
          '  threadId = indexTo3D(index, uOutputDim)',
          '  kernel()',
          `  gl_FragData[0].${channel} = kernelResult`
        );
      }

      getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
        if (!this.subKernels) return result;
        for (let i = 0; i < this.subKernels.length; i++) {
          const subKernel = this.subKernels[i];
          if (subKernel.returnType === 'Integer') {
            result.push(
              `  gl_FragData[${i + 1}].${channel} = float(subKernelResult_${this.subKernels[i].name})`
            );
          } else {
            result.push(
              `  gl_FragData[${i + 1}].${channel} = subKernelResult_${this.subKernels[i].name}`
            );
          }
        }
      }

      getMainResultKernelNumberTexture() {
        return [
          '  threadId = indexTo3D(index, uOutputDim)',
          '  kernel()',
          '  gl_FragData[0][0] = kernelResult',
        ];
      }

      getMainResultSubKernelNumberTexture() {
        const result = [];
        if (!this.subKernels) return result;
        for (let i = 0; i < this.subKernels.length; ++i) {
          const subKernel = this.subKernels[i];
          if (subKernel.returnType === 'Integer') {
            result.push(
              `  gl_FragData[${i + 1}][0] = float(subKernelResult_${subKernel.name})`
            );
          } else {
            result.push(
              `  gl_FragData[${i + 1}][0] = subKernelResult_${subKernel.name}`
            );
          }
        }
        return result;
      }

      getMainResultKernelArray2Texture() {
        return [
          '  threadId = indexTo3D(index, uOutputDim)',
          '  kernel()',
          '  gl_FragData[0][0] = kernelResult[0]',
          '  gl_FragData[0][1] = kernelResult[1]',
        ];
      }

      getMainResultSubKernelArray2Texture() {
        const result = [];
        if (!this.subKernels) return result;
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`
          );
        }
        return result;
      }

      getMainResultKernelArray3Texture() {
        return [
          '  threadId = indexTo3D(index, uOutputDim)',
          '  kernel()',
          '  gl_FragData[0][0] = kernelResult[0]',
          '  gl_FragData[0][1] = kernelResult[1]',
          '  gl_FragData[0][2] = kernelResult[2]',
        ];
      }

      getMainResultSubKernelArray3Texture() {
        const result = [];
        if (!this.subKernels) return result;
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
            `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
            `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`
          );
        }
        return result;
      }

      getMainResultKernelArray4Texture() {
        return [
          '  threadId = indexTo3D(index, uOutputDim)',
          '  kernel()',
          '  gl_FragData[0] = kernelResult',
        ];
      }

      getMainResultSubKernelArray4Texture() {
        const result = [];
        if (!this.subKernels) return result;
        switch (this.returnType) {
          case 'Number':
          case 'Float':
          case 'Integer':
            for (let i = 0; i < this.subKernels.length; ++i) {
              const subKernel = this.subKernels[i];
              if (subKernel.returnType === 'Integer') {
                result.push(
                  `  gl_FragData[${i + 1}] = float(subKernelResult_${this.subKernels[i].name})`
                );
              } else {
                result.push(
                  `  gl_FragData[${i + 1}] = subKernelResult_${this.subKernels[i].name}`
                );
              }
            }
            break;
          case 'Array(2)':
            for (let i = 0; i < this.subKernels.length; ++i) {
              result.push(
                `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
                `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`
              );
            }
            break;
          case 'Array(3)':
            for (let i = 0; i < this.subKernels.length; ++i) {
              result.push(
                `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
                `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
                `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`
              );
            }
            break;
          case 'Array(4)':
            for (let i = 0; i < this.subKernels.length; ++i) {
              result.push(
                `  gl_FragData[${i + 1}][0] = subKernelResult_${this.subKernels[i].name}[0]`,
                `  gl_FragData[${i + 1}][1] = subKernelResult_${this.subKernels[i].name}[1]`,
                `  gl_FragData[${i + 1}][2] = subKernelResult_${this.subKernels[i].name}[2]`,
                `  gl_FragData[${i + 1}][3] = subKernelResult_${this.subKernels[i].name}[3]`
              );
            }
            break;
        }

        return result;
      }

      replaceArtifacts(src, map) {
        return src.replace(/[ ]*__([A-Z]+[0-9]*([_]?[A-Z]*[0-9]?)*)__;\n/g, (match, artifact) => {
          if (map.hasOwnProperty(artifact)) {
            return map[artifact];
          }
          throw `unhandled artifact ${artifact}`;
        });
      }

      getFragmentShader(args) {
        if (this.compiledFragmentShader !== null) {
          return this.compiledFragmentShader;
        }
        return this.compiledFragmentShader = this.replaceArtifacts(this.constructor.fragmentShader, this._getFragShaderArtifactMap(args));
      }

      getVertexShader(args) {
        if (this.compiledVertexShader !== null) {
          return this.compiledVertexShader;
        }
        return this.compiledVertexShader = this.replaceArtifacts(this.constructor.vertexShader, this._getVertShaderArtifactMap(args));
      }

      toString() {
        const setupContextString = utils.linesToString([
          `const gl = context`,
        ]);
        return glKernelString(this.constructor, arguments, this, setupContextString);
      }

      destroy(removeCanvasReferences) {
        if (!this.context) return;
        if (this.buffer) {
          this.context.deleteBuffer(this.buffer);
        }
        if (this.framebuffer) {
          this.context.deleteFramebuffer(this.framebuffer);
        }
        for (const width in this.rawValueFramebuffers) {
          for (const height in this.rawValueFramebuffers[width]) {
            this.context.deleteFramebuffer(this.rawValueFramebuffers[width][height]);
            delete this.rawValueFramebuffers[width][height];
          }
          delete this.rawValueFramebuffers[width];
        }
        if (this.vertShader) {
          this.context.deleteShader(this.vertShader);
        }
        if (this.fragShader) {
          this.context.deleteShader(this.fragShader);
        }
        if (this.program) {
          this.context.deleteProgram(this.program);
        }
        if (this.texture) {
          this.texture.delete();
          const textureCacheIndex = this.textureCache.indexOf(this.texture.texture);
          if (textureCacheIndex > -1) {
            this.textureCache.splice(textureCacheIndex, 1);
          }
          this.texture = null;
        }
        if (this.mappedTextures && this.mappedTextures.length) {
          for (let i = 0; i < this.mappedTextures.length; i++) {
            const mappedTexture = this.mappedTextures[i];
            mappedTexture.delete();
            const textureCacheIndex = this.textureCache.indexOf(mappedTexture.texture);
            if (textureCacheIndex > -1) {
              this.textureCache.splice(textureCacheIndex, 1);
            }
          }
          this.mappedTextures = null;
        }
        if (this.kernelArguments) {
          for (let i = 0; i < this.kernelArguments.length; i++) {
            this.kernelArguments[i].destroy();
          }
        }
        if (this.kernelConstants) {
          for (let i = 0; i < this.kernelConstants.length; i++) {
            this.kernelConstants[i].destroy();
          }
        }
        while (this.textureCache.length > 0) {
          const texture = this.textureCache.pop();
          this.context.deleteTexture(texture);
        }
        if (removeCanvasReferences) {
          const idx = canvases.indexOf(this.canvas);
          if (idx >= 0) {
            canvases[idx] = null;
            maxTexSizes[idx] = null;
          }
        }
        this.destroyExtensions();
        delete this.context;
        delete this.canvas;
        if (!this.gpu) return;
        const i = this.gpu.kernels.indexOf(this);
        if (i === -1) return;
        this.gpu.kernels.splice(i, 1);
      }

      destroyExtensions() {
        this.extensions.OES_texture_float = null;
        this.extensions.OES_texture_float_linear = null;
        this.extensions.OES_element_index_uint = null;
        this.extensions.WEBGL_draw_buffers = null;
      }

      static destroyContext(context) {
        const extension = context.getExtension('WEBGL_lose_context');
        if (extension) {
          extension.loseContext();
        }
      }

      toJSON() {
        const json = super.toJSON();
        json.functionNodes = FunctionBuilder.fromKernel(this, WebGLFunctionNode).toJSON();
        json.settings.threadDim = this.threadDim;
        return json;
      }
    }

    module.exports = {
      WebGLKernel
    };
    },{"../../plugins/math-random-uniformly-distributed":112,"../../utils":114,"../function-builder":9,"../gl/kernel":13,"../gl/kernel-string":12,"./fragment-shader":37,"./function-node":38,"./kernel-value-maps":39,"./vertex-shader":71}],71:[function(require,module,exports){
    const vertexShader = `__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

attribute vec2 aPos;
attribute vec2 aTexCoord;

varying vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;

    module.exports = {
      vertexShader
    };
    },{}],72:[function(require,module,exports){
    const fragmentShader = `#version 300 es
__HEADER__;
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;
__SAMPLER_2D_ARRAY_TACTIC_DECLARATION__;

const int LOOP_MAX = __LOOP_MAX__;

__PLUGINS__;
__CONSTANTS__;

in vec2 vTexCoord;

float atan2(float v1, float v2) {
  if (v1 == 0.0 || v2 == 0.0) return 0.0;
  return atan(v1 / v2);
}

float cbrt(float x) {
  if (x >= 0.0) {
    return pow(x, 1.0 / 3.0);
  } else {
    return -pow(x, 1.0 / 3.0);
  }
}

float expm1(float x) {
  return pow(${Math.E}, x) - 1.0; 
}

float fround(highp float x) {
  return x;
}

float imul(float v1, float v2) {
  return float(int(v1) * int(v2));
}

float log10(float x) {
  return log2(x) * (1.0 / log2(10.0));
}

float log1p(float x) {
  return log(1.0 + x);
}

float _pow(float v1, float v2) {
  if (v2 == 0.0) return 1.0;
  return pow(v1, v2);
}

float _round(float x) {
  return floor(x + 0.5);
}


const int BIT_COUNT = 32;
int modi(int x, int y) {
  return x - y * (x / y);
}

int bitwiseOr(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) || (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseXOR(int a, int b) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) != (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 || b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseAnd(int a, int b) {
  int result = 0;
  int n = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if ((modi(a, 2) == 1) && (modi(b, 2) == 1)) {
      result += n;
    }
    a = a / 2;
    b = b / 2;
    n = n * 2;
    if(!(a > 0 && b > 0)) {
      break;
    }
  }
  return result;
}
int bitwiseNot(int a) {
  int result = 0;
  int n = 1;
  
  for (int i = 0; i < BIT_COUNT; i++) {
    if (modi(a, 2) == 0) {
      result += n;    
    }
    a = a / 2;
    n = n * 2;
  }
  return result;
}
int bitwiseZeroFillLeftShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n *= 2;
  }

  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

int bitwiseSignedRightShift(int num, int shifts) {
  return int(floor(float(num) / pow(2.0, float(shifts))));
}

int bitwiseZeroFillRightShift(int n, int shift) {
  int maxBytes = BIT_COUNT;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (maxBytes >= n) {
      break;
    }
    maxBytes *= 2;
  }
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= shift) {
      break;
    }
    n /= 2;
  }
  int result = 0;
  int byteVal = 1;
  for (int i = 0; i < BIT_COUNT; i++) {
    if (i >= maxBytes) break;
    if (modi(n, 2) > 0) { result += byteVal; }
    n = int(n / 2);
    byteVal *= 2;
  }
  return result;
}

vec2 integerMod(vec2 x, float y) {
  vec2 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec3 integerMod(vec3 x, float y) {
  vec3 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

vec4 integerMod(vec4 x, vec4 y) {
  vec4 res = floor(mod(x, y));
  return res * step(1.0 - floor(y), -res);
}

float integerMod(float x, float y) {
  float res = floor(mod(x, y));
  return res * (res > floor(y) - 1.0 ? 0.0 : 1.0);
}

int integerMod(int x, int y) {
  return x - (y * int(x/y));
}

__DIVIDE_WITH_INTEGER_CHECK__;

// Here be dragons!
// DO NOT OPTIMIZE THIS CODE
// YOU WILL BREAK SOMETHING ON SOMEBODY\'S MACHINE
// LEAVE IT AS IT IS, LEST YOU WASTE YOUR OWN TIME
const vec2 MAGIC_VEC = vec2(1.0, -256.0);
const vec4 SCALE_FACTOR = vec4(1.0, 256.0, 65536.0, 0.0);
const vec4 SCALE_FACTOR_INV = vec4(1.0, 0.00390625, 0.0000152587890625, 0.0); // 1, 1/256, 1/65536
float decode32(vec4 texel) {
  __DECODE32_ENDIANNESS__;
  texel *= 255.0;
  vec2 gte128;
  gte128.x = texel.b >= 128.0 ? 1.0 : 0.0;
  gte128.y = texel.a >= 128.0 ? 1.0 : 0.0;
  float exponent = 2.0 * texel.a - 127.0 + dot(gte128, MAGIC_VEC);
  float res = exp2(round(exponent));
  texel.b = texel.b - 128.0 * gte128.x;
  res = dot(texel, SCALE_FACTOR) * exp2(round(exponent-23.0)) + res;
  res *= gte128.y * -2.0 + 1.0;
  return res;
}

float decode16(vec4 texel, int index) {
  int channel = integerMod(index, 2);
  return texel[channel*2] * 255.0 + texel[channel*2 + 1] * 65280.0;
}

float decode8(vec4 texel, int index) {
  int channel = integerMod(index, 4);
  return texel[channel] * 255.0;
}

vec4 legacyEncode32(float f) {
  float F = abs(f);
  float sign = f < 0.0 ? 1.0 : 0.0;
  float exponent = floor(log2(F));
  float mantissa = (exp2(-exponent) * F);
  // exponent += floor(log2(mantissa));
  vec4 texel = vec4(F * exp2(23.0-exponent)) * SCALE_FACTOR_INV;
  texel.rg = integerMod(texel.rg, 256.0);
  texel.b = integerMod(texel.b, 128.0);
  texel.a = exponent*0.5 + 63.5;
  texel.ba += vec2(integerMod(exponent+127.0, 2.0), sign) * 128.0;
  texel = floor(texel);
  texel *= 0.003921569; // 1/255
  __ENCODE32_ENDIANNESS__;
  return texel;
}

// https://github.com/gpujs/gpu.js/wiki/Encoder-details
vec4 encode32(float value) {
  if (value == 0.0) return vec4(0, 0, 0, 0);

  float exponent;
  float mantissa;
  vec4  result;
  float sgn;

  sgn = step(0.0, -value);
  value = abs(value);

  exponent = floor(log2(value));

  mantissa = value*pow(2.0, -exponent)-1.0;
  exponent = exponent+127.0;
  result   = vec4(0,0,0,0);

  result.a = floor(exponent/2.0);
  exponent = exponent - result.a*2.0;
  result.a = result.a + 128.0*sgn;

  result.b = floor(mantissa * 128.0);
  mantissa = mantissa - result.b / 128.0;
  result.b = result.b + exponent*128.0;

  result.g = floor(mantissa*32768.0);
  mantissa = mantissa - result.g/32768.0;

  result.r = floor(mantissa*8388608.0);
  return result/255.0;
}
// Dragons end here

int index;
ivec3 threadId;

ivec3 indexTo3D(int idx, ivec3 texDim) {
  int z = int(idx / (texDim.x * texDim.y));
  idx -= z * int(texDim.x * texDim.y);
  int y = int(idx / texDim.x);
  int x = int(integerMod(idx, texDim.x));
  return ivec3(x, y, z);
}

float get32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return decode32(texel);
}

float get16(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 2;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 2, texSize.y));
  return decode16(texel, index);
}

float get8(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int w = texSize.x * 4;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize.x * 4, texSize.y));
  return decode8(texel, index);
}

float getMemoryOptimized32(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + (texDim.x * (y + (texDim.y * z)));
  int channel = integerMod(index, 4);
  index = index / 4;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  index = index / 4;
  vec4 texel = texture(tex, st / vec2(texSize));
  return texel[channel];
}

vec4 getImage2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, st / vec2(texSize));
}

vec4 getImage3D(sampler2DArray tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  return texture(tex, vec3(st / vec2(texSize), z));
}

float getFloatFromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return result[0];
}

vec2 getVec2FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec2(result[0], result[1]);
}

vec2 getMemoryOptimizedVec2(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  index = index / 2;
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  if (channel == 0) return vec2(texel.r, texel.g);
  if (channel == 1) return vec2(texel.b, texel.a);
  return vec2(0.0, 0.0);
}

vec3 getVec3FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  vec4 result = getImage2D(tex, texSize, texDim, z, y, x);
  return vec3(result[0], result[1], result[2]);
}

vec3 getMemoryOptimizedVec3(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int fieldIndex = 3 * (x + texDim.x * (y + texDim.y * z));
  int vectorIndex = fieldIndex / 4;
  int vectorOffset = fieldIndex - vectorIndex * 4;
  int readY = vectorIndex / texSize.x;
  int readX = vectorIndex - readY * texSize.x;
  vec4 tex1 = texture(tex, (vec2(readX, readY) + 0.5) / vec2(texSize));

  if (vectorOffset == 0) {
    return tex1.xyz;
  } else if (vectorOffset == 1) {
    return tex1.yzw;
  } else {
    readX++;
    if (readX >= texSize.x) {
      readX = 0;
      readY++;
    }
    vec4 tex2 = texture(tex, vec2(readX, readY) / vec2(texSize));
    if (vectorOffset == 2) {
      return vec3(tex1.z, tex1.w, tex2.x);
    } else {
      return vec3(tex1.w, tex2.x, tex2.y);
    }
  }
}

vec4 getVec4FromSampler2D(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  return getImage2D(tex, texSize, texDim, z, y, x);
}

vec4 getMemoryOptimizedVec4(sampler2D tex, ivec2 texSize, ivec3 texDim, int z, int y, int x) {
  int index = x + texDim.x * (y + texDim.y * z);
  int channel = integerMod(index, 2);
  int w = texSize.x;
  vec2 st = vec2(float(integerMod(index, w)), float(index / w)) + 0.5;
  vec4 texel = texture(tex, st / vec2(texSize));
  return vec4(texel.r, texel.g, texel.b, texel.a);
}

vec4 actualColor;
void color(float r, float g, float b, float a) {
  actualColor = vec4(r,g,b,a);
}

void color(float r, float g, float b) {
  color(r,g,b,1.0);
}

float modulo(float number, float divisor) {
  if (number < 0.0) {
    number = abs(number);
    if (divisor < 0.0) {
      divisor = abs(divisor);
    }
    return -mod(number, divisor);
  }
  if (divisor < 0.0) {
    divisor = abs(divisor);
  }
  return mod(number, divisor);
}

__INJECTED_NATIVE__;
__MAIN_CONSTANTS__;
__MAIN_ARGUMENTS__;
__KERNEL__;

void main(void) {
  index = int(vTexCoord.s * float(uTexSize.x)) + int(vTexCoord.t * float(uTexSize.y)) * uTexSize.x;
  __MAIN_RESULT__;
}`;

    module.exports = {
      fragmentShader
    };
    },{}],73:[function(require,module,exports){
    const { utils } = require('../../utils');
    const { WebGLFunctionNode } = require('../web-gl/function-node');

    class WebGL2FunctionNode extends WebGLFunctionNode {

      astIdentifierExpression(idtNode, retArr) {
        if (idtNode.type !== 'Identifier') {
          throw this.astErrorOutput(
            'IdentifierExpression - not an Identifier',
            idtNode
          );
        }

        const type = this.getType(idtNode);

        const name = utils.sanitizeName(idtNode.name);
        if (idtNode.name === 'Infinity') {
          retArr.push('intBitsToFloat(2139095039)');
        } else if (type === 'Boolean') {
          if (this.argumentNames.indexOf(name) > -1) {
            retArr.push(`bool(user_${name})`);
          } else {
            retArr.push(`user_${name}`);
          }
        } else {
          retArr.push(`user_${name}`);
        }

        return retArr;
      }
    }

    module.exports = {
      WebGL2FunctionNode
    };
    },{"../../utils":114,"../web-gl/function-node":38}],74:[function(require,module,exports){
    const { WebGL2KernelValueBoolean } = require('./kernel-value/boolean');
    const { WebGL2KernelValueFloat } = require('./kernel-value/float');
    const { WebGL2KernelValueInteger } = require('./kernel-value/integer');

    const { WebGL2KernelValueHTMLImage } = require('./kernel-value/html-image');
    const { WebGL2KernelValueDynamicHTMLImage } = require('./kernel-value/dynamic-html-image');

    const { WebGL2KernelValueHTMLImageArray } = require('./kernel-value/html-image-array');
    const { WebGL2KernelValueDynamicHTMLImageArray } = require('./kernel-value/dynamic-html-image-array');

    const { WebGL2KernelValueHTMLVideo } = require('./kernel-value/html-video');
    const { WebGL2KernelValueDynamicHTMLVideo } = require('./kernel-value/dynamic-html-video');

    const { WebGL2KernelValueSingleInput } = require('./kernel-value/single-input');
    const { WebGL2KernelValueDynamicSingleInput } = require('./kernel-value/dynamic-single-input');

    const { WebGL2KernelValueUnsignedInput } = require('./kernel-value/unsigned-input');
    const { WebGL2KernelValueDynamicUnsignedInput } = require('./kernel-value/dynamic-unsigned-input');

    const { WebGL2KernelValueMemoryOptimizedNumberTexture } = require('./kernel-value/memory-optimized-number-texture');
    const { WebGL2KernelValueDynamicMemoryOptimizedNumberTexture } = require('./kernel-value/dynamic-memory-optimized-number-texture');

    const { WebGL2KernelValueNumberTexture } = require('./kernel-value/number-texture');
    const { WebGL2KernelValueDynamicNumberTexture } = require('./kernel-value/dynamic-number-texture');

    const { WebGL2KernelValueSingleArray } = require('./kernel-value/single-array');
    const { WebGL2KernelValueDynamicSingleArray } = require('./kernel-value/dynamic-single-array');

    const { WebGL2KernelValueSingleArray1DI } = require('./kernel-value/single-array1d-i');
    const { WebGL2KernelValueDynamicSingleArray1DI } = require('./kernel-value/dynamic-single-array1d-i');

    const { WebGL2KernelValueSingleArray2DI } = require('./kernel-value/single-array2d-i');
    const { WebGL2KernelValueDynamicSingleArray2DI } = require('./kernel-value/dynamic-single-array2d-i');

    const { WebGL2KernelValueSingleArray3DI } = require('./kernel-value/single-array3d-i');
    const { WebGL2KernelValueDynamicSingleArray3DI } = require('./kernel-value/dynamic-single-array3d-i');

    const { WebGL2KernelValueArray2 } = require('./kernel-value/array2');
    const { WebGL2KernelValueArray3 } = require('./kernel-value/array3');
    const { WebGL2KernelValueArray4 } = require('./kernel-value/array4');

    const { WebGL2KernelValueUnsignedArray } = require('./kernel-value/unsigned-array');
    const { WebGL2KernelValueDynamicUnsignedArray } = require('./kernel-value/dynamic-unsigned-array');

    const kernelValueMaps = {
      unsigned: {
        dynamic: {
          'Boolean': WebGL2KernelValueBoolean,
          'Integer': WebGL2KernelValueInteger,
          'Float': WebGL2KernelValueFloat,
          'Array': WebGL2KernelValueDynamicUnsignedArray,
          'Array(2)': WebGL2KernelValueArray2,
          'Array(3)': WebGL2KernelValueArray3,
          'Array(4)': WebGL2KernelValueArray4,
          'Array1D(2)': false,
          'Array1D(3)': false,
          'Array1D(4)': false,
          'Array2D(2)': false,
          'Array2D(3)': false,
          'Array2D(4)': false,
          'Array3D(2)': false,
          'Array3D(3)': false,
          'Array3D(4)': false,
          'Input': WebGL2KernelValueDynamicUnsignedInput,
          'NumberTexture': WebGL2KernelValueDynamicNumberTexture,
          'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,
          'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,
          'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,
          'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,
          'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
          'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,
          'OffscreenCanvas': WebGL2KernelValueDynamicHTMLImage,
          'HTMLImage': WebGL2KernelValueDynamicHTMLImage,
          'ImageBitmap': WebGL2KernelValueDynamicHTMLImage,
          'ImageData': WebGL2KernelValueDynamicHTMLImage,
          'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,
          'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,
        },
        static: {
          'Boolean': WebGL2KernelValueBoolean,
          'Float': WebGL2KernelValueFloat,
          'Integer': WebGL2KernelValueInteger,
          'Array': WebGL2KernelValueUnsignedArray,
          'Array(2)': WebGL2KernelValueArray2,
          'Array(3)': WebGL2KernelValueArray3,
          'Array(4)': WebGL2KernelValueArray4,
          'Array1D(2)': false,
          'Array1D(3)': false,
          'Array1D(4)': false,
          'Array2D(2)': false,
          'Array2D(3)': false,
          'Array2D(4)': false,
          'Array3D(2)': false,
          'Array3D(3)': false,
          'Array3D(4)': false,
          'Input': WebGL2KernelValueUnsignedInput,
          'NumberTexture': WebGL2KernelValueNumberTexture,
          'ArrayTexture(1)': WebGL2KernelValueNumberTexture,
          'ArrayTexture(2)': WebGL2KernelValueNumberTexture,
          'ArrayTexture(3)': WebGL2KernelValueNumberTexture,
          'ArrayTexture(4)': WebGL2KernelValueNumberTexture,
          'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
          'HTMLCanvas': WebGL2KernelValueHTMLImage,
          'OffscreenCanvas': WebGL2KernelValueHTMLImage,
          'HTMLImage': WebGL2KernelValueHTMLImage,
          'ImageBitmap': WebGL2KernelValueHTMLImage,
          'ImageData': WebGL2KernelValueHTMLImage,
          'HTMLImageArray': WebGL2KernelValueHTMLImageArray,
          'HTMLVideo': WebGL2KernelValueHTMLVideo,
        }
      },
      single: {
        dynamic: {
          'Boolean': WebGL2KernelValueBoolean,
          'Integer': WebGL2KernelValueInteger,
          'Float': WebGL2KernelValueFloat,
          'Array': WebGL2KernelValueDynamicSingleArray,
          'Array(2)': WebGL2KernelValueArray2,
          'Array(3)': WebGL2KernelValueArray3,
          'Array(4)': WebGL2KernelValueArray4,
          'Array1D(2)': WebGL2KernelValueDynamicSingleArray1DI,
          'Array1D(3)': WebGL2KernelValueDynamicSingleArray1DI,
          'Array1D(4)': WebGL2KernelValueDynamicSingleArray1DI,
          'Array2D(2)': WebGL2KernelValueDynamicSingleArray2DI,
          'Array2D(3)': WebGL2KernelValueDynamicSingleArray2DI,
          'Array2D(4)': WebGL2KernelValueDynamicSingleArray2DI,
          'Array3D(2)': WebGL2KernelValueDynamicSingleArray3DI,
          'Array3D(3)': WebGL2KernelValueDynamicSingleArray3DI,
          'Array3D(4)': WebGL2KernelValueDynamicSingleArray3DI,
          'Input': WebGL2KernelValueDynamicSingleInput,
          'NumberTexture': WebGL2KernelValueDynamicNumberTexture,
          'ArrayTexture(1)': WebGL2KernelValueDynamicNumberTexture,
          'ArrayTexture(2)': WebGL2KernelValueDynamicNumberTexture,
          'ArrayTexture(3)': WebGL2KernelValueDynamicNumberTexture,
          'ArrayTexture(4)': WebGL2KernelValueDynamicNumberTexture,
          'MemoryOptimizedNumberTexture': WebGL2KernelValueDynamicMemoryOptimizedNumberTexture,
          'HTMLCanvas': WebGL2KernelValueDynamicHTMLImage,
          'OffscreenCanvas': WebGL2KernelValueDynamicHTMLImage,
          'HTMLImage': WebGL2KernelValueDynamicHTMLImage,
          'ImageBitmap': WebGL2KernelValueDynamicHTMLImage,
          'ImageData': WebGL2KernelValueDynamicHTMLImage,
          'HTMLImageArray': WebGL2KernelValueDynamicHTMLImageArray,
          'HTMLVideo': WebGL2KernelValueDynamicHTMLVideo,
        },
        static: {
          'Boolean': WebGL2KernelValueBoolean,
          'Float': WebGL2KernelValueFloat,
          'Integer': WebGL2KernelValueInteger,
          'Array': WebGL2KernelValueSingleArray,
          'Array(2)': WebGL2KernelValueArray2,
          'Array(3)': WebGL2KernelValueArray3,
          'Array(4)': WebGL2KernelValueArray4,
          'Array1D(2)': WebGL2KernelValueSingleArray1DI,
          'Array1D(3)': WebGL2KernelValueSingleArray1DI,
          'Array1D(4)': WebGL2KernelValueSingleArray1DI,
          'Array2D(2)': WebGL2KernelValueSingleArray2DI,
          'Array2D(3)': WebGL2KernelValueSingleArray2DI,
          'Array2D(4)': WebGL2KernelValueSingleArray2DI,
          'Array3D(2)': WebGL2KernelValueSingleArray3DI,
          'Array3D(3)': WebGL2KernelValueSingleArray3DI,
          'Array3D(4)': WebGL2KernelValueSingleArray3DI,
          'Input': WebGL2KernelValueSingleInput,
          'NumberTexture': WebGL2KernelValueNumberTexture,
          'ArrayTexture(1)': WebGL2KernelValueNumberTexture,
          'ArrayTexture(2)': WebGL2KernelValueNumberTexture,
          'ArrayTexture(3)': WebGL2KernelValueNumberTexture,
          'ArrayTexture(4)': WebGL2KernelValueNumberTexture,
          'MemoryOptimizedNumberTexture': WebGL2KernelValueMemoryOptimizedNumberTexture,
          'HTMLCanvas': WebGL2KernelValueHTMLImage,
          'OffscreenCanvas': WebGL2KernelValueHTMLImage,
          'HTMLImage': WebGL2KernelValueHTMLImage,
          'ImageBitmap': WebGL2KernelValueHTMLImage,
          'ImageData': WebGL2KernelValueHTMLImage,
          'HTMLImageArray': WebGL2KernelValueHTMLImageArray,
          'HTMLVideo': WebGL2KernelValueHTMLVideo,
        }
      },
    };

    function lookupKernelValueType(type, dynamic, precision, value) {
      if (!type) {
        throw new Error('type missing');
      }
      if (!dynamic) {
        throw new Error('dynamic missing');
      }
      if (!precision) {
        throw new Error('precision missing');
      }
      if (value.type) {
        type = value.type;
      }
      const types = kernelValueMaps[precision][dynamic];
      if (types[type] === false) {
        return null;
      } else if (types[type] === undefined) {
        throw new Error(`Could not find a KernelValue for ${ type }`);
      }
      return types[type];
    }

    module.exports = {
      kernelValueMaps,
      lookupKernelValueType
    };
    },{"./kernel-value/array2":75,"./kernel-value/array3":76,"./kernel-value/array4":77,"./kernel-value/boolean":78,"./kernel-value/dynamic-html-image":80,"./kernel-value/dynamic-html-image-array":79,"./kernel-value/dynamic-html-video":81,"./kernel-value/dynamic-memory-optimized-number-texture":82,"./kernel-value/dynamic-number-texture":83,"./kernel-value/dynamic-single-array":84,"./kernel-value/dynamic-single-array1d-i":85,"./kernel-value/dynamic-single-array2d-i":86,"./kernel-value/dynamic-single-array3d-i":87,"./kernel-value/dynamic-single-input":88,"./kernel-value/dynamic-unsigned-array":89,"./kernel-value/dynamic-unsigned-input":90,"./kernel-value/float":91,"./kernel-value/html-image":93,"./kernel-value/html-image-array":92,"./kernel-value/html-video":94,"./kernel-value/integer":95,"./kernel-value/memory-optimized-number-texture":96,"./kernel-value/number-texture":97,"./kernel-value/single-array":98,"./kernel-value/single-array1d-i":99,"./kernel-value/single-array2d-i":100,"./kernel-value/single-array3d-i":101,"./kernel-value/single-input":102,"./kernel-value/unsigned-array":103,"./kernel-value/unsigned-input":104}],75:[function(require,module,exports){
    const { WebGLKernelValueArray2 } = require('../../web-gl/kernel-value/array2');

    class WebGL2KernelValueArray2 extends WebGLKernelValueArray2 {}

    module.exports = {
      WebGL2KernelValueArray2
    };
    },{"../../web-gl/kernel-value/array2":41}],76:[function(require,module,exports){
    const { WebGLKernelValueArray3 } = require('../../web-gl/kernel-value/array3');

    class WebGL2KernelValueArray3 extends WebGLKernelValueArray3 {}

    module.exports = {
      WebGL2KernelValueArray3
    };
    },{"../../web-gl/kernel-value/array3":42}],77:[function(require,module,exports){
    const { WebGLKernelValueArray4 } = require('../../web-gl/kernel-value/array4');

    class WebGL2KernelValueArray4 extends WebGLKernelValueArray4 {}

    module.exports = {
      WebGL2KernelValueArray4
    };
    },{"../../web-gl/kernel-value/array4":43}],78:[function(require,module,exports){
    const { WebGLKernelValueBoolean } = require('../../web-gl/kernel-value/boolean');

    class WebGL2KernelValueBoolean extends WebGLKernelValueBoolean {}

    module.exports = {
      WebGL2KernelValueBoolean
    };
    },{"../../web-gl/kernel-value/boolean":44}],79:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGL2KernelValueHTMLImageArray } = require('./html-image-array');

    class WebGL2KernelValueDynamicHTMLImageArray extends WebGL2KernelValueHTMLImageArray {
      getSource() {
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2DArray ${this.id}`,
          `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
          `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
        ]);
      }

      updateValue(images) {
        const { width, height } = images[0];
        this.checkSize(width, height);
        this.dimensions = [width, height, images.length];
        this.textureSize = [width, height];
        this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
        this.kernel.setUniform2iv(this.sizeId, this.textureSize);
        super.updateValue(images);
      }
    }

    module.exports = {
      WebGL2KernelValueDynamicHTMLImageArray
    };
    },{"../../../utils":114,"./html-image-array":92}],80:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueDynamicHTMLImage } = require('../../web-gl/kernel-value/dynamic-html-image');

    class WebGL2KernelValueDynamicHTMLImage extends WebGLKernelValueDynamicHTMLImage {
      getSource() {
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2D ${this.id}`,
          `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
          `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
        ]);
      }
    }

    module.exports = {
      WebGL2KernelValueDynamicHTMLImage
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/dynamic-html-image":45}],81:[function(require,module,exports){
    require('../../../utils');
    const { WebGL2KernelValueDynamicHTMLImage } = require('./dynamic-html-image');

    class WebGL2KernelValueDynamicHTMLVideo extends WebGL2KernelValueDynamicHTMLImage {}

    module.exports = {
      WebGL2KernelValueDynamicHTMLVideo
    };
    },{"../../../utils":114,"./dynamic-html-image":80}],82:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueDynamicMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/dynamic-memory-optimized-number-texture');

    class WebGL2KernelValueDynamicMemoryOptimizedNumberTexture extends WebGLKernelValueDynamicMemoryOptimizedNumberTexture {
      getSource() {
        return utils.linesToString([
          `uniform sampler2D ${this.id}`,
          `uniform ivec2 ${this.sizeId}`,
          `uniform ivec3 ${this.dimensionsId}`,
        ]);
      }
    }

    module.exports = {
      WebGL2KernelValueDynamicMemoryOptimizedNumberTexture
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/dynamic-memory-optimized-number-texture":47}],83:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueDynamicNumberTexture } = require('../../web-gl/kernel-value/dynamic-number-texture');

    class WebGL2KernelValueDynamicNumberTexture extends WebGLKernelValueDynamicNumberTexture {
      getSource() {
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2D ${this.id}`,
          `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
          `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
        ]);
      }
    }

    module.exports = {
      WebGL2KernelValueDynamicNumberTexture
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/dynamic-number-texture":48}],84:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGL2KernelValueSingleArray } = require('../../web-gl2/kernel-value/single-array');

    class WebGL2KernelValueDynamicSingleArray extends WebGL2KernelValueSingleArray {
      getSource() {
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2D ${this.id}`,
          `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
          `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
        ]);
      }

      updateValue(value) {
        this.dimensions = utils.getDimensions(value, true);
        this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
        this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
        this.checkSize(this.textureSize[0], this.textureSize[1]);
        this.uploadValue = new Float32Array(this.uploadArrayLength);
        this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
        this.kernel.setUniform2iv(this.sizeId, this.textureSize);
        super.updateValue(value);
      }
    }

    module.exports = {
      WebGL2KernelValueDynamicSingleArray
    };
    },{"../../../utils":114,"../../web-gl2/kernel-value/single-array":98}],85:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGL2KernelValueSingleArray1DI } = require('../../web-gl2/kernel-value/single-array1d-i');

    class WebGL2KernelValueDynamicSingleArray1DI extends WebGL2KernelValueSingleArray1DI {
      getSource() {
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2D ${this.id}`,
          `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
          `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
        ]);
      }

      updateValue(value) {
        this.setShape(value);
        this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
        this.kernel.setUniform2iv(this.sizeId, this.textureSize);
        super.updateValue(value);
      }
    }

    module.exports = {
      WebGL2KernelValueDynamicSingleArray1DI
    };
    },{"../../../utils":114,"../../web-gl2/kernel-value/single-array1d-i":99}],86:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGL2KernelValueSingleArray2DI } = require('../../web-gl2/kernel-value/single-array2d-i');

    class WebGL2KernelValueDynamicSingleArray2DI extends WebGL2KernelValueSingleArray2DI {
      getSource() {
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2D ${this.id}`,
          `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
          `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
        ]);
      }

      updateValue(value) {
        this.setShape(value);
        this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
        this.kernel.setUniform2iv(this.sizeId, this.textureSize);
        super.updateValue(value);
      }
    }

    module.exports = {
      WebGL2KernelValueDynamicSingleArray2DI
    };
    },{"../../../utils":114,"../../web-gl2/kernel-value/single-array2d-i":100}],87:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGL2KernelValueSingleArray3DI } = require('../../web-gl2/kernel-value/single-array3d-i');

    class WebGL2KernelValueDynamicSingleArray3DI extends WebGL2KernelValueSingleArray3DI {
      getSource() {
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2D ${this.id}`,
          `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
          `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
        ]);
      }

      updateValue(value) {
        this.setShape(value);
        this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
        this.kernel.setUniform2iv(this.sizeId, this.textureSize);
        super.updateValue(value);
      }
    }

    module.exports = {
      WebGL2KernelValueDynamicSingleArray3DI
    };
    },{"../../../utils":114,"../../web-gl2/kernel-value/single-array3d-i":101}],88:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGL2KernelValueSingleInput } = require('../../web-gl2/kernel-value/single-input');

    class WebGL2KernelValueDynamicSingleInput extends WebGL2KernelValueSingleInput {
      getSource() {
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2D ${this.id}`,
          `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
          `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
        ]);
      }

      updateValue(value) {
        let [w, h, d] = value.size;
        this.dimensions = new Int32Array([w || 1, h || 1, d || 1]);
        this.textureSize = utils.getMemoryOptimizedFloatTextureSize(this.dimensions, this.bitRatio);
        this.uploadArrayLength = this.textureSize[0] * this.textureSize[1] * this.bitRatio;
        this.checkSize(this.textureSize[0], this.textureSize[1]);
        this.uploadValue = new Float32Array(this.uploadArrayLength);
        this.kernel.setUniform3iv(this.dimensionsId, this.dimensions);
        this.kernel.setUniform2iv(this.sizeId, this.textureSize);
        super.updateValue(value);
      }
    }

    module.exports = {
      WebGL2KernelValueDynamicSingleInput
    };
    },{"../../../utils":114,"../../web-gl2/kernel-value/single-input":102}],89:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueDynamicUnsignedArray } = require('../../web-gl/kernel-value/dynamic-unsigned-array');

    class WebGL2KernelValueDynamicUnsignedArray extends WebGLKernelValueDynamicUnsignedArray {
      getSource() {
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2D ${this.id}`,
          `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
          `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
        ]);
      }
    }

    module.exports = {
      WebGL2KernelValueDynamicUnsignedArray
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-array":54}],90:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueDynamicUnsignedInput } = require('../../web-gl/kernel-value/dynamic-unsigned-input');

    class WebGL2KernelValueDynamicUnsignedInput extends WebGLKernelValueDynamicUnsignedInput {
      getSource() {
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2D ${this.id}`,
          `uniform ${ variablePrecision } ivec2 ${this.sizeId}`,
          `uniform ${ variablePrecision } ivec3 ${this.dimensionsId}`,
        ]);
      }
    }

    module.exports = {
      WebGL2KernelValueDynamicUnsignedInput
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/dynamic-unsigned-input":55}],91:[function(require,module,exports){
    require('../../../utils');
    const { WebGLKernelValueFloat } = require('../../web-gl/kernel-value/float');

    class WebGL2KernelValueFloat extends WebGLKernelValueFloat {}

    module.exports = {
      WebGL2KernelValueFloat
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/float":56}],92:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelArray } = require('../../web-gl/kernel-value/array');

    class WebGL2KernelValueHTMLImageArray extends WebGLKernelArray {
      constructor(value, settings) {
        super(value, settings);
        this.checkSize(value[0].width, value[0].height);
        this.dimensions = [value[0].width, value[0].height, value.length];
        this.textureSize = [value[0].width, value[0].height];
      }
      defineTexture() {
        const { context: gl } = this;
        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);
        gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      }

      getStringValueHandler() {
        return `const uploadValue_${this.name} = ${this.varName};\n`;
      }
      getSource() {
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2DArray ${this.id}`,
          `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
          `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
        ]);
      }

      updateValue(images) {
        const { context: gl } = this;
        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D_ARRAY, this.texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage3D(
          gl.TEXTURE_2D_ARRAY,
          0,
          gl.RGBA,
          images[0].width,
          images[0].height,
          images.length,
          0,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          null
        );
        for (let i = 0; i < images.length; i++) {
          const xOffset = 0;
          const yOffset = 0;
          const imageDepth = 1;
          gl.texSubImage3D(
            gl.TEXTURE_2D_ARRAY,
            0,
            xOffset,
            yOffset,
            i,
            images[i].width,
            images[i].height,
            imageDepth,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            this.uploadValue = images[i]
          );
        }
        this.kernel.setUniform1i(this.id, this.index);
      }
    }

    module.exports = {
      WebGL2KernelValueHTMLImageArray
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/array":40}],93:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueHTMLImage } = require('../../web-gl/kernel-value/html-image');

    class WebGL2KernelValueHTMLImage extends WebGLKernelValueHTMLImage {
      getSource() {
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2D ${this.id}`,
          `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
          `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
        ]);
      }
    }

    module.exports = {
      WebGL2KernelValueHTMLImage
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/html-image":57}],94:[function(require,module,exports){
    require('../../../utils');
    const { WebGL2KernelValueHTMLImage } = require('./html-image');

    class WebGL2KernelValueHTMLVideo extends WebGL2KernelValueHTMLImage {}

    module.exports = {
      WebGL2KernelValueHTMLVideo
    };
    },{"../../../utils":114,"./html-image":93}],95:[function(require,module,exports){
    const { WebGLKernelValueInteger } = require('../../web-gl/kernel-value/integer');

    class WebGL2KernelValueInteger extends WebGLKernelValueInteger {
      getSource(value) {
        const variablePrecision = this.getVariablePrecisionString();
        if (this.origin === 'constants') {
          return `const ${ variablePrecision } int ${this.id} = ${ parseInt(value) };\n`;
        }
        return `uniform ${ variablePrecision } int ${this.id};\n`;
      }

      updateValue(value) {
        if (this.origin === 'constants') return;
        this.kernel.setUniform1i(this.id, this.uploadValue = value);
      }
    }

    module.exports = {
      WebGL2KernelValueInteger
    };
    },{"../../web-gl/kernel-value/integer":60}],96:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueMemoryOptimizedNumberTexture } = require('../../web-gl/kernel-value/memory-optimized-number-texture');

    class WebGL2KernelValueMemoryOptimizedNumberTexture extends WebGLKernelValueMemoryOptimizedNumberTexture {
      getSource() {
        const { id, sizeId, textureSize, dimensionsId, dimensions } = this;
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform sampler2D ${id}`,
          `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,
          `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,
        ]);
      }
    }

    module.exports = {
      WebGL2KernelValueMemoryOptimizedNumberTexture
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/memory-optimized-number-texture":61}],97:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueNumberTexture } = require('../../web-gl/kernel-value/number-texture');

    class WebGL2KernelValueNumberTexture extends WebGLKernelValueNumberTexture {
      getSource() {
        const { id, sizeId, textureSize, dimensionsId, dimensions } = this;
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2D ${id}`,
          `${ variablePrecision } ivec2 ${sizeId} = ivec2(${textureSize[0]}, ${textureSize[1]})`,
          `${ variablePrecision } ivec3 ${dimensionsId} = ivec3(${dimensions[0]}, ${dimensions[1]}, ${dimensions[2]})`,
        ]);
      }
    }

    module.exports = {
      WebGL2KernelValueNumberTexture
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/number-texture":62}],98:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueSingleArray } = require('../../web-gl/kernel-value/single-array');

    class WebGL2KernelValueSingleArray extends WebGLKernelValueSingleArray {
      getSource() {
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2D ${this.id}`,
          `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
          `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
        ]);
      }

      updateValue(value) {
        if (value.constructor !== this.initialValueConstructor) {
          this.onUpdateValueMismatch(value.constructor);
          return;
        }
        const { context: gl } = this;
        utils.flattenTo(value, this.uploadValue);
        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
        this.kernel.setUniform1i(this.id, this.index);
      }
    }

    module.exports = {
      WebGL2KernelValueSingleArray
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/single-array":63}],99:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueSingleArray1DI } = require('../../web-gl/kernel-value/single-array1d-i');

    class WebGL2KernelValueSingleArray1DI extends WebGLKernelValueSingleArray1DI {
      updateValue(value) {
        if (value.constructor !== this.initialValueConstructor) {
          this.onUpdateValueMismatch(value.constructor);
          return;
        }
        const { context: gl } = this;
        utils.flattenTo(value, this.uploadValue);
        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
        this.kernel.setUniform1i(this.id, this.index);
      }
    }

    module.exports = {
      WebGL2KernelValueSingleArray1DI
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/single-array1d-i":64}],100:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueSingleArray2DI } = require('../../web-gl/kernel-value/single-array2d-i');

    class WebGL2KernelValueSingleArray2DI extends WebGLKernelValueSingleArray2DI {
      updateValue(value) {
        if (value.constructor !== this.initialValueConstructor) {
          this.onUpdateValueMismatch(value.constructor);
          return;
        }
        const { context: gl } = this;
        utils.flattenTo(value, this.uploadValue);
        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
        this.kernel.setUniform1i(this.id, this.index);
      }
    }

    module.exports = {
      WebGL2KernelValueSingleArray2DI
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/single-array2d-i":65}],101:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueSingleArray3DI } = require('../../web-gl/kernel-value/single-array3d-i');

    class WebGL2KernelValueSingleArray3DI extends WebGLKernelValueSingleArray3DI {
      updateValue(value) {
        if (value.constructor !== this.initialValueConstructor) {
          this.onUpdateValueMismatch(value.constructor);
          return;
        }
        const { context: gl } = this;
        utils.flattenTo(value, this.uploadValue);
        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
        this.kernel.setUniform1i(this.id, this.index);
      }
    }

    module.exports = {
      WebGL2KernelValueSingleArray3DI
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/single-array3d-i":66}],102:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueSingleInput } = require('../../web-gl/kernel-value/single-input');

    class WebGL2KernelValueSingleInput extends WebGLKernelValueSingleInput {
      getSource() {
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2D ${this.id}`,
          `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
          `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
        ]);
      }

      updateValue(input) {
        const { context: gl } = this;
        utils.flattenTo(input.value, this.uploadValue);
        gl.activeTexture(this.contextHandle);
        gl.bindTexture(gl.TEXTURE_2D, this.texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, this.textureSize[0], this.textureSize[1], 0, gl.RGBA, gl.FLOAT, this.uploadValue);
        this.kernel.setUniform1i(this.id, this.index);
      }
    }

    module.exports = {
      WebGL2KernelValueSingleInput
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/single-input":67}],103:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueUnsignedArray } = require('../../web-gl/kernel-value/unsigned-array');

    class WebGL2KernelValueUnsignedArray extends WebGLKernelValueUnsignedArray {
      getSource() {
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2D ${this.id}`,
          `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
          `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
        ]);
      }
    }

    module.exports = {
      WebGL2KernelValueUnsignedArray
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/unsigned-array":68}],104:[function(require,module,exports){
    const { utils } = require('../../../utils');
    const { WebGLKernelValueUnsignedInput } = require('../../web-gl/kernel-value/unsigned-input');

    class WebGL2KernelValueUnsignedInput extends WebGLKernelValueUnsignedInput {
      getSource() {
        const variablePrecision = this.getVariablePrecisionString();
        return utils.linesToString([
          `uniform ${ variablePrecision } sampler2D ${this.id}`,
          `${ variablePrecision } ivec2 ${this.sizeId} = ivec2(${this.textureSize[0]}, ${this.textureSize[1]})`,
          `${ variablePrecision } ivec3 ${this.dimensionsId} = ivec3(${this.dimensions[0]}, ${this.dimensions[1]}, ${this.dimensions[2]})`,
        ]);
      }
    }

    module.exports = {
      WebGL2KernelValueUnsignedInput
    };
    },{"../../../utils":114,"../../web-gl/kernel-value/unsigned-input":69}],105:[function(require,module,exports){
    const { WebGLKernel } = require('../web-gl/kernel');
    const { WebGL2FunctionNode } = require('./function-node');
    const { FunctionBuilder } = require('../function-builder');
    const { utils } = require('../../utils');
    const { fragmentShader } = require('./fragment-shader');
    const { vertexShader } = require('./vertex-shader');
    const { lookupKernelValueType } = require('./kernel-value-maps');

    let isSupported = null;
    let testCanvas = null;
    let testContext = null;

    let features = null;

    class WebGL2Kernel extends WebGLKernel {
      static get isSupported() {
        if (isSupported !== null) {
          return isSupported;
        }
        this.setupFeatureChecks();
        isSupported = this.isContextMatch(testContext);
        return isSupported;
      }

      static setupFeatureChecks() {
        if (typeof document !== 'undefined') {
          testCanvas = document.createElement('canvas');
        } else if (typeof OffscreenCanvas !== 'undefined') {
          testCanvas = new OffscreenCanvas(0, 0);
        }
        if (!testCanvas) return;
        testContext = testCanvas.getContext('webgl2');
        if (!testContext || !testContext.getExtension) return;
        ({
          EXT_color_buffer_float: testContext.getExtension('EXT_color_buffer_float'),
          OES_texture_float_linear: testContext.getExtension('OES_texture_float_linear'),
        });
        features = this.getFeatures();
      }

      static isContextMatch(context) {
        if (typeof WebGL2RenderingContext !== 'undefined') {
          return context instanceof WebGL2RenderingContext;
        }
        return false;
      }

      static getFeatures() {
        const gl = this.testContext;
        return Object.freeze({
          isFloatRead: this.getIsFloatRead(),
          isIntegerDivisionAccurate: this.getIsIntegerDivisionAccurate(),
          isSpeedTacticSupported: this.getIsSpeedTacticSupported(),
          kernelMap: true,
          isTextureFloat: true,
          isDrawBuffers: true,
          channelCount: this.getChannelCount(),
          maxTextureSize: this.getMaxTextureSize(),
          lowIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_INT),
          lowFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.LOW_FLOAT),
          mediumIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_INT),
          mediumFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT),
          highIntPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT),
          highFloatPrecision: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),
        });
      }

      static getIsTextureFloat() {
        return true;
      }

      static getChannelCount() {
        return testContext.getParameter(testContext.MAX_DRAW_BUFFERS);
      }

      static getMaxTextureSize() {
        return testContext.getParameter(testContext.MAX_TEXTURE_SIZE);
      }

      static lookupKernelValueType(type, dynamic, precision, value) {
        return lookupKernelValueType(type, dynamic, precision, value);
      }

      static get testCanvas() {
        return testCanvas;
      }

      static get testContext() {
        return testContext;
      }

      static get features() {
        return features;
      }

      static get fragmentShader() {
        return fragmentShader;
      }
      static get vertexShader() {
        return vertexShader;
      }

      initContext() {
        const settings = {
          alpha: false,
          depth: false,
          antialias: false
        };
        return this.canvas.getContext('webgl2', settings);
      }

      initExtensions() {
        this.extensions = {
          EXT_color_buffer_float: this.context.getExtension('EXT_color_buffer_float'),
          OES_texture_float_linear: this.context.getExtension('OES_texture_float_linear'),
        };
      }

      validateSettings(args) {
        if (!this.validate) {
          this.texSize = utils.getKernelTextureSize({
            optimizeFloatMemory: this.optimizeFloatMemory,
            precision: this.precision,
          }, this.output);
          return;
        }

        const { features } = this.constructor;
        if (this.precision === 'single' && !features.isFloatRead) {
          throw new Error('Float texture outputs are not supported');
        } else if (!this.graphical && this.precision === null) {
          this.precision = features.isFloatRead ? 'single' : 'unsigned';
        }

        if (this.fixIntegerDivisionAccuracy === null) {
          this.fixIntegerDivisionAccuracy = !features.isIntegerDivisionAccurate;
        } else if (this.fixIntegerDivisionAccuracy && features.isIntegerDivisionAccurate) {
          this.fixIntegerDivisionAccuracy = false;
        }

        this.checkOutput();

        if (!this.output || this.output.length === 0) {
          if (args.length !== 1) {
            throw new Error('Auto output only supported for kernels with only one input');
          }

          const argType = utils.getVariableType(args[0], this.strictIntegers);
          switch (argType) {
            case 'Array':
              this.output = utils.getDimensions(argType);
              break;
            case 'NumberTexture':
            case 'MemoryOptimizedNumberTexture':
            case 'ArrayTexture(1)':
            case 'ArrayTexture(2)':
            case 'ArrayTexture(3)':
            case 'ArrayTexture(4)':
              this.output = args[0].output;
              break;
            default:
              throw new Error('Auto output not supported for input type: ' + argType);
          }
        }

        if (this.graphical) {
          if (this.output.length !== 2) {
            throw new Error('Output must have 2 dimensions on graphical mode');
          }

          if (this.precision === 'single') {
            console.warn('Cannot use graphical mode and single precision at the same time');
            this.precision = 'unsigned';
          }

          this.texSize = utils.clone(this.output);
          return;
        } else if (!this.graphical && this.precision === null && features.isTextureFloat) {
          this.precision = 'single';
        }

        this.texSize = utils.getKernelTextureSize({
          optimizeFloatMemory: this.optimizeFloatMemory,
          precision: this.precision,
        }, this.output);

        this.checkTextureSize();
      }

      translateSource() {
        const functionBuilder = FunctionBuilder.fromKernel(this, WebGL2FunctionNode, {
          fixIntegerDivisionAccuracy: this.fixIntegerDivisionAccuracy
        });
        this.translatedSource = functionBuilder.getPrototypeString('kernel');
        this.setupReturnTypes(functionBuilder);
      }

      drawBuffers() {
        this.context.drawBuffers(this.drawBuffersMap);
      }

      getTextureFormat() {
        const { context: gl } = this;
        switch (this.getInternalFormat()) {
          case gl.R32F:
            return gl.RED;
          case gl.RG32F:
            return gl.RG;
          case gl.RGBA32F:
            return gl.RGBA;
          case gl.RGBA:
            return gl.RGBA;
          default:
            throw new Error('Unknown internal format');
        }
      }
      getInternalFormat() {
        const { context: gl } = this;

        if (this.precision === 'single') {
          if (this.pipeline) {
            switch (this.returnType) {
              case 'Number':
              case 'Float':
              case 'Integer':
                if (this.optimizeFloatMemory) {
                  return gl.RGBA32F;
                } else {
                  return gl.R32F;
                }
                case 'Array(2)':
                  return gl.RG32F;
                case 'Array(3)': 
                case 'Array(4)':
                  return gl.RGBA32F;
                default:
                  throw new Error('Unhandled return type');
            }
          }
          return gl.RGBA32F;
        }
        return gl.RGBA;
      }

      _setupOutputTexture() {
        const gl = this.context;
        if (this.texture) {
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.texture.texture, 0);
          return;
        }
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
        const texture = gl.createTexture();
        const texSize = this.texSize;
        gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount);
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        const format = this.getInternalFormat();
        if (this.precision === 'single') {
          gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);
        } else {
          gl.texImage2D(gl.TEXTURE_2D, 0, format, texSize[0], texSize[1], 0, format, gl.UNSIGNED_BYTE, null);
        }
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        this.texture = new this.TextureConstructor({
          texture,
          size: texSize,
          dimensions: this.threadDim,
          output: this.output,
          context: this.context,
          internalFormat: this.getInternalFormat(),
          textureFormat: this.getTextureFormat(),
          kernel: this,
        });
      }

      _setupSubOutputTextures() {
        const gl = this.context;
        if (this.mappedTextures) {
          for (let i = 0; i < this.subKernels.length; i++) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, this.mappedTextures[i].texture, 0);
          }
          return;
        }
        const texSize = this.texSize;
        this.drawBuffersMap = [gl.COLOR_ATTACHMENT0];
        this.mappedTextures = [];
        for (let i = 0; i < this.subKernels.length; i++) {
          const texture = this.createTexture();
          this.drawBuffersMap.push(gl.COLOR_ATTACHMENT0 + i + 1);
          gl.activeTexture(gl.TEXTURE0 + this.constantTextureCount + this.argumentTextureCount + i);
          gl.bindTexture(gl.TEXTURE_2D, texture);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
          const format = this.getInternalFormat();
          if (this.precision === 'single') {
            gl.texStorage2D(gl.TEXTURE_2D, 1, format, texSize[0], texSize[1]);
          } else {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, texSize[0], texSize[1], 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
          }
          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i + 1, gl.TEXTURE_2D, texture, 0);

          this.mappedTextures.push(new this.TextureConstructor({
            texture,
            size: texSize,
            dimensions: this.threadDim,
            output: this.output,
            context: this.context,
            internalFormat: this.getInternalFormat(),
            textureFormat: this.getTextureFormat(),
            kernel: this,
          }));
        }
      }

      _getHeaderString() {
        return '';
      }

      _getTextureCoordinate() {
        const subKernels = this.subKernels;
        const variablePrecision = this.getVariablePrecisionString(this.texSize, this.tactic);
        if (subKernels === null || subKernels.length < 1) {
          return `in ${ variablePrecision } vec2 vTexCoord;\n`;
        } else {
          return `out ${ variablePrecision } vec2 vTexCoord;\n`;
        }
      }

      _getMainArgumentsString(args) {
        const result = [];
        const argumentNames = this.argumentNames;
        for (let i = 0; i < argumentNames.length; i++) {
          result.push(this.kernelArguments[i].getSource(args[i]));
        }
        return result.join('');
      }

      getKernelString() {
        const result = [this.getKernelResultDeclaration()];
        const subKernels = this.subKernels;
        if (subKernels !== null) {
          result.push(
            'layout(location = 0) out vec4 data0'
          );
          switch (this.returnType) {
            case 'Number':
            case 'Float':
            case 'Integer':
              for (let i = 0; i < subKernels.length; i++) {
                const subKernel = subKernels[i];
                result.push(
                  subKernel.returnType === 'Integer' ?
                  `int subKernelResult_${ subKernel.name } = 0` :
                  `float subKernelResult_${ subKernel.name } = 0.0`,
                  `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
                );
              }
              break;
            case 'Array(2)':
              for (let i = 0; i < subKernels.length; i++) {
                result.push(
                  `vec2 subKernelResult_${ subKernels[i].name }`,
                  `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
                );
              }
              break;
            case 'Array(3)':
              for (let i = 0; i < subKernels.length; i++) {
                result.push(
                  `vec3 subKernelResult_${ subKernels[i].name }`,
                  `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
                );
              }
              break;
            case 'Array(4)':
              for (let i = 0; i < subKernels.length; i++) {
                result.push(
                  `vec4 subKernelResult_${ subKernels[i].name }`,
                  `layout(location = ${ i + 1 }) out vec4 data${ i + 1 }`
                );
              }
              break;
          }
        } else {
          result.push(
            'out vec4 data0'
          );
        }

        return utils.linesToString(result) + this.translatedSource;
      }

      getMainResultGraphical() {
        return utils.linesToString([
          '  threadId = indexTo3D(index, uOutputDim)',
          '  kernel()',
          '  data0 = actualColor',
        ]);
      }

      getMainResultPackedPixels() {
        switch (this.returnType) {
          case 'LiteralInteger':
          case 'Number':
          case 'Integer':
          case 'Float':
            return this.getMainResultKernelPackedPixels() +
              this.getMainResultSubKernelPackedPixels();
          default:
            throw new Error(`packed output only usable with Numbers, "${this.returnType}" specified`);
        }
      }

      getMainResultKernelPackedPixels() {
        return utils.linesToString([
          '  threadId = indexTo3D(index, uOutputDim)',
          '  kernel()',
          `  data0 = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(kernelResult)`
        ]);
      }

      getMainResultSubKernelPackedPixels() {
        const result = [];
        if (!this.subKernels) return '';
        for (let i = 0; i < this.subKernels.length; i++) {
          const subKernel = this.subKernels[i];
          if (subKernel.returnType === 'Integer') {
            result.push(
              `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(float(subKernelResult_${this.subKernels[i].name}))`
            );
          } else {
            result.push(
              `  data${i + 1} = ${this.useLegacyEncoder ? 'legacyEncode32' : 'encode32'}(subKernelResult_${this.subKernels[i].name})`
            );
          }
        }
        return utils.linesToString(result);
      }

      getMainResultKernelMemoryOptimizedFloats(result, channel) {
        result.push(
          '  threadId = indexTo3D(index, uOutputDim)',
          '  kernel()',
          `  data0.${channel} = kernelResult`
        );
      }

      getMainResultSubKernelMemoryOptimizedFloats(result, channel) {
        if (!this.subKernels) return result;
        for (let i = 0; i < this.subKernels.length; i++) {
          const subKernel = this.subKernels[i];
          if (subKernel.returnType === 'Integer') {
            result.push(
              `  data${i + 1}.${channel} = float(subKernelResult_${subKernel.name})`
            );
          } else {
            result.push(
              `  data${i + 1}.${channel} = subKernelResult_${subKernel.name}`
            );
          }
        }
      }

      getMainResultKernelNumberTexture() {
        return [
          '  threadId = indexTo3D(index, uOutputDim)',
          '  kernel()',
          '  data0[0] = kernelResult',
        ];
      }

      getMainResultSubKernelNumberTexture() {
        const result = [];
        if (!this.subKernels) return result;
        for (let i = 0; i < this.subKernels.length; ++i) {
          const subKernel = this.subKernels[i];
          if (subKernel.returnType === 'Integer') {
            result.push(
              `  data${i + 1}[0] = float(subKernelResult_${subKernel.name})`
            );
          } else {
            result.push(
              `  data${i + 1}[0] = subKernelResult_${subKernel.name}`
            );
          }
        }
        return result;
      }

      getMainResultKernelArray2Texture() {
        return [
          '  threadId = indexTo3D(index, uOutputDim)',
          '  kernel()',
          '  data0[0] = kernelResult[0]',
          '  data0[1] = kernelResult[1]',
        ];
      }

      getMainResultSubKernelArray2Texture() {
        const result = [];
        if (!this.subKernels) return result;
        for (let i = 0; i < this.subKernels.length; ++i) {
          const subKernel = this.subKernels[i];
          result.push(
            `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,
            `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`
          );
        }
        return result;
      }

      getMainResultKernelArray3Texture() {
        return [
          '  threadId = indexTo3D(index, uOutputDim)',
          '  kernel()',
          '  data0[0] = kernelResult[0]',
          '  data0[1] = kernelResult[1]',
          '  data0[2] = kernelResult[2]',
        ];
      }

      getMainResultSubKernelArray3Texture() {
        const result = [];
        if (!this.subKernels) return result;
        for (let i = 0; i < this.subKernels.length; ++i) {
          const subKernel = this.subKernels[i];
          result.push(
            `  data${i + 1}[0] = subKernelResult_${subKernel.name}[0]`,
            `  data${i + 1}[1] = subKernelResult_${subKernel.name}[1]`,
            `  data${i + 1}[2] = subKernelResult_${subKernel.name}[2]`
          );
        }
        return result;
      }

      getMainResultKernelArray4Texture() {
        return [
          '  threadId = indexTo3D(index, uOutputDim)',
          '  kernel()',
          '  data0 = kernelResult',
        ];
      }

      getMainResultSubKernelArray4Texture() {
        const result = [];
        if (!this.subKernels) return result;
        for (let i = 0; i < this.subKernels.length; ++i) {
          result.push(
            `  data${i + 1} = subKernelResult_${this.subKernels[i].name}`
          );
        }
        return result;
      }

      destroyExtensions() {
        this.extensions.EXT_color_buffer_float = null;
        this.extensions.OES_texture_float_linear = null;
      }

      toJSON() {
        const json = super.toJSON();
        json.functionNodes = FunctionBuilder.fromKernel(this, WebGL2FunctionNode).toJSON();
        json.settings.threadDim = this.threadDim;
        return json;
      }
    }

    module.exports = {
      WebGL2Kernel
    };
    },{"../../utils":114,"../function-builder":9,"../web-gl/kernel":70,"./fragment-shader":72,"./function-node":73,"./kernel-value-maps":74,"./vertex-shader":106}],106:[function(require,module,exports){
    const vertexShader = `#version 300 es
__FLOAT_TACTIC_DECLARATION__;
__INT_TACTIC_DECLARATION__;
__SAMPLER_2D_TACTIC_DECLARATION__;

in vec2 aPos;
in vec2 aTexCoord;

out vec2 vTexCoord;
uniform vec2 ratio;

void main(void) {
  gl_Position = vec4((aPos + vec2(1)) * ratio + vec2(-1), 0, 1);
  vTexCoord = aTexCoord;
}`;

    module.exports = {
      vertexShader
    };
    },{}],107:[function(require,module,exports){
    const lib = require('./index');
    const GPU = lib.GPU;
    for (const p in lib) {
      if (!lib.hasOwnProperty(p)) continue;
      if (p === 'GPU') continue; 
      GPU[p] = lib[p];
    }

    if (typeof window !== 'undefined') {
      bindTo(window);
    }
    if (typeof self !== 'undefined') {
      bindTo(self);
    }

    function bindTo(target) {
      if (target.GPU) return;
      Object.defineProperty(target, 'GPU', {
        get() {
          return GPU;
        }
      });
    }

    module.exports = lib;
    },{"./index":109}],108:[function(require,module,exports){
    const { gpuMock } = require('gpu-mock.js');
    const { utils } = require('./utils');
    require('./backend/kernel');
    const { CPUKernel } = require('./backend/cpu/kernel');
    const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');
    const { WebGL2Kernel } = require('./backend/web-gl2/kernel');
    const { WebGLKernel } = require('./backend/web-gl/kernel');
    const { kernelRunShortcut } = require('./kernel-run-shortcut');


    const kernelOrder = [HeadlessGLKernel, WebGL2Kernel, WebGLKernel];

    const kernelTypes = ['gpu', 'cpu'];

    const internalKernels = {
      'headlessgl': HeadlessGLKernel,
      'webgl2': WebGL2Kernel,
      'webgl': WebGLKernel,
    };

    let validate = true;

    class GPU {
      static disableValidation() {
        validate = false;
      }

      static enableValidation() {
        validate = true;
      }

      static get isGPUSupported() {
        return kernelOrder.some(Kernel => Kernel.isSupported);
      }

      static get isKernelMapSupported() {
        return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.kernelMap);
      }

      static get isOffscreenCanvasSupported() {
        return (typeof Worker !== 'undefined' && typeof OffscreenCanvas !== 'undefined') || typeof importScripts !== 'undefined';
      }

      static get isWebGLSupported() {
        return WebGLKernel.isSupported;
      }

      static get isWebGL2Supported() {
        return WebGL2Kernel.isSupported;
      }

      static get isHeadlessGLSupported() {
        return HeadlessGLKernel.isSupported;
      }

      static get isCanvasSupported() {
        return typeof HTMLCanvasElement !== 'undefined';
      }

      static get isGPUHTMLImageArraySupported() {
        return WebGL2Kernel.isSupported;
      }

      static get isSinglePrecisionSupported() {
        return kernelOrder.some(Kernel => Kernel.isSupported && Kernel.features.isFloatRead && Kernel.features.isTextureFloat);
      }

      constructor(settings) {
        settings = settings || {};
        this.canvas = settings.canvas || null;
        this.context = settings.context || null;
        this.mode = settings.mode;
        this.Kernel = null;
        this.kernels = [];
        this.functions = [];
        this.nativeFunctions = [];
        this.injectedNative = null;
        if (this.mode === 'dev') return;
        this.chooseKernel();
        if (settings.functions) {
          for (let i = 0; i < settings.functions.length; i++) {
            this.addFunction(settings.functions[i]);
          }
        }

        if (settings.nativeFunctions) {
          for (const p in settings.nativeFunctions) {
            if (!settings.nativeFunctions.hasOwnProperty(p)) continue;
            const s = settings.nativeFunctions[p];
            const { name, source } = s;
            this.addNativeFunction(name, source, s);
          }
        }
      }

      chooseKernel() {
        if (this.Kernel) return;

        let Kernel = null;

        if (this.context) {
          for (let i = 0; i < kernelOrder.length; i++) {
            const ExternalKernel = kernelOrder[i];
            if (ExternalKernel.isContextMatch(this.context)) {
              if (!ExternalKernel.isSupported) {
                throw new Error(`Kernel type ${ExternalKernel.name} not supported`);
              }
              Kernel = ExternalKernel;
              break;
            }
          }
          if (Kernel === null) {
            throw new Error('unknown Context');
          }
        } else if (this.mode) {
          if (this.mode in internalKernels) {
            if (!validate || internalKernels[this.mode].isSupported) {
              Kernel = internalKernels[this.mode];
            }
          } else if (this.mode === 'gpu') {
            for (let i = 0; i < kernelOrder.length; i++) {
              if (kernelOrder[i].isSupported) {
                Kernel = kernelOrder[i];
                break;
              }
            }
          } else if (this.mode === 'cpu') {
            Kernel = CPUKernel;
          }
          if (!Kernel) {
            throw new Error(`A requested mode of "${this.mode}" and is not supported`);
          }
        } else {
          for (let i = 0; i < kernelOrder.length; i++) {
            if (kernelOrder[i].isSupported) {
              Kernel = kernelOrder[i];
              break;
            }
          }
          if (!Kernel) {
            Kernel = CPUKernel;
          }
        }

        if (!this.mode) {
          this.mode = Kernel.mode;
        }
        this.Kernel = Kernel;
      }

      createKernel(source, settings) {
        if (typeof source === 'undefined') {
          throw new Error('Missing source parameter');
        }
        if (typeof source !== 'object' && !utils.isFunction(source) && typeof source !== 'string') {
          throw new Error('source parameter not a function');
        }

        const kernels = this.kernels;
        if (this.mode === 'dev') {
          const devKernel = gpuMock(source, upgradeDeprecatedCreateKernelSettings(settings));
          kernels.push(devKernel);
          return devKernel;
        }

        source = typeof source === 'function' ? source.toString() : source;
        const switchableKernels = {};
        const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings) || {};
        if (settings && typeof settings.argumentTypes === 'object') {
          settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);
        }

        function onRequestFallback(args) {
          console.warn('Falling back to CPU');
          const fallbackKernel = new CPUKernel(source, {
            argumentTypes: kernelRun.argumentTypes,
            constantTypes: kernelRun.constantTypes,
            graphical: kernelRun.graphical,
            loopMaxIterations: kernelRun.loopMaxIterations,
            constants: kernelRun.constants,
            dynamicOutput: kernelRun.dynamicOutput,
            dynamicArgument: kernelRun.dynamicArguments,
            output: kernelRun.output,
            precision: kernelRun.precision,
            pipeline: kernelRun.pipeline,
            immutable: kernelRun.immutable,
            optimizeFloatMemory: kernelRun.optimizeFloatMemory,
            fixIntegerDivisionAccuracy: kernelRun.fixIntegerDivisionAccuracy,
            functions: kernelRun.functions,
            nativeFunctions: kernelRun.nativeFunctions,
            injectedNative: kernelRun.injectedNative,
            subKernels: kernelRun.subKernels,
            strictIntegers: kernelRun.strictIntegers,
            debug: kernelRun.debug,
          });
          fallbackKernel.build.apply(fallbackKernel, args);
          const result = fallbackKernel.run.apply(fallbackKernel, args);
          kernelRun.replaceKernel(fallbackKernel);
          return result;
        }

        function onRequestSwitchKernel(reasons, args, _kernel) {
          if (_kernel.debug) {
            console.warn('Switching kernels');
          }
          let newOutput = null;
          if (_kernel.signature && !switchableKernels[_kernel.signature]) {
            switchableKernels[_kernel.signature] = _kernel;
          }
          if (_kernel.dynamicOutput) {
            for (let i = reasons.length - 1; i >= 0; i--) {
              const reason = reasons[i];
              if (reason.type === 'outputPrecisionMismatch') {
                newOutput = reason.needed;
              }
            }
          }

          const Constructor = _kernel.constructor;
          const argumentTypes = Constructor.getArgumentTypes(_kernel, args);
          const signature = Constructor.getSignature(_kernel, argumentTypes);
          const existingKernel = switchableKernels[signature];
          if (existingKernel) {
            existingKernel.onActivate(_kernel);
            return existingKernel;
          }

          const newKernel = switchableKernels[signature] = new Constructor(source, {
            argumentTypes,
            constantTypes: _kernel.constantTypes,
            graphical: _kernel.graphical,
            loopMaxIterations: _kernel.loopMaxIterations,
            constants: _kernel.constants,
            dynamicOutput: _kernel.dynamicOutput,
            dynamicArgument: _kernel.dynamicArguments,
            context: _kernel.context,
            canvas: _kernel.canvas,
            output: newOutput || _kernel.output,
            precision: _kernel.precision,
            pipeline: _kernel.pipeline,
            immutable: _kernel.immutable,
            optimizeFloatMemory: _kernel.optimizeFloatMemory,
            fixIntegerDivisionAccuracy: _kernel.fixIntegerDivisionAccuracy,
            functions: _kernel.functions,
            nativeFunctions: _kernel.nativeFunctions,
            injectedNative: _kernel.injectedNative,
            subKernels: _kernel.subKernels,
            strictIntegers: _kernel.strictIntegers,
            debug: _kernel.debug,
            gpu: _kernel.gpu,
            validate,
            returnType: _kernel.returnType,
            tactic: _kernel.tactic,
            onRequestFallback,
            onRequestSwitchKernel,
            texture: _kernel.texture,
            mappedTextures: _kernel.mappedTextures,
            drawBuffersMap: _kernel.drawBuffersMap,
          });
          newKernel.build.apply(newKernel, args);
          kernelRun.replaceKernel(newKernel);
          kernels.push(newKernel);
          return newKernel;
        }
        const mergedSettings = Object.assign({
          context: this.context,
          canvas: this.canvas,
          functions: this.functions,
          nativeFunctions: this.nativeFunctions,
          injectedNative: this.injectedNative,
          gpu: this,
          validate,
          onRequestFallback,
          onRequestSwitchKernel
        }, settingsCopy);

        const kernel = new this.Kernel(source, mergedSettings);
        const kernelRun = kernelRunShortcut(kernel);

        if (!this.canvas) {
          this.canvas = kernel.canvas;
        }

        if (!this.context) {
          this.context = kernel.context;
        }

        kernels.push(kernel);

        return kernelRun;
      }

      createKernelMap() {
        let fn;
        let settings;
        const argument2Type = typeof arguments[arguments.length - 2];
        if (argument2Type === 'function' || argument2Type === 'string') {
          fn = arguments[arguments.length - 2];
          settings = arguments[arguments.length - 1];
        } else {
          fn = arguments[arguments.length - 1];
        }

        if (this.mode !== 'dev') {
          if (!this.Kernel.isSupported || !this.Kernel.features.kernelMap) {
            if (this.mode && kernelTypes.indexOf(this.mode) < 0) {
              throw new Error(`kernelMap not supported on ${this.Kernel.name}`);
            }
          }
        }

        const settingsCopy = upgradeDeprecatedCreateKernelSettings(settings);
        if (settings && typeof settings.argumentTypes === 'object') {
          settingsCopy.argumentTypes = Object.keys(settings.argumentTypes).map(argumentName => settings.argumentTypes[argumentName]);
        }

        if (Array.isArray(arguments[0])) {
          settingsCopy.subKernels = [];
          const functions = arguments[0];
          for (let i = 0; i < functions.length; i++) {
            const source = functions[i].toString();
            const name = utils.getFunctionNameFromString(source);
            settingsCopy.subKernels.push({
              name,
              source,
              property: i,
            });
          }
        } else {
          settingsCopy.subKernels = [];
          const functions = arguments[0];
          for (let p in functions) {
            if (!functions.hasOwnProperty(p)) continue;
            const source = functions[p].toString();
            const name = utils.getFunctionNameFromString(source);
            settingsCopy.subKernels.push({
              name: name || p,
              source,
              property: p,
            });
          }
        }
        return this.createKernel(fn, settingsCopy);
      }

      combineKernels() {
        const firstKernel = arguments[0];
        const combinedKernel = arguments[arguments.length - 1];
        if (firstKernel.kernel.constructor.mode === 'cpu') return combinedKernel;
        const canvas = arguments[0].canvas;
        const context = arguments[0].context;
        const max = arguments.length - 1;
        for (let i = 0; i < max; i++) {
          arguments[i]
            .setCanvas(canvas)
            .setContext(context)
            .setPipeline(true);
        }

        return function() {
          const texture = combinedKernel.apply(this, arguments);
          if (texture.toArray) {
            return texture.toArray();
          }
          return texture;
        };
      }

      setFunctions(functions) {
        this.functions = functions;
        return this;
      }

      setNativeFunctions(nativeFunctions) {
        this.nativeFunctions = nativeFunctions;
        return this;
      }

      addFunction(source, settings) {
        this.functions.push({ source, settings });
        return this;
      }

      addNativeFunction(name, source, settings) {
        if (this.kernels.length > 0) {
          throw new Error('Cannot call "addNativeFunction" after "createKernels" has been called.');
        }
        this.nativeFunctions.push(Object.assign({ name, source }, settings));
        return this;
      }

      injectNative(source) {
        this.injectedNative = source;
        return this;
      }

      destroy() {
        return new Promise((resolve, reject) => {
          if (!this.kernels) {
            resolve();
          }
          setTimeout(() => {
            try {
              for (let i = 0; i < this.kernels.length; i++) {
                this.kernels[i].destroy(true); 
              }
              let firstKernel = this.kernels[0];
              if (firstKernel) {
                if (firstKernel.kernel) {
                  firstKernel = firstKernel.kernel;
                }
                if (firstKernel.constructor.destroyContext) {
                  firstKernel.constructor.destroyContext(this.context);
                }
              }
            } catch (e) {
              reject(e);
            }
            resolve();
          }, 0);
        });
      }
    }


    function upgradeDeprecatedCreateKernelSettings(settings) {
      if (!settings) {
        return {};
      }
      const upgradedSettings = Object.assign({}, settings);

      if (settings.hasOwnProperty('floatOutput')) {
        utils.warnDeprecated('setting', 'floatOutput', 'precision');
        upgradedSettings.precision = settings.floatOutput ? 'single' : 'unsigned';
      }
      if (settings.hasOwnProperty('outputToTexture')) {
        utils.warnDeprecated('setting', 'outputToTexture', 'pipeline');
        upgradedSettings.pipeline = Boolean(settings.outputToTexture);
      }
      if (settings.hasOwnProperty('outputImmutable')) {
        utils.warnDeprecated('setting', 'outputImmutable', 'immutable');
        upgradedSettings.immutable = Boolean(settings.outputImmutable);
      }
      if (settings.hasOwnProperty('floatTextures')) {
        utils.warnDeprecated('setting', 'floatTextures', 'optimizeFloatMemory');
        upgradedSettings.optimizeFloatMemory = Boolean(settings.floatTextures);
      }
      return upgradedSettings;
    }

    module.exports = {
      GPU,
      kernelOrder,
      kernelTypes
    };
    },{"./backend/cpu/kernel":8,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/kernel":70,"./backend/web-gl2/kernel":105,"./kernel-run-shortcut":111,"./utils":114,"gpu-mock.js":4}],109:[function(require,module,exports){
    const { GPU } = require('./gpu');
    const { alias } = require('./alias');
    const { utils } = require('./utils');
    const { Input, input } = require('./input');
    const { Texture } = require('./texture');
    const { FunctionBuilder } = require('./backend/function-builder');
    const { FunctionNode } = require('./backend/function-node');
    const { CPUFunctionNode } = require('./backend/cpu/function-node');
    const { CPUKernel } = require('./backend/cpu/kernel');

    const { HeadlessGLKernel } = require('./backend/headless-gl/kernel');

    const { WebGLFunctionNode } = require('./backend/web-gl/function-node');
    const { WebGLKernel } = require('./backend/web-gl/kernel');
    const { kernelValueMaps: webGLKernelValueMaps } = require('./backend/web-gl/kernel-value-maps');

    const { WebGL2FunctionNode } = require('./backend/web-gl2/function-node');
    const { WebGL2Kernel } = require('./backend/web-gl2/kernel');
    const { kernelValueMaps: webGL2KernelValueMaps } = require('./backend/web-gl2/kernel-value-maps');

    const { GLKernel } = require('./backend/gl/kernel');

    const { Kernel } = require('./backend/kernel');

    const { FunctionTracer } = require('./backend/function-tracer');

    const mathRandom = require('./plugins/math-random-uniformly-distributed');

    module.exports = {
      alias,
      CPUFunctionNode,
      CPUKernel,
      GPU,
      FunctionBuilder,
      FunctionNode,
      HeadlessGLKernel,
      Input,
      input,
      Texture,
      utils,

      WebGL2FunctionNode,
      WebGL2Kernel,
      webGL2KernelValueMaps,

      WebGLFunctionNode,
      WebGLKernel,
      webGLKernelValueMaps,

      GLKernel,
      Kernel,
      FunctionTracer,

      plugins: {
        mathRandom
      }
    };
    },{"./alias":5,"./backend/cpu/function-node":6,"./backend/cpu/kernel":8,"./backend/function-builder":9,"./backend/function-node":10,"./backend/function-tracer":11,"./backend/gl/kernel":13,"./backend/headless-gl/kernel":34,"./backend/kernel":36,"./backend/web-gl/function-node":38,"./backend/web-gl/kernel":70,"./backend/web-gl/kernel-value-maps":39,"./backend/web-gl2/function-node":73,"./backend/web-gl2/kernel":105,"./backend/web-gl2/kernel-value-maps":74,"./gpu":108,"./input":110,"./plugins/math-random-uniformly-distributed":112,"./texture":113,"./utils":114}],110:[function(require,module,exports){
    class Input {
      constructor(value, size) {
        this.value = value;
        if (Array.isArray(size)) {
          this.size = size;
        } else {
          this.size = new Int32Array(3);
          if (size.z) {
            this.size = new Int32Array([size.x, size.y, size.z]);
          } else if (size.y) {
            this.size = new Int32Array([size.x, size.y]);
          } else {
            this.size = new Int32Array([size.x]);
          }
        }

        const [w, h, d] = this.size;
        if (d) {
          if (this.value.length !== (w * h * d)) {
            throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} * ${d} = ${(h * w * d)}`);
          }
        } else if (h) {
          if (this.value.length !== (w * h)) {
            throw new Error(`Input size ${this.value.length} does not match ${w} * ${h} = ${(h * w)}`);
          }
        } else {
          if (this.value.length !== w) {
            throw new Error(`Input size ${this.value.length} does not match ${w}`);
          }
        }

      }

      toArray() {
        const { utils } = require('./utils');
        const [w, h, d] = this.size;
        if (d) {
          return utils.erectMemoryOptimized3DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h, d);
        } else if (h) {
          return utils.erectMemoryOptimized2DFloat(this.value.subarray ? this.value : new Float32Array(this.value), w, h);
        } else {
          return this.value;
        }
      }
    }

    function input(value, size) {
      return new Input(value, size);
    }

    module.exports = {
      Input,
      input
    };
    },{"./utils":114}],111:[function(require,module,exports){
    const { utils } = require('./utils');

    function kernelRunShortcut(kernel) {
      let run = function() {
        kernel.build.apply(kernel, arguments);
        run = function() {
          let result = kernel.run.apply(kernel, arguments);
          if (kernel.switchingKernels) {
            const reasons = kernel.resetSwitchingKernels();
            const newKernel = kernel.onRequestSwitchKernel(reasons, arguments, kernel);
            shortcut.kernel = kernel = newKernel;
            result = newKernel.run.apply(newKernel, arguments);
          }
          if (kernel.renderKernels) {
            return kernel.renderKernels();
          } else if (kernel.renderOutput) {
            return kernel.renderOutput();
          } else {
            return result;
          }
        };
        return run.apply(kernel, arguments);
      };
      const shortcut = function() {
        return run.apply(kernel, arguments);
      };
      shortcut.exec = function() {
        return new Promise((accept, reject) => {
          try {
            accept(run.apply(this, arguments));
          } catch (e) {
            reject(e);
          }
        });
      };
      shortcut.replaceKernel = function(replacementKernel) {
        kernel = replacementKernel;
        bindKernelToShortcut(kernel, shortcut);
      };

      bindKernelToShortcut(kernel, shortcut);
      return shortcut;
    }

    function bindKernelToShortcut(kernel, shortcut) {
      if (shortcut.kernel) {
        shortcut.kernel = kernel;
        return;
      }
      const properties = utils.allPropertiesOf(kernel);
      for (let i = 0; i < properties.length; i++) {
        const property = properties[i];
        if (property[0] === '_' && property[1] === '_') continue;
        if (typeof kernel[property] === 'function') {
          if (property.substring(0, 3) === 'add' || property.substring(0, 3) === 'set') {
            shortcut[property] = function() {
              shortcut.kernel[property].apply(shortcut.kernel, arguments);
              return shortcut;
            };
          } else {
            shortcut[property] = function() {
              return shortcut.kernel[property].apply(shortcut.kernel, arguments);
            };
          }
        } else {
          shortcut.__defineGetter__(property, () => shortcut.kernel[property]);
          shortcut.__defineSetter__(property, (value) => {
            shortcut.kernel[property] = value;
          });
        }
      }
      shortcut.kernel = kernel;
    }
    module.exports = {
      kernelRunShortcut
    };
    },{"./utils":114}],112:[function(require,module,exports){
    const source = `// https://www.shadertoy.com/view/4t2SDh
//note: uniformly distributed, normalized rand, [0,1]
highp float randomSeedShift = 1.0;
highp float slide = 1.0;
uniform highp float randomSeed1;
uniform highp float randomSeed2;

highp float nrand(highp vec2 n) {
  highp float result = fract(sin(dot((n.xy + 1.0) * vec2(randomSeed1 * slide, randomSeed2 * randomSeedShift), vec2(12.9898, 78.233))) * 43758.5453);
  randomSeedShift = result;
  if (randomSeedShift > 0.5) {
    slide += 0.00009; 
  } else {
    slide += 0.0009;
  }
  return result;
}`;

    const name = 'math-random-uniformly-distributed';

    const functionMatch = `Math.random()`;

    const functionReplace = `nrand(vTexCoord)`;

    const functionReturnType = 'Number';
    const onBeforeRun = (kernel) => {
      kernel.setUniform1f('randomSeed1', Math.random());
      kernel.setUniform1f('randomSeed2', Math.random());
    };

    const plugin = {
      name,
      onBeforeRun,
      functionMatch,
      functionReplace,
      functionReturnType,
      source
    };

    module.exports = plugin;
    },{}],113:[function(require,module,exports){
    class Texture {
      constructor(settings) {
        const {
          texture,
          size,
          dimensions,
          output,
          context,
          type = 'NumberTexture',
          kernel,
          internalFormat,
          textureFormat
        } = settings;
        if (!output) throw new Error('settings property "output" required.');
        if (!context) throw new Error('settings property "context" required.');
        if (!texture) throw new Error('settings property "texture" required.');
        if (!kernel) throw new Error('settings property "kernel" required.');
        this.texture = texture;
        if (texture._refs) {
          texture._refs++;
        } else {
          texture._refs = 1;
        }
        this.size = size;
        this.dimensions = dimensions;
        this.output = output;
        this.context = context;
        this.kernel = kernel;
        this.type = type;
        this._deleted = false;
        this.internalFormat = internalFormat;
        this.textureFormat = textureFormat;
      }

      toArray() {
        throw new Error(`Not implemented on ${this.constructor.name}`);
      }

      clone() {
        throw new Error(`Not implemented on ${this.constructor.name}`);
      }

      delete() {
        throw new Error(`Not implemented on ${this.constructor.name}`);
      }

      clear() {
        throw new Error(`Not implemented on ${this.constructor.name}`);
      }
    }

    module.exports = {
      Texture
    };
    },{}],114:[function(require,module,exports){
    const acorn = require('acorn');
    const { Input } = require('./input');
    const { Texture } = require('./texture');

    const FUNCTION_NAME = /function ([^(]*)/;
    const STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg;
    const ARGUMENT_NAMES = /([^\s,]+)/g;

    const utils = {
      systemEndianness() {
        return _systemEndianness;
      },
      getSystemEndianness() {
        const b = new ArrayBuffer(4);
        const a = new Uint32Array(b);
        const c = new Uint8Array(b);
        a[0] = 0xdeadbeef;
        if (c[0] === 0xef) return 'LE';
        if (c[0] === 0xde) return 'BE';
        throw new Error('unknown endianness');
      },

      isFunction(funcObj) {
        return typeof(funcObj) === 'function';
      },

      isFunctionString(fn) {
        if (typeof fn === 'string') {
          return (fn
            .slice(0, 'function'.length)
            .toLowerCase() === 'function');
        }
        return false;
      },

      getFunctionNameFromString(funcStr) {
        const result = FUNCTION_NAME.exec(funcStr);
        if (!result || result.length === 0) return null;
        return result[1].trim();
      },

      getFunctionBodyFromString(funcStr) {
        return funcStr.substring(funcStr.indexOf('{') + 1, funcStr.lastIndexOf('}'));
      },

      getArgumentNamesFromString(fn) {
        const fnStr = fn.replace(STRIP_COMMENTS, '');
        let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
        if (result === null) {
          result = [];
        }
        return result;
      },

      clone(obj) {
        if (obj === null || typeof obj !== 'object' || obj.hasOwnProperty('isActiveClone')) return obj;

        const temp = obj.constructor(); 

        for (let key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            obj.isActiveClone = null;
            temp[key] = utils.clone(obj[key]);
            delete obj.isActiveClone;
          }
        }

        return temp;
      },

      isArray(array) {
        return !isNaN(array.length);
      },

      getVariableType(value, strictIntegers) {
        if (utils.isArray(value)) {
          if (value.length > 0 && value[0].nodeName === 'IMG') {
            return 'HTMLImageArray';
          }
          return 'Array';
        }

        switch (value.constructor) {
          case Boolean:
            return 'Boolean';
          case Number:
            if (strictIntegers && Number.isInteger(value)) {
              return 'Integer';
            }
            return 'Float';
          case Texture:
            return value.type;
          case Input:
            return 'Input';
        }
        if ('nodeName' in value) {
          switch (value.nodeName) {
            case 'IMG':
              return 'HTMLImage';
            case 'CANVAS':
              return 'HTMLImage';
            case 'VIDEO':
              return 'HTMLVideo';
          }
        } else if (value.hasOwnProperty('type')) {
          return value.type;
        } else if (typeof OffscreenCanvas !== 'undefined' && value instanceof OffscreenCanvas) {
          return 'OffscreenCanvas';
        } else if (typeof ImageBitmap !== 'undefined' && value instanceof ImageBitmap) {
          return 'ImageBitmap';
        } else if (typeof ImageData !== 'undefined' && value instanceof ImageData) {
          return 'ImageData';
        }
        return 'Unknown';
      },

      getKernelTextureSize(settings, dimensions) {
        let [w, h, d] = dimensions;
        let texelCount = (w || 1) * (h || 1) * (d || 1);

        if (settings.optimizeFloatMemory && settings.precision === 'single') {
          w = texelCount = Math.ceil(texelCount / 4);
        }
        if (h > 1 && w * h === texelCount) {
          return new Int32Array([w, h]);
        }
        return utils.closestSquareDimensions(texelCount);
      },

      closestSquareDimensions(length) {
        const sqrt = Math.sqrt(length);
        let high = Math.ceil(sqrt);
        let low = Math.floor(sqrt);
        while (high * low < length) {
          high--;
          low = Math.ceil(length / high);
        }
        return new Int32Array([low, Math.ceil(length / low)]);
      },

      getMemoryOptimizedFloatTextureSize(dimensions, bitRatio) {
        const totalArea = utils.roundTo((dimensions[0] || 1) * (dimensions[1] || 1) * (dimensions[2] || 1) * (dimensions[3] || 1), 4);
        const texelCount = totalArea / bitRatio;
        return utils.closestSquareDimensions(texelCount);
      },

      getMemoryOptimizedPackedTextureSize(dimensions, bitRatio) {
        const [w, h, d] = dimensions;
        const totalArea = utils.roundTo((w || 1) * (h || 1) * (d || 1), 4);
        const texelCount = totalArea / (4 / bitRatio);
        return utils.closestSquareDimensions(texelCount);
      },

      roundTo(n, d) {
        return Math.floor((n + d - 1) / d) * d;
      },
      getDimensions(x, pad) {
        let ret;
        if (utils.isArray(x)) {
          const dim = [];
          let temp = x;
          while (utils.isArray(temp)) {
            dim.push(temp.length);
            temp = temp[0];
          }
          ret = dim.reverse();
        } else if (x instanceof Texture) {
          ret = x.output;
        } else if (x instanceof Input) {
          ret = x.size;
        } else {
          throw new Error(`Unknown dimensions of ${x}`);
        }

        if (pad) {
          ret = Array.from(ret);
          while (ret.length < 3) {
            ret.push(1);
          }
        }

        return new Int32Array(ret);
      },

      flatten2dArrayTo(array, target) {
        let offset = 0;
        for (let y = 0; y < array.length; y++) {
          target.set(array[y], offset);
          offset += array[y].length;
        }
      },

      flatten3dArrayTo(array, target) {
        let offset = 0;
        for (let z = 0; z < array.length; z++) {
          for (let y = 0; y < array[z].length; y++) {
            target.set(array[z][y], offset);
            offset += array[z][y].length;
          }
        }
      },

      flatten4dArrayTo(array, target) {
        let offset = 0;
        for (let l = 0; l < array.length; l++) {
          for (let z = 0; z < array[l].length; z++) {
            for (let y = 0; y < array[l][z].length; y++) {
              target.set(array[l][z][y], offset);
              offset += array[l][z][y].length;
            }
          }
        }
      },

      flattenTo(array, target) {
        if (utils.isArray(array[0])) {
          if (utils.isArray(array[0][0])) {
            if (utils.isArray(array[0][0][0])) {
              utils.flatten4dArrayTo(array, target);
            } else {
              utils.flatten3dArrayTo(array, target);
            }
          } else {
            utils.flatten2dArrayTo(array, target);
          }
        } else {
          target.set(array);
        }
      },

      splitArray(array, part) {
        const result = [];
        for (let i = 0; i < array.length; i += part) {
          result.push(new array.constructor(array.buffer, i * 4 + array.byteOffset, part));
        }
        return result;
      },

      getAstString(source, ast) {
        const lines = Array.isArray(source) ? source : source.split(/\r?\n/g);
        const start = ast.loc.start;
        const end = ast.loc.end;
        const result = [];
        if (start.line === end.line) {
          result.push(lines[start.line - 1].substring(start.column, end.column));
        } else {
          result.push(lines[start.line - 1].slice(start.column));
          for (let i = start.line; i < end.line; i++) {
            result.push(lines[i]);
          }
          result.push(lines[end.line - 1].slice(0, end.column));
        }
        return result.join('\n');
      },

      allPropertiesOf(obj) {
        const props = [];

        do {
          props.push.apply(props, Object.getOwnPropertyNames(obj));
        } while (obj = Object.getPrototypeOf(obj));

        return props;
      },

      linesToString(lines) {
        if (lines.length > 0) {
          return lines.join(';\n') + ';\n';
        } else {
          return '\n';
        }
      },
      warnDeprecated(type, oldName, newName) {
        if (newName) {
          console.warn(`You are using a deprecated ${ type } "${ oldName }". It has been replaced with "${ newName }". Fixing, but please upgrade as it will soon be removed.`);
        } else {
          console.warn(`You are using a deprecated ${ type } "${ oldName }". It has been removed. Fixing, but please upgrade as it will soon be removed.`);
        }
      },
      flipPixels: (pixels, width, height) => {
        const halfHeight = height / 2 | 0; 
        const bytesPerRow = width * 4;
        const temp = new Uint8ClampedArray(width * 4);
        const result = pixels.slice(0);
        for (let y = 0; y < halfHeight; ++y) {
          const topOffset = y * bytesPerRow;
          const bottomOffset = (height - y - 1) * bytesPerRow;

          temp.set(result.subarray(topOffset, topOffset + bytesPerRow));

          result.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);

          result.set(temp, bottomOffset);
        }
        return result;
      },
      erectPackedFloat: (array, width) => {
        return array.subarray(0, width);
      },
      erect2DPackedFloat: (array, width, height) => {
        const yResults = new Array(height);
        for (let y = 0; y < height; y++) {
          const xStart = y * width;
          const xEnd = xStart + width;
          yResults[y] = array.subarray(xStart, xEnd);
        }
        return yResults;
      },
      erect3DPackedFloat: (array, width, height, depth) => {
        const zResults = new Array(depth);
        for (let z = 0; z < depth; z++) {
          const yResults = new Array(height);
          for (let y = 0; y < height; y++) {
            const xStart = (z * height * width) + y * width;
            const xEnd = xStart + width;
            yResults[y] = array.subarray(xStart, xEnd);
          }
          zResults[z] = yResults;
        }
        return zResults;
      },
      erectMemoryOptimizedFloat: (array, width) => {
        return array.subarray(0, width);
      },
      erectMemoryOptimized2DFloat: (array, width, height) => {
        const yResults = new Array(height);
        for (let y = 0; y < height; y++) {
          const offset = y * width;
          yResults[y] = array.subarray(offset, offset + width);
        }
        return yResults;
      },
      erectMemoryOptimized3DFloat: (array, width, height, depth) => {
        const zResults = new Array(depth);
        for (let z = 0; z < depth; z++) {
          const yResults = new Array(height);
          for (let y = 0; y < height; y++) {
            const offset = (z * height * width) + (y * width);
            yResults[y] = array.subarray(offset, offset + width);
          }
          zResults[z] = yResults;
        }
        return zResults;
      },
      erectFloat: (array, width) => {
        const xResults = new Float32Array(width);
        let i = 0;
        for (let x = 0; x < width; x++) {
          xResults[x] = array[i];
          i += 4;
        }
        return xResults;
      },
      erect2DFloat: (array, width, height) => {
        const yResults = new Array(height);
        let i = 0;
        for (let y = 0; y < height; y++) {
          const xResults = new Float32Array(width);
          for (let x = 0; x < width; x++) {
            xResults[x] = array[i];
            i += 4;
          }
          yResults[y] = xResults;
        }
        return yResults;
      },
      erect3DFloat: (array, width, height, depth) => {
        const zResults = new Array(depth);
        let i = 0;
        for (let z = 0; z < depth; z++) {
          const yResults = new Array(height);
          for (let y = 0; y < height; y++) {
            const xResults = new Float32Array(width);
            for (let x = 0; x < width; x++) {
              xResults[x] = array[i];
              i += 4;
            }
            yResults[y] = xResults;
          }
          zResults[z] = yResults;
        }
        return zResults;
      },
      erectArray2: (array, width) => {
        const xResults = new Array(width);
        const xResultsMax = width * 4;
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x, x + 2);
        }
        return xResults;
      },
      erect2DArray2: (array, width, height) => {
        const yResults = new Array(height);
        const XResultsMax = width * 4;
        for (let y = 0; y < height; y++) {
          const xResults = new Array(width);
          const offset = y * XResultsMax;
          let i = 0;
          for (let x = 0; x < XResultsMax; x += 4) {
            xResults[i++] = array.subarray(x + offset, x + offset + 2);
          }
          yResults[y] = xResults;
        }
        return yResults;
      },
      erect3DArray2: (array, width, height, depth) => {
        const xResultsMax = width * 4;
        const zResults = new Array(depth);
        for (let z = 0; z < depth; z++) {
          const yResults = new Array(height);
          for (let y = 0; y < height; y++) {
            const xResults = new Array(width);
            const offset = (z * xResultsMax * height) + (y * xResultsMax);
            let i = 0;
            for (let x = 0; x < xResultsMax; x += 4) {
              xResults[i++] = array.subarray(x + offset, x + offset + 2);
            }
            yResults[y] = xResults;
          }
          zResults[z] = yResults;
        }
        return zResults;
      },
      erectArray3: (array, width) => {
        const xResults = new Array(width);
        const xResultsMax = width * 4;
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x, x + 3);
        }
        return xResults;
      },
      erect2DArray3: (array, width, height) => {
        const xResultsMax = width * 4;
        const yResults = new Array(height);
        for (let y = 0; y < height; y++) {
          const xResults = new Array(width);
          const offset = y * xResultsMax;
          let i = 0;
          for (let x = 0; x < xResultsMax; x += 4) {
            xResults[i++] = array.subarray(x + offset, x + offset + 3);
          }
          yResults[y] = xResults;
        }
        return yResults;
      },
      erect3DArray3: (array, width, height, depth) => {
        const xResultsMax = width * 4;
        const zResults = new Array(depth);
        for (let z = 0; z < depth; z++) {
          const yResults = new Array(height);
          for (let y = 0; y < height; y++) {
            const xResults = new Array(width);
            const offset = (z * xResultsMax * height) + (y * xResultsMax);
            let i = 0;
            for (let x = 0; x < xResultsMax; x += 4) {
              xResults[i++] = array.subarray(x + offset, x + offset + 3);
            }
            yResults[y] = xResults;
          }
          zResults[z] = yResults;
        }
        return zResults;
      },
      erectArray4: (array, width) => {
        const xResults = new Array(array);
        const xResultsMax = width * 4;
        let i = 0;
        for (let x = 0; x < xResultsMax; x += 4) {
          xResults[i++] = array.subarray(x, x + 4);
        }
        return xResults;
      },
      erect2DArray4: (array, width, height) => {
        const xResultsMax = width * 4;
        const yResults = new Array(height);
        for (let y = 0; y < height; y++) {
          const xResults = new Array(width);
          const offset = y * xResultsMax;
          let i = 0;
          for (let x = 0; x < xResultsMax; x += 4) {
            xResults[i++] = array.subarray(x + offset, x + offset + 4);
          }
          yResults[y] = xResults;
        }
        return yResults;
      },
      erect3DArray4: (array, width, height, depth) => {
        const xResultsMax = width * 4;
        const zResults = new Array(depth);
        for (let z = 0; z < depth; z++) {
          const yResults = new Array(height);
          for (let y = 0; y < height; y++) {
            const xResults = new Array(width);
            const offset = (z * xResultsMax * height) + (y * xResultsMax);
            let i = 0;
            for (let x = 0; x < xResultsMax; x += 4) {
              xResults[i++] = array.subarray(x + offset, x + offset + 4);
            }
            yResults[y] = xResults;
          }
          zResults[z] = yResults;
        }
        return zResults;
      },

      flattenFunctionToString: (source, settings) => {
        const { findDependency, thisLookup, doNotDefine } = settings;
        let flattened = settings.flattened;
        if (!flattened) {
          flattened = settings.flattened = {};
        }
        const ast = acorn.parse(source);
        const functionDependencies = [];
        let indent = 0;

        function flatten(ast) {
          if (Array.isArray(ast)) {
            const results = [];
            for (let i = 0; i < ast.length; i++) {
              results.push(flatten(ast[i]));
            }
            return results.join('');
          }
          switch (ast.type) {
            case 'Program':
              return flatten(ast.body) + (ast.body[0].type === 'VariableDeclaration' ? ';' : '');
            case 'FunctionDeclaration':
              return `function ${ast.id.name}(${ast.params.map(flatten).join(', ')}) ${ flatten(ast.body) }`;
            case 'BlockStatement': {
              const result = [];
              indent += 2;
              for (let i = 0; i < ast.body.length; i++) {
                const flat = flatten(ast.body[i]);
                if (flat) {
                  result.push(' '.repeat(indent) + flat, ';\n');
                }
              }
              indent -= 2;
              return `{\n${result.join('')}}`;
            }
            case 'VariableDeclaration':
              const declarations = utils.normalizeDeclarations(ast)
                .map(flatten)
                .filter(r => r !== null);
              if (declarations.length < 1) {
                return '';
              } else {
                return `${ast.kind} ${declarations.join(',')}`;
              }
              case 'VariableDeclarator':
                if (ast.init.object && ast.init.object.type === 'ThisExpression') {
                  const lookup = thisLookup(ast.init.property.name, true);
                  if (lookup) {
                    return `${ast.id.name} = ${flatten(ast.init)}`;
                  } else {
                    return null;
                  }
                } else {
                  return `${ast.id.name} = ${flatten(ast.init)}`;
                }
                case 'CallExpression': {
                  if (ast.callee.property.name === 'subarray') {
                    return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                  }
                  if (ast.callee.object.name === 'gl' || ast.callee.object.name === 'context') {
                    return `${flatten(ast.callee.object)}.${flatten(ast.callee.property)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                  }
                  if (ast.callee.object.type === 'ThisExpression') {
                    functionDependencies.push(findDependency('this', ast.callee.property.name));
                    return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                  } else if (ast.callee.object.name) {
                    const foundSource = findDependency(ast.callee.object.name, ast.callee.property.name);
                    if (foundSource === null) {
                      return `${ast.callee.object.name}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                    } else {
                      functionDependencies.push(foundSource);
                      return `${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                    }
                  } else if (ast.callee.object.type === 'MemberExpression') {
                    return `${flatten(ast.callee.object)}.${ast.callee.property.name}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                  } else {
                    throw new Error('unknown ast.callee');
                  }
                }
                case 'ReturnStatement':
                  return `return ${flatten(ast.argument)}`;
                case 'BinaryExpression':
                  return `(${flatten(ast.left)}${ast.operator}${flatten(ast.right)})`;
                case 'UnaryExpression':
                  if (ast.prefix) {
                    return `${ast.operator} ${flatten(ast.argument)}`;
                  } else {
                    return `${flatten(ast.argument)} ${ast.operator}`;
                  }
                  case 'ExpressionStatement':
                    return `${flatten(ast.expression)}`;
                  case 'SequenceExpression':
                    return `(${flatten(ast.expressions)})`;
                  case 'ArrowFunctionExpression':
                    return `(${ast.params.map(flatten).join(', ')}) => ${flatten(ast.body)}`;
                  case 'Literal':
                    return ast.raw;
                  case 'Identifier':
                    return ast.name;
                  case 'MemberExpression':
                    if (ast.object.type === 'ThisExpression') {
                      return thisLookup(ast.property.name);
                    }
                    if (ast.computed) {
                      return `${flatten(ast.object)}[${flatten(ast.property)}]`;
                    }
                    return flatten(ast.object) + '.' + flatten(ast.property);
                  case 'ThisExpression':
                    return 'this';
                  case 'NewExpression':
                    return `new ${flatten(ast.callee)}(${ast.arguments.map(value => flatten(value)).join(', ')})`;
                  case 'ForStatement':
                    return `for (${flatten(ast.init)};${flatten(ast.test)};${flatten(ast.update)}) ${flatten(ast.body)}`;
                  case 'AssignmentExpression':
                    return `${flatten(ast.left)}${ast.operator}${flatten(ast.right)}`;
                  case 'UpdateExpression':
                    return `${flatten(ast.argument)}${ast.operator}`;
                  case 'IfStatement':
                    return `if (${flatten(ast.test)}) ${flatten(ast.consequent)}`;
                  case 'ThrowStatement':
                    return `throw ${flatten(ast.argument)}`;
                  case 'ObjectPattern':
                    return ast.properties.map(flatten).join(', ');
                  case 'ArrayPattern':
                    return ast.elements.map(flatten).join(', ');
                  case 'DebuggerStatement':
                    return 'debugger;';
                  case 'ConditionalExpression':
                    return `${flatten(ast.test)}?${flatten(ast.consequent)}:${flatten(ast.alternate)}`;
                  case 'Property':
                    if (ast.kind === 'init') {
                      return flatten(ast.key);
                    }
          }
          throw new Error(`unhandled ast.type of ${ ast.type }`);
        }
        const result = flatten(ast);
        if (functionDependencies.length > 0) {
          const flattenedFunctionDependencies = [];
          for (let i = 0; i < functionDependencies.length; i++) {
            const functionDependency = functionDependencies[i];
            if (!flattened[functionDependency]) {
              flattened[functionDependency] = true;
            }
            functionDependency ? flattenedFunctionDependencies.push(utils.flattenFunctionToString(functionDependency, settings) + '\n') : '';
          }
          return flattenedFunctionDependencies.join('') + result;
        }
        return result;
      },

      normalizeDeclarations: (ast) => {
        if (ast.type !== 'VariableDeclaration') throw new Error('Ast is not of type "VariableDeclaration"');
        const normalizedDeclarations = [];
        for (let declarationIndex = 0; declarationIndex < ast.declarations.length; declarationIndex++) {
          const declaration = ast.declarations[declarationIndex];
          if (declaration.id && declaration.id.type === 'ObjectPattern' && declaration.id.properties) {
            const { properties } = declaration.id;
            for (let propertyIndex = 0; propertyIndex < properties.length; propertyIndex++) {
              const property = properties[propertyIndex];
              if (property.value.type === 'ObjectPattern' && property.value.properties) {
                for (let subPropertyIndex = 0; subPropertyIndex < property.value.properties.length; subPropertyIndex++) {
                  const subProperty = property.value.properties[subPropertyIndex];
                  if (subProperty.type === 'Property') {
                    normalizedDeclarations.push({
                      type: 'VariableDeclarator',
                      id: {
                        type: 'Identifier',
                        name: subProperty.key.name
                      },
                      init: {
                        type: 'MemberExpression',
                        object: {
                          type: 'MemberExpression',
                          object: declaration.init,
                          property: {
                            type: 'Identifier',
                            name: property.key.name
                          },
                          computed: false
                        },
                        property: {
                          type: 'Identifier',
                          name: subProperty.key.name
                        },
                        computed: false
                      }
                    });
                  } else {
                    throw new Error('unexpected state');
                  }
                }
              } else if (property.value.type === 'Identifier') {
                normalizedDeclarations.push({
                  type: 'VariableDeclarator',
                  id: {
                    type: 'Identifier',
                    name: property.value && property.value.name ? property.value.name : property.key.name
                  },
                  init: {
                    type: 'MemberExpression',
                    object: declaration.init,
                    property: {
                      type: 'Identifier',
                      name: property.key.name
                    },
                    computed: false
                  }
                });
              } else {
                throw new Error('unexpected state');
              }
            }
          } else if (declaration.id && declaration.id.type === 'ArrayPattern' && declaration.id.elements) {
            const { elements } = declaration.id;
            for (let elementIndex = 0; elementIndex < elements.length; elementIndex++) {
              const element = elements[elementIndex];
              if (element.type === 'Identifier') {
                normalizedDeclarations.push({
                  type: 'VariableDeclarator',
                  id: {
                    type: 'Identifier',
                    name: element.name
                  },
                  init: {
                    type: 'MemberExpression',
                    object: declaration.init,
                    property: {
                      type: 'Literal',
                      value: elementIndex,
                      raw: elementIndex.toString(),
                      start: element.start,
                      end: element.end
                    },
                    computed: true
                  }
                });
              } else {
                throw new Error('unexpected state');
              }
            }
          } else {
            normalizedDeclarations.push(declaration);
          }
        }
        return normalizedDeclarations;
      },

      splitHTMLImageToRGB: (gpu, image) => {
        const rKernel = gpu.createKernel(function(a) {
          const pixel = a[this.thread.y][this.thread.x];
          return pixel.r * 255;
        }, {
          output: [image.width, image.height],
          precision: 'unsigned',
          argumentTypes: { a: 'HTMLImage' },
        });
        const gKernel = gpu.createKernel(function(a) {
          const pixel = a[this.thread.y][this.thread.x];
          return pixel.g * 255;
        }, {
          output: [image.width, image.height],
          precision: 'unsigned',
          argumentTypes: { a: 'HTMLImage' },
        });
        const bKernel = gpu.createKernel(function(a) {
          const pixel = a[this.thread.y][this.thread.x];
          return pixel.b * 255;
        }, {
          output: [image.width, image.height],
          precision: 'unsigned',
          argumentTypes: { a: 'HTMLImage' },
        });
        const aKernel = gpu.createKernel(function(a) {
          const pixel = a[this.thread.y][this.thread.x];
          return pixel.a * 255;
        }, {
          output: [image.width, image.height],
          precision: 'unsigned',
          argumentTypes: { a: 'HTMLImage' },
        });
        const result = [
          rKernel(image),
          gKernel(image),
          bKernel(image),
          aKernel(image),
        ];
        result.rKernel = rKernel;
        result.gKernel = gKernel;
        result.bKernel = bKernel;
        result.aKernel = aKernel;
        result.gpu = gpu;
        return result;
      },

      splitRGBAToCanvases: (gpu, rgba, width, height) => {
        const visualKernelR = gpu.createKernel(function(v) {
          const pixel = v[this.thread.y][this.thread.x];
          this.color(pixel.r / 255, 0, 0, 255);
        }, {
          output: [width, height],
          graphical: true,
          argumentTypes: { v: 'Array2D(4)' }
        });
        visualKernelR(rgba);

        const visualKernelG = gpu.createKernel(function(v) {
          const pixel = v[this.thread.y][this.thread.x];
          this.color(0, pixel.g / 255, 0, 255);
        }, {
          output: [width, height],
          graphical: true,
          argumentTypes: { v: 'Array2D(4)' }
        });
        visualKernelG(rgba);

        const visualKernelB = gpu.createKernel(function(v) {
          const pixel = v[this.thread.y][this.thread.x];
          this.color(0, 0, pixel.b / 255, 255);
        }, {
          output: [width, height],
          graphical: true,
          argumentTypes: { v: 'Array2D(4)' }
        });
        visualKernelB(rgba);

        const visualKernelA = gpu.createKernel(function(v) {
          const pixel = v[this.thread.y][this.thread.x];
          this.color(255, 255, 255, pixel.a / 255);
        }, {
          output: [width, height],
          graphical: true,
          argumentTypes: { v: 'Array2D(4)' }
        });
        visualKernelA(rgba);
        return [
          visualKernelR.canvas,
          visualKernelG.canvas,
          visualKernelB.canvas,
          visualKernelA.canvas,
        ];
      },

      getMinifySafeName: (fn) => {
        try {
          const ast = acorn.parse(`const value = ${fn.toString()}`);
          const { init } = ast.body[0].declarations[0];
          return init.body.name || init.body.body[0].argument.name;
        } catch (e) {
          throw new Error('Unrecognized function type.  Please use `() => yourFunctionVariableHere` or function() { return yourFunctionVariableHere; }');
        }
      },
      sanitizeName: function(name) {
        if (dollarSign.test(name)) {
          name = name.replace(dollarSign, 'S_S');
        }
        if (doubleUnderscore.test(name)) {
          name = name.replace(doubleUnderscore, 'U_U');
        } else if (singleUnderscore.test(name)) {
          name = name.replace(singleUnderscore, 'u_u');
        }
        return name;
      }
    };

    const dollarSign = /\$/;
    const doubleUnderscore = /__/;
    const singleUnderscore = /_/;

    const _systemEndianness = utils.getSystemEndianness();

    module.exports = {
      utils
    };
    },{"./input":110,"./texture":113,"acorn":1}]},{},[107])(107)
    });
    });

    let gpuInstance = null;
    /**
     * Sets up the gpu.js instance
     */
    function setup(value) {
        gpuInstance = value;
    }
    function makeKernel(fn, settings) {
        let _gpuInstance = gpuInstance;
        if (_gpuInstance === null) {
            _gpuInstance = new gpuBrowser.GPU({ mode: 'gpu' });
            setup(_gpuInstance);
        }
        return _gpuInstance
            .createKernel(fn, settings)
            .setPipeline(true);
    }
    function makeKernelMap(map, fn, settings) {
        let _gpuInstance = gpuInstance;
        if (_gpuInstance === null) {
            _gpuInstance = new gpuBrowser.GPU({ mode: 'gpu' });
            setup(_gpuInstance);
        }
        return _gpuInstance
            .createKernelMap(map, fn, settings)
            .setPipeline(true);
    }
    /**
     * Compiles a function into a gpu.js dev mode kernel
     */
    // export function makeDevKernel(
    //   fn: ThreadFunction,
    //   settings: makeKernelSettings
    // ): IKernelRunShortcut {
    //   if ('map' in settings) {
    //     throw new Error('map kernels are not supported by dev kernels');
    //   }
    //   const gpu = new GPU({ mode: 'dev' });
    //   return gpu.createKernel(fn, settings);
    // }
    function kernelInput(value, size) {
        return new gpuBrowser.Input(value, size);
    }
    /**
     * Deletes a gpu.js texture and frees VRAM
     */
    function release(possibleTexture) {
        if (possibleTexture instanceof gpuBrowser.Texture) {
            possibleTexture.delete();
        }
    }
    /**
     * Cleans ie sets all elements to 0 of a Texture or a js array
     */
    function clear(value) {
        if (value instanceof gpuBrowser.Texture) {
            value.clear();
            return;
        }
        // array
        if (Array.isArray(value)) {
            if (typeof value[0] === 'number') {
                value.fill(0);
            }
            else if (typeof value[0][0] === 'number') {
                for (let x = 0; x < value.length; x++) {
                    value[x].fill(0);
                }
                return;
            }
            else if (typeof value[0][0][0] === 'number') {
                // cube
                for (let y = 0; y < value.length; y++) {
                    const row = value[y];
                    for (let x = 0; x < row.length; x++) {
                        row[x].fill(0);
                    }
                }
                return;
            }
        }
        if (value instanceof Float32Array) {
            value.fill(0);
            return;
        }
        throw new Error('unhandled value');
    }
    /**
     * Clones a value
     */
    function clone(value) {
        if (value instanceof gpuBrowser.Texture) {
            return value.clone();
        }
        if (value instanceof Float32Array) {
            return value.slice(0);
        }
        if (Array.isArray(value)) {
            if (typeof value[0] === 'number') {
                return value.slice(0);
            }
            else if (typeof value[0][0] === 'number') {
                const matrix = new Array(value.length);
                for (let x = 0; x < value.length; x++) {
                    matrix[x] = value[x].slice(0);
                }
                return matrix;
            }
            else if (typeof value[0][0][0] === 'number') {
                const cube = new Array(value.length);
                for (let y = 0; y < value.length; y++) {
                    const row = value[y];
                    const matrix = new Array(row.length);
                    for (let x = 0; x < row.length; x++) {
                        matrix[x] = row[x].slice(0);
                    }
                }
                return cube;
            }
        }
        throw new Error('unhandled value');
    }

    /**
     * 2D Mean Squared Error
     */
    function mse2d(errors) {
        let sum = 0;
        for (let y = 0; y < this.constants.height; y++) {
            for (let x = 0; x < this.constants.width; x++) {
                sum += errors[y][x] ** 2;
            }
        }
        return sum / this.constants.length;
    }
    class MeanSquaredError {
        constructor({ width, height }) {
            this.calculate = makeKernel(mse2d, {
                output: [1],
                constants: {
                    width,
                    height,
                    length: width * height,
                },
                immutable: true,
            });
            this.addAbsolute = makeKernel(function (prevError, prevLayerErrors) {
                return prevError[0] + Math.abs(prevLayerErrors[0][0]);
            }, {
                output: [1],
                immutable: true,
            });
            this.add = makeKernel(function (value1, value2) {
                return value1[0] + value2[0];
            }, {
                output: [1],
                immutable: true,
            });
            this.divide = makeKernel(function (length, mseSum) {
                const value = mseSum[0];
                if (value > 0) {
                    return value / length;
                }
                return 0;
            }, {
                output: [1],
                immutable: true,
            });
        }
    }

    const baseLayerDefaultSettings = {
        width: 1,
        height: 1,
        depth: null,
        weights: null,
        deltas: null,
        praxis: null,
        praxisOpts: null,
        cleanupDeltas: true,
    };
    class BaseLayer {
        constructor(settings) {
            this.praxis = null;
            this.predictKernel = null;
            this.compareKernel = null;
            if (settings) {
                this.settings = { ...baseLayerDefaultSettings, ...settings };
            }
            else {
                this.settings = { ...baseLayerDefaultSettings };
            }
            this.setupPraxis();
        }
        get width() {
            var _a;
            return (_a = this.settings.width) !== null && _a !== void 0 ? _a : 0;
        }
        get height() {
            var _a;
            return (_a = this.settings.height) !== null && _a !== void 0 ? _a : 0;
        }
        get depth() {
            var _a;
            return (_a = this.settings.depth) !== null && _a !== void 0 ? _a : 0;
        }
        get weights() {
            return this.settings.weights;
        }
        set weights(weights) {
            this.settings.weights = weights;
            if (this.settings.cleanupDeltas && this.deltas) {
                clear(this.deltas);
            }
        }
        get deltas() {
            return this.settings.deltas;
        }
        set deltas(deltas) {
            this.settings.deltas = deltas;
        }
        get id() {
            var _a;
            return (_a = this.settings.id) !== null && _a !== void 0 ? _a : '';
        }
        set id(title) {
            this.settings.id = title;
        }
        setupPraxis() {
            const { initPraxis, praxis, praxisOpts } = this.settings;
            if (!this.praxis) {
                if (initPraxis) {
                    if (praxisOpts) {
                        this.praxis = initPraxis(this, praxisOpts);
                    }
                    else {
                        this.praxis = initPraxis(this);
                    }
                }
                else if (praxis) {
                    this.praxis = praxis;
                }
            }
        }
        /*
        get weights() {
          return this._weights;
        }
      
        set weights(value) {
          if (value) {
            if (value.dimensions) {
              if (value.dimensions[0] !== this.width) {
                throw new Error(`${this.constructor.name}.weights being set with improper value width`);
              }
              if (value.dimensions[1] !== this.height) {
                throw new Error(`${this.constructor.name}.weights being set with improper value height`);
              }
            } else {
              if (value[0].length !== this.width) {
                throw new Error(`${this.constructor.name}.weights being set with improper value width`);
              }
              if (value.length !== this.height) {
                throw new Error(`${this.constructor.name}.weights being set with improper value height`);
              }
            }
          }
          this._weights = value;
        }
      
        get deltas() {
          return this._deltas;
        }
      
        set deltas(value) {
          if (value) {
            if (value.dimensions) {
              if (value.dimensions[0] !== this.width) {
                throw new Error(`${this.constructor.name}.deltas being set with improper value width`);
              }
              if (value.dimensions[1] !== this.height) {
                throw new Error(`${this.constructor.name}.deltas being set with improper value height`);
              }
            } else {
              if (value[0].length !== this.width) {
                throw new Error(`${this.constructor.name}.deltas being set with improper value width`);
              }
              if (value.length !== this.height) {
                throw new Error(`${this.constructor.name}.deltas being set with improper value height`);
              }
            }
          }
          this._deltas = value;
        } */
        validate() {
            if (Number.isNaN(this.height)) {
                throw new Error(`${this.constructor.name} layer height is not a number`);
            }
            if (Number.isNaN(this.width)) {
                throw new Error(`${this.constructor.name} layer width is not a number`);
            }
            if (this.height < 1) {
                throw new Error(`${this.constructor.name} layer height is less than 1`);
            }
            if (this.width < 1) {
                throw new Error(`${this.constructor.name} layer width is less than 1`);
            }
        }
        setupKernels(isTraining) { }
        reuseKernels(layer) {
            if (layer.width !== this.width) {
                throw new Error(`${this.constructor.name} kernel width mismatch ${layer.width} is not ${this.width}`);
            }
            if (layer.height !== this.height) {
                throw new Error(`${this.constructor.name} kernel width mismatch ${layer.height} is not ${this.height}`);
            }
            if (layer.hasOwnProperty('predictKernel') && layer.predictKernel !== null) {
                if (!layer.predictKernel.immutable) {
                    throw new Error(`${layer.constructor.name}.predictKernel is not reusable, set kernel.immutable = true`);
                }
                this.predictKernel = layer.predictKernel;
            }
            if (layer.hasOwnProperty('compareKernel') && layer.compareKernel !== null) {
                if (!layer.compareKernel.immutable) {
                    throw new Error(`${layer.constructor.name}.compareKernel is not reusable, set kernel.immutable = true`);
                }
                this.compareKernel = layer.compareKernel;
            }
            this.praxis = layer.praxis;
        }
        predict(inputs) { }
        compare(targetValues) { }
        learn(learningRate) { }
        toArray() {
            return Array.isArray(this.weights)
                ? this.weights
                : this.weights.toArray();
        }
        toJSON() {
            return BaseLayer.toJSON(this);
        }
        static toJSON(layer) {
            const { weights } = layer;
            return {
                width: layer.width,
                height: layer.height,
                depth: layer.depth,
                weights: toUntypedArray((weights && weights instanceof gpuBrowser.Texture
                    ? weights.toArray()
                    : weights)),
                type: layer.constructor.name,
                praxisOpts: layer.praxis ? layer.praxis.toJSON() : null,
            };
        }
    }
    function toUntypedArray(weights) {
        if (weights === null)
            return null;
        if (Array.isArray(weights)) {
            if (typeof weights[0] === 'number') {
                return weights;
            }
            else if (Array.isArray(weights[0]) && typeof weights[0][0] === 'number') {
                return weights;
            }
            else if (Array.isArray(weights[0][0]) &&
                typeof weights[0][0][0] === 'number') {
                return weights;
            }
            else if (weights[0] instanceof Float32Array) {
                const matrix = weights;
                return matrix.map((row) => {
                    return Array.from(row);
                });
            }
            else if (weights[0][0] instanceof Float32Array) {
                const cube = weights;
                return cube.map((matrix) => {
                    return matrix.map((row) => {
                        return Array.from(row);
                    });
                });
            }
        }
        else if (weights) {
            return Array.from(weights);
        }
        throw new Error('unexpected value');
    }

    /**
     * Returns an array of zeros
     */
    function zeros$1(size) {
        return new Float32Array(size);
    }

    /**
     * Returns a 2D tensor(matrix) of zeros
     */
    function zeros2D(width, height) {
        const result = new Array(height);
        for (let y = 0; y < height; y++) {
            result[y] = zeros$1(width);
        }
        return result;
    }

    /**
     * Returns a 3D tensor of arrays
     */
    function zeros3D(width, height, depth) {
        const result = new Array(depth);
        for (let z = 0; z < depth; z++) {
            result[z] = zeros2D(width, height);
        }
        return result;
    }

    class Activation extends BaseLayer {
        constructor(inputLayer, settings) {
            super(settings);
            this.inputLayer = inputLayer;
            const { width, height, depth } = this;
            this.predictKernel = null;
            this.compareKernel = null;
            this.validate();
            if (depth > 0) {
                this.weights = zeros3D(width, height, depth);
                this.deltas = zeros3D(width, height, depth);
            }
            else if (height > 0) {
                this.weights = zeros2D(width, height);
                this.deltas = zeros2D(width, height);
            }
            this.setupPraxis();
        }
        get width() {
            return this.inputLayer.width;
        }
        get height() {
            return this.inputLayer.height;
        }
        get depth() {
            return this.inputLayer.depth;
        }
    }

    class Filter extends BaseLayer {
        constructor(settings, inputLayer) {
            super();
            this.settings = settings;
            this.inputLayer = inputLayer;
        }
        get width() {
            return this.inputLayer.width;
        }
        get height() {
            return this.inputLayer.height;
        }
        get depth() {
            return this.inputLayer.depth;
        }
        get filterCount() {
            return this.settings.filterCount;
        }
        get filterWidth() {
            return this.settings.filterWidth;
        }
        get filterHeight() {
            return this.settings.filterHeight;
        }
        get filters() {
            return this.settings.filters;
        }
        set filters(filters) {
            this.settings.filters = filters;
        }
        get filterDeltas() {
            return this.settings.filterDeltas;
        }
        set filterDeltas(filterDeltas) {
            this.settings.filterDeltas = filterDeltas;
        }
    }

    class Internal {
        constructor() {
            this.predictKernel = null;
            this.compareKernel = null;
            this.praxis = null;
        }
        get width() {
            return this.settings.width;
        }
        get height() {
            return this.settings.height;
        }
        get depth() {
            return this.settings.depth;
        }
        get weights() {
            return this.settings.weights;
        }
        set weights(weights) {
            this.settings.weights = weights;
        }
        get deltas() {
            return this.settings.deltas;
        }
        set deltas(deltas) {
            this.settings.deltas = deltas;
        }
        toJSON() {
            return BaseLayer.toJSON(this);
        }
    }

    class Modifier extends BaseLayer {
        constructor(inputLayer, settings) {
            super({
                ...settings,
                width: inputLayer.width,
                height: inputLayer.height,
                depth: inputLayer.depth,
            });
            this.inputLayer = inputLayer;
        }
        validate() {
            var _a;
            super.validate();
            if (this.width !== this.inputLayer.width) {
                throw new Error(`width of ${this.width} does not match inputLayer.width of ${this.inputLayer.width}`);
            }
            if (this.height !== this.inputLayer.height) {
                throw new Error(`height of ${this.height} does not match inputLayer.height of ${this.inputLayer.height}`);
            }
            if (this.depth !== ((_a = this.inputLayer.depth) !== null && _a !== void 0 ? _a : 0)) {
                throw new Error(`depth of ${this.depth} does not match inputLayer.depth of ${this.inputLayer.depth}`);
            }
        }
    }

    class Operator extends BaseLayer {
        constructor(inputLayer1, inputLayer2, settings) {
            super(settings);
            this.inputLayer1 = inputLayer1;
            this.inputLayer2 = inputLayer2;
            this.validate();
            this.weights = zeros2D(this.width, this.height);
            this.deltas = zeros2D(this.width, this.height);
            this.setupPraxis();
        }
    }

    function compare1D(weights, targetValues) {
        return weights[this.thread.y][this.thread.x] - targetValues[this.thread.x];
    }
    function compare2D$5(weights, targetValues) {
        return (weights[this.thread.y][this.thread.x] -
            targetValues[this.thread.y][this.thread.x]);
    }
    class Target extends BaseLayer {
        constructor(settings, inputLayer) {
            super(settings);
            this.inputLayer = inputLayer;
            this.validate();
            if (this.depth) {
                throw new Error('Target layer not implemented for depth');
            }
            else if (this.height) {
                this.weights = zeros2D(this.width, this.height);
                this.deltas = zeros2D(this.width, this.height);
                this.errors = zeros2D(this.width, this.height);
            }
            else {
                this.weights = zeros$1(this.width);
                this.deltas = zeros$1(this.width);
                this.errors = zeros$1(this.width);
            }
        }
        setupKernels() {
            if (this.width === 1) {
                this.compareKernel = makeKernel(compare1D, {
                    output: [this.width, this.height],
                    immutable: true,
                });
            }
            else {
                this.compareKernel = makeKernel(compare2D$5, {
                    output: [this.width, this.height],
                    immutable: true,
                });
            }
        }
        predict() {
            // TODO: should we clone here?
            // NOTE: this looks like it shouldn't be, but the weights are immutable, and this is where they are reused.
            release(this.weights);
            this.weights = clone(this.inputLayer.weights);
        }
        compare(targetValues) {
            // this is where weights attach to deltas
            // deltas will be zero on learn, so save it in error for comparing to mse later
            release(this.deltas);
            release(this.errors);
            release(this.inputLayer.deltas);
            this.deltas = this.compareKernel(this.weights, targetValues);
            this.inputLayer.deltas = clone(this.deltas);
            this.errors = clone(this.deltas);
        }
        setupPraxis() { }
    }
    function target(settings, inputLayer) {
        return new Target(settings, inputLayer);
    }

    // eslint-disable-next-line @typescript-eslint/no-extraneous-class
    class InternalModel {
    }
    // eslint-disable-next-line @typescript-eslint/no-extraneous-class
    class EntryPoint extends BaseLayer {
    }
    // eslint-disable-next-line @typescript-eslint/no-extraneous-class
    class Model extends BaseLayer {
        learn(learningRate) {
            // TODO: do we need to release here?
            const { weights: oldWeights } = this;
            if (!this.praxis)
                throw new Error('this.praxis not defined');
            this.weights = this.praxis.run(this, learningRate);
            release(oldWeights);
        }
    }

    /* Functions for turning sparse hashes into arrays and vice versa */
    const lookup = {
        /**
         * Performs `[{a: 1}, {b: 6, c: 7}] -> {a: 0, b: 1, c: 2}`
         * @param {Object} hashes
         * @returns {Object}
         */
        toTable(hashes) {
            const hash = hashes.reduce((memo, hash) => {
                return Object.assign(memo, hash);
            }, {});
            return lookup.toHash(hash);
        },
        /**
         * Performs `[{a: 1}, {b: 6, c: 7}] -> {a: 0, b: 1, c: 2}`
         */
        toTable2D(objects2D) {
            const table = {};
            let valueIndex = 0;
            for (let i = 0; i < objects2D.length; i++) {
                const objects = objects2D[i];
                for (let j = 0; j < objects.length; j++) {
                    const object = objects[j];
                    for (const p in object) {
                        if (object.hasOwnProperty(p) && !table.hasOwnProperty(p)) {
                            table[p] = valueIndex++;
                        }
                    }
                }
            }
            return table;
        },
        toInputTable2D(data) {
            const table = {};
            let tableIndex = 0;
            for (let dataIndex = 0; dataIndex < data.length; dataIndex++) {
                const input = data[dataIndex].input;
                for (let i = 0; i < input.length; i++) {
                    const object = input[i];
                    for (const p in object) {
                        if (!object.hasOwnProperty(p))
                            continue;
                        if (!table.hasOwnProperty(p)) {
                            table[p] = tableIndex++;
                        }
                    }
                }
            }
            return table;
        },
        toOutputTable2D(data) {
            const table = {};
            let tableIndex = 0;
            for (let dataIndex = 0; dataIndex < data.length; dataIndex++) {
                const output = data[dataIndex].output;
                for (let i = 0; i < output.length; i++) {
                    const object = output[i];
                    for (const p in object) {
                        if (!object.hasOwnProperty(p))
                            continue;
                        if (!table.hasOwnProperty(p)) {
                            table[p] = tableIndex++;
                        }
                    }
                }
            }
            return table;
        },
        /**
         * performs `{a: 6, b: 7} -> {a: 0, b: 1}`
         */
        toHash(hash) {
            const lookup = {};
            let index = 0;
            const keys = Object.keys(hash);
            for (let i = 0; i < keys.length; i++) {
                lookup[keys[i]] = index++;
            }
            return lookup;
        },
        /**
         * performs `{a: 0, b: 1}, {a: 6} -> [6, 0]`
         */
        toArray(lookup, object, arrayLength) {
            const result = new Float32Array(arrayLength);
            for (const p in lookup) {
                if (!lookup.hasOwnProperty(p))
                    continue;
                result[lookup[p]] = object.hasOwnProperty(p) ? object[p] : 0;
            }
            return result;
        },
        toArrayShort(lookup, object) {
            const result = [];
            for (const p in lookup) {
                if (!lookup.hasOwnProperty(p))
                    continue;
                if (!object.hasOwnProperty(p))
                    break;
                result[lookup[p]] = object[p];
            }
            return Float32Array.from(result);
        },
        toArrays(lookup, objects, arrayLength) {
            const result = [];
            for (let i = 0; i < objects.length; i++) {
                result.push(this.toArray(lookup, objects[i], arrayLength));
            }
            return result;
        },
        /**
         * performs `{a: 0, b: 1}, [6, 7] -> {a: 6, b: 7}`
         * @param {Object} lookup
         * @param {Array} array
         * @returns {Object}
         */
        toObject(lookup, array) {
            const object = {};
            for (const p in lookup) {
                if (!lookup.hasOwnProperty(p))
                    continue;
                object[p] = array[lookup[p]];
            }
            return object;
        },
        toObjectPartial(lookup, array, offset = 0, limit = 0) {
            const object = {};
            let i = 0;
            for (const p in lookup) {
                if (!lookup.hasOwnProperty(p))
                    continue;
                if (offset > 0) {
                    if (i++ < offset)
                        continue;
                }
                if (limit > 0) {
                    if (i++ >= limit)
                        continue;
                }
                object[p] = array[lookup[p] - offset];
            }
            return object;
        },
        dataShape(data) {
            const shape = [];
            let lastData;
            if (data.hasOwnProperty('input')) {
                shape.push('datum');
                lastData = data.input;
            }
            else if (Array.isArray(data)) {
                if (data[0] &&
                    data[0].input) {
                    shape.push('array', 'datum');
                    lastData = data[0].input;
                }
                else if (Array.isArray(data[0])) {
                    shape.push('array');
                    lastData = data[0];
                }
                else {
                    lastData = data;
                }
            }
            else {
                lastData = data;
            }
            let p;
            while (lastData) {
                p = Object.keys(lastData)[0];
                if (Array.isArray(lastData) ||
                    typeof lastData.buffer === 'object') {
                    shape.push('array');
                    const possibleNumber = lastData[parseInt(p)];
                    if (typeof possibleNumber === 'number') {
                        shape.push('number');
                        break;
                    }
                    else {
                        lastData = possibleNumber;
                    }
                }
                else if (typeof lastData === 'object' &&
                    typeof lastData.buffer !== 'object') {
                    shape.push('object');
                    const possibleNumber = lastData[p];
                    if (typeof possibleNumber === 'number') {
                        shape.push('number');
                        break;
                    }
                    else {
                        lastData = possibleNumber;
                    }
                }
                else {
                    throw new Error('unhandled signature');
                }
            }
            return shape;
        },
        addKeys(value, table) {
            if (Array.isArray(value))
                return table;
            let i = Object.keys(table).length;
            for (const p in value) {
                if (!value.hasOwnProperty(p))
                    continue;
                if (table.hasOwnProperty(p))
                    continue;
                table[p] = i++;
            }
            return table;
        },
    };

    class BasePraxis {
        constructor(layerTemplate, settings = {}) {
            this.layerTemplate = layerTemplate;
            this.settings = { ...settings };
            this.kernel = null;
        }
        get width() {
            return this.layerTemplate.width;
        }
        get height() {
            return this.layerTemplate.height;
        }
        get depth() {
            return this.layerTemplate.depth;
        }
        setupKernels() { }
        reuseKernels(praxis) {
            if (praxis.width !== this.width) {
                throw new Error(`${this.constructor.name} kernel width mismatch ${praxis.width} is not ${this.width}`);
            }
            if (praxis.height !== this.height) {
                throw new Error(`${this.constructor.name} kernel width mismatch ${praxis.height} is not ${this.height}`);
            }
            if (praxis.hasOwnProperty('kernel')) {
                this.kernel = praxis.kernel;
            }
        }
        toJSON() {
            return { ...this.settings };
        }
    }

    function update$2(weights, deltas) {
        return (weights[this.thread.y][this.thread.x] +
            this.constants.learningRate * deltas[this.thread.y][this.thread.x]);
    }
    const defaultSettings$1 = {
        learningRate: 0.3,
    };
    class ArthurDeviationBiases extends BasePraxis {
        constructor(layer, settings) {
            super(layer);
            this.settings = { ...defaultSettings$1, ...settings };
            this.kernel = null;
        }
        run(layer) {
            return this.kernel(layer.weights, layer.deltas);
        }
        setupKernels() {
            var _a;
            this.kernel = makeKernel(update$2, {
                output: [this.width, this.height],
                constants: {
                    learningRate: (_a = this.settings.learningRate) !== null && _a !== void 0 ? _a : 0.01,
                },
            });
        }
    }
    function arthurDeviationBiases(layer, settings) {
        return new ArthurDeviationBiases(layer, settings);
    }

    function updateChange(value) {
        return value;
    }
    function update$1(changes, weights, incomingWeights, inputDeltas) {
        const lastChange = changes[this.thread.y][this.thread.x];
        const inputDelta = inputDeltas[this.thread.y][0];
        const weight = weights[this.thread.y][this.thread.x];
        const incoming = incomingWeights[this.thread.x][0];
        const change = this.constants.learningRate * inputDelta * incoming +
            this.constants.momentum * lastChange;
        return weight + change;
    }
    const defaultSettings = {
        learningRate: 0.3,
        momentum: 0.1,
        weightsLayer: null,
        incomingLayer: null,
        deltaLayer: null,
    };
    class ArthurDeviationWeights extends BasePraxis {
        constructor(layer, settings) {
            super(layer);
            this.kernelMap = null;
            this.settings = { ...defaultSettings, ...settings };
            this.changes = zeros2D(layer.width, layer.height);
        }
        get learningRate() {
            return this.settings.learningRate;
        }
        get momentum() {
            return this.settings.momentum;
        }
        get weightsLayer() {
            return this.settings.weightsLayer;
        }
        set weightsLayer(layer) {
            this.settings.weightsLayer = layer;
        }
        get deltaLayer() {
            return this.settings.deltaLayer;
        }
        set deltaLayer(layer) {
            this.settings.deltaLayer = layer;
        }
        get incomingLayer() {
            return this.settings.incomingLayer;
        }
        set incomingLayer(layer) {
            this.settings.incomingLayer = layer;
        }
        run() {
            const output = this.kernelMap(this.changes, this.weightsLayer.weights, this.incomingLayer.weights, this.deltaLayer.deltas);
            this.changes = output.changes;
            return output.result;
        }
        setupKernels() {
            this.kernelMap = makeKernelMap({
                changes: updateChange,
            }, update$1, {
                output: [this.width, this.height],
                constants: {
                    learningRate: this.learningRate,
                    momentum: this.momentum,
                },
            });
        }
    }
    function arthurDeviationWeights(layer, settings) {
        return new ArthurDeviationWeights(layer, settings);
    }

    function getMomentum(delta, decay, previousMomentum) {
        return previousMomentum * decay + (1 - decay) * delta * delta;
    }
    function clipByValue(value, max, min) {
        if (value > max) {
            return max;
        }
        if (value < min) {
            return min;
        }
        return value;
    }
    /**
     * @description Momentum Root Mean Square Propagation Function
     */
    function update(weights, deltas, previousMomenta) {
        const delta = deltas[this.thread.y][this.thread.x];
        const clippedDelta = clipByValue(delta, this.constants.clipValue, -this.constants.clipValue);
        const weight = weights[this.thread.y][this.thread.x];
        const previousMomentum = previousMomenta[this.thread.y][this.thread.x];
        const momentum = getMomentum(delta, this.constants.decayRate, previousMomentum);
        return (weight +
            (-this.constants.learningRate * clippedDelta) /
                Math.sqrt(momentum + this.constants.smoothEps) -
            this.constants.regularizationStrength * weight);
    }
    const defaults$8 = {
        decayRate: 0.999,
        regularizationStrength: 0.000001,
        learningRate: 0.01,
        smoothEps: 1e-8,
        clipValue: 5,
    };
    class MomentumRootMeanSquaredPropagation extends BasePraxis {
        constructor(layerTemplate, settings = {}) {
            super(layerTemplate);
            this.kernelMap = null;
            this.settings = { ...defaults$8, ...settings };
            this.momenta = zeros2D(layerTemplate.width, layerTemplate.height);
        }
        get clipValue() {
            return this.settings.clipValue;
        }
        get decayRate() {
            return this.settings.decayRate;
        }
        get learningRate() {
            return this.settings.learningRate;
        }
        get regularizationStrength() {
            return this.settings.regularizationStrength;
        }
        get smoothEps() {
            return this.settings.smoothEps;
        }
        run(layer) {
            const { momenta, result } = this.kernelMap(layer.weights, layer.deltas, this.momenta);
            release(this.momenta);
            this.momenta = momenta;
            return result;
        }
        setupKernels() {
            this.kernelMap = makeKernelMap({
                momenta: getMomentum,
            }, update, {
                output: [this.width, this.height],
                constants: {
                    clipValue: this.clipValue,
                    decayRate: this.decayRate,
                    learningRate: this.learningRate,
                    regularizationStrength: this.regularizationStrength,
                    smoothEps: this.smoothEps,
                },
                functions: [clipByValue],
                immutable: true,
            });
        }
    }
    function momentumRootMeanSquaredPropagation(layer, settings) {
        return new MomentumRootMeanSquaredPropagation(layer, settings);
    }
    /**
     * @description Mathematician friendly name of MomentumRootMeanSquaredPropagation class. For those that are not mere mortals
     */
    const MRmsProp = MomentumRootMeanSquaredPropagation;
    const mRmsProp = momentumRootMeanSquaredPropagation;

    var index = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ArthurDeviationBiases: ArthurDeviationBiases,
        arthurDeviationBiases: arthurDeviationBiases,
        ArthurDeviationWeights: ArthurDeviationWeights,
        arthurDeviationWeights: arthurDeviationWeights,
        MomentumRootMeanSquaredPropagation: MomentumRootMeanSquaredPropagation,
        momentumRootMeanSquaredPropagation: momentumRootMeanSquaredPropagation,
        MRmsProp: MRmsProp,
        mRmsProp: mRmsProp
    });

    function traverseLayersFrom(layer, cb) {
        if (layer.hasOwnProperty('inputLayer')) {
            traverseLayersFrom(layer.inputLayer, cb);
        }
        else {
            if (layer.hasOwnProperty('inputLayer1')) {
                traverseLayersFrom(layer.inputLayer1, cb);
            }
            if (layer.hasOwnProperty('inputLayer2')) {
                traverseLayersFrom(layer.inputLayer2, cb);
            }
        }
        cb(layer);
    }

    function flattenLayers(layers) {
        const result = layers.slice(0);
        for (let i = 0; i < result.length; i++) {
            let offset = 0;
            traverseLayersFrom(result[i], (layer) => {
                if (!result.includes(layer)) {
                    result.splice(i + offset, 0, layer);
                    offset++;
                }
            });
        }
        return result;
    }

    function checkSameSize(layer1, layer2) {
        if (layer1.width !== layer2.width) {
            throw new Error(`Layer width mismatch of ${layer1.width} and ${layer2.width}`);
        }
        if (layer1.height !== layer2.height) {
            throw new Error(`Layer height mismatch of ${layer1.height} and ${layer2.height}`);
        }
    }

    function predict$8(inputWeights1, inputWeights2) {
        return (inputWeights1[this.thread.y][this.thread.x] +
            inputWeights2[this.thread.y][this.thread.x]);
    }
    class Add extends Operator {
        get width() {
            return this.inputLayer1.width;
        }
        get height() {
            return this.inputLayer1.height;
        }
        get depth() {
            return this.inputLayer1.depth;
        }
        validate() {
            super.validate();
            checkSameSize(this.inputLayer1, this.inputLayer2);
        }
        setupKernels() {
            this.predictKernel = makeKernel(predict$8, {
                output: [this.width, this.height],
                immutable: true,
            });
        }
        predict() {
            release(this.weights);
            this.weights = this.predictKernel(this.inputLayer1.weights, this.inputLayer2.weights);
        }
        compare() {
            // TODO: Do we need release and clone here?
            release(this.inputLayer1.deltas);
            release(this.inputLayer2.deltas);
            this.inputLayer1.deltas = clone(this.deltas);
            this.inputLayer2.deltas = clone(this.deltas);
        }
    }
    function add$1(inputLayer1, inputLayer2, settings) {
        return new Add(inputLayer1, inputLayer2, settings);
    }

    function randomWeight() {
        return Math.random() * 0.4 - 0.2;
    }

    /**
     * Returns a random float between given min and max bounds (inclusive)
     * @param min Minimum value of the ranfom float
     * @param max Maximum value of the random float
     */
    function randomFloat(min, max) {
        return Math.random() * (max - min) + min;
    }
    /**
     * Complicated math. All you need to know is that it returns a random number.
     * More info: https://en.wikipedia.org/wiki/Normal_distribution
     */
    function gaussRandom() {
        if (gaussRandom.returnV) {
            gaussRandom.returnV = false;
            return gaussRandom.vVal;
        }
        const u = 2 * Math.random() - 1;
        const v = 2 * Math.random() - 1;
        const r = u * u + v * v;
        if (r === 0 || r > 1) {
            return gaussRandom();
        }
        const c = Math.sqrt((-2 * Math.log(r)) / r);
        gaussRandom.vVal = v * c; // cache this
        gaussRandom.returnV = true;
        return u * c;
    }
    /**
     * Returns a random integer between given min and max bounds
     * @param min Minimum value of the random integer
     * @param max Maximum value of the random integer
     */
    function randomInteger(min, max) {
        return Math.floor(Math.random() * (max - min) + min);
    }
    /**
     * If you know what this is: https://en.wikipedia.org/wiki/Normal_distribution
     * @param mu
     * @param std
     */
    function randomN(mu, std) {
        return mu + gaussRandom() * std;
    }
    gaussRandom.returnV = false;
    gaussRandom.vVal = 0;

    var random$1 = /*#__PURE__*/Object.freeze({
        __proto__: null,
        randomFloat: randomFloat,
        gaussRandom: gaussRandom,
        randomInteger: randomInteger,
        randomN: randomN
    });

    /**
     * Returns an array of given size, full of randomness
     */
    function randos(size, std = null) {
        const array = new Float32Array(size);
        if (std === null) {
            for (let i = 0; i < size; i++) {
                array[i] = randomWeight();
            }
        }
        else {
            for (let i = 0; i < size; i++) {
                array[i] = randomFloat(-std, std);
            }
        }
        return array;
    }
    /**
     * Returns a 2D matrix of given size, full of randomness
     */
    function randos2D(width, height, std) {
        const result = new Array(height);
        for (let y = 0; y < height; y++) {
            result[y] = randos(width, std);
        }
        return result;
    }
    /**
     * Returns a 3D tensor of given size, full of randomness
     */
    function randos3D(width, height, depth, std) {
        const result = new Array(depth);
        for (let z = 0; z < depth; z++) {
            result[z] = randos2D(width, height, std);
        }
        return result;
    }

    const defaults$7 = {
        ...baseLayerDefaultSettings,
        std: null,
    };
    class Random extends Model {
        constructor(settings) {
            super();
            this.settings = { ...defaults$7, ...settings };
            this.setupPraxis();
            this.validate();
            if (!this.weights) {
                this.weights = randos2D(this.width, this.height, settings.std);
            }
            if (!this.deltas) {
                this.deltas = zeros2D(this.width, this.height);
            }
        }
        predict() { }
        compare() { }
    }
    function random(settings) {
        return new Random(settings);
    }

    function predict$7(weights1, weights2) {
        let sum = 0;
        for (let i = 0; i < this.constants.size; i++) {
            sum += weights1[this.thread.y][i] * weights2[i][this.thread.x];
        }
        return sum;
    }
    function compareFromX(deltas, inputDeltas, inputWeights) {
        let sum = inputDeltas[this.thread.y][this.thread.x];
        for (let i = 0; i < this.constants.size; i++) {
            sum += deltas[this.thread.y][i] * inputWeights[this.thread.x][i];
        }
        return sum;
    }
    function compareFromY(deltas, inputDeltas, inputWeights) {
        let sum = inputDeltas[this.thread.y][this.thread.x];
        for (let i = 0; i < this.constants.size; i++) {
            sum += deltas[i][this.thread.x] * inputWeights[i][this.thread.y];
        }
        return sum;
    }
    class Multiply extends Operator {
        constructor() {
            super(...arguments);
            this.compareKernel1 = null;
            this.compareKernel2 = null;
        }
        get width() {
            return this.inputLayer2.width;
        }
        set width(width) {
            throw new Error('Cannot set width on Multiply');
        }
        get height() {
            return this.inputLayer1.height;
        }
        set height(height) {
            throw new Error('Cannot set height on Multiply');
        }
        get depth() {
            return this.inputLayer1.depth;
        }
        set depth(depth) {
            throw new Error('Cannot set depth on Multiply');
        }
        validate() {
            super.validate();
            if (this.inputLayer1.width !== this.inputLayer2.height) {
                throw new Error(`Layer width mismatch of ${this.inputLayer1.width} and ${this.inputLayer2.height}`);
            }
        }
        setupKernels() {
            this.predictKernel = makeKernel(predict$7, {
                output: [this.width, this.height],
                constants: {
                    size: this.inputLayer2.height,
                },
                immutable: true,
            });
            this.compareKernel1 = makeKernel(compareFromX, {
                output: [this.inputLayer1.width, this.inputLayer1.height],
                constants: {
                    size: this.inputLayer2.width,
                },
                immutable: true,
            });
            this.compareKernel2 = makeKernel(compareFromY, {
                output: [this.inputLayer2.width, this.inputLayer2.height],
                constants: {
                    size: this.inputLayer1.height,
                },
                immutable: true,
            });
        }
        reuseKernels(layer) {
            super.reuseKernels(layer);
            this.compareKernel1 = layer.compareKernel1;
            this.compareKernel2 = layer.compareKernel2;
        }
        predict() {
            release(this.weights);
            if (!this.predictKernel)
                throw new Error('this.predictKernel is not set');
            this.weights = this.predictKernel(this.inputLayer1.weights, this.inputLayer2.weights);
        }
        compare() {
            if (!this.compareKernel1)
                throw new Error('this.compareKernel1 not set');
            if (!this.compareKernel2)
                throw new Error('this.compareKernel2 not set');
            const inputLayer1Deltas = this.inputLayer1.deltas;
            const inputLayer2Deltas = this.inputLayer2.deltas;
            const newDeltas1 = this.compareKernel1(this.deltas, this.inputLayer1.deltas, this.inputLayer2.weights);
            const newDeltas2 = this.compareKernel2(this.deltas, this.inputLayer2.deltas, this.inputLayer1.weights);
            this.inputLayer2.deltas = newDeltas2;
            this.inputLayer1.deltas = newDeltas1;
            release(inputLayer1Deltas);
            release(inputLayer2Deltas);
        }
        setupPraxis() { }
        toJSON() {
            return {
                ...super.toJSON(),
                width: this.width,
                height: this.height,
            };
        }
    }
    function multiply$1(inputLayer1, inputLayer2, settings) {
        return new Multiply(inputLayer1, inputLayer2, settings);
    }

    function predict2D$4(inputs) {
        return 1 / (1 + Math.exp(-inputs[this.thread.y][this.thread.x]));
    }
    function predict3D$5(inputs) {
        return (1 / (1 + Math.exp(-inputs[this.thread.z][this.thread.y][this.thread.x])));
    }
    function compare2D$4(weights, deltas) {
        const weight = weights[this.thread.y][this.thread.x];
        const delta = deltas[this.thread.y][this.thread.x];
        return weight * (1 - weight) * delta;
    }
    function compare3D$4(weights, deltas) {
        const weight = weights[this.thread.z][this.thread.y][this.thread.x];
        const delta = deltas[this.thread.z][this.thread.y][this.thread.x];
        return weight * (1 - weight) * delta;
    }
    class Sigmoid extends Activation {
        setupKernels() {
            if (this.depth > 0) {
                this.predictKernel = makeKernel(predict3D$5, {
                    output: [this.width, this.height, this.depth],
                    functions: [activate$2],
                    immutable: true,
                });
                this.compareKernel = makeKernel(compare3D$4, {
                    output: [this.width, this.height, this.depth],
                    functions: [measure$2],
                    immutable: true,
                });
            }
            else {
                this.predictKernel = makeKernel(predict2D$4, {
                    output: [this.width, this.height],
                    functions: [activate$2],
                    immutable: true,
                });
                this.compareKernel = makeKernel(compare2D$4, {
                    output: [this.width, this.height],
                    functions: [measure$2],
                    immutable: true,
                });
            }
        }
        predict() {
            release(this.weights);
            this.weights = this.predictKernel(this.inputLayer.weights);
        }
        compare() {
            release(this.inputLayer.deltas);
            this.inputLayer.deltas = this.compareKernel(this.weights, this.deltas);
        }
        learn(learningRate) { }
    }
    function sigmoid$1(inputLayer, settings) {
        return new Sigmoid(inputLayer, settings);
    }

    function arthurFeedForward(settings, inputLayer) {
        const { height } = settings;
        function initWeightsPraxis(layerTemplate, settings) {
            const praxis = arthurDeviationWeights(layerTemplate, settings);
            praxis.setupKernels();
            return praxis;
        }
        function initBiasesPraxis(layerTemplate, settings) {
            const praxis = arthurDeviationBiases(layerTemplate, settings);
            praxis.setupKernels();
            return praxis;
        }
        const weightsLayer = random({
            id: 'weights',
            height,
            width: inputLayer.height,
            initPraxis: initWeightsPraxis,
        });
        const biasesLayer = random({
            id: 'biases',
            height,
            initPraxis: initBiasesPraxis,
        });
        const multiplyLayer = multiply$1(weightsLayer, inputLayer);
        const addLayer = add$1(multiplyLayer, biasesLayer);
        const sigmoidLayer = sigmoid$1(addLayer);
        const weightsPraxis = weightsLayer.praxis;
        weightsPraxis.weightsLayer = weightsLayer;
        weightsPraxis.incomingLayer = inputLayer;
        weightsPraxis.deltaLayer = sigmoidLayer;
        return sigmoidLayer;
    }

    function getStride(settings, defaults) {
        if (typeof settings.stride === 'number') {
            return { strideX: settings.stride, strideY: settings.stride };
        }
        else {
            let strideX = defaults.stride;
            let strideY = defaults.stride;
            if (typeof settings.strideX === 'number') {
                strideX = settings.strideX;
            }
            if (typeof settings.strideY === 'number') {
                strideY = settings.strideY;
            }
            return { strideX, strideY };
        }
    }
    function getPadding(settings, defaults) {
        if (typeof settings.padding === 'number') {
            return { paddingX: settings.padding, paddingY: settings.padding };
        }
        else {
            let paddingX = defaults.padding;
            let paddingY = defaults.padding;
            if (typeof settings.paddingX === 'number') {
                paddingX = settings.paddingX;
            }
            if (typeof settings.paddingY === 'number') {
                paddingY = settings.paddingY;
            }
            return { paddingX, paddingY };
        }
    }

    /**
     * Returns an array of a given size with each element filled with a single value
     */
    function values(size, value) {
        return new Float32Array(size).fill(value);
    }

    function predict$6(inputs, filters, biases) {
        const startFilterX = this.constants.paddingX - this.thread.x * this.constants.strideX;
        const startInputX = this.thread.x * this.constants.strideX - this.constants.paddingX;
        const endFilterX = Math.min(this.constants.filterWidth, startFilterX + this.constants.inputWidth);
        const startFilterY = this.constants.paddingY - this.thread.y * this.constants.strideY;
        const startInputY = this.thread.y * this.constants.strideY - this.constants.paddingY;
        const endFilterY = Math.min(this.constants.filterHeight, startFilterY + this.constants.inputHeight);
        let sum = 0;
        for (let z = 0; z < this.constants.inputDepth; z++) {
            for (let filterY = Math.max(0, startFilterY), inputY = Math.max(0, startInputY); filterY < endFilterY; filterY++, inputY++) {
                for (let filterX = Math.max(0, startFilterX), inputX = Math.max(0, startInputX); filterX < endFilterX; filterX++, inputX++) {
                    sum += filters[z][filterY][filterX] * inputs[z][inputY][inputX];
                }
            }
        }
        return sum + biases[this.thread.z];
    }
    function compareFilterDeltas$1(filterDeltas, inputs, deltas) {
        const startDeltaX = Math.max(0, Math.ceil((this.constants.paddingX - this.thread.x) / this.constants.strideX));
        const startInputX = startDeltaX * this.constants.strideX +
            this.thread.x -
            this.constants.paddingX;
        const endDeltaX = Math.min(this.constants.deltaWidth, Math.floor((this.constants.inputWidth -
            1 -
            this.thread.x +
            this.constants.paddingX) /
            this.constants.strideX) + 1);
        const startDeltaY = Math.max(0, Math.ceil((this.constants.paddingY - this.thread.y) / this.constants.strideY));
        const startInputY = startDeltaY * this.constants.strideY +
            this.thread.y -
            this.constants.paddingY;
        const endDeltaY = Math.min(this.constants.deltaHeight, Math.floor((this.constants.inputHeight -
            1 -
            this.thread.y +
            this.constants.paddingY) /
            this.constants.strideY) + 1);
        let sum = filterDeltas[this.thread.z][this.thread.y][this.thread.x];
        for (let deltaY = startDeltaY, inputY = startInputY; deltaY < endDeltaY; deltaY++, inputY += this.constants.strideY) {
            for (let deltaX = startDeltaX, inputX = startInputX; deltaX < endDeltaX; deltaX++, inputX += this.constants.strideX) {
                sum +=
                    inputs[this.thread.z][inputY][inputX] *
                        deltas[this.constants.deltaZ][deltaY][deltaX];
            }
        }
        return sum;
    }
    function compareInputDeltas$1(inputDeltas, filters, deltas) {
        const x = this.thread.x + this.constants.paddingX;
        const startDeltaX = x < this.constants.filterWidth
            ? 0
            : Math.floor((x - this.constants.filterWidth + this.constants.strideX) /
                this.constants.strideX);
        const startFilterX = x - startDeltaX * this.constants.strideX;
        const endDeltaX = Math.min(startDeltaX + Math.floor(startFilterX / this.constants.strideX) + 1, this.constants.deltaWidth);
        const y = this.thread.y + this.constants.paddingY;
        const startDeltaY = y < this.constants.filterHeight
            ? 0
            : Math.floor((y - this.constants.filterHeight + this.constants.strideY) /
                this.constants.strideY);
        const startFilterY = y - startDeltaY * this.constants.strideY;
        const endDeltaY = Math.min(startDeltaY + Math.floor(startFilterY / this.constants.strideY) + 1, this.constants.deltaHeight);
        let sum = inputDeltas[this.thread.z][this.thread.y][this.thread.x];
        let deltaY = startDeltaY;
        for (let filterY = startFilterY; deltaY < endDeltaY; filterY -= this.constants.strideY, deltaY++) {
            let deltaX = startDeltaX;
            for (let filterX = startFilterX; deltaX < endDeltaX; filterX -= this.constants.strideX, deltaX++) {
                sum +=
                    filters[this.thread.z][filterY][filterX] *
                        deltas[this.constants.deltaZ][deltaY][deltaX];
            }
        }
        return sum;
    }
    function compareBiases$1(biasDeltas, deltas) {
        let sum = 0;
        for (let y = 0; y < this.constants.deltaHeight; y++) {
            for (let x = 0; x < this.constants.deltaWidth; x++) {
                sum += deltas[this.thread.z][y][x];
            }
        }
        return biasDeltas[this.thread.z][this.thread.y][this.thread.x] + sum;
    }
    const defaults$6 = {
        stride: 0,
        padding: 0,
        bias: 0.1,
        filterCount: 1,
        filterWidth: 0,
        filterHeight: 0,
    };
    class Convolution extends Filter {
        constructor(settings, inputLayer) {
            var _a, _b, _c;
            super(settings, inputLayer);
            this.compareFilterDeltasKernel = null;
            this.compareInputDeltasKernel = null;
            this.compareBiasesKernel = null;
            this.settings = {
                ...defaults$6,
                ...settings,
                ...getPadding(settings, defaults$6),
                ...getStride(settings, defaults$6),
            };
            this.weights = (_a = settings.weights) !== null && _a !== void 0 ? _a : randos3D(this.width, this.height, this.depth);
            this.deltas = zeros3D(this.width, this.height, this.depth);
            this.biases = values(this.depth, this.bias);
            this.biasDeltas = (_b = settings.biasDeltas) !== null && _b !== void 0 ? _b : randos(this.depth);
            this.filters = (_c = settings.filters) !== null && _c !== void 0 ? _c : randos3D(this.filterWidth, this.filterHeight, this.filterCount);
            this.filterDeltas = zeros3D(this.filterWidth, this.filterHeight, this.filterCount);
            this.validate();
        }
        get strideX() {
            return this.settings.strideX;
        }
        get strideY() {
            return this.settings.strideY;
        }
        get paddingX() {
            return this.settings.paddingX;
        }
        get paddingY() {
            return this.settings.paddingX;
        }
        get width() {
            return Math.floor((this.inputLayer.width + this.paddingX * 2 - this.filterWidth) /
                this.strideX +
                1);
        }
        get height() {
            return Math.floor((this.inputLayer.height + this.paddingY * 2 - this.filterHeight) /
                this.strideY +
                1);
        }
        get bias() {
            return this.settings.bias;
        }
        get depth() {
            return this.filterCount;
        }
        get biases() {
            return this.settings.biases;
        }
        set biases(biases) {
            this.settings.biases = biases;
        }
        get biasDeltas() {
            return this.settings.biasDeltas;
        }
        set biasDeltas(weights) {
            this.settings.biasDeltas = weights;
        }
        get filters() {
            return this.settings.filters;
        }
        set filters(filters) {
            this.settings.filters = filters;
        }
        get filterDeltas() {
            return this.settings.filterDeltas;
        }
        set filterDeltas(filterDeltas) {
            this.settings.filterDeltas = filterDeltas;
        }
        setupKernels() {
            this.predictKernel = makeKernel(predict$6, {
                constants: {
                    inputWidth: this.inputLayer.width,
                    inputHeight: this.inputLayer.height,
                    inputDepth: this.inputLayer.depth,
                    strideX: this.strideX,
                    strideY: this.strideY,
                    paddingX: this.paddingX,
                    paddingY: this.paddingY,
                    filterWidth: this.filterWidth,
                    filterHeight: this.filterHeight,
                },
                output: [this.width, this.height, this.depth],
                immutable: true,
            });
            this.compareFilterDeltasKernel = makeKernel(compareFilterDeltas$1, {
                constants: {
                    deltaWidth: this.width,
                    deltaHeight: this.height,
                    deltaZ: this.depth,
                    inputWidth: this.inputLayer.width,
                    inputHeight: this.inputLayer.height,
                    inputDepth: this.inputLayer.depth,
                    strideX: this.strideX,
                    strideY: this.strideY,
                    paddingX: this.paddingX,
                    paddingY: this.paddingY,
                    filterWidth: this.filterWidth,
                    filterHeight: this.filterHeight,
                },
                output: [this.width, this.height, this.depth],
                immutable: true,
            });
            this.compareInputDeltasKernel = makeKernel(compareInputDeltas$1, {
                constants: {
                    deltaWidth: this.width,
                    deltaHeight: this.height,
                    deltaZ: this.depth,
                    strideX: this.strideX,
                    strideY: this.strideY,
                    paddingX: this.paddingX,
                    paddingY: this.paddingY,
                    filterWidth: this.filterWidth,
                    filterHeight: this.filterHeight,
                    filterCount: this.filterCount,
                },
                output: [
                    this.inputLayer.width,
                    this.inputLayer.height,
                    this.inputLayer.depth,
                ],
                immutable: true,
            });
            this.compareBiasesKernel = makeKernel(compareBiases$1, {
                output: [1, 1, this.depth],
                constants: {
                    deltaWidth: this.width,
                    deltaHeight: this.height,
                },
                immutable: true,
            });
        }
        predict() {
            this.weights = this.predictKernel(this.inputLayer.weights, this.filters, this.biases);
        }
        compare() {
            const { filterDeltas, biasDeltas } = this;
            this.filterDeltas = this.compareFilterDeltasKernel(filterDeltas, this.inputLayer.weights, this.deltas);
            release(filterDeltas);
            this.biasDeltas = this.compareBiasesKernel(biasDeltas, this.deltas);
            release(biasDeltas);
            release(this.deltas);
            this.deltas = this.compareInputDeltasKernel(this.filters, this.inputLayer.deltas);
            release(this.inputLayer.deltas);
            // TODO: do we need to clone here?
            this.inputLayer.deltas = clone(this.deltas);
        }
        learn(learningRate) {
            // TODO: handle filters
            // TODO: do we need to release here?
            const { weights: oldWeights } = this;
            this.weights = this.praxis.run(this, learningRate);
            release(oldWeights);
        }
    }
    function convolution(settings, inputLayer) {
        return new Convolution(settings, inputLayer);
    }

    function setDropout(dropout) {
        return dropout;
    }
    function trainingPredict(inputs) {
        if (setDropout(Math.random()) < this.constants.probability) {
            return 0;
        }
        return inputs[this.thread.y][this.thread.x];
    }
    function predict$5(inputs) {
        return inputs[this.thread.y][this.thread.x] * this.constants.probability;
    }
    function compare$3(dropouts, deltas) {
        if (dropouts[this.thread.y][this.thread.x] === 0) {
            return 0;
        }
        return deltas[this.thread.y][this.thread.x];
    }
    const dropoutDefaults = {
        ...baseLayerDefaultSettings,
        probability: 0.5,
    };
    class Dropout extends Filter {
        constructor(inputLayer, settings) {
            super(settings, inputLayer);
            this.predictKernelMap = null;
            this.settings = { ...dropoutDefaults, ...settings };
            this.dropouts = null;
            this.validate();
        }
        setupKernels(isTraining) {
            const output = [this.width, this.height];
            if (isTraining) {
                this.predictKernelMap = makeKernelMap({ dropouts: setDropout }, trainingPredict, {
                    output,
                    immutable: true,
                });
                this.compareKernel = makeKernel(compare$3, { output, immutable: true });
            }
            else {
                this.predictKernelMap = makeKernelMap({}, predict$5, { output, immutable: true });
            }
        }
        predict() {
            release(this.weights);
            if (this.dropouts) {
                release(this.dropouts);
            }
            const { result, dropouts } = this
                .predictKernelMap(this.inputLayer.weights);
            this.weights = result;
            this.dropouts = dropouts;
        }
        compare() {
            release(this.deltas);
            this.deltas = this.compareKernel(this.dropouts, this.inputLayer.deltas);
        }
    }
    function dropout(inputLayer, settings) {
        return new Dropout(inputLayer, settings);
    }

    function feedForward(settings, input) {
        const { height, praxisOpts = null } = settings;
        const weights = random({
            id: 'weights',
            height,
            width: input.height,
            praxisOpts,
        });
        const biases = random({ id: 'biases', height, praxisOpts });
        return sigmoid$1(add$1(multiply$1(weights, input, { praxisOpts }), biases, { praxisOpts }), { praxisOpts });
    }

    function predict$4(inputs, filters, biases) {
        let output = 0;
        let i = 0;
        for (let y = 0; y < this.constants.inputHeight; y++) {
            for (let x = 0; x < this.constants.inputWidth; x++) {
                output += inputs[y][x] * filters[this.thread.x][i];
                i++;
            }
        }
        return output + biases[this.thread.x];
    }
    function predict3D$4(inputs, filters, biases) {
        let output = 0;
        let i = 0;
        for (let z = 0; z < this.constants.inputDepth; z++) {
            for (let y = 0; y < this.constants.inputHeight; y++) {
                for (let x = 0; x < this.constants.inputWidth; x++) {
                    output += inputs[z][y][x] * filters[this.thread.x][i];
                    i++;
                }
            }
        }
        return output + biases[this.thread.x];
    }
    function compareInputDeltas(inputDeltas, deltas, filters) {
        let sum = 0;
        const filterX = this.thread.x + this.thread.y * this.output.x;
        for (let filterY = 0; filterY < this.constants.filterCount; filterY++) {
            sum += filters[filterY][filterX] * deltas[0][filterY];
        }
        return sum + inputDeltas[this.thread.y][this.thread.x];
    }
    function compareInputDeltas3D(inputDeltas, deltas, filters) {
        let sum = 0;
        const filterX = this.thread.x + this.thread.y * this.output.x;
        for (let filterY = 0; filterY < this.constants.filterCount; filterY++) {
            sum += filters[filterY][filterX] * deltas[0][filterY];
        }
        return sum + inputDeltas[this.thread.z][this.thread.y][this.thread.x];
    }
    function compareBiases(biases, deltas) {
        return biases[this.thread.x] + deltas[this.thread.y][this.thread.x];
    }
    function compareFilterDeltas(filterDeltas, inputWeights, deltas) {
        return (filterDeltas[this.thread.y][this.thread.x] +
            inputWeights[this.thread.y][this.thread.x] *
                deltas[this.constants.deltaY][this.constants.deltaX]);
    }
    function compareFilterDeltas3D(filterDeltas, inputWeights, deltas) {
        const inputZ = Math.floor(this.thread.x / (this.constants.inputWidth * this.constants.inputHeight));
        const inputY = Math.floor((this.thread.x -
            inputZ * this.constants.inputWidth * this.constants.inputHeight) /
            this.constants.inputWidth);
        const inputX = this.thread.x -
            this.constants.inputWidth * (inputY + this.constants.inputHeight * inputZ);
        return (filterDeltas[this.thread.y][this.thread.x] +
            inputWeights[inputZ][inputY][inputX] * deltas[0][this.thread.y]);
    }
    class FullyConnected extends Filter {
        constructor(settings, inputLayer) {
            super(settings, inputLayer);
            this.compareFilterDeltasKernel = null;
            this.compareInputDeltasKernel = null;
            this.compareBiasesKernel = null;
            this.settings = { ...settings };
            this.validate();
            const connectionCount = inputLayer.width * inputLayer.height * inputLayer.depth;
            this.biases = values(this.height, this.bias);
            this.biasDeltas = zeros$1(this.height);
            this.filters = randos2D(connectionCount, this.height);
            this.filterDeltas = zeros2D(connectionCount, this.height);
            if (this.depth > 0) {
                this.weights = randos3D(this.width, this.height, this.depth);
                this.deltas = zeros3D(this.width, this.height, this.depth);
            }
            else if (this.height > 0) {
                this.weights = randos2D(this.width, this.height);
                this.deltas = zeros2D(this.width, this.height);
            }
        }
        get bias() {
            return this.settings.bias;
        }
        get biases() {
            return this.settings.biases;
        }
        set biases(biases) {
            this.settings.biases = biases;
        }
        get biasDeltas() {
            return this.settings.biases;
        }
        set biasDeltas(biasDeltas) {
            this.settings.biasDeltas = biasDeltas;
        }
        validate() {
            super.validate();
            if (this.depth > 0)
                throw new Error('depth not supported');
        }
        setupKernels() {
            const { inputLayer } = this;
            const connectionCount = inputLayer.width * inputLayer.height * inputLayer.depth;
            if (inputLayer.depth > 0) {
                this.predictKernel = makeKernel(predict3D$4, {
                    output: [this.width, this.height],
                    constants: {
                        inputHeight: inputLayer.height,
                        inputWidth: inputLayer.width,
                        inputDepth: inputLayer.depth,
                    },
                });
                this.compareFilterDeltasKernel = makeKernel(compareFilterDeltas3D, {
                    output: [connectionCount, this.height],
                    constants: {
                        deltaX: 0,
                        deltaY: 0,
                        inputWidth: inputLayer.width,
                        inputHeight: inputLayer.height,
                    },
                    immutable: true,
                });
                this.compareInputDeltasKernel = makeKernel(compareInputDeltas3D, {
                    output: [inputLayer.width, inputLayer.height, inputLayer.depth],
                    constants: {
                        filterCount: this.height,
                    },
                    immutable: true,
                });
            }
            else {
                this.predictKernel = makeKernel(predict$4, {
                    output: [this.width, this.height],
                    constants: {
                        inputHeight: inputLayer.height,
                        inputWidth: inputLayer.width,
                    },
                });
                this.compareFilterDeltasKernel = makeKernel(compareFilterDeltas, {
                    output: [connectionCount, this.height],
                    constants: {
                        deltaX: 0,
                        deltaY: 0,
                        inputWidth: inputLayer.width,
                        inputHeight: inputLayer.height,
                    },
                });
                this.compareInputDeltasKernel = makeKernel(compareInputDeltas, {
                    output: [inputLayer.width, inputLayer.height],
                    constants: {
                        filterCount: this.height,
                    },
                });
            }
            this.compareBiasesKernel = makeKernel(compareBiases, {
                output: [this.width, this.height],
            });
        }
        predict() {
            this.weights = this.predictKernel(this.inputLayer.weights, this.filters, this.biases);
        }
        compare() {
            const inputLayerDeltas = this.inputLayer.deltas;
            this.inputLayer.deltas = this
                .compareInputDeltasKernel(inputLayerDeltas, this.deltas, this.filters);
            release(inputLayerDeltas);
            const { biasDeltas, filterDeltas } = this;
            // TODO: handle biasDeltas learn
            this.biasDeltas = this.compareBiasesKernel(this.biases, this.deltas);
            // TODO: handle filterDeltas learn
            this.filterDeltas = this.compareFilterDeltasKernel(filterDeltas, this.inputLayer.weights, this.deltas);
            release(biasDeltas);
            release(filterDeltas);
        }
    }
    function fullyConnected(settings, inputLayer) {
        return new FullyConnected(settings, inputLayer);
    }

    function predict$3(weights) {
        return -weights[this.thread.y][this.thread.x];
    }
    class Negative extends Modifier {
        constructor(inputLayer, settings) {
            super(inputLayer, settings);
            this.validate();
        }
        setupKernels() {
            this.predictKernel = makeKernel(predict$3, {
                output: [this.width, this.height],
            });
        }
        predict() {
            this.weights = this.predictKernel(this.inputLayer.weights);
        }
    }
    function negative(inputLayer, settings) {
        return new Negative(inputLayer, settings);
    }

    function predict$2(inputLayerWeights1, inputLayerWeights2) {
        return (inputLayerWeights1[this.thread.y][this.thread.x] *
            inputLayerWeights2[this.thread.y][this.thread.x]);
    }
    function compare$2(weights, deltas) {
        return (weights[this.thread.y][this.thread.x] * deltas[this.thread.y][this.thread.x]);
    }
    class MultiplyElement extends Operator {
        get width() {
            return this.inputLayer1.width;
        }
        get height() {
            return this.inputLayer1.height;
        }
        get depth() {
            return this.inputLayer1.depth;
        }
        validate() {
            super.validate();
            checkSameSize(this.inputLayer1, this.inputLayer2);
        }
        setupKernels() {
            this.predictKernel = makeKernel(predict$2, {
                output: [this.width, this.height],
                immutable: true,
            });
            this.compareKernel = makeKernel(compare$2, {
                output: [this.width, this.height],
                immutable: true,
            });
        }
        predict() {
            release(this.weights);
            this.weights = this.predictKernel(this.inputLayer1.weights, this.inputLayer2.weights);
        }
        compare() {
            release(this.inputLayer1.deltas);
            release(this.inputLayer2.deltas);
            this.inputLayer1.deltas = this.compareKernel(this.inputLayer2.weights, this.deltas);
            this.inputLayer2.deltas = this.compareKernel(this.inputLayer1.weights, this.deltas);
        }
    }
    function multiplyElement$1(inputLayer1, inputLayer2, settings) {
        return new MultiplyElement(inputLayer1, inputLayer2, settings);
    }

    function ones$1(size) {
        return new Float32Array(size).fill(1);
    }
    function ones2D(width, height) {
        const result = new Array(height);
        for (let y = 0; y < height; y++) {
            result[y] = ones$1(width);
        }
        return result;
    }

    class Ones extends Model {
        constructor(settings) {
            super(settings);
            this.validate();
            this.weights = ones2D(this.width, this.height);
            this.deltas = zeros2D(this.width, this.height);
        }
    }
    function ones(settings) {
        return new Ones(settings);
    }

    function predict2D$3(inputs) {
        return activate$1(inputs[this.thread.y][this.thread.x]);
    }
    function predict3D$3(inputs) {
        return activate$1(inputs[this.thread.z][this.thread.y][this.thread.x]);
    }
    function compare2D$3(weights, errors) {
        return measure$1(weights[this.thread.y][this.thread.x], errors[this.thread.y][this.thread.x]);
    }
    function compare3D$3(weights, errors) {
        return measure$1(weights[this.thread.z][this.thread.y][this.thread.x], errors[this.thread.z][this.thread.y][this.thread.x]);
    }
    class Tanh extends Activation {
        setupKernels() {
            if (this.depth > 0) {
                this.predictKernel = makeKernel(predict3D$3, {
                    output: [this.width, this.height, this.depth],
                    functions: [activate$1],
                    immutable: true,
                });
                this.compareKernel = makeKernel(compare3D$3, {
                    output: [this.width, this.height, this.depth],
                    functions: [measure$1],
                    immutable: true,
                });
            }
            else {
                this.predictKernel = makeKernel(predict2D$3, {
                    output: [this.width, this.height],
                    functions: [activate$1],
                    immutable: true,
                });
                this.compareKernel = makeKernel(compare2D$3, {
                    output: [this.width, this.height],
                    functions: [measure$1],
                    immutable: true,
                });
            }
        }
        predict() {
            release(this.weights);
            this.weights = this.predictKernel(this.inputLayer.weights);
        }
        compare() {
            release(this.inputLayer.deltas);
            this.inputLayer.deltas = this.compareKernel(this.weights, this.deltas);
        }
    }
    function tanh$1(inputLayer, settings) {
        return new Tanh(inputLayer, settings);
    }

    class Zeros extends Model {
        constructor(settings) {
            super(settings);
            this.validate();
            this.weights = zeros2D(this.width, this.height);
            this.deltas = zeros2D(this.width, this.height);
        }
        predict() {
            // throw new Error(`${this.constructor.name}-predict is not yet implemented`)
        }
        compare() {
            // throw new Error(`${this.constructor.name}-compare is not yet implemented`)
        }
    }
    function zeros(settings) {
        return new Zeros(settings);
    }

    function gru(settings, recurrentInput, input) {
        const { height } = settings;
        const updateGateWeights = random({ height, width: input.height });
        const updateGatePeepholes = random({ width: height, height });
        const updateGateBias = zeros({ height });
        const updateGate = sigmoid$1(add$1(add$1(multiply$1(updateGateWeights, input), multiply$1(updateGatePeepholes, recurrentInput)), updateGateBias));
        const resetGateWeights = random({ height, width: input.height });
        const resetGatePeepholes = random({ width: height, height });
        const resetGateBias = zeros({ height });
        const resetGate = sigmoid$1(add$1(add$1(multiply$1(resetGateWeights, input), multiply$1(resetGatePeepholes, recurrentInput)), resetGateBias));
        const cellWeights = random({ height, width: input.height });
        const cellPeepholes = random({ width: height, height });
        const cellBias = zeros({ height });
        const cell = tanh$1(add$1(add$1(multiply$1(cellWeights, input), multiply$1(cellPeepholes, multiplyElement$1(resetGate, recurrentInput))), cellBias));
        // compute hidden state as gated, saturated cell activations
        // negate updateGate
        return add$1(multiplyElement$1(add$1(ones({ width: updateGate.width, height: updateGate.height }), negative(updateGate)), cell), multiplyElement$1(recurrentInput, updateGate));
    }

    const defaults$5 = {
        weights: null,
    };
    class Input extends EntryPoint {
        constructor(settings) {
            super({ ...defaults$5, ...settings });
            this.reshapeInput = null;
            this.validate();
            this.reshapeInput = null;
            this.deltas = zeros2D(this.width, this.height);
        }
        setupKernels() {
            if (this.width === 1) {
                this.predict = this.predict1D;
                this.reshapeInput = makeKernel(function (value) {
                    return value[this.thread.y];
                }, {
                    output: [1, this.height],
                    immutable: true,
                });
            }
        }
        reuseKernels(layer) {
            // super.reuseKernels(layer);
            this.reshapeInput = layer.reshapeInput;
        }
        predict(inputs) {
            if ((Array.isArray(inputs) || inputs instanceof Float32Array) &&
                typeof inputs[0] === 'number' &&
                inputs.length === this.height * this.width) {
                release(this.weights);
                this.weights = kernelInput(inputs, [this.width, this.height]);
            }
            else if (Array.isArray(inputs) &&
                inputs.length === this.height &&
                (Array.isArray(inputs[0]) || inputs[0] instanceof Float32Array) &&
                inputs[0].length === this.width) {
                this.weights = clone(inputs);
            }
            else {
                throw new Error('Inputs are not of sized correctly');
            }
        }
        predict1D(inputs) {
            if (this.weights)
                release(this.weights);
            if (this.reshapeInput) {
                this.weights = this.reshapeInput(inputs);
            }
            else {
                this.weights = inputs;
            }
        }
        compare() {
            // throw new Error(`${this.constructor.name}-compare is not yet implemented`)
        }
        learn() { }
    }
    function input(settings) {
        return new Input(settings);
    }

    function predict2D$2(inputs) {
        return activate(inputs[this.thread.y][this.thread.x]);
    }
    function predict3D$2(inputs) {
        return activate(inputs[this.thread.z][this.thread.y][this.thread.x]);
    }
    function compare2D$2(weights, deltas) {
        return measure(weights[this.thread.y][this.thread.x], deltas[this.thread.y][this.thread.x]);
    }
    function compare3D$2(weights, deltas) {
        return measure(weights[this.thread.z][this.thread.y][this.thread.x], deltas[this.thread.z][this.thread.y][this.thread.x]);
    }
    class LeakyRelu extends Activation {
        setupKernels() {
            const { width, height, depth } = this.inputLayer;
            if (this.depth > 0) {
                this.predictKernel = makeKernel(predict3D$2, {
                    output: [width, height, depth],
                    functions: [activate],
                    immutable: true,
                });
                this.compareKernel = makeKernel(compare3D$2, {
                    output: [width, height, depth],
                    functions: [measure],
                    immutable: true,
                });
            }
            else {
                this.predictKernel = makeKernel(predict2D$2, {
                    output: [width, height],
                    functions: [activate],
                    immutable: true,
                });
                this.compareKernel = makeKernel(compare2D$2, {
                    output: [width, height],
                    functions: [measure],
                    immutable: true,
                });
            }
        }
        predict() {
            release(this.weights);
            this.weights = this.predictKernel(this.inputLayer.weights);
        }
        compare() {
            const { deltas } = this;
            this.deltas = this.compareKernel(this.weights, deltas);
            release(deltas);
        }
    }
    function leakyRelu(inputLayer, settings) {
        return new LeakyRelu(inputLayer, settings);
    }

    function lstmCell(settings, input, recurrentInput) {
        const { height } = settings;
        if (typeof height !== 'number') {
            throw new Error('no settings.height given');
        }
        if (recurrentInput.setDimensions) {
            recurrentInput.setDimensions(1, height);
        }
        const inputGateWeights = random({
            width: input.height,
            height,
            std: 0.08,
            id: 'inputGateWeights',
        });
        const inputGatePeepholes = random({
            width: height,
            height,
            std: 0.08,
            id: 'inputGatePeepholes',
        });
        const inputGateBias = zeros({ width: 1, height, id: 'inputGateBias' });
        const inputGate = sigmoid$1(add$1(add$1(multiply$1(inputGateWeights, input), multiply$1(inputGatePeepholes, recurrentInput)), inputGateBias), { id: 'inputGate' });
        const forgetGateWeights = random({
            width: input.height,
            height,
            std: 0.08,
            id: 'forgetGateWeights',
        });
        const forgetGatePeepholes = random({
            width: height,
            height,
            std: 0.08,
            id: 'forgetGatePeepholes',
        });
        const forgetGateBias = zeros({ width: 1, height, id: 'forgetGateBias' });
        const forgetGate = sigmoid$1(add$1(add$1(multiply$1(forgetGateWeights, input), multiply$1(forgetGatePeepholes, recurrentInput)), forgetGateBias), { id: 'forgetGate' });
        const outputGateWeights = random({
            width: input.height,
            height,
            std: 0.08,
            id: 'outputGateWeights',
        });
        const outputGatePeepholes = random({
            width: height,
            height,
            std: 0.08,
            id: 'outputGatePeepholes',
        });
        const outputGateBias = zeros({ width: 1, height, id: 'outputGateBias' });
        const outputGate = sigmoid$1(add$1(add$1(multiply$1(outputGateWeights, input), multiply$1(outputGatePeepholes, recurrentInput)), outputGateBias), { id: 'outputGate' });
        const memoryWeights = random({
            width: input.height,
            height,
            std: 0.08,
            id: 'memoryWeights',
        });
        const memoryPeepholes = random({
            width: height,
            height,
            std: 0.08,
            id: 'memoryPeepholes',
        });
        const memoryBias = zeros({ width: 1, height, id: 'memoryBias' });
        const memory = tanh$1(add$1(add$1(multiply$1(memoryWeights, input), multiply$1(memoryPeepholes, recurrentInput)), memoryBias), { id: 'memory' });
        // compute new cell activation
        const retainCell = multiplyElement$1(forgetGate, recurrentInput, {
            id: 'retainCell',
        }); // what do we keep from cell
        const writeCell = multiplyElement$1(inputGate, memory, { id: 'writeCell' }); // what do we write to cell
        const cell = add$1(retainCell, writeCell, { id: 'cell' }); // new cell contents
        // compute hidden state as gated, saturated cell activations
        return multiplyElement$1(outputGate, tanh$1(cell), { id: 'activations' });
    }

    function output(settings, inputLayer) {
        const { height } = settings;
        const outputGate = random({
            height,
            width: inputLayer.height,
            id: 'outputGate',
            std: 0.08,
        });
        const output = random({ height, id: 'output', std: 0.08 });
        const outputGateConnector = multiply$1(outputGate, inputLayer, {
            id: 'outputGateConnected',
        });
        return target({ id: 'target', ...settings }, add$1(outputGateConnector, output));
    }

    function setSwitchY(value) {
        return value;
    }
    function setSwitchX(value) {
        return value;
    }
    function predict$1(inputs) {
        // Ends are exclusive, that is if end=4, the last item is 3
        const unclippedStartInputX = this.thread.x * this.constants.strideX - this.constants.paddingX;
        const unclippedStartInputY = this.thread.y * this.constants.strideY - this.constants.paddingY;
        const unclippedEndInputX = unclippedStartInputX + this.constants.filterWidth;
        const unclippedEndInputY = unclippedStartInputY + this.constants.filterHeight;
        const startInputX = Math.max(unclippedStartInputX, 0);
        const startInputY = Math.max(unclippedStartInputY, 0);
        const endInputX = Math.min(unclippedEndInputX, this.constants.inputWidth);
        const endInputY = Math.min(unclippedEndInputY, this.constants.inputHeight);
        let largestValue = inputs[this.thread.z][startInputY][startInputX];
        for (let y = startInputY; y < endInputY; y++) {
            for (let x = startInputX; x < endInputX; x++) {
                const input = inputs[this.thread.z][y][x];
                if (input > largestValue) {
                    largestValue = input;
                }
            }
        }
        return largestValue;
    }
    function compare$1(deltas, switchX, switchY) {
        const xCenter = this.thread.x + 0.5;
        const yCenter = this.thread.y + 0.5;
        const invStrideX = 1 / this.constants.strideX;
        const invStrideY = 1 / this.constants.strideY;
        const startSourceX = Math.max(0, Math.ceil((xCenter - this.constants.filterWidth + this.constants.paddingX) *
            invStrideX));
        const startSourceY = Math.max(0, Math.ceil((yCenter - this.constants.filterHeight + this.constants.paddingY) *
            invStrideY));
        const endSourceX = Math.min(Math.ceil((xCenter + this.constants.paddingX) * invStrideX), this.constants.outputWidth);
        const endSourceY = Math.min(Math.ceil((yCenter + this.constants.paddingY) * invStrideY), this.constants.outputHeight);
        let result = 0;
        for (let backY = startSourceY; backY < endSourceY; backY++) {
            for (let backX = startSourceX; backX < endSourceX; backX++) {
                const switchXValue = switchX[backY][backX];
                const switchYValue = switchY[backY][backX];
                if (Math.abs(switchXValue - this.thread.x) < 0.1 &&
                    Math.abs(switchYValue - this.thread.y) < 0.1) {
                    result += deltas[backY][backX];
                }
            }
        }
        return result;
    }
    const defaults$4 = {
        padding: 0,
        stride: 0,
        filterWidth: 0,
        filterHeight: 0,
        filterCount: 0,
    };
    class Pool extends Filter {
        constructor(settings, inputLayer) {
            super(settings, inputLayer);
            this.predictKernelMap = null;
            this.settings = {
                ...settings,
                ...getStride(settings, defaults$4),
                ...getPadding(settings, defaults$4),
            };
            this.weights = randos3D(this.width, this.height, this.depth);
            this.deltas = zeros3D(this.width, this.height, this.depth);
            this.validate();
        }
        get strideX() {
            return this.settings.strideX;
        }
        get strideY() {
            return this.settings.strideY;
        }
        get paddingX() {
            return this.settings.paddingX;
        }
        get paddingY() {
            return this.settings.paddingY;
        }
        get width() {
            // Using floor prefers to pad less (or use negative padding) on the right
            // using ceil prefers to pad more
            return Math.ceil((this.inputLayer.width + this.paddingX * 2 - this.filterWidth) /
                this.strideX +
                1);
        }
        get height() {
            // Using floor prefers to pad less (or use negative padding) on the bottom
            // using ceil prefers to pad more
            return Math.floor((this.inputLayer.height + this.paddingY * 2 - this.filterHeight) /
                this.strideY +
                1);
        }
        get depth() {
            return this.settings.filterCount;
        }
        get filterCount() {
            // TODO: handle 1 depth?
            return this.settings.filterCount;
        }
        get switchX() {
            return this.settings.switchX;
        }
        set switchX(switchX) {
            this.settings.switchX = switchX;
        }
        get switchY() {
            return this.settings.switchY;
        }
        set switchY(switchY) {
            this.settings.switchY = switchY;
        }
        setupKernels() {
            this.predictKernelMap = makeKernelMap({
                switchX: setSwitchX,
                switchY: setSwitchY,
            }, predict$1, {
                output: [this.width, this.height, this.depth],
                constants: {
                    inputWidth: this.inputLayer.width,
                    inputHeight: this.inputLayer.height,
                    paddingX: this.paddingX,
                    paddingY: this.paddingY,
                    filterHeight: this.filterHeight,
                    filterWidth: this.filterWidth,
                    strideX: this.strideX,
                    strideY: this.strideY,
                },
            });
            this.compareKernel = makeKernel(compare$1, {
                output: [
                    this.inputLayer.width,
                    this.inputLayer.height,
                    this.inputLayer.depth,
                ],
                constants: {
                    inputWidth: this.inputLayer.width,
                    inputHeight: this.inputLayer.height,
                    outputWidth: this.width,
                    outputHeight: this.height,
                    filterWidth: this.filterWidth,
                    filterHeight: this.filterHeight,
                    paddingX: this.paddingX,
                    paddingY: this.paddingY,
                    strideX: this.strideX,
                    strideY: this.strideY,
                },
            });
        }
        predict() {
            const { result: weights, switchX, switchY } = this
                .predictKernelMap(this.inputLayer.weights);
            this.switchX = switchX;
            this.switchY = switchY;
            this.weights = weights;
        }
        compare() {
            // debugger;
            // const depth = this.inputLayer.deltas.length;
            // const height = this.inputLayer.deltas[0].length;
            // const width = this.inputLayer.deltas[0][0].length;
            // const type = typeof this.inputLayer.deltas[0][0][0];
            const inputLayerDeltas = this.inputLayer.deltas;
            this.inputLayer.deltas = this.compareKernel(this.deltas, this.switchX, this.switchY);
            release(inputLayerDeltas);
            // debugger;
            // if (depth !== this.inputLayer.deltas.length) debugger;
            // if (height !== this.inputLayer.deltas[0].length) debugger;
            // if (width !== this.inputLayer.deltas[0][0].length) debugger;
            // if (type !== typeof this.inputLayer.deltas[0][0][0]) debugger;
        }
    }
    function pool(settings, inputLayer) {
        return new Pool(settings, inputLayer);
    }

    class RecurrentInput extends Internal {
        constructor(recurrentInput) {
            super();
            this.praxis = null;
            this.predictKernel = null;
            this.compareKernel = null;
            this.settings = {};
            this.recurrentInput = recurrentInput;
            this.validate();
        }
        get width() {
            return this.recurrentInput.width;
        }
        get height() {
            return this.recurrentInput.height;
        }
        get depth() {
            return this.recurrentInput.depth;
        }
        get deltas() {
            return this.recurrentInput.deltas;
        }
        set deltas(deltas) {
            const recurrentInputDeltas = this.recurrentInput.deltas;
            this.recurrentInput.deltas = deltas;
            release(recurrentInputDeltas);
        }
        get weights() {
            return this.recurrentInput.weights;
        }
        set weights(weights) {
            const recurrentInputWeights = this.recurrentInput.weights;
            this.recurrentInput.weights = weights;
            release(recurrentInputWeights);
        }
        validate() {
            BaseLayer.prototype.validate.call(this);
            if (this.width !== this.recurrentInput.width) {
                throw new Error(`${this.constructor.name} layer width ${this.width} and ${this.recurrentInput.constructor.name} width (${this.recurrentInput.width}) are not same`);
            }
            if (this.height !== this.recurrentInput.height) {
                throw new Error(`${this.constructor.name} layer height ${this.height} and ${this.recurrentInput.constructor.name} width (${this.recurrentInput.height}) are not same`);
            }
        }
        setDimensions(width, height) {
            this.recurrentInput.width = width;
            this.recurrentInput.height = height;
        }
        predict() {
            // throw new Error(`${this.constructor.name}-predict is not yet implemented`)
        }
        compare() {
            // throw new Error(`${this.constructor.name}-compare is not yet implemented`)
        }
        learn() {
            // throw new Error(`${this.constructor.name}-learn is not yet implemented`)
        }
        setupKernels() {
            // throw new Error(
            //   `${this.constructor.name}-setupKernels is not yet implemented`
            // )
        }
        reuseKernels() {
            // throw new Error(
            //   `${this.constructor.name}-reuseKernels is not yet implemented`
            // )
        }
    }

    class RecurrentZeros extends Internal {
        constructor(settings) {
            super();
            this.praxis = null;
            this.settings = {};
            this.predictKernel = null;
            this.compareKernel = null;
            if (settings) {
                this.settings = { ...settings };
            }
        }
        setDimensions(width, height) {
            this.praxis = null;
            this.settings = {
                ...this.settings,
                width,
                height,
                weights: zeros2D(width, height),
                deltas: zeros2D(width, height),
            };
        }
        setupKernels() {
            // throw new Error(
            //   `${this.constructor.name}-setupKernels is not yet implemented`
            // )
        }
        reuseKernels() {
            // throw new Error(
            //   `${this.constructor.name}-reuseKernels is not yet implemented`
            // )
        }
        predict() {
            // throw new Error(`${this.constructor.name}-predict is not yet implemented`)
        }
        compare() {
            // throw new Error(`${this.constructor.name}-compare is not yet implemented`)
        }
        learn(learningRate) {
            const { weights: oldWeights } = this;
            this.weights = this.praxis.run(this, learningRate);
            // this.deltas = deltas;
            release(oldWeights);
        }
    }
    function recurrentZeros() {
        return new RecurrentZeros();
    }

    function predict2D$1(inputs) {
        return activate$3(inputs[this.thread.y][this.thread.x]);
    }
    function compare2D$1(weights, deltas) {
        return measure$3(weights[this.thread.y][this.thread.x], deltas[this.thread.y][this.thread.x]);
    }
    function predict3D$1(inputs) {
        return activate$3(inputs[this.thread.z][this.thread.y][this.thread.x]);
    }
    function compare3D$1(weights, deltas) {
        return measure$3(weights[this.thread.z][this.thread.y][this.thread.x], deltas[this.thread.z][this.thread.y][this.thread.x]);
    }
    class Relu extends Activation {
        setupKernels() {
            const { width, height, depth } = this.inputLayer;
            if (depth > 0) {
                this.predictKernel = makeKernel(predict3D$1, {
                    output: [width, height, depth],
                    functions: [activate$3],
                    immutable: true,
                });
                this.compareKernel = makeKernel(compare3D$1, {
                    output: [width, height, depth],
                    functions: [measure$3],
                    immutable: true,
                });
            }
            else {
                this.predictKernel = makeKernel(predict2D$1, {
                    output: [width, height],
                    functions: [activate$3],
                    immutable: true,
                });
                this.compareKernel = makeKernel(compare2D$1, {
                    output: [width, height],
                    functions: [measure$3],
                    immutable: true,
                });
            }
        }
        predict() {
            release(this.weights);
            this.weights = this.predictKernel(this.inputLayer.weights);
        }
        compare() {
            release(this.inputLayer.deltas);
            this.inputLayer.deltas = this.compareKernel(this.weights, this.deltas);
        }
    }
    function relu$1(inputLayer, settings) {
        return new Relu(inputLayer, settings);
    }

    function rnnCell(settings, input, recurrentInput) {
        const { height } = settings;
        if (typeof height !== 'number')
            throw new Error('height not set');
        if (recurrentInput.setDimensions) {
            recurrentInput.setDimensions(1, height);
        }
        // wxh
        const weight = random({
            id: 'weight',
            height,
            width: input.height,
            std: 0.08,
        });
        // whh
        const transition = random({
            id: 'transition',
            height,
            width: height,
            std: 0.08,
        });
        // bhh
        const bias = zeros({ id: 'bias', height });
        return relu$1(add$1(add$1(multiply$1(weight, input), multiply$1(transition, recurrentInput)), bias));
    }

    class Regression extends BaseLayer {
        constructor(settings, inputLayer) {
            super(settings);
            this.inputLayer = inputLayer;
            this.validate();
        }
        predict() {
            release(this.weights);
            this.weights = clone(this.inputLayer.weights);
        }
        learn() {
            // throw new Error(`${this.constructor.name}-learn is not yet implemented`)
        }
    }
    // TODO: handle `loss += 0.5*dy*dy;` total and sum in learn
    function regression(settings, inputLayer) {
        return new Regression(settings, inputLayer);
    }

    function getMaxValue2D(inputs) {
        let maxInput = -Infinity;
        for (let y = 0; y < this.constants.inputHeight; y++) {
            for (let x = 0; x < this.constants.inputWidth; x++) {
                const input = inputs[y][x];
                if (input > maxInput) {
                    maxInput = input;
                }
            }
        }
        return maxInput;
    }
    function getMaxValue3D(inputs) {
        let maxInput = -Infinity;
        for (let z = 0; z < this.constants.inputDepth; z++) {
            for (let y = 0; y < this.constants.inputHeight; y++) {
                for (let x = 0; x < this.constants.inputWidth; x++) {
                    const input = inputs[z][y][x];
                    if (input > maxInput) {
                        maxInput = input;
                    }
                }
            }
        }
        return maxInput;
    }
    function getSum2D(inputs) {
        let sum = 0;
        for (let y = 0; y < this.constants.inputHeight; y++) {
            for (let x = 0; x < this.constants.inputWidth; x++) {
                sum += inputs[y][x];
            }
        }
        return sum;
    }
    function getSum3D(inputs) {
        let sum = 0;
        for (let z = 0; z < this.constants.inputDepth; z++) {
            for (let y = 0; y < this.constants.inputHeight; y++) {
                for (let x = 0; x < this.constants.inputWidth; x++) {
                    sum += inputs[z][y][x];
                }
            }
        }
        return sum;
    }
    function getExponentials(inputs, maxInput) {
        return Math.exp(inputs[this.thread.x] - maxInput[0]);
    }
    function getExponentials3D(inputs, maxInput) {
        return Math.exp(inputs[this.thread.z][this.thread.y][this.thread.x] - maxInput[0]);
    }
    function predict2D(exponentials, exponentialsSum) {
        return exponentials[this.thread.y][this.thread.x] / exponentialsSum[0];
    }
    function predict3D(exponentials, exponentialsSum) {
        return (exponentials[this.thread.z][this.thread.y][this.thread.x] /
            exponentialsSum[0]);
    }
    function compare2D(target, exponentials) {
        let indicator = 0;
        const index = this.thread.x + this.thread.y * this.output.x;
        if (index === target) {
            indicator = 1;
        }
        return -(indicator - exponentials[this.thread.y][this.thread.x]);
    }
    function compare3D(target, exponentials) {
        let indicator = 0;
        const index = this.thread.x +
            this.thread.y * this.output.x +
            this.thread.z * this.output.x * this.output.y;
        if (index === target) {
            indicator = 1;
        }
        return -(indicator - exponentials[this.thread.z][this.thread.y][this.thread.x]);
    }
    // TODO: handle: `return -Math.log(this.es[y]);` in learn
    class SoftMax extends Modifier {
        constructor(inputLayer, settings) {
            super(inputLayer, settings);
            this.errors = null;
            this.getExponentialsKernel = null;
            this.getMaxValueKernel = null;
            this.getSumKernel = null;
            this.validate();
            if (this.depth > 0) {
                this.weights = randos3D(this.width, this.height, this.depth);
                this.deltas = zeros3D(this.width, this.height, this.depth);
            }
            else if (this.height > 0) {
                this.weights = randos2D(this.width, this.height);
                this.deltas = zeros2D(this.width, this.height);
            }
            else {
                this.weights = randos(this.width);
                this.deltas = zeros$1(this.width);
            }
        }
        setupKernels() {
            const { width, height, depth } = this;
            if (depth > 0) {
                this.getExponentialsKernel = makeKernel(getExponentials3D, {
                    output: [width, height, depth],
                });
                this.getMaxValueKernel = makeKernel(getMaxValue3D, {
                    output: [1, 1, 1],
                    constants: {
                        inputWidth: width,
                        inputHeight: height,
                        inputDepth: depth,
                    },
                });
                this.getSumKernel = makeKernel(getSum3D, {
                    output: [1, 1, 1],
                    constants: {
                        inputWidth: width,
                        inputHeight: height,
                        inputDepth: depth,
                    },
                });
                this.predictKernel = makeKernel(predict3D, {
                    output: [width, height, depth],
                });
                this.compareKernel = makeKernel(compare3D, {
                    output: [width, height, depth],
                    immutable: true,
                });
            }
            else {
                this.getExponentialsKernel = makeKernel(getExponentials, {
                    output: [width, height],
                });
                this.getMaxValueKernel = makeKernel(getMaxValue2D, {
                    output: [1, 1],
                    constants: {
                        inputWidth: width,
                        inputHeight: height,
                    },
                });
                this.getSumKernel = makeKernel(getSum2D, {
                    output: [1, 1],
                    constants: {
                        inputWidth: width,
                        inputHeight: height,
                    },
                });
                this.predictKernel = makeKernel(predict2D, {
                    output: [width, height],
                });
                this.compareKernel = makeKernel(compare2D, {
                    output: [width, height],
                    immutable: true,
                });
            }
        }
        predict() {
            const maxValue = this.getMaxValueKernel(this.inputLayer.weights);
            const exponentials = this.getExponentialsKernel(this.inputLayer.weights, maxValue);
            const exponentialsSum = this.getSumKernel(exponentials);
            this.weights = this.predictKernel(exponentials, exponentialsSum);
        }
        compare(targetValues) {
            const { deltas, errors } = this;
            this.errors = this.compareKernel(targetValues[0], deltas);
            this.deltas = clone(this.errors);
            release(deltas);
            release(errors);
            const inputLayerDeltas = this.inputLayer.deltas;
            this.inputLayer.deltas = clone(this.deltas);
            release(inputLayerDeltas);
        }
    }
    function softMax(inputLayer, settings) {
        return new SoftMax(inputLayer, settings);
    }

    class SVM extends BaseLayer {
        constructor(inputLayer, settings) {
            super(settings);
            this.inputLayer = inputLayer;
        }
        predict() {
            release(this.weights);
            this.weights = clone(this.inputLayer.weights);
            this.validate();
        }
        learn() {
            // throw new Error(`${this.constructor.name}-learn is not yet implemented`)
        }
    }
    // function learn(target) {
    //   if (y === i) {
    //     continue;
    //   }
    //   const ydiff = -yscore + x.w[i] + margin;
    //   if (ydiff > 0) {
    //     // violating dimension, apply loss
    //     x.dw[i] += 1;
    //     x.dw[y] -= 1;
    //     loss += ydiff;
    //   }
    // }
    function svm(inputLayer, settings) {
        return new SVM(inputLayer, settings);
    }

    function predict(value) {
        return value[this.thread.x][this.thread.y];
    }
    const compare = predict;
    class Transpose extends Modifier {
        get width() {
            return this.inputLayer.height;
        }
        get height() {
            return this.inputLayer.width;
        }
        constructor(inputLayer) {
            super(inputLayer);
            this.validate();
        }
        setupKernels() {
            this.predictKernel = makeKernel(predict, {
                output: [this.height, this.width],
            });
            this.compareKernel = makeKernel(compare, {
                output: [this.width, this.height],
            });
        }
        predict() {
            this.weights = this.predictKernel(this.inputLayer.weights);
        }
        compare() {
            this.inputLayer.deltas = this.compareKernel(this.deltas);
        }
    }
    function transpose(inputLayer) {
        return new Transpose(inputLayer);
    }

    const layerTypes = {
        Activation,
        Internal,
        InternalModel,
        EntryPoint,
        Filter,
        Model,
        Modifier,
        Operator,
        Target,
    };

    var layer = /*#__PURE__*/Object.freeze({
        __proto__: null,
        layerTypes: layerTypes,
        Add: Add,
        add: add$1,
        arthurFeedForward: arthurFeedForward,
        BaseLayer: BaseLayer,
        baseLayerDefaultSettings: baseLayerDefaultSettings,
        Convolution: Convolution,
        convolution: convolution,
        Dropout: Dropout,
        dropout: dropout,
        feedForward: feedForward,
        FullyConnected: FullyConnected,
        fullyConnected: fullyConnected,
        gru: gru,
        Input: Input,
        input: input,
        LeakyRelu: LeakyRelu,
        leakyRelu: leakyRelu,
        lstmCell: lstmCell,
        Multiply: Multiply,
        multiply: multiply$1,
        MultiplyElement: MultiplyElement,
        multiplyElement: multiplyElement$1,
        Negative: Negative,
        negative: negative,
        Ones: Ones,
        ones: ones,
        output: output,
        Pool: Pool,
        pool: pool,
        Random: Random,
        random: random,
        RecurrentInput: RecurrentInput,
        RecurrentZeros: RecurrentZeros,
        rnnCell: rnnCell,
        Regression: Regression,
        regression: regression,
        Relu: Relu,
        relu: relu$1,
        Sigmoid: Sigmoid,
        sigmoid: sigmoid$1,
        SoftMax: SoftMax,
        softMax: softMax,
        SVM: SVM,
        svm: svm,
        Tanh: Tanh,
        tanh: tanh$1,
        Target: Target,
        target: target,
        Transpose: Transpose,
        transpose: transpose,
        Zeros: Zeros,
        zeros: zeros
    });

    const layerNameTypes = Object.keys(layer);
    function layerFromJSON(jsonLayer, inputLayer1, inputLayer2) {
        if (!layerNameTypes.find((layerNameType) => layerNameType === jsonLayer.type)) {
            return null;
        }
        const Layer = layer[jsonLayer.type];
        if (Layer.prototype instanceof layerTypes.Filter) {
            if (!inputLayer1)
                throw new Error('inputLayer missing');
            return new Layer(jsonLayer, inputLayer1);
        }
        else if (Layer.prototype instanceof layerTypes.Activation ||
            Layer.prototype instanceof layerTypes.Modifier) {
            if (!inputLayer1)
                throw new Error('inputLayer missing');
            return new Layer(inputLayer1, jsonLayer);
        }
        else if (Layer.prototype instanceof layerTypes.Internal) {
            return new Layer(jsonLayer);
        }
        else if (Layer.prototype instanceof layerTypes.Operator) {
            if (!inputLayer1)
                throw new Error('inputLayer1 missing');
            if (!inputLayer2)
                throw new Error('inputLayer2 missing');
            return new Layer(inputLayer1, inputLayer2, jsonLayer);
        }
        else if (Layer.prototype instanceof layerTypes.InternalModel ||
            Layer.prototype instanceof layerTypes.EntryPoint ||
            Layer.prototype instanceof layerTypes.Model) {
            return new Layer(jsonLayer);
        }
        else if (Layer === Target) {
            if (!inputLayer1)
                throw new Error('inputLayer missing');
            return new Layer(jsonLayer, inputLayer1);
        }
        return null;
    }

    class LookupTable {
        constructor(data, prop) {
            this.prop = null;
            this.table = {};
            this.length = 0;
            const table = this.table;
            if (prop) {
                this.prop = prop;
                for (let i = 0; i < data.length; i++) {
                    const datum = data[i];
                    const object = datum[prop];
                    for (const p in object) {
                        if (!object.hasOwnProperty(p))
                            continue;
                        if (table.hasOwnProperty(p))
                            continue;
                        table[p] = this.length++;
                    }
                }
            }
            else if (Array.isArray(data) && Array.isArray(data[0])) {
                for (let i = 0; i < data.length; i++) {
                    const array = data[i];
                    for (let j = 0; j < array.length; j++) {
                        const object = array[j];
                        for (const p in object) {
                            if (!object.hasOwnProperty(p))
                                continue;
                            if (table.hasOwnProperty(p))
                                continue;
                            table[p] = this.length++;
                        }
                    }
                }
            }
            else {
                for (let i = 0; i < data.length; i++) {
                    const object = data[i];
                    for (const p in object) {
                        if (!object.hasOwnProperty(p))
                            continue;
                        if (table.hasOwnProperty(p))
                            continue;
                        table[p] = this.length++;
                    }
                }
            }
        }
    }

    var browser = createCommonjsModule(function (module, exports) {
    var __assign = (commonjsGlobal && commonjsGlobal.__assign) || function () {
        __assign = Object.assign || function(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.thaw = exports.Block = exports.Thaw = void 0;
    /**
     * thaw an array of items
     */
    var Thaw = /** @class */ (function () {
        function Thaw(items, options) {
            var _this = this;
            if (options === void 0) { options = {}; }
            var _a = __assign(__assign({}, Thaw.defaultSettings), options), each = _a.each, done = _a.done;
            this.i = 0;
            this.isStopped = false;
            this.items = items;
            this.options = options;
            this.tick = function () {
                if (_this.isStopped)
                    return;
                _this.timeout = setTimeout(_this.tick, 0);
                if (Thaw.thawing)
                    return;
                var item = _this.items[_this.i];
                if (_this.i >= _this.items.length) {
                    if (done !== null) {
                        Thaw.thawing = true;
                        done();
                        Thaw.thawing = false;
                    }
                    _this.isStopped = true;
                    clearTimeout(_this.timeout);
                    return;
                }
                if (each !== null) {
                    Thaw.thawing = true;
                    each(item, _this.i);
                    Thaw.thawing = false;
                }
                else if (item !== undefined) {
                    item();
                }
                _this.i++;
            };
            Thaw.thaws.push(this);
            if (!options.delay) {
                this.tick();
            }
        }
        Object.defineProperty(Thaw, "isThawing", {
            /**
             * returns if Thaw.js is thawing
             */
            get: function () {
                return Thaw.thawing;
            },
            enumerable: false,
            configurable: true
        });
        /**
         * Stops all Thaw instances
         */
        Thaw.stopAll = function () {
            for (var i = 0; i < Thaw.thaws.length; i++) {
                Thaw.thaws[i].stop();
            }
        };
        /**
         * readies thaw to continue
         */
        Thaw.prototype.makeReady = function () {
            if (this.isStopped) {
                this.isStopped = false;
                return true;
            }
            return false;
        };
        /**
         * Adds an item to the end of this instance of Thaw and readies Thaw to process it
         */
        Thaw.prototype.add = function (item) {
            this.items.push(item);
            if (this.makeReady()) {
                this.tick();
            }
            return this;
        };
        /**
         * Inserts an item just after the current item being processed in Thaw and readies Thaw to process it
         */
        Thaw.prototype.insert = function (item) {
            this.items.splice(this.i, 0, item);
            if (this.makeReady()) {
                this.tick();
            }
            return this;
        };
        /**
         * Adds an Array to the end of this instance of Thaw and readies Thaw to process it
         */
        Thaw.prototype.addArray = function (items) {
            this.items = this.items.concat(items);
            if (this.makeReady()) {
                this.tick();
            }
            return this;
        };
        /**
         * Inserts an Array just after the current item being processed in Thaw and readies Thaw to process them
         */
        Thaw.prototype.insertArray = function (items) {
            var before = this.items.splice(0, this.i);
            var after = this.items;
            this.items = before.concat(items, after);
            if (this.makeReady()) {
                this.tick();
            }
            return this;
        };
        /**
         * Stops this instance of Thaw
         */
        Thaw.prototype.stop = function () {
            this.isStopped = true;
            clearTimeout(this.timeout);
            if (this.options.done) {
                this.options.done();
            }
            return this;
        };
        Thaw.thawing = false;
        Thaw.thaws = [];
        Thaw.defaultSettings = {
            each: null,
            done: null
        };
        return Thaw;
    }());
    exports.Thaw = Thaw;
    /**
     * simple thaw
     */
    function thaw(items, options) {
        return new Thaw(items, options);
    }
    exports.thaw = thaw;
    var Block = /** @class */ (function () {
        function Block(options, count) {
            if (count === void 0) { count = 200; }
            this.index = 0;
            this.thaws = [];
            this.count = count;
            this.options = options;
        }
        /**
         * add an item to the end of items
         */
        Block.prototype.add = function (item) {
            var next = this.next();
            next.add(item);
            return this;
        };
        /**
         * add an Array to the end of items
         */
        Block.prototype.addArray = function (items) {
            var next = this.next();
            next.addArray(items);
            return this;
        };
        /**
         * insert an item into items @ current position
         */
        Block.prototype.insert = function (item) {
            var next = this.next();
            next.insert(item);
            return this;
        };
        /**
         * insert and array into items @ current position
         */
        Block.prototype.insertArray = function (items) {
            var next = this.next();
            next.insertArray(items);
            return this;
        };
        /**
         * Stops all thaws in this block
         */
        Block.prototype.stop = function () {
            for (var i = 0; i < this.thaws.length; i++) {
                this.thaws[i].stop();
            }
            return this;
        };
        /**
         * Get next available in block
         */
        Block.prototype.next = function () {
            var thaw;
            var thaws = this.thaws;
            if (thaws.length < this.count) {
                thaw = new Thaw([], this.options);
                thaws.push(thaw);
            }
            else {
                thaw = thaws[this.index] || null;
            }
            this.index++;
            if (this.index >= this.count) {
                this.index = 0;
            }
            return thaw;
        };
        return Block;
    }());
    exports.Block = Block;
    if (typeof window !== 'undefined') {
        // @ts-ignore
        window.Thaw = Thaw;
        // @ts-ignore
        window.thaw = thaw;
        // @ts-ignore
        window.Thaw.Block = Block;
    }
    });

    const defaults$3 = {
        learningRate: 0.3,
        binaryThresh: 0.5,
        initPraxis: (layerTemplate, settings) => {
            var _a;
            return momentumRootMeanSquaredPropagation(layerTemplate, (_a = layerTemplate.settings.praxisOpts) !== null && _a !== void 0 ? _a : settings);
        },
    };
    const trainDefaults$3 = {
        iterations: 20000,
        errorThresh: 0.005,
        log: false,
        logPeriod: 10,
        learningRate: 0.3,
        callbackPeriod: 10,
        errorCheckInterval: 100,
        timeout: Infinity,
    };
    class FeedForward {
        constructor(options = {}) {
            this.trainOpts = {};
            this.layers = null;
            this._inputLayer = null;
            this._hiddenLayers = null;
            this._outputLayer = null;
            this._model = null;
            this.meanSquaredError = null;
            this.inputLookup = null;
            this.inputLookupLength = null;
            this.outputLookup = null;
            this.outputLookupLength = null;
            this.options = { ...defaults$3, ...options };
            this._updateTrainingOptions({
                ...trainDefaults$3,
                ...options,
            });
        }
        static _validateTrainingOptions(options) {
            const { iterations, errorThresh, log, logPeriod, learningRate, callback, callbackPeriod, timeout, } = options;
            const validations = {
                iterations: () => typeof iterations === 'number' && iterations > 0,
                errorThresh: () => typeof errorThresh === 'number' && errorThresh > 0 && errorThresh < 1,
                log: () => typeof log === 'function' || typeof log === 'boolean',
                logPeriod: () => typeof logPeriod === 'number' && logPeriod > 0,
                learningRate: () => typeof learningRate === 'number' &&
                    learningRate > 0 &&
                    learningRate < 1,
                callback: () => typeof callback === 'function' || callback === null,
                callbackPeriod: () => typeof callbackPeriod === 'number' && callbackPeriod > 0,
                timeout: () => typeof timeout === 'number' && timeout > 0,
            };
            Object.keys(trainDefaults$3).forEach((key) => {
                if (validations.hasOwnProperty(key) && !validations[key]()) {
                    const val = options[key];
                    throw new Error(`[${key}, ${(val !== null && val !== void 0 ? val : 'undefined').toString()}] is out of normal training range, your network will probably not train.`);
                }
            });
        }
        /**
         * if a method is passed in method is used
         * if false passed in nothing is logged
         */
        _setLogMethod(log) {
            if (typeof log === 'function') {
                this.trainOpts.log = log;
            }
            else if (log) {
                // eslint-disable-next-line
                this.trainOpts.log = console.log;
            }
            else {
                this.trainOpts.log = false;
            }
        }
        _updateTrainingOptions(opts) {
            var _a;
            this.trainOpts = { ...trainDefaults$3, ...this.trainOpts, ...opts };
            FeedForward._validateTrainingOptions(this.trainOpts);
            this._setLogMethod((_a = opts.log) !== null && _a !== void 0 ? _a : this.trainOpts.log);
            const { callback, callbackPeriod, errorCheckInterval } = this.trainOpts;
            if (callback && callbackPeriod !== errorCheckInterval) {
                console.warn(`options.callbackPeriod with value of ${(callbackPeriod !== null && callbackPeriod !== void 0 ? callbackPeriod : 'undefined').toString()} does not match options.errorCheckInterval with value of ${(errorCheckInterval !== null && errorCheckInterval !== void 0 ? errorCheckInterval : 'undefined').toString()}, if logging error, it will repeat.  These values may need to match`);
            }
        }
        _connectOptionsLayers() {
            const { inputLayerIndex, outputLayerIndex, layers } = this.options;
            if (!layers)
                throw new Error('this.options.layers in unexpected state');
            if (typeof inputLayerIndex !== 'number')
                throw new Error('inputLayerIndex not a number');
            if (typeof outputLayerIndex !== 'number')
                throw new Error('inputLayerIndex not a number');
            const inputLayer = layers[inputLayerIndex];
            if (!inputLayer) {
                throw new Error('inputLayer not found in this.options.layers');
            }
            const outputLayer = layers[outputLayerIndex];
            if (!outputLayer) {
                throw new Error('outputLayer not found in this.options.layers');
            }
            this._inputLayer = inputLayer;
            this._hiddenLayers = layers.slice(inputLayerIndex, outputLayerIndex - inputLayerIndex);
            this._outputLayer = outputLayer;
            return layers;
        }
        _connectNewLayers() {
            const { inputLayer, outputLayer } = this.options;
            if (!inputLayer)
                throw new Error('inputLayer not defined');
            const layers = [];
            this._inputLayer = inputLayer();
            const hiddenLayers = this._connectHiddenLayers(this._inputLayer);
            if (!outputLayer)
                throw new Error('outputLayer not defined');
            this._outputLayer = outputLayer(hiddenLayers[hiddenLayers.length - 1], hiddenLayers.length);
            layers.push(this._inputLayer);
            layers.push(...hiddenLayers);
            layers.push(this._outputLayer);
            return flattenLayers(layers);
        }
        _connectHiddenLayers(previousLayer) {
            this._hiddenLayers = [];
            const result = [];
            const { hiddenLayers } = this.options;
            if (!hiddenLayers)
                throw new Error('hiddenLayers not defined');
            for (let i = 0; i < hiddenLayers.length; i++) {
                const hiddenLayer = hiddenLayers[i](previousLayer, i);
                result.push(hiddenLayer);
                this._hiddenLayers.push(hiddenLayer);
                previousLayer = hiddenLayer;
            }
            return result;
        }
        initialize() {
            this.layers = this.options.layers
                ? this._connectOptionsLayers()
                : this._connectNewLayers();
            this.initializeLayers(this.layers);
            this._model = this.layers.filter((l) => l instanceof Model);
        }
        initializeLayers(layers) {
            var _a, _b;
            for (let i = 0; i < layers.length; i++) {
                const layer = layers[i];
                // TODO: optimize for when training or just running
                layer.setupKernels(true);
                if (layer instanceof Model &&
                    layer.praxis === null &&
                    typeof this.options.initPraxis === 'function') {
                    layer.praxis = this.options.initPraxis(layer, (_b = (_a = layer.settings.praxisOpts) !== null && _a !== void 0 ? _a : this.options.praxisOpts) !== null && _b !== void 0 ? _b : {});
                    layer.praxis.setupKernels();
                }
            }
            const lastLayer = layers[layers.length - 1];
            this.meanSquaredError = new MeanSquaredError({
                width: lastLayer.width,
                height: lastLayer.height,
            });
        }
        run(input) {
            let typeSafeInput;
            if (Array.isArray(input) || input.buffer) {
                typeSafeInput = input;
            }
            else {
                if (this.inputLookup) {
                    typeSafeInput = lookup.toArray(this.inputLookup, input, this.inputLookupLength);
                }
                else {
                    throw new Error('input is incompatible with net');
                }
            }
            let output = this.runInput(typeSafeInput);
            if (output instanceof gpuBrowser.Texture) {
                output = output.toArray();
            }
            if (this.outputLookup) {
                return lookup.toObject(this.outputLookup, output);
            }
            return output;
        }
        runInput(input) {
            if (!this.layers)
                throw new Error('not initialized');
            this.layers[0].predict(input);
            for (let i = 1; i < this.layers.length; i++) {
                this.layers[i].predict();
            }
            return this.layers[this.layers.length - 1].weights;
        }
        train(data, options = {}) {
            const { preparedData, status, endTime } = this._prepTraining(data, options);
            let continueTicking = true;
            const calculateError = () => this._calculateTrainingError(preparedData);
            const trainPatterns = () => this._trainPatterns(preparedData);
            while (continueTicking) {
                continueTicking = this._trainingTick(status, endTime, calculateError, trainPatterns);
            }
            return status;
        }
        async trainAsync(data, options = {}) {
            const { preparedData, status, endTime } = this._prepTraining(data, options);
            return await new Promise((resolve, reject) => {
                try {
                    const calculateError = () => this._calculateTrainingError(preparedData);
                    const trainPatterns = () => this._trainPatterns(preparedData);
                    const thawedTrain = new browser.Thaw(new Array(this.trainOpts.iterations), {
                        delay: true,
                        each: () => this._trainingTick(status, endTime, calculateError, trainPatterns) || thawedTrain.stop(),
                        done: () => resolve(status),
                    });
                    thawedTrain.tick();
                }
                catch (trainError) {
                    reject(trainError);
                }
            });
        }
        _trainingTick(status, endTime, calculateError, trainPatterns) {
            const { trainOpts } = this;
            if (status.iterations >= trainOpts.iterations ||
                status.error <= trainOpts.errorThresh ||
                Date.now() >= endTime) {
                return false;
            }
            if (typeof trainOpts.log === 'function' &&
                status.iterations % trainOpts.logPeriod === 0) {
                status.error = calculateError();
                trainOpts.log(`iterations: ${status.iterations}, training error: ${status.error}`);
            }
            else if (status.iterations % trainOpts.errorCheckInterval ===
                0) {
                status.error = calculateError();
            }
            else {
                trainPatterns();
            }
            if (trainOpts.callback &&
                status.iterations % trainOpts.callbackPeriod === 0) {
                trainOpts.callback(Object.assign(status));
            }
            status.iterations++;
            return true;
        }
        _prepTraining(data, options) {
            this._updateTrainingOptions(options);
            const formattedData = this.formatData(data);
            const endTime = this.trainOpts.timeout
                ? Date.now() + this.trainOpts.timeout
                : 0;
            const status = {
                error: 1,
                iterations: 0,
            };
            this.verifyIsInitialized();
            return {
                preparedData: this.transferData(formattedData),
                status,
                endTime,
            };
        }
        verifyIsInitialized() {
            if (!this._model) {
                this.initialize();
            }
        }
        _calculateTrainingError(preparedData) {
            let sum = new Float32Array([0]);
            const meanSquaredError = this.meanSquaredError;
            for (let i = 0; i < preparedData.length; ++i) {
                const prevSum = sum;
                const error = this._trainPattern(preparedData[i].input, preparedData[i].output, true);
                sum = meanSquaredError.add(sum, error);
                release(error);
                release(prevSum);
            }
            const result = meanSquaredError.divide(preparedData.length, sum);
            release(sum);
            if (result instanceof gpuBrowser.Texture) {
                const resultArray = result.toArray();
                release(result);
                return resultArray[0];
            }
            return result[0];
        }
        /**
         * @param data
         * @private
         */
        _trainPatterns(data) {
            for (let i = 0; i < data.length; ++i) {
                this._trainPattern(data[i].input, data[i].output, false);
            }
        }
        _trainPattern(input, target, logErrorRate) {
            var _a;
            // forward propagate
            this.runInput(input);
            // back propagate
            this._calculateDeltas(target);
            this.adjustWeights();
            if (logErrorRate) {
                if (!((_a = this._outputLayer) === null || _a === void 0 ? void 0 : _a.errors)) {
                    throw new Error('outputLayer.errors not defined');
                }
                return this.meanSquaredError.calculate(this._outputLayer.errors);
            }
            return null;
        }
        _calculateDeltas(target) {
            const layers = this.layers;
            for (let i = layers.length - 1; i > -1; i--) {
                layers[i].compare(target);
            }
        }
        /**
         *
         */
        adjustWeights() {
            const _model = this._model;
            for (let i = 0; i < _model.length; i++) {
                _model[i].learn(this.trainOpts.learningRate);
            }
        }
        /**
         *
         * @param data
         * @returns {*}
         */
        formatData(data) {
            if (!Array.isArray(data)) {
                // turn stream datum into array
                const tmp = [];
                tmp.push(data);
                data = tmp;
            }
            // turn sparse hash input into arrays with 0s as filler
            const inputDatumCheck = data[0].input;
            let formattedData;
            if (Array.isArray(data) &&
                !Array.isArray(inputDatumCheck) &&
                !(inputDatumCheck instanceof Float32Array)) {
                if (!this.inputLookup) {
                    const lookupTable = new LookupTable(data, 'input');
                    this.inputLookup = lookupTable.table;
                    this.inputLookupLength = lookupTable.length;
                }
                formattedData = data.map((datumParam) => {
                    const array = lookup.toArray(this.inputLookup, datumParam.input, this.inputLookupLength);
                    return { input: array };
                }, this);
            }
            else {
                formattedData = data;
            }
            const outputDatumCheck = data[0].output;
            if (!Array.isArray(outputDatumCheck) &&
                !(outputDatumCheck instanceof Float32Array)) {
                if (!this.outputLookup) {
                    const lookupTable = new LookupTable(data, 'output');
                    this.outputLookup = lookupTable.table;
                    this.outputLookupLength = lookupTable.length;
                }
                formattedData = data.map((datumParam, index) => {
                    const array = lookup.toArray(this.outputLookup, datumParam.output, this.inputLookupLength);
                    return {
                        input: formattedData[index].input,
                        output: array,
                    };
                }, this);
            }
            return formattedData;
        }
        transferData(formattedData) {
            const transferredData = new Array(formattedData.length);
            const transferInput = makeKernel(function (value) {
                return value[this.thread.x];
            }, {
                output: [formattedData[0].input.length],
                immutable: true,
            });
            const transferOutput = makeKernel(function (value) {
                return value[this.thread.x];
            }, {
                output: [formattedData[0].output.length],
                immutable: true,
            });
            for (let i = 0; i < formattedData.length; i++) {
                const formattedDatum = formattedData[i];
                transferredData[i] = {
                    input: transferInput(formattedDatum.input),
                    output: transferOutput(formattedDatum.output),
                };
            }
            return transferredData;
        }
        /**
         *
         * @param data
         * @returns {
         *  {
         *    error: number,
         *    misclasses: Array
         *  }
         * }
         */
        test() {
            throw new Error(`${this.constructor.name}-test is not yet implemented`);
        }
        /**
         *
         */
        toJSON() {
            var _a;
            if (!this.layers) {
                this.initialize();
            }
            if (!this._model ||
                !this.layers ||
                !this._inputLayer ||
                !this._hiddenLayers ||
                !this._outputLayer) {
                throw new Error('network is not initialized');
            }
            const jsonLayers = [];
            for (let i = 0; i < this.layers.length; i++) {
                const layer = this.layers[i];
                const jsonLayer = layer.toJSON();
                if (layer.hasOwnProperty('inputLayer')) {
                    jsonLayer.inputLayerIndex = this.layers.indexOf(layer.inputLayer);
                }
                else if (layer.hasOwnProperty('inputLayer1') &&
                    layer.hasOwnProperty('inputLayer2')) {
                    jsonLayer.inputLayer1Index = this.layers.indexOf(layer.inputLayer1);
                    jsonLayer.inputLayer2Index = this.layers.indexOf(layer.inputLayer2);
                }
                jsonLayers.push(jsonLayer);
            }
            return {
                type: this.constructor.name,
                sizes: (_a = this.options.sizes) !== null && _a !== void 0 ? _a : [this._inputLayer.height]
                    .concat(this._hiddenLayers.map((l) => l.height))
                    .concat([this._outputLayer.height]),
                outputLayerIndex: this.layers.indexOf(this._outputLayer),
                layers: jsonLayers,
                inputLayerIndex: this.layers.indexOf(this._inputLayer),
            };
        }
        static fromJSON(json, getLayer) {
            var _a, _b, _c, _d;
            const jsonLayers = json.layers;
            const layers = [];
            const inputLayer = getLayer
                ? (_a = layerFromJSON(jsonLayers[0])) !== null && _a !== void 0 ? _a : getLayer(jsonLayers[0]) : layerFromJSON(jsonLayers[0]);
            if (!inputLayer)
                throw new Error('unable to find layer');
            layers.push(inputLayer);
            for (let i = 1; i < jsonLayers.length; i++) {
                const jsonLayer = jsonLayers[i];
                if (typeof jsonLayer.inputLayerIndex === 'undefined' &&
                    typeof jsonLayer.inputLayer1Index === 'undefined' &&
                    typeof jsonLayer.inputLayer2Index === 'undefined') {
                    const layer = getLayer
                        ? (_b = layerFromJSON(jsonLayer)) !== null && _b !== void 0 ? _b : getLayer(jsonLayer) : layerFromJSON(jsonLayer);
                    if (!layer)
                        throw new Error('unable to find layer');
                    layers.push(layer);
                }
                else if (typeof jsonLayer.inputLayerIndex === 'number') {
                    const inputLayer = layers[jsonLayer.inputLayerIndex];
                    if (!inputLayer) {
                        throw new Error('inputLayer1 not found');
                    }
                    const layer = getLayer
                        ? (_c = layerFromJSON(jsonLayer, inputLayer)) !== null && _c !== void 0 ? _c : getLayer(jsonLayer, inputLayer) : layerFromJSON(jsonLayer, inputLayer);
                    if (!layer)
                        throw new Error('unable to find layer');
                    layers.push(layer);
                }
                else {
                    if (typeof jsonLayer.inputLayer1Index !== 'number') {
                        throw new Error('Cannot create network from provided JSON. inputLayer1Index not defined.');
                    }
                    if (typeof jsonLayer.inputLayer2Index !== 'number') {
                        throw new Error('Cannot create network from provided JSON. inputLayer2Index not defined.');
                    }
                    const inputLayer1 = layers[jsonLayer.inputLayer1Index];
                    const inputLayer2 = layers[jsonLayer.inputLayer2Index];
                    if (inputLayer1 === undefined)
                        throw new Error(`Cannot create network from provided JSON. layer of index ${jsonLayer.inputLayer1Index} not found.`);
                    if (inputLayer2 === undefined)
                        throw new Error(`Cannot create network from provided JSON. layer of index ${jsonLayer.inputLayer2Index} not found.`);
                    const layer = getLayer
                        ? (_d = layerFromJSON(jsonLayer, inputLayer1, inputLayer2)) !== null && _d !== void 0 ? _d : getLayer(jsonLayer, inputLayer1, inputLayer2) : layerFromJSON(jsonLayer, inputLayer1, inputLayer2);
                    if (!layer)
                        throw new Error('unable to find layer');
                    layers.push(layer);
                }
            }
            return new this({ ...json, layers });
        }
        /**
         *
         * @returns {Function}
         */
        toFunction() {
            throw new Error(`${this.constructor.name}-toFunction is not yet implemented`);
        }
    }

    function likely(input, net) {
        if (!net) {
            throw new TypeError(`Required parameter 'net' is of type ${typeof net}. Must be of type 'bpMl.NeuralNetwork'`);
        }
        const output = net.run(input);
        let maxProp = null;
        let maxValue = -1;
        Object.entries(output).forEach(([key, value]) => {
            if (typeof value !== 'undefined' &&
                typeof value === 'number' &&
                value > maxValue) {
                maxProp = key;
                maxValue = value;
            }
        });
        return maxProp;
    }

    function arraysToFloat32Arrays(arrays) {
        const result = [];
        for (let i = 0; i < arrays.length; i++) {
            result.push(Float32Array.from(arrays[i]));
        }
        return result;
    }
    function inputOutputArraysToFloat32Arrays(input, output) {
        const result = [];
        for (let i = 0; i < input.length; i++) {
            result.push(Float32Array.from(input[i]));
        }
        for (let i = 0; i < output.length; i++) {
            result.push(Float32Array.from(output[i]));
        }
        return result;
    }
    function arrayToFloat32Arrays(array) {
        const result = [];
        for (let i = 0; i < array.length; i++) {
            result.push(Float32Array.from([array[i]]));
        }
        return result;
    }
    function inputOutputArrayToFloat32Arrays(input, output) {
        const result = [];
        for (let i = 0; i < input.length; i++) {
            result.push(Float32Array.from([input[i]]));
        }
        for (let i = 0; i < output.length; i++) {
            result.push(Float32Array.from([output[i]]));
        }
        return result;
    }
    function arrayToFloat32Array(array) {
        return Float32Array.from(array);
    }
    function inputOutputObjectsToFloat32Arrays(input, output, inputTable, outputTable, inputLength, outputLength) {
        const results = [];
        for (let i = 0; i < input.length; i++) {
            const object = input[i];
            const result = new Float32Array(inputLength);
            for (const p in object) {
                if (object.hasOwnProperty(p)) {
                    result[inputTable[p]] = object[p];
                }
            }
            results.push(result);
        }
        for (let i = 0; i < output.length; i++) {
            const object = output[i];
            const result = new Float32Array(outputLength);
            for (const p in object) {
                if (object.hasOwnProperty(p)) {
                    result[outputTable[p]] = object[p];
                }
            }
            results.push(result);
        }
        return results;
    }
    function objectToFloat32Arrays(object) {
        const result = [];
        for (const p in object) {
            if (!object.hasOwnProperty(p))
                continue;
            result.push(Float32Array.from([object[p]]));
        }
        return result;
    }
    function inputOutputObjectToFloat32Arrays(input, output) {
        const result = [];
        for (const p in input) {
            if (!input.hasOwnProperty(p))
                continue;
            result.push(Float32Array.from([input[p]]));
        }
        for (const p in output) {
            if (!output.hasOwnProperty(p))
                continue;
            result.push(Float32Array.from([output[p]]));
        }
        return result;
    }
    function objectToFloat32Array(object, table, length) {
        const result = new Float32Array(length);
        for (const p in object) {
            if (object.hasOwnProperty(p)) {
                result[table[p]] = object[p];
            }
        }
        return result;
    }

    function max(values) {
        if (Array.isArray(values) || values instanceof Float32Array) {
            return Math.max(...values);
        }
        else {
            return Math.max(...Object.values(values));
        }
    }

    function mse$1(errors) {
        // mean squared error
        let sum = 0;
        for (let i = 0; i < errors.length; i++) {
            sum += errors[i] ** 2;
        }
        return sum / errors.length;
    }

    function getTypedArrayFn(value, table) {
        if (value.buffer instanceof ArrayBuffer) {
            return null;
        }
        if (Array.isArray(value)) {
            return arrayToFloat32Array;
        }
        if (!table)
            throw new Error('table is not Object');
        const { length } = Object.keys(table);
        return (v) => {
            const array = new Float32Array(length);
            for (const p in table) {
                if (!table.hasOwnProperty(p))
                    continue;
                if (typeof v[p] !== 'number')
                    continue;
                array[table[p]] = v[p] || 0;
            }
            return array;
        };
    }
    function defaults$2() {
        return {
            inputSize: 0,
            outputSize: 0,
            binaryThresh: 0.5,
        };
    }
    function trainDefaults$2() {
        return {
            activation: 'sigmoid',
            iterations: 20000,
            errorThresh: 0.005,
            log: false,
            logPeriod: 10,
            leakyReluAlpha: 0.01,
            learningRate: 0.3,
            momentum: 0.1,
            callbackPeriod: 10,
            timeout: Infinity,
            beta1: 0.9,
            beta2: 0.999,
            epsilon: 1e-8,
        };
    }
    class NeuralNetwork {
        constructor(options = {}) {
            this.options = defaults$2();
            this.trainOpts = trainDefaults$2();
            this.sizes = [];
            this.outputLayer = -1;
            this.biases = [];
            this.weights = []; // weights for bias nodes
            this.outputs = [];
            // state for training
            this.deltas = [];
            this.changes = []; // for momentum
            this.errors = [];
            this.errorCheckInterval = 1;
            this.inputLookup = null;
            this.inputLookupLength = 0;
            this.outputLookup = null;
            this.outputLookupLength = 0;
            this._formatInput = null;
            this._formatOutput = null;
            this.runInput = (input) => {
                this.setActivation();
                return this.runInput(input);
            };
            this.calculateDeltas = (output) => {
                this.setActivation();
                return this.calculateDeltas(output);
            };
            // adam
            this.biasChangesLow = [];
            this.biasChangesHigh = [];
            this.changesLow = [];
            this.changesHigh = [];
            this.iterations = 0;
            this.options = { ...this.options, ...options };
            this.updateTrainingOptions(options);
            const { inputSize, hiddenLayers, outputSize } = this.options;
            if (inputSize && outputSize) {
                this.sizes = [inputSize].concat(hiddenLayers !== null && hiddenLayers !== void 0 ? hiddenLayers : []).concat([outputSize]);
            }
        }
        /**
         *
         * Expects this.sizes to have been set
         */
        initialize() {
            if (!this.sizes.length) {
                throw new Error('Sizes must be set before initializing');
            }
            this.outputLayer = this.sizes.length - 1;
            this.biases = new Array(this.outputLayer); // weights for bias nodes
            this.weights = new Array(this.outputLayer);
            this.outputs = new Array(this.outputLayer);
            // state for training
            this.deltas = new Array(this.outputLayer);
            this.changes = new Array(this.outputLayer); // for momentum
            this.errors = new Array(this.outputLayer);
            for (let layerIndex = 0; layerIndex <= this.outputLayer; layerIndex++) {
                const size = this.sizes[layerIndex];
                this.deltas[layerIndex] = zeros$1(size);
                this.errors[layerIndex] = zeros$1(size);
                this.outputs[layerIndex] = zeros$1(size);
                if (layerIndex > 0) {
                    this.biases[layerIndex] = randos(size);
                    this.weights[layerIndex] = new Array(size);
                    this.changes[layerIndex] = new Array(size);
                    for (let nodeIndex = 0; nodeIndex < size; nodeIndex++) {
                        const prevSize = this.sizes[layerIndex - 1];
                        this.weights[layerIndex][nodeIndex] = randos(prevSize);
                        this.changes[layerIndex][nodeIndex] = zeros$1(prevSize);
                    }
                }
            }
            this.setActivation();
            if (this.trainOpts.praxis === 'adam') {
                this._setupAdam();
            }
        }
        setActivation(activation) {
            const value = activation !== null && activation !== void 0 ? activation : this.trainOpts.activation;
            switch (value) {
                case 'sigmoid':
                    this.runInput = this._runInputSigmoid;
                    this.calculateDeltas = this._calculateDeltasSigmoid;
                    break;
                case 'relu':
                    this.runInput = this._runInputRelu;
                    this.calculateDeltas = this._calculateDeltasRelu;
                    break;
                case 'leaky-relu':
                    this.runInput = this._runInputLeakyRelu;
                    this.calculateDeltas = this._calculateDeltasLeakyRelu;
                    break;
                case 'tanh':
                    this.runInput = this._runInputTanh;
                    this.calculateDeltas = this._calculateDeltasTanh;
                    break;
                default:
                    throw new Error(`Unknown activation ${value}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`);
            }
        }
        get isRunnable() {
            return this.sizes.length > 0;
        }
        run(input) {
            if (!this.isRunnable) {
                throw new Error('network not runnable');
            }
            let formattedInput;
            if (this.inputLookup) {
                formattedInput = lookup.toArray(this.inputLookup, input, this.inputLookupLength);
            }
            else {
                formattedInput = input;
            }
            this.validateInput(formattedInput);
            const output = this.runInput(formattedInput).slice(0);
            if (this.outputLookup) {
                return lookup.toObject(this.outputLookup, output);
            }
            return output;
        }
        _runInputSigmoid(input) {
            this.outputs[0] = input; // set output state of input layer
            let output = null;
            for (let layer = 1; layer <= this.outputLayer; layer++) {
                const activeLayer = this.sizes[layer];
                const activeWeights = this.weights[layer];
                const activeBiases = this.biases[layer];
                const activeOutputs = this.outputs[layer];
                for (let node = 0; node < activeLayer; node++) {
                    const weights = activeWeights[node];
                    let sum = activeBiases[node];
                    for (let k = 0; k < weights.length; k++) {
                        sum += weights[k] * input[k];
                    }
                    // sigmoid
                    activeOutputs[node] = 1 / (1 + Math.exp(-sum));
                }
                output = input = activeOutputs;
            }
            if (!output) {
                throw new Error('output was empty');
            }
            return output;
        }
        _runInputRelu(input) {
            this.outputs[0] = input; // set output state of input layer
            let output = null;
            for (let layer = 1; layer <= this.outputLayer; layer++) {
                const activeSize = this.sizes[layer];
                const activeWeights = this.weights[layer];
                const activeBiases = this.biases[layer];
                const activeOutputs = this.outputs[layer];
                for (let node = 0; node < activeSize; node++) {
                    const weights = activeWeights[node];
                    let sum = activeBiases[node];
                    for (let k = 0; k < weights.length; k++) {
                        sum += weights[k] * input[k];
                    }
                    // relu
                    activeOutputs[node] = sum < 0 ? 0 : sum;
                }
                output = input = activeOutputs;
            }
            if (!output) {
                throw new Error('output was empty');
            }
            return output;
        }
        _runInputLeakyRelu(input) {
            this.outputs[0] = input; // set output state of input layer
            const { leakyReluAlpha } = this.trainOpts;
            let output = null;
            for (let layer = 1; layer <= this.outputLayer; layer++) {
                const activeSize = this.sizes[layer];
                const activeWeights = this.weights[layer];
                const activeBiases = this.biases[layer];
                const activeOutputs = this.outputs[layer];
                for (let node = 0; node < activeSize; node++) {
                    const weights = activeWeights[node];
                    let sum = activeBiases[node];
                    for (let k = 0; k < weights.length; k++) {
                        sum += weights[k] * input[k];
                    }
                    // leaky relu
                    activeOutputs[node] = Math.max(sum, leakyReluAlpha * sum);
                }
                output = input = activeOutputs;
            }
            if (!output) {
                throw new Error('output was empty');
            }
            return output;
        }
        _runInputTanh(input) {
            this.outputs[0] = input; // set output state of input layer
            let output = null;
            for (let layer = 1; layer <= this.outputLayer; layer++) {
                const activeSize = this.sizes[layer];
                const activeWeights = this.weights[layer];
                const activeBiases = this.biases[layer];
                const activeOutputs = this.outputs[layer];
                for (let node = 0; node < activeSize; node++) {
                    const weights = activeWeights[node];
                    let sum = activeBiases[node];
                    for (let k = 0; k < weights.length; k++) {
                        sum += weights[k] * input[k];
                    }
                    // tanh
                    activeOutputs[node] = Math.tanh(sum);
                }
                output = input = activeOutputs;
            }
            if (!output) {
                throw new Error('output was empty');
            }
            return output;
        }
        /**
         *
         * Verifies network sizes are initialized
         * If they are not it will initialize them based off the data set.
         */
        verifyIsInitialized(preparedData) {
            if (this.sizes.length && this.outputLayer > 0)
                return;
            this.sizes = [];
            this.sizes.push(preparedData[0].input.length);
            if (!this.options.hiddenLayers) {
                this.sizes.push(Math.max(3, Math.floor(preparedData[0].input.length / 2)));
            }
            else {
                this.options.hiddenLayers.forEach((size) => {
                    this.sizes.push(size);
                });
            }
            this.sizes.push(preparedData[0].output.length);
            this.initialize();
        }
        updateTrainingOptions(trainOpts) {
            const merged = { ...this.trainOpts, ...trainOpts };
            this.validateTrainingOptions(merged);
            this.trainOpts = merged;
            this.setLogMethod(this.trainOpts.log);
        }
        validateTrainingOptions(options) {
            const validations = {
                activation: () => {
                    return ['sigmoid', 'relu', 'leaky-relu', 'tanh'].includes(options.activation);
                },
                iterations: () => {
                    const val = options.iterations;
                    return typeof val === 'number' && val > 0;
                },
                errorThresh: () => {
                    const val = options.errorThresh;
                    return typeof val === 'number' && val > 0 && val < 1;
                },
                log: () => {
                    const val = options.log;
                    return typeof val === 'function' || typeof val === 'boolean';
                },
                logPeriod: () => {
                    const val = options.logPeriod;
                    return typeof val === 'number' && val > 0;
                },
                leakyReluAlpha: () => {
                    const val = options.leakyReluAlpha;
                    return typeof val === 'number' && val > 0 && val < 1;
                },
                learningRate: () => {
                    const val = options.learningRate;
                    return typeof val === 'number' && val > 0 && val < 1;
                },
                momentum: () => {
                    const val = options.momentum;
                    return typeof val === 'number' && val > 0 && val < 1;
                },
                callback: () => {
                    const val = options.callback;
                    return typeof val === 'function' || val === undefined;
                },
                callbackPeriod: () => {
                    const val = options.callbackPeriod;
                    return typeof val === 'number' && val > 0;
                },
                timeout: () => {
                    const val = options.timeout;
                    return typeof val === 'number' && val > 0;
                },
                praxis: () => {
                    const val = options.praxis;
                    return !val || val === 'adam';
                },
                beta1: () => {
                    const val = options.beta1;
                    return val > 0 && val < 1;
                },
                beta2: () => {
                    const val = options.beta2;
                    return val > 0 && val < 1;
                },
                epsilon: () => {
                    const val = options.epsilon;
                    return val > 0 && val < 1;
                },
            };
            for (const p in validations) {
                const v = options;
                if (!validations[p]()) {
                    throw new Error(`[${p}, ${v[p]}] is out of normal training range, your network will probably not train.`);
                }
            }
        }
        /**
         *
         *  Gets JSON of trainOpts object
         *    NOTE: Activation is stored directly on JSON object and not in the training options
         */
        getTrainOptsJSON() {
            const { activation, iterations, errorThresh, log, logPeriod, leakyReluAlpha, learningRate, momentum, callbackPeriod, timeout, praxis, beta1, beta2, epsilon, } = this.trainOpts;
            return {
                activation,
                iterations,
                errorThresh,
                log: typeof log === 'function'
                    ? true
                    : typeof log === 'boolean'
                        ? log
                        : false,
                logPeriod,
                leakyReluAlpha,
                learningRate,
                momentum,
                callbackPeriod,
                timeout: timeout === Infinity ? 'Infinity' : timeout,
                praxis,
                beta1,
                beta2,
                epsilon,
            };
        }
        setLogMethod(log) {
            if (typeof log === 'function') {
                this.trainOpts.log = log;
            }
            else if (log) {
                this.trainOpts.log = this.logTrainingStatus;
            }
            else {
                this.trainOpts.log = false;
            }
        }
        logTrainingStatus(status) {
            console.log(`iterations: ${status.iterations}, training error: ${status.error}`);
        }
        calculateTrainingError(data) {
            let sum = 0;
            for (let i = 0; i < data.length; ++i) {
                sum += this.trainPattern(data[i], true);
            }
            return sum / data.length;
        }
        trainPatterns(data) {
            for (let i = 0; i < data.length; ++i) {
                this.trainPattern(data[i]);
            }
        }
        trainingTick(data, status, endTime) {
            const { callback, callbackPeriod, errorThresh, iterations, log, logPeriod, } = this.trainOpts;
            if (status.iterations >= iterations ||
                status.error <= errorThresh ||
                Date.now() >= endTime) {
                return false;
            }
            status.iterations++;
            if (log && status.iterations % logPeriod === 0) {
                status.error = this.calculateTrainingError(data);
                log(status);
            }
            else if (status.iterations % this.errorCheckInterval === 0) {
                status.error = this.calculateTrainingError(data);
            }
            else {
                this.trainPatterns(data);
            }
            if (callback && status.iterations % callbackPeriod === 0) {
                callback({
                    iterations: status.iterations,
                    error: status.error,
                });
            }
            return true;
        }
        prepTraining(data, options = {}) {
            this.updateTrainingOptions(options);
            const preparedData = this.formatData(data);
            const endTime = Date.now() + this.trainOpts.timeout;
            const status = {
                error: 1,
                iterations: 0,
            };
            this.verifyIsInitialized(preparedData);
            this.validateData(preparedData);
            return {
                preparedData,
                status,
                endTime,
            };
        }
        train(data, options = {}) {
            const { preparedData, status, endTime } = this.prepTraining(data, options);
            while (true) {
                if (!this.trainingTick(preparedData, status, endTime)) {
                    break;
                }
            }
            return status;
        }
        async trainAsync(data, options = {}) {
            const { preparedData, status, endTime } = this.prepTraining(data, options);
            return await new Promise((resolve, reject) => {
                try {
                    const thawedTrain = new browser.Thaw(new Array(this.trainOpts.iterations), {
                        delay: true,
                        each: () => this.trainingTick(preparedData, status, endTime) ||
                            thawedTrain.stop(),
                        done: () => resolve(status),
                    });
                    thawedTrain.tick();
                }
                catch (trainError) {
                    reject(trainError);
                }
            });
        }
        trainPattern(value, logErrorRate) {
            // forward propagate
            this.runInput(value.input);
            // back propagate
            this.calculateDeltas(value.output);
            this.adjustWeights();
            if (logErrorRate) {
                return mse$1(this.errors[this.outputLayer]);
            }
            return null;
        }
        _calculateDeltasSigmoid(target) {
            for (let layer = this.outputLayer; layer >= 0; layer--) {
                const activeSize = this.sizes[layer];
                const activeOutput = this.outputs[layer];
                const activeError = this.errors[layer];
                const activeDeltas = this.deltas[layer];
                const nextLayer = this.weights[layer + 1];
                for (let node = 0; node < activeSize; node++) {
                    const output = activeOutput[node];
                    let error = 0;
                    if (layer === this.outputLayer) {
                        error = target[node] - output;
                    }
                    else {
                        const deltas = this.deltas[layer + 1];
                        for (let k = 0; k < deltas.length; k++) {
                            error += deltas[k] * nextLayer[k][node];
                        }
                    }
                    activeError[node] = error;
                    activeDeltas[node] = error * output * (1 - output);
                }
            }
        }
        _calculateDeltasRelu(target) {
            for (let layer = this.outputLayer; layer >= 0; layer--) {
                const currentSize = this.sizes[layer];
                const currentOutputs = this.outputs[layer];
                const nextWeights = this.weights[layer + 1];
                const nextDeltas = this.deltas[layer + 1];
                const currentErrors = this.errors[layer];
                const currentDeltas = this.deltas[layer];
                for (let node = 0; node < currentSize; node++) {
                    const output = currentOutputs[node];
                    let error = 0;
                    if (layer === this.outputLayer) {
                        error = target[node] - output;
                    }
                    else {
                        for (let k = 0; k < nextDeltas.length; k++) {
                            error += nextDeltas[k] * nextWeights[k][node];
                        }
                    }
                    currentErrors[node] = error;
                    currentDeltas[node] = output > 0 ? error : 0;
                }
            }
        }
        _calculateDeltasLeakyRelu(target) {
            const alpha = this.trainOpts.leakyReluAlpha;
            for (let layer = this.outputLayer; layer >= 0; layer--) {
                const currentSize = this.sizes[layer];
                const currentOutputs = this.outputs[layer];
                const nextDeltas = this.deltas[layer + 1];
                const nextWeights = this.weights[layer + 1];
                const currentErrors = this.errors[layer];
                const currentDeltas = this.deltas[layer];
                for (let node = 0; node < currentSize; node++) {
                    const output = currentOutputs[node];
                    let error = 0;
                    if (layer === this.outputLayer) {
                        error = target[node] - output;
                    }
                    else {
                        for (let k = 0; k < nextDeltas.length; k++) {
                            error += nextDeltas[k] * nextWeights[k][node];
                        }
                    }
                    currentErrors[node] = error;
                    currentDeltas[node] = output > 0 ? error : alpha * error;
                }
            }
        }
        _calculateDeltasTanh(target) {
            for (let layer = this.outputLayer; layer >= 0; layer--) {
                const currentSize = this.sizes[layer];
                const currentOutputs = this.outputs[layer];
                const nextDeltas = this.deltas[layer + 1];
                const nextWeights = this.weights[layer + 1];
                const currentErrors = this.errors[layer];
                const currentDeltas = this.deltas[layer];
                for (let node = 0; node < currentSize; node++) {
                    const output = currentOutputs[node];
                    let error = 0;
                    if (layer === this.outputLayer) {
                        error = target[node] - output;
                    }
                    else {
                        for (let k = 0; k < nextDeltas.length; k++) {
                            error += nextDeltas[k] * nextWeights[k][node];
                        }
                    }
                    currentErrors[node] = error;
                    currentDeltas[node] = (1 - output * output) * error;
                }
            }
        }
        /**
         *
         * Changes weights of networks
         */
        adjustWeights() {
            const { learningRate, momentum } = this.trainOpts;
            for (let layer = 1; layer <= this.outputLayer; layer++) {
                const incoming = this.outputs[layer - 1];
                const activeSize = this.sizes[layer];
                const activeDelta = this.deltas[layer];
                const activeChanges = this.changes[layer];
                const activeWeights = this.weights[layer];
                const activeBiases = this.biases[layer];
                for (let node = 0; node < activeSize; node++) {
                    const delta = activeDelta[node];
                    for (let k = 0; k < incoming.length; k++) {
                        let change = activeChanges[node][k];
                        change = learningRate * delta * incoming[k] + momentum * change;
                        activeChanges[node][k] = change;
                        activeWeights[node][k] += change;
                    }
                    activeBiases[node] += learningRate * delta;
                }
            }
        }
        _setupAdam() {
            this.biasChangesLow = [];
            this.biasChangesHigh = [];
            this.changesLow = [];
            this.changesHigh = [];
            this.iterations = 0;
            for (let layer = 0; layer <= this.outputLayer; layer++) {
                const size = this.sizes[layer];
                if (layer > 0) {
                    this.biasChangesLow[layer] = zeros$1(size);
                    this.biasChangesHigh[layer] = zeros$1(size);
                    this.changesLow[layer] = new Array(size);
                    this.changesHigh[layer] = new Array(size);
                    for (let node = 0; node < size; node++) {
                        const prevSize = this.sizes[layer - 1];
                        this.changesLow[layer][node] = zeros$1(prevSize);
                        this.changesHigh[layer][node] = zeros$1(prevSize);
                    }
                }
            }
            this.adjustWeights = this._adjustWeightsAdam;
        }
        _adjustWeightsAdam() {
            this.iterations++;
            const { iterations } = this;
            const { beta1, beta2, epsilon, learningRate } = this.trainOpts;
            for (let layer = 1; layer <= this.outputLayer; layer++) {
                const incoming = this.outputs[layer - 1];
                const currentSize = this.sizes[layer];
                const currentDeltas = this.deltas[layer];
                const currentChangesLow = this.changesLow[layer];
                const currentChangesHigh = this.changesHigh[layer];
                const currentWeights = this.weights[layer];
                const currentBiases = this.biases[layer];
                const currentBiasChangesLow = this.biasChangesLow[layer];
                const currentBiasChangesHigh = this.biasChangesHigh[layer];
                for (let node = 0; node < currentSize; node++) {
                    const delta = currentDeltas[node];
                    for (let k = 0; k < incoming.length; k++) {
                        const gradient = delta * incoming[k];
                        const changeLow = currentChangesLow[node][k] * beta1 + (1 - beta1) * gradient;
                        const changeHigh = currentChangesHigh[node][k] * beta2 +
                            (1 - beta2) * gradient * gradient;
                        const momentumCorrection = changeLow / (1 - Math.pow(beta1, iterations));
                        const gradientCorrection = changeHigh / (1 - Math.pow(beta2, iterations));
                        currentChangesLow[node][k] = changeLow;
                        currentChangesHigh[node][k] = changeHigh;
                        currentWeights[node][k] +=
                            (learningRate * momentumCorrection) /
                                (Math.sqrt(gradientCorrection) + epsilon);
                    }
                    const biasGradient = currentDeltas[node];
                    const biasChangeLow = currentBiasChangesLow[node] * beta1 + (1 - beta1) * biasGradient;
                    const biasChangeHigh = currentBiasChangesHigh[node] * beta2 +
                        (1 - beta2) * biasGradient * biasGradient;
                    const biasMomentumCorrection = currentBiasChangesLow[node] / (1 - Math.pow(beta1, iterations));
                    const biasGradientCorrection = currentBiasChangesHigh[node] / (1 - Math.pow(beta2, iterations));
                    currentBiasChangesLow[node] = biasChangeLow;
                    currentBiasChangesHigh[node] = biasChangeHigh;
                    currentBiases[node] +=
                        (learningRate * biasMomentumCorrection) /
                            (Math.sqrt(biasGradientCorrection) + epsilon);
                }
            }
        }
        validateData(data) {
            const inputSize = this.sizes[0];
            const outputSize = this.sizes[this.sizes.length - 1];
            const { length } = data;
            for (let i = 0; i < length; i++) {
                const { input, output } = data[i];
                if (input.length !== inputSize) {
                    throw new Error(`input at index ${i} length ${input.length} must be ${inputSize}`);
                }
                if (data[i].output.length !== outputSize) {
                    throw new Error(`output at index ${i} length ${output.length} must be ${outputSize}`);
                }
            }
        }
        validateInput(formattedInput) {
            const inputSize = this.sizes[0];
            if (formattedInput.length !== inputSize) {
                throw new Error(`input length ${formattedInput.length} must match options.inputSize of ${inputSize}`);
            }
        }
        formatData(data) {
            if (!Array.isArray(data[0].input)) {
                if (this.inputLookup) {
                    this.inputLookupLength = Object.keys(this.inputLookup).length;
                }
                else {
                    const inputLookup = new LookupTable(data, 'input');
                    this.inputLookup = inputLookup.table;
                    this.inputLookupLength = inputLookup.length;
                }
            }
            if (!Array.isArray(data[0].output)) {
                if (this.outputLookup) {
                    this.outputLookupLength = Object.keys(this.outputLookup).length;
                }
                else {
                    const lookup = new LookupTable(data, 'output');
                    this.outputLookup = lookup.table;
                    this.outputLookupLength = lookup.length;
                }
            }
            if (!this._formatInput) {
                this._formatInput = getTypedArrayFn(data[0].input, this.inputLookup);
            }
            if (!this._formatOutput) {
                this._formatOutput = getTypedArrayFn(data[0].output, this.outputLookup);
            }
            // turn sparse hash input into arrays with 0s as filler
            if (this._formatInput && this._formatOutput) {
                const result = [];
                for (let i = 0; i < data.length; i++) {
                    result.push({
                        input: this._formatInput(data[i].input),
                        output: this._formatOutput(data[i].output),
                    });
                }
                return result;
            }
            if (this._formatInput) {
                const result = [];
                for (let i = 0; i < data.length; i++) {
                    result.push({
                        input: this._formatInput(data[i].input),
                        output: data[i].output,
                    });
                }
                return result;
            }
            if (this._formatOutput) {
                const result = [];
                for (let i = 0; i < data.length; i++) {
                    result.push({
                        input: data[i].input,
                        output: this._formatOutput(data[i].output),
                    });
                }
                return result;
            }
            return data;
        }
        addFormat(data) {
            var _a, _b;
            if (!Array.isArray(data.input) || typeof data.input[0] !== 'number') {
                this.inputLookup = lookup.addKeys(data.input, (_a = this.inputLookup) !== null && _a !== void 0 ? _a : {});
                if (this.inputLookup) {
                    this.inputLookupLength = Object.keys(this.inputLookup).length;
                }
            }
            if (!Array.isArray(data.output) || typeof data.output[0] !== 'number') {
                this.outputLookup = lookup.addKeys(data.output, (_b = this.outputLookup) !== null && _b !== void 0 ? _b : {});
                if (this.outputLookup) {
                    this.outputLookupLength = Object.keys(this.outputLookup).length;
                }
            }
        }
        test(data) {
            const { preparedData } = this.prepTraining(data);
            // for binary classification problems with one output node
            const isBinary = preparedData[0].output.length === 1;
            // for classification problems
            const misclasses = [];
            // run each pattern through the trained network and collect
            // error and misclassification statistics
            let errorSum = 0;
            if (isBinary) {
                let falsePos = 0;
                let falseNeg = 0;
                let truePos = 0;
                let trueNeg = 0;
                for (let i = 0; i < preparedData.length; i++) {
                    const output = this.runInput(preparedData[i].input);
                    const target = preparedData[i].output;
                    const actual = output[0] > this.options.binaryThresh ? 1 : 0;
                    const expected = target[0];
                    if (actual !== expected) {
                        const misclass = preparedData[i];
                        misclasses.push({
                            input: misclass.input,
                            output: misclass.output,
                            actual,
                            expected,
                        });
                    }
                    if (actual === 0 && expected === 0) {
                        trueNeg++;
                    }
                    else if (actual === 1 && expected === 1) {
                        truePos++;
                    }
                    else if (actual === 0 && expected === 1) {
                        falseNeg++;
                    }
                    else if (actual === 1 && expected === 0) {
                        falsePos++;
                    }
                    errorSum += mse$1(output.map((value, i) => {
                        return target[i] - value;
                    }));
                }
                return {
                    error: errorSum / preparedData.length,
                    misclasses,
                    total: preparedData.length,
                    trueNeg,
                    truePos,
                    falseNeg,
                    falsePos,
                    precision: truePos > 0 ? truePos / (truePos + falsePos) : 0,
                    recall: truePos > 0 ? truePos / (truePos + falseNeg) : 0,
                    accuracy: (trueNeg + truePos) / preparedData.length,
                };
            }
            for (let i = 0; i < preparedData.length; i++) {
                const output = this.runInput(preparedData[i].input);
                const target = preparedData[i].output;
                const actual = output.indexOf(max(output));
                const expected = target.indexOf(max(target));
                if (actual !== expected) {
                    const misclass = preparedData[i];
                    misclasses.push({
                        input: misclass.input,
                        output: misclass.output,
                        actual,
                        expected,
                    });
                }
                errorSum += mse$1(output.map((value, i) => {
                    return target[i] - value;
                }));
            }
            return {
                error: errorSum / preparedData.length,
                misclasses,
                total: preparedData.length,
            };
        }
        toJSON() {
            var _a, _b;
            if (!this.isRunnable) {
                this.initialize();
            }
            // use Array.from, keeping json small
            const jsonLayerWeights = this.weights.map((layerWeights) => {
                return layerWeights.map((layerWeights) => Array.from(layerWeights));
            });
            const jsonLayerBiases = this.biases.map((layerBiases) => Array.from(layerBiases));
            const jsonLayers = [];
            const outputLength = this.sizes.length - 1;
            for (let i = 0; i <= outputLength; i++) {
                jsonLayers.push({
                    weights: (_a = jsonLayerWeights[i]) !== null && _a !== void 0 ? _a : [],
                    biases: (_b = jsonLayerBiases[i]) !== null && _b !== void 0 ? _b : [],
                });
            }
            return {
                type: 'NeuralNetwork',
                sizes: [...this.sizes],
                layers: jsonLayers,
                inputLookup: this.inputLookup ? { ...this.inputLookup } : null,
                inputLookupLength: this.inputLookupLength,
                outputLookup: this.outputLookup ? { ...this.outputLookup } : null,
                outputLookupLength: this.outputLookupLength,
                options: { ...this.options },
                trainOpts: this.getTrainOptsJSON(),
            };
        }
        fromJSON(json) {
            this.options = { ...defaults$2(), ...json.options };
            if (json.hasOwnProperty('trainOpts')) {
                const trainOpts = {
                    ...json.trainOpts,
                    timeout: json.trainOpts.timeout === 'Infinity'
                        ? Infinity
                        : json.trainOpts.timeout,
                };
                this.updateTrainingOptions(trainOpts);
            }
            this.sizes = json.sizes;
            this.initialize();
            this.inputLookup = json.inputLookup ? { ...json.inputLookup } : null;
            this.inputLookupLength = json.inputLookupLength;
            this.outputLookup = json.outputLookup ? { ...json.outputLookup } : null;
            this.outputLookupLength = json.outputLookupLength;
            const jsonLayers = json.layers;
            const layerWeights = this.weights.map((layerWeights, layerIndex) => {
                return jsonLayers[layerIndex].weights.map((layerWeights) => Float32Array.from(layerWeights));
            });
            const layerBiases = this.biases.map((layerBiases, layerIndex) => Float32Array.from(jsonLayers[layerIndex].biases));
            for (let i = 0; i <= this.outputLayer; i++) {
                this.weights[i] = layerWeights[i] || [];
                this.biases[i] = layerBiases[i] || [];
            }
            return this;
        }
        toFunction(cb) {
            const { activation, leakyReluAlpha } = this.trainOpts;
            let needsVar = false;
            const nodeHandle = (layerIndex, nodeIndex) => {
                if (layerIndex === 0) {
                    return `(input[${nodeIndex}]||0)`;
                }
                const weights = this.weights[layerIndex][nodeIndex];
                const bias = this.biases[layerIndex][nodeIndex];
                if (!weights) {
                    throw new Error(`weights at layerIndex ${layerIndex} & nodeIndex ${nodeIndex} not found`);
                }
                if (!bias) {
                    throw new Error(`bias as layerIndex ${layerIndex} & nodeIndex ${nodeIndex} not found`);
                }
                const weightsArray = [];
                weights.forEach((weight, subNodeIndex) => {
                    if (weight < 0) {
                        weightsArray.push(`${weight}*${nodeHandle(layerIndex - 1, subNodeIndex)}`);
                    }
                    else {
                        weightsArray.push(`+${weight}*${nodeHandle(layerIndex - 1, subNodeIndex)}`);
                    }
                });
                const result = `(${bias.toString()}${weightsArray.join('')})`;
                switch (activation) {
                    case 'sigmoid':
                        return `1/(1+1/Math.exp(${result}))`;
                    case 'relu': {
                        needsVar = true;
                        return `((v=${result})<0?0:v)`;
                    }
                    case 'leaky-relu': {
                        needsVar = true;
                        return `Math.max((v=${result}),${leakyReluAlpha}*v)`;
                    }
                    case 'tanh':
                        return `Math.tanh(${result})`;
                    default:
                        throw new Error(`Unknown activation ${activation}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`);
                }
            };
            function checkKeys(keys) {
                if (keys.find((v) => v.includes('"'))) {
                    throw new Error(`key contains '"', which is not compatible`);
                }
            }
            const layersAsMath = [];
            let result;
            let inputLookup = '';
            if (this.inputLookup) {
                const keys = Object.keys(this.inputLookup);
                checkKeys(keys);
                inputLookup = `input = new Float32Array([${Object.keys(this.inputLookup)
                .map((key) => `input["${key}"]`)
                .join(',')}]);`;
            }
            if (this.sizes.length < 1)
                throw new Error('No layers');
            for (let nodeIndex = 0; nodeIndex < this.sizes[this.outputLayer]; nodeIndex++) {
                layersAsMath.push(nodeHandle(this.outputLayer, nodeIndex));
            }
            if (this.outputLookup) {
                const keys = Object.keys(this.outputLookup);
                checkKeys(keys);
                const values = keys
                    .map((key, i) => `"${key}":${layersAsMath[i]}`)
                    .join(',');
                result = `{${values}}`;
            }
            else {
                result = `[${layersAsMath.join(',')}]`;
            }
            const source = `${inputLookup}${needsVar ? 'var v;' : ''}return ${result};`;
            // eslint-disable-next-line @typescript-eslint/no-implied-eval,no-new-func
            return new Function('input', cb ? cb(source) : source);
        }
    }

    function weightedSumSigmoid(weights, biases, inputs) {
        let sum = biases[this.thread.x];
        for (let k = 0; k < this.constants.size; k++) {
            sum += weights[this.thread.x][k] * inputs[k];
        }
        // sigmoid
        return 1 / (1 + Math.exp(-sum));
    }
    function weightedSumRelu(weights, biases, inputs) {
        let sum = biases[this.thread.x];
        for (let k = 0; k < this.constants.size; k++) {
            sum += weights[this.thread.x][k] * inputs[k];
        }
        // relu
        return sum < 0 ? 0 : sum;
    }
    function weightedSumLeakyRelu(weights, biases, inputs) {
        let sum = biases[this.thread.x];
        for (let k = 0; k < this.constants.size; k++) {
            sum += weights[this.thread.x][k] * inputs[k];
        }
        // leaky relu
        return sum < 0 ? 0 : 0.01 * sum;
    }
    function weightedSumTanh(weights, biases, inputs) {
        let sum = biases[this.thread.x];
        for (let k = 0; k < this.constants.size; k++) {
            sum += weights[this.thread.x][k] * inputs[k];
        }
        // tanh
        return Math.tanh(sum);
    }
    function calcErrorOutput(output, target) {
        return target - output;
    }
    function calcDeltasSigmoid(error, output) {
        // sigmoid derivative
        return error * output * (1 - output);
    }
    function calcDeltasRelu(error, output) {
        // relu derivative
        return output > 0 ? error : 0;
    }
    function calcDeltasLeakyRelu(error, output) {
        // leaky relu derivative
        return output > 0 ? error : 0.01 * error;
    }
    function calcDeltasTanh(error, output) {
        // tanh derivative
        return (1 - output * output) * error;
    }
    function calcError(x, size, nextWeights, nextDeltas) {
        let error = 0;
        for (let k = 0; k < size; k++) {
            error += nextDeltas[k] * nextWeights[k][x];
        }
        return error;
    }
    function calcChanges(learningRate, momentum, previousChange, delta, previousOutput) {
        return learningRate * delta * previousOutput + momentum * previousChange;
    }
    function addWeights(change, weight) {
        return change + weight;
    }
    function addBiases(biases, deltas) {
        return (biases[this.thread.x] + deltas[this.thread.x] * this.constants.learningRate);
    }
    // mean squared error, reimplemented for GPU
    function mse(errors) {
        let sum = 0;
        for (let i = 0; i < this.constants.size; i++) {
            sum += errors[i] ** 2;
        }
        return sum / this.constants.size;
    }
    class NeuralNetworkGPU extends NeuralNetwork {
        constructor(options = {}) {
            super(options);
            this.texturizeInputData = () => {
                throw new Error('not yet setup');
            };
            this.forwardPropagate = [];
            this.backwardPropagate = [];
            this.changesPropagate = [];
            this.biasesPropagate = [];
            this.getMSE = () => {
                throw new Error('not yet setup');
            };
            this._addMSE = () => {
                throw new Error('not yet setup');
            };
            this._divideMSESum = () => {
                throw new Error('not yet setup');
            };
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            this.outputs = [];
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            this.deltas = [];
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            this.errors = [];
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            this.weights = [];
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            this.changes = [];
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            this.biases = [];
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            this.runInput = (input) => {
                let output;
                this.outputs[0] = input;
                for (let layer = 1; layer <= this.outputLayer; layer++) {
                    release(this.outputs[layer]);
                    this.outputs[layer] = this.forwardPropagate[layer](this.weights[layer], this.biases[layer], input);
                    output = input = this.outputs[layer];
                }
                return output;
            };
            this.calculateDeltas = (target) => {
                for (let layer = this.outputLayer; layer > 0; layer--) {
                    release(this.deltas[layer]);
                    release(this.errors[layer]);
                    let output;
                    if (layer === this.outputLayer) {
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-expect-error
                        output = this.backwardPropagate[layer](this.outputs[layer], target);
                    }
                    else {
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-expect-error
                        output = this.backwardPropagate[layer](this.weights[layer + 1], this.outputs[layer], this.deltas[layer + 1]);
                    }
                    this.deltas[layer] = output.result;
                    this.errors[layer] = output.error;
                }
            };
            this.errorCheckInterval = 100;
            this.gpu = new gpuBrowser.GPU({ mode: options.mode });
        }
        initialize() {
            super.initialize();
            this.buildRunInput();
            this.buildCalculateDeltas();
            this.buildGetChanges();
            this.buildChangeBiases();
            this.buildGetMSE();
        }
        setActivation() { }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        trainPattern(value, logErrorRate) {
            // forward propagate
            this.runInput(value.input);
            // back propagate
            this.calculateDeltas(value.output);
            this.adjustWeights();
            if (logErrorRate) {
                return this.getMSE(this.errors[this.outputLayer]);
            }
            return null;
        }
        calculateTrainingError(data) {
            let sum = new Float32Array([0]);
            for (let i = 0; i < data.length; ++i) {
                const prevSum = sum;
                const error = this.trainPattern(data[i], true);
                sum = this._addMSE(sum, error);
                release(error);
                release(prevSum);
            }
            const result = this._divideMSESum(data.length, sum);
            release(sum);
            return (result instanceof gpuBrowser.Texture
                ? result.toArray()
                : result)[0];
        }
        adjustWeights() {
            this.getChanges();
            this.changeBiases();
        }
        buildRunInput() {
            let weightedSum = null;
            switch (this.trainOpts.activation) {
                case 'sigmoid':
                    weightedSum = weightedSumSigmoid;
                    break;
                case 'relu':
                    weightedSum = weightedSumRelu;
                    break;
                case 'leaky-relu':
                    weightedSum = weightedSumLeakyRelu;
                    break;
                case 'tanh':
                    weightedSum = weightedSumTanh;
                    break;
                default:
                    throw new Error(`Unknown activation ${this.trainOpts.activation}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`);
            }
            for (let layer = 1; layer <= this.outputLayer; layer++) {
                this.forwardPropagate[layer] = this.gpu.createKernel(weightedSum, {
                    output: [this.sizes[layer]],
                    pipeline: true,
                    constants: {
                        size: this.sizes[layer - 1],
                    },
                    immutable: true,
                });
            }
            this.texturizeInputData = this.gpu.createKernel(function (value) {
                return value[this.thread.x];
            }, {
                output: [this.sizes[1]],
                pipeline: true,
                immutable: true,
            });
        }
        buildCalculateDeltas() {
            let calcDeltas;
            switch (this.trainOpts.activation) {
                case 'sigmoid':
                    calcDeltas = calcDeltasSigmoid;
                    break;
                case 'relu':
                    calcDeltas = calcDeltasRelu;
                    break;
                case 'leaky-relu':
                    calcDeltas = calcDeltasLeakyRelu;
                    break;
                case 'tanh':
                    calcDeltas = calcDeltasTanh;
                    break;
                default:
                    throw new Error(`Unknown activation ${this.trainOpts.activation}. Available activations are: 'sigmoid', 'relu', 'leaky-relu', 'tanh'`);
            }
            calcDeltas = gpuBrowser.alias(gpuBrowser.utils.getMinifySafeName(() => calcDeltas), calcDeltas);
            this.gpu.addFunction(calcDeltas);
            for (let layer = this.outputLayer; layer > 0; layer--) {
                if (layer === this.outputLayer) {
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-expect-error
                    this.backwardPropagate[this.outputLayer] = this.gpu.createKernelMap({
                        error: calcErrorOutput,
                    }, function (outputs, targets) {
                        const output = outputs[this.thread.x];
                        const target = targets[this.thread.x];
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-expect-error
                        return calcDeltas(calcErrorOutput(output, target), output);
                    }, {
                        output: [this.sizes[this.outputLayer]],
                        pipeline: true,
                        immutable: true,
                    });
                }
                else {
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-expect-error
                    this.backwardPropagate[layer] = this.gpu.createKernelMap({
                        error: calcError,
                    }, function (nextWeights, outputs, nextDeltas) {
                        const output = outputs[this.thread.x];
                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                        // @ts-expect-error
                        return calcDeltas(calcError(this.thread.x, this.constants.size, nextWeights, nextDeltas), output);
                    }, {
                        output: [this.sizes[layer]],
                        pipeline: true,
                        constants: {
                            size: this.sizes[layer + 1],
                        },
                        immutable: true,
                    });
                }
            }
        }
        buildGetChanges() {
            for (let layer = 1; layer <= this.outputLayer; layer++) {
                // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                // @ts-expect-error
                this.changesPropagate[layer] = this.gpu.createKernelMap({
                    weights: addWeights,
                    changes: calcChanges,
                }, function (previousOutputs, deltas, weights, previousChanges) {
                    const change = calcChanges(this.constants.learningRate, this.constants.momentum, previousChanges[this.thread.y][this.thread.x], deltas[this.thread.y], previousOutputs[this.thread.x]);
                    return addWeights(change, weights[this.thread.y][this.thread.x]);
                }, {
                    output: [this.sizes[layer - 1], this.sizes[layer]],
                    pipeline: true,
                    constants: {
                        size: this.sizes[layer - 1],
                        learningRate: this.trainOpts.learningRate,
                        momentum: this.trainOpts.momentum,
                    },
                    immutable: true,
                });
            }
        }
        getChanges() {
            for (let layer = 1; layer <= this.outputLayer; layer++) {
                const weights = this.weights[layer];
                const changes = this.changes[layer];
                const output = this.changesPropagate[layer](this.outputs[layer - 1], this.deltas[layer], weights, changes);
                release(weights);
                release(changes);
                this.weights[layer] = output.weights;
                this.changes[layer] = output.changes;
                release(output.result);
            }
        }
        buildChangeBiases() {
            for (let layer = 1; layer <= this.outputLayer; layer++) {
                this.biasesPropagate[layer] = this.gpu.createKernel(addBiases, {
                    output: [this.sizes[layer]],
                    pipeline: true,
                    constants: {
                        learningRate: this.trainOpts.learningRate,
                    },
                    immutable: true,
                });
            }
        }
        changeBiases() {
            for (let layer = 1; layer <= this.outputLayer; layer++) {
                const biases = this.biases[layer];
                this.biases[layer] = this.biasesPropagate[layer](biases, this.deltas[layer]);
                release(biases);
            }
        }
        buildGetMSE() {
            this.getMSE = this.gpu.createKernel(mse, {
                output: [1],
                constants: {
                    size: this.sizes[this.outputLayer],
                },
                pipeline: true,
                immutable: true,
            });
            this._addMSE = this.gpu.createKernel(function (value1, value2) {
                return value1[0] + value2[0];
            }, {
                output: [1],
                pipeline: true,
                immutable: true,
            });
            this._divideMSESum = this.gpu.createKernel(function (length, mseSum) {
                const value = mseSum[0];
                if (value > 0) {
                    return value / length;
                }
                return 0;
            }, {
                output: [1],
            });
        }
        run(input) {
            if (!this.isRunnable) {
                throw new Error('network not runnable');
            }
            let formattedInput;
            if (this.inputLookup) {
                formattedInput = lookup.toArray(this.inputLookup, input, this.inputLookupLength);
            }
            else {
                formattedInput = input;
            }
            this.validateInput(formattedInput);
            const outputTextures = this.runInput(formattedInput);
            const output = outputTextures instanceof gpuBrowser.Texture
                ? outputTextures.toArray()
                : outputTextures;
            if (this.outputLookup) {
                return lookup.toObject(this.outputLookup, output);
            }
            return output;
        }
        // @ts-expect-error the underlying network works as normal, but we are working on the GPU
        prepTraining(data, options = {}) {
            this.updateTrainingOptions(options);
            const preparedData = this.formatData(data);
            const endTime = Date.now() + this.trainOpts.timeout;
            const status = {
                error: 1,
                iterations: 0,
            };
            this.verifyIsInitialized(preparedData);
            const texturizeOutputData = this.gpu.createKernel(function (value) {
                return value[this.thread.x];
            }, {
                output: [preparedData[0].output.length],
                pipeline: true,
                immutable: true,
            });
            return {
                preparedData: preparedData.map((set) => ({
                    input: this.texturizeInputData(set.input),
                    output: texturizeOutputData(set.output),
                })),
                status,
                endTime,
            };
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        toFunction() {
            throw new Error(`${this.constructor.name}-toFunction is not yet implemented`);
        }
        toJSON() {
            var _a, _b;
            if (this.sizes === null) {
                this.initialize();
            }
            // use Array.from, keeping json small
            const jsonLayerWeights = this.weights.map((layerWeights) => {
                return (layerWeights instanceof gpuBrowser.Texture
                    ? layerWeights.toArray()
                    : layerWeights).map((layerWeights) => Array.from(layerWeights));
            });
            const jsonLayerBiases = this.biases.map((layerBiases) => Array.from(layerBiases instanceof gpuBrowser.Texture
                ? layerBiases.toArray()
                : layerBiases));
            const jsonLayers = [];
            for (let i = 0; i <= this.outputLayer; i++) {
                jsonLayers.push({
                    weights: (_a = jsonLayerWeights[i]) !== null && _a !== void 0 ? _a : [],
                    biases: (_b = jsonLayerBiases[i]) !== null && _b !== void 0 ? _b : [],
                });
            }
            return {
                type: 'NeuralNetworkGPU',
                sizes: [...this.sizes],
                layers: jsonLayers,
                inputLookup: this.inputLookup ? { ...this.inputLookup } : null,
                inputLookupLength: this.inputLookupLength,
                outputLookup: this.outputLookup ? { ...this.outputLookup } : null,
                outputLookupLength: this.outputLookupLength,
                options: { ...this.options },
                trainOpts: this.getTrainOptsJSON(),
            };
        }
    }

    class RecurrentConnection extends Internal {
        constructor() {
            super(...arguments);
            this.settings = {};
            this.layer = null;
        }
        setLayer(layer) {
            this.layer = layer;
        }
        get width() {
            if (!this.layer)
                throw new Error('layer not set');
            return this.layer.width;
        }
        set width(value) {
            throw new Error(`${this.constructor.name}-width is not yet implemented`);
        }
        get height() {
            if (!this.layer)
                throw new Error('layer not set');
            return this.layer.height;
        }
        set height(value) {
            throw new Error(`${this.constructor.name}-height is not yet implemented`);
        }
        get deltas() {
            if (!this.layer)
                throw new Error('layer not set');
            return this.layer.deltas;
        }
        set deltas(deltas) {
            if (!this.layer)
                throw new Error('layer not set');
            release(this.layer.deltas);
            this.layer.deltas = deltas;
        }
        get weights() {
            if (!this.layer)
                throw new Error('layer not set');
            return this.layer.weights;
        }
        set weights(weights) {
            if (!this.layer)
                throw new Error('layer not set');
            release(this.layer.weights);
            this.layer.weights = weights;
        }
        predict() {
            // throw new Error(`${this.constructor.name}-predict is not yet implemented`)
        }
        compare() {
            // throw new Error(`${this.constructor.name}-compare is not yet implemented`)
        }
        learn() {
            throw new Error('no longer using');
        }
        setupKernels() {
            // throw new Error(
            //   `${this.constructor.name}-setupKernels is not yet implemented`
            // )
        }
        reuseKernels() {
            // throw new Error(
            //   `${this.constructor.name}-reuseKernels is not yet implemented`
            // )
        }
    }

    class Recurrent extends FeedForward {
        // TODO: use generics in extend
        constructor(options = {}) {
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            super(options);
            this.trainOpts = {};
            this._outputConnection = null;
            this._layerSets = [];
            this._hiddenLayerOutputIndices = [];
            this._model = null;
        }
        _connectLayers() {
            if (!this.options.inputLayer) {
                throw new Error('inputLayer not found');
            }
            if (!this.options.outputLayer) {
                throw new Error('outputLayer not found');
            }
            const inputLayer = this.options.inputLayer();
            const hiddenLayers = this._connectHiddenLayers(inputLayer);
            const outputLayer = this.options.outputLayer(hiddenLayers[hiddenLayers.length - 1], -1);
            return {
                inputLayer,
                hiddenLayers,
                outputLayer,
            };
        }
        _connectLayersDeep() {
            const layers = [];
            const previousLayers = this._layerSets[this._layerSets.length - 1];
            let usedHiddenLayerOutputIndex = 0;
            function findInputLayer(inputLayer) {
                const index = previousLayers.indexOf(inputLayer);
                if (index < 0)
                    throw new Error('unable to find layer');
                return layers[index];
            }
            function layerSettings(layer) {
                return {
                    ...layer.settings,
                    weights: null,
                    deltas: null,
                    praxis: null,
                };
            }
            for (let i = 0; i < previousLayers.length; i++) {
                const previousLayer = previousLayers[i];
                let layer;
                if (previousLayer instanceof Activation) {
                    layer = new previousLayer.constructor(findInputLayer(previousLayer.inputLayer), layerSettings(previousLayer));
                }
                else if (previousLayer instanceof EntryPoint) {
                    layer = new previousLayer.constructor(layerSettings(previousLayer));
                }
                else if (previousLayer instanceof Filter) {
                    layer = new previousLayer.constructor(layerSettings(previousLayer.inputLayer), findInputLayer(previousLayer.inputLayer));
                }
                else if (previousLayer instanceof Internal) {
                    const previousHiddenLayerOutput = previousLayers[this._hiddenLayerOutputIndices[usedHiddenLayerOutputIndex++]];
                    if (previousLayer instanceof RecurrentConnection) {
                        throw new Error('unfinished');
                    }
                    else if (previousLayer instanceof RecurrentInput) {
                        layer = new RecurrentInput(previousHiddenLayerOutput);
                    }
                    else if (previousLayer instanceof RecurrentZeros) {
                        layer = new RecurrentInput(previousHiddenLayerOutput);
                    }
                    else {
                        throw new Error(`hidden layer ${previousLayer.constructor.name} extends unknown hidden layer`);
                    }
                }
                else if (previousLayer instanceof InternalModel ||
                    previousLayer instanceof Model) {
                    layer = previousLayer;
                }
                else if (previousLayer instanceof Modifier) {
                    layer = new previousLayer.constructor(findInputLayer(previousLayer.inputLayer), layerSettings(previousLayer.inputLayer));
                }
                else if (previousLayer instanceof Operator) {
                    layer = new previousLayer.constructor(findInputLayer(previousLayer.inputLayer1), findInputLayer(previousLayer.inputLayer2), layerSettings(previousLayer));
                }
                else if (previousLayer instanceof Target) {
                    layer = new previousLayer.constructor(layerSettings(previousLayer), findInputLayer(previousLayer.inputLayer));
                }
                else {
                    throw new Error(`hidden layer ${previousLayer.constructor.name} extends unknown hidden layer`);
                }
                layers.push(layer);
            }
            return layers;
        }
        _connectHiddenLayers(previousLayer) {
            const hiddenLayers = [];
            if (!this.options.hiddenLayers)
                throw new Error('hiddenLayers not defined');
            for (let i = 0; i < this.options.hiddenLayers.length; i++) {
                const recurrentInput = new RecurrentZeros();
                const hiddenLayer = this.options.hiddenLayers[i](previousLayer, recurrentInput, i);
                previousLayer = hiddenLayer;
                hiddenLayers.push(hiddenLayer);
            }
            return hiddenLayers;
        }
        initialize() {
            this._outputConnection = new RecurrentConnection();
            let layerSet;
            if (this.options.layers) {
                layerSet = this._connectOptionsLayers();
            }
            else {
                const { inputLayer, hiddenLayers, outputLayer } = this._connectLayers();
                layerSet = flattenLayers([inputLayer, ...hiddenLayers, outputLayer]);
                this._hiddenLayerOutputIndices = hiddenLayers.map((l) => layerSet.indexOf(l));
                this._inputLayer = inputLayer;
                this._hiddenLayers = hiddenLayers;
                this._outputLayer = outputLayer;
            }
            this.layers = layerSet;
            this._layerSets = [layerSet];
            this._model = layerSet.filter((l) => l instanceof Model || l instanceof InternalModel);
            this.initializeLayers(layerSet);
        }
        initializeDeep() {
            const layers = this._connectLayersDeep();
            for (let i = 0; i < layers.length; i++) {
                const layer = layers[i];
                layer.setupKernels(true);
                layer.reuseKernels(this._layerSets[0][i]);
            }
            this._layerSets.push(layers);
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        run(inputs) {
            while (this._layerSets.length <= inputs.length) {
                this.initializeDeep();
            }
            const result = this.runInputs(inputs);
            if (result instanceof gpuBrowser.Texture) {
                return result.toArray();
            }
            return result;
        }
        runInput(input) {
            throw new Error('use .runInputs()');
        }
        runInputs(inputs) {
            while (this._layerSets.length < inputs.length) {
                this.initializeDeep();
            }
            const max = inputs.length - 1; // last output will be compared with last index
            for (let x = 0; x <= max; x++) {
                const layerSet = this._layerSets[x];
                layerSet[0].predict(inputs[x]);
                for (let i = 1; i < layerSet.length; i++) {
                    layerSet[i].predict();
                }
            }
            const lastLayerUsed = this._layerSets[max];
            const result = lastLayerUsed[lastLayerUsed.length - 1].weights;
            this.end();
            return result;
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        train(data, options = {}) {
            const { preparedData, status, endTime } = this._prepTraining(data, options);
            let continueTicking = true;
            const calculateError = () => this._calculateTrainingError(preparedData);
            const trainPatters = () => this._trainPatterns(preparedData);
            while (continueTicking) {
                continueTicking = this._trainingTick(status, endTime, calculateError, trainPatters);
            }
            return status;
        }
        end() {
            const x = this._layerSets.length - 1;
            const lastLayerSet = this._layerSets[x];
            lastLayerSet[0].predict([new Float32Array([0])]);
            for (let i = 1; i < lastLayerSet.length; i++) {
                lastLayerSet[i].predict();
            }
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        transferData(formattedData) {
            return formattedData;
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        _prepTraining(data, options) {
            this._updateTrainingOptions(options);
            const endTime = this.trainOpts.timeout
                ? Date.now() + this.trainOpts.timeout
                : 0;
            const status = {
                error: 1,
                iterations: 0,
            };
            this.verifyIsInitialized();
            return {
                preparedData: this.transferData(data),
                status,
                endTime,
            };
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        _calculateTrainingError(data) {
            if (!this.meanSquaredError) {
                throw new Error('this.meanSquaredError not setup');
            }
            let sum = new Float32Array(1);
            for (let i = 0; i < data.length; ++i) {
                const prevSum = sum;
                const error = this._trainPattern(data[i], true);
                sum = this.meanSquaredError.add(sum, error);
                release(error);
                release(prevSum);
            }
            const result = this.meanSquaredError.divide(data.length, sum);
            release(sum);
            if (result instanceof gpuBrowser.Texture) {
                const resultArray = result.toArray();
                return resultArray[0];
            }
            return result[0];
        }
        // TODO: more types
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        formatData(data) {
            return data;
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        _calculateDeltas(target) {
            const lastLayerSet = this._layerSets[this._layerSets.length - 1];
            // Iterate from the second to last layer backwards, propagating 0's
            for (let i = lastLayerSet.length - 2; i >= 0; i--) {
                lastLayerSet[i].compare();
            }
            for (let x = target.length - 2; x >= 0; x--) {
                const layerSet = this._layerSets[x];
                layerSet[layerSet.length - 1].compare(target[x + 1]);
                for (let i = layerSet.length - 2; i >= 0; i--) {
                    layerSet[i].compare();
                }
            }
        }
        adjustWeights() {
            var _a;
            const _model = this._model;
            for (let i = 0; i < _model.length; i++) {
                _model[i].learn((_a = this.options.learningRate) !== null && _a !== void 0 ? _a : 0);
            }
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        _trainPatterns(data) {
            for (let i = 0; i < data.length; ++i) {
                this._trainPattern(data[i], false);
            }
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        _trainPattern(inputs, logErrorRate) {
            // forward propagate
            this.runInputs(inputs);
            // back propagate
            this._calculateDeltas(inputs);
            this.adjustWeights();
            if (logErrorRate) {
                if (!this.meanSquaredError) {
                    throw new Error('this.meanSquaredError not setup');
                }
                let error = new Float32Array(1);
                for (let i = 0, max = inputs.length - 2; i <= max; i++) {
                    const layerSet = this._layerSets[i];
                    const lastLayer = layerSet[layerSet.length - 1];
                    const prevError = error;
                    error = this.meanSquaredError.addAbsolute(prevError, lastLayer.errors);
                    release(prevError);
                }
                return clone(this.meanSquaredError.divide(inputs.length, error));
            }
            return null;
        }
    }

    /**
     * A matrix
     */
    class Matrix {
        constructor(rows, columns) {
            this.rows = 0;
            this.columns = 0;
            if (rows)
                this.rows = rows;
            if (columns)
                this.columns = columns;
            this.weights = zeros$1(this.rows * this.columns);
            this.deltas = zeros$1(this.rows * this.columns);
        }
        getWeight(row, col) {
            // slow but careful accessor function
            // we want row-major order
            const ix = this.columns * row + col;
            if (ix < 0 || ix >= this.weights.length) {
                throw new Error('get accessor is skewed');
            }
            return this.weights[ix];
        }
        setWeight(row, col, v) {
            // slow but careful accessor function
            const ix = this.columns * row + col;
            if (ix < 0 || ix >= this.weights.length) {
                throw new Error('set accessor is skewed');
            }
            this.weights[ix] = v;
            return this;
        }
        getDelta(row, col) {
            // slow but careful accessor function
            // we want row-major order
            const ix = this.columns * row + col;
            if (ix < 0 || ix >= this.deltas.length) {
                throw new Error('get accessor is skewed');
            }
            return this.deltas[ix];
        }
        setDelta(row, col, v) {
            // slow but careful accessor function
            const ix = this.columns * row + col;
            if (ix < 0 || ix >= this.weights.length) {
                throw new Error('set accessor is skewed');
            }
            this.deltas[ix] = v;
            return this;
        }
        toJSON() {
            return {
                rows: this.rows,
                columns: this.columns,
                weights: Array.from(this.weights.slice(0)),
            };
        }
        static fromJSON(json) {
            const matrix = new Matrix(json.rows, json.columns);
            for (let i = 0, max = json.rows * json.columns; i < max; i++) {
                matrix.weights[i] = json.weights[i]; // copy over weights
            }
            return matrix;
        }
        static fromArray(weights) {
            const matrix = new Matrix(weights.length, weights[0].length);
            matrix.fromArray(weights);
            return matrix;
        }
        deltasToArray() {
            return this.toArray('deltas');
        }
        weightsToArray() {
            return this.toArray('weights');
        }
        toArray(prop = 'weights') {
            const result = new Array(this.rows);
            this.iterate({
                row: (rowIndex) => {
                    result[rowIndex] = new Array(this.columns);
                },
                column: (rowIndex, columnIndex) => {
                    if (prop === 'weights') {
                        result[rowIndex][columnIndex] = this.getWeight(rowIndex, columnIndex);
                    }
                    else if (prop === 'deltas') {
                        result[rowIndex][columnIndex] = this.getDelta(rowIndex, columnIndex);
                    }
                },
            });
            return result;
        }
        fromArray(array, prop = 'weights') {
            if (array.length !== this.rows) {
                throw new Error('rows do not match');
            }
            if (array[0].length !== this.columns) {
                throw new Error('columns do not match');
            }
            this.iterate({
                column: (rowIndex, columnIndex) => {
                    const value = array[rowIndex][columnIndex];
                    if (typeof value !== 'number') {
                        throw new Error('value not number');
                    }
                    if (prop === 'weights') {
                        this.setWeight(rowIndex, columnIndex, value);
                    }
                    else if (prop === 'deltas') {
                        this.setDelta(rowIndex, columnIndex, value);
                    }
                },
            });
            return this;
        }
        iterate(callbacks) {
            const rows = this.rows;
            const columns = this.columns;
            for (let rowIndex = 0; rowIndex < rows; rowIndex++) {
                if (callbacks.row) {
                    callbacks.row(rowIndex);
                }
                for (let columnIndex = 0; columnIndex < columns; columnIndex++) {
                    if (callbacks.column) {
                        callbacks.column(rowIndex, columnIndex);
                    }
                }
            }
            return this;
        }
    }

    /** return Matrix but filled with random numbers from gaussian
     */
    class RandomMatrix extends Matrix {
        constructor(rows, columns, std) {
            super(rows, columns);
            this.std = std;
            for (let i = 0, max = this.weights.length; i < max; i++) {
                this.weights[i] = randomFloat(-std, std);
            }
        }
    }

    class DataFormatter {
        constructor(values, maxThreshold = 0) {
            this.values = values;
            this.indexTable = {};
            this.characterTable = {};
            this.characters = [];
            this.specialIndexes = [];
            this.isSetup = false;
            if (values === undefined)
                return;
            this.setup(values, maxThreshold);
        }
        setup(values, maxThreshold = 0) {
            if (this.isSetup)
                throw new Error('DataFormatter is already setup');
            this.values = values;
            // go over all characters and keep track of all unique ones seen
            // count up all characters
            this.buildCharactersFromIterable(values);
            this.buildTables(maxThreshold);
            if (values[0].input) {
                this.addInputOutput();
            }
            this.addUnrecognized();
            this.isSetup = true;
        }
        buildCharactersFromIterable(values) {
            const tempCharactersTable = {};
            for (let dataFormatterIndex = 0, dataFormatterLength = values.length; dataFormatterIndex < dataFormatterLength; dataFormatterIndex++) {
                const characters = values[dataFormatterIndex];
                // if (typeof characters === 'string') {
                //   const character = characters;
                //   if (tempCharactersTable.hasOwnProperty(character)) continue;
                //   tempCharactersTable[character] = true;
                //   this.characters.push(character);
                if (characters.hasOwnProperty('length')) {
                    const iteratable = characters;
                    for (let characterIndex = 0, charactersLength = iteratable.length; characterIndex < charactersLength; characterIndex++) {
                        const character = iteratable[characterIndex];
                        if (tempCharactersTable.hasOwnProperty(character))
                            continue;
                        tempCharactersTable[character] = true;
                        this.characters.push(character);
                    }
                }
                else if (typeof characters === 'number') {
                    if (tempCharactersTable.hasOwnProperty(characters))
                        continue;
                    tempCharactersTable[characters] = true;
                    this.characters.push(characters);
                }
                else if (typeof characters === 'boolean') {
                    const character = characters.toString();
                    if (tempCharactersTable.hasOwnProperty(character))
                        continue;
                    tempCharactersTable[character] = true;
                    this.characters.push(character);
                }
                else if (Array.isArray(characters) &&
                    typeof characters[0] === 'string') {
                    for (let i = 0; i < characters.length; i++) {
                        const character = characters[i];
                        if (tempCharactersTable.hasOwnProperty(character))
                            continue;
                        tempCharactersTable[character] = true;
                        this.characters.push(character);
                    }
                }
                else if (Array.isArray(characters) &&
                    (typeof characters[0] === 'number' ||
                        typeof characters[0] === 'boolean')) {
                    for (let i = 0; i < characters.length; i++) {
                        const character = characters[i].toString();
                        if (tempCharactersTable.hasOwnProperty(dataFormatterIndex))
                            continue;
                        tempCharactersTable[character] = true;
                        this.characters.push(character);
                    }
                }
                else if (characters.hasOwnProperty('input') &&
                    characters.hasOwnProperty('output')) {
                    const { input, output } = characters;
                    if (Array.isArray(input)) {
                        this.addCharacters(input, tempCharactersTable);
                    }
                    else {
                        this.addCharacters(input.toString(), tempCharactersTable);
                    }
                    if (Array.isArray(output)) {
                        this.addCharacters(output, tempCharactersTable);
                    }
                    else {
                        this.addCharacters(output.toString(), tempCharactersTable);
                    }
                }
                else {
                    throw new Error('Unhandled value');
                }
            }
        }
        addCharacters(characters, charactersTable) {
            for (let i = 0; i < characters.length; i++) {
                const character = characters[i].toString();
                if (charactersTable.hasOwnProperty(character))
                    continue;
                charactersTable[character] = true;
                this.characters.push(character);
            }
        }
        buildTables(maxThreshold) {
            // filter by count threshold and create pointers
            const charactersLength = this.characters.length;
            for (let characterIndex = 0; characterIndex < charactersLength; characterIndex++) {
                const character = this.characters[characterIndex];
                if (characterIndex >= maxThreshold) {
                    // add character to dataFormatter
                    this.indexTable[character] = characterIndex;
                    this.characterTable[characterIndex] = character;
                }
            }
        }
        toIndexes(value, maxThreshold = 0) {
            const result = [];
            const { indexTable } = this;
            switch (typeof value) {
                case 'number':
                case 'boolean':
                    value = value.toString();
            }
            for (let i = 0, max = value.length; i < max; i++) {
                const character = value[i].toString();
                let index = indexTable[character];
                if (index === undefined) {
                    if (indexTable.unrecognized) {
                        index = indexTable.unrecognized;
                    }
                    else {
                        throw new Error(`unrecognized character "${character}"`);
                    }
                }
                if (index < maxThreshold)
                    continue;
                result.push(index);
            }
            return result;
        }
        toIndexesInputOutput(input, output, maxThreshold = 0) {
            const result = this.toIndexesValue(input, maxThreshold, true);
            if (typeof output === 'undefined')
                return result;
            return result.concat(this.toIndexesValue(output, maxThreshold, false));
        }
        toIndexesValue(value, maxThreshold, isInput) {
            if (typeof value === 'string') {
                value = value.split('');
            }
            else if (typeof value === 'number' || typeof value === 'boolean') {
                value = value.toString().split('');
            }
            else if (Array.isArray(value) &&
                (typeof value[0] === 'number' ||
                    typeof value[0] === 'boolean' ||
                    typeof value[0] === 'string')) {
                value = value.map((v) => v.toString());
            }
            else {
                throw new Error('unrecognized value');
            }
            if (isInput) {
                value = value.concat(['stop-input', 'start-output']);
            }
            return this.toIndexes(value, maxThreshold);
        }
        toCharacters(indices, maxThreshold = 0) {
            const result = [];
            const { indexTable, characterTable } = this;
            for (let i = 0, max = indices.length; i < max; i++) {
                const index = indices[i];
                if (index < maxThreshold)
                    continue;
                let character = characterTable[index];
                if (character === undefined) {
                    if (indexTable.unrecognized) {
                        character = characterTable[indexTable.unrecognized];
                    }
                    else {
                        throw new Error(`unrecognized index "${index}"`);
                    }
                }
                else if (character !== null) {
                    result.push(character.toString());
                }
            }
            return result;
        }
        toString(indices, maxThreshold) {
            return this.toCharacters(indices, maxThreshold).join('');
        }
        addInputOutput() {
            this.addSpecial('stop-input');
            this.addSpecial('start-output');
        }
        addUnrecognized() {
            this.addSpecial('unrecognized');
        }
        static fromAllPrintable(maxThreshold, values = ['\n']) {
            for (let i = 32; i <= 126; i++) {
                values.push(String.fromCharCode(i));
            }
            return new DataFormatter(values, maxThreshold);
        }
        static fromAllPrintableInputOutput(maxThreshold, values = ['\n']) {
            const dataFormatter = DataFormatter.fromAllPrintable(maxThreshold, values);
            dataFormatter.addInputOutput();
            dataFormatter.addUnrecognized();
            return dataFormatter;
        }
        static fromStringInputOutput(string, maxThreshold) {
            const values = Array.from(new Set(string)).join('');
            const dataFormatter = new DataFormatter(values.split(''), maxThreshold);
            dataFormatter.addInputOutput();
            dataFormatter.addUnrecognized();
            dataFormatter.isSetup = true;
            return dataFormatter;
        }
        static fromArrayInputOutput(data, maxThreshold) {
            const values = [];
            for (let i = 0; i < data.length; i++) {
                const datum = data[i];
                values.push(validateAndCast(datum.input), validateAndCast(datum.output));
            }
            const flatArray = Array.isArray(values)
                ? values.flat()
                : values;
            const dataFormatter = new DataFormatter(Array.from(new Set(flatArray)), maxThreshold);
            dataFormatter.addInputOutput();
            dataFormatter.addUnrecognized();
            dataFormatter.isSetup = true;
            return dataFormatter;
        }
        static fromString(string, maxThreshold = 0) {
            const values = Array.from(new Set(string)).join('');
            return new DataFormatter(values.split(''), maxThreshold);
        }
        toJSON() {
            return {
                indexTable: this.indexTable,
                characterTable: this.characterTable,
                values: this.values,
                characters: this.characters,
                specialIndexes: this.specialIndexes,
            };
        }
        /** TODO: Type better, The type of json is not "string that is a valid JSON", it is a POJO in the shape of DataFormatter.
         * this method re-hydrates the the data as an instance of DataFormatter.
         */
        static fromJSON(json) {
            const dataFormatter = new DataFormatter();
            dataFormatter.indexTable = json.indexTable;
            dataFormatter.characterTable = json.characterTable;
            dataFormatter.values = json.values;
            dataFormatter.characters = json.characters;
            dataFormatter.specialIndexes = json.specialIndexes;
            dataFormatter.isSetup = true;
            return dataFormatter;
        }
        addSpecial(special, character = null) {
            const specialIndex = (this.indexTable[special] = this.characters.length);
            this.characterTable[specialIndex] = character;
            this.specialIndexes.push(this.characters.length);
            this.characters.push(special);
        }
        toFunctionString() {
            return `
var characterTable = ${JSON.stringify(this.characterTable)};
var indexTable = ${JSON.stringify(this.indexTable)};
var characters = ${JSON.stringify(this.characters)};
var dataFormatter = {
  toIndexes: function ${this.toIndexes.toString()},
  toIndexesInputOutput: function ${this.toIndexesInputOutput.toString()},
  toCharacters: function ${this.toCharacters.toString()},
  toIndexesValue: function ${this.toIndexesValue.toString()},
};`;
        }
        formatDataIn(input, output) {
            var _a;
            if (input === undefined)
                return [];
            if (Array.isArray(input) && typeof input[0] === 'number') {
                return input;
            }
            if ((_a = this.indexTable) === null || _a === void 0 ? void 0 : _a.hasOwnProperty('stop-input')) {
                return this.toIndexesInputOutput(input, output);
            }
            return this.toIndexes(input);
        }
        formatDataOut(input, output) {
            return this.toCharacters(output).join('');
        }
        format(data) {
            if (typeof data[0] === 'number' &&
                !Array.isArray(data[0]) &&
                (!data[0].hasOwnProperty('input') || !data[0].hasOwnProperty('output'))) {
                return data;
            }
            const result = [];
            if (typeof data[0] === 'string' ||
                typeof data[0] === 'number' ||
                Array.isArray(data[0])) {
                if (!this.isSetup) {
                    this.setup(data);
                    for (let i = 0; i < data.length; i++) {
                        result.push(this.formatDataIn(validateAndCast(data[i])));
                    }
                }
                else {
                    for (let i = 0, max = data.length; i < max; i++) {
                        result.push(this.formatDataIn(data[i]));
                    }
                }
            }
            else if (data[0].input && data[0].output) {
                if (!this.isSetup) {
                    this.setup(data);
                }
                for (let i = 0, max = data.length; i < max; i++) {
                    result.push(this.formatDataIn(validateAndCast(data[i].input), validateAndCast(data[i].output)));
                }
            }
            else {
                throw new Error('unrecognized data');
            }
            return result;
        }
    }
    function validateAndCast(value) {
        if (typeof value === 'string')
            return value;
        if (typeof value === 'number')
            return value.toString();
        if (typeof value === 'boolean')
            return value.toString();
        if (Array.isArray(value) && typeof value[0] === 'string')
            return value;
        if (typeof value[0] === 'boolean') {
            return value.map((v) => v.toString());
        }
        if (typeof value[0] === 'number') {
            return value.map((v) => v.toString());
        }
        throw new Error('unrecognized value, expected string[], string, number[], number, boolean[], or boolean');
    }

    function copy(product, left) {
        product.rows = left.rows;
        product.columns = left.columns;
        product.weights = left.weights.slice(0);
        product.deltas = left.deltas.slice(0);
    }

    /**
     * add {left} and {right} matrix weights into {into}
     */
    function add(product, left, right) {
        for (let i = 0; i < left.weights.length; i++) {
            product.weights[i] = left.weights[i] + right.weights[i];
            product.deltas[i] = 0;
        }
    }

    /**
     * adds {from} deltas to {left} and {right} deltas
     */
    function addB(product, left, right) {
        for (let i = 0; i < product.deltas.length; i++) {
            left.deltas[i] = product.deltas[i];
            right.deltas[i] = product.deltas[i];
        }
    }

    /**
     * makes matrix weights and deltas all ones
     */
    function allOnes(product) {
        for (let i = 0; i < product.weights.length; i++) {
            product.weights[i] = 1;
            product.deltas[i] = 0;
        }
    }

    function cloneNegative(product, left) {
        product.rows = left.rows;
        product.columns = left.columns;
        product.weights = left.weights.slice(0);
        product.deltas = left.deltas.slice(0);
        for (let i = 0; i < left.weights.length; i++) {
            product.weights[i] = -left.weights[i];
            product.deltas[i] = 0;
        }
    }

    /**
     * multiply {left} and {right} matrix weights to {into}
     */
    function multiply(product, left, right) {
        const leftRows = left.rows;
        const leftColumns = left.columns;
        const rightColumns = right.columns;
        // loop over rows of left
        for (let leftRow = 0; leftRow < leftRows; leftRow++) {
            const leftRowBase = leftColumns * leftRow;
            const rightRowBase = rightColumns * leftRow;
            // loop over cols of right
            for (let rightColumn = 0; rightColumn < rightColumns; rightColumn++) {
                // dot product loop
                let dot = 0;
                // loop over columns of left
                for (let leftColumn = 0; leftColumn < leftColumns; leftColumn++) {
                    const rightColumnBase = rightColumns * leftColumn;
                    const leftIndex = leftRowBase + leftColumn;
                    const rightIndex = rightColumnBase + rightColumn;
                    dot += left.weights[leftIndex] * right.weights[rightIndex];
                    left.deltas[leftIndex] = 0;
                    right.deltas[rightIndex] = 0;
                }
                product.weights[rightRowBase + rightColumn] = dot;
            }
        }
    }

    /**
     * multiplies {from} deltas to {left} and {right}
     */
    function multiplyB(product, left, right) {
        const leftRows = left.rows;
        const leftColumns = left.columns;
        const rightColumns = right.columns;
        // loop over rows of left
        for (let leftRowRoot = 0; leftRowRoot < leftRows; leftRowRoot++) {
            const leftRowBase = leftColumns * leftRowRoot;
            const rightRowBase = rightColumns * leftRowRoot;
            // loop over cols of right
            for (let rightColumn = 0; rightColumn < rightColumns; rightColumn++) {
                // loop over columns of left
                for (let leftColumn = 0; leftColumn < leftColumns; leftColumn++) {
                    const rightColumnBase = rightColumns * leftColumn;
                    const leftRow = leftRowBase + leftColumn;
                    const rightRow = rightColumnBase + rightColumn;
                    const backPropagateValue = product.deltas[rightRowBase + rightColumn];
                    left.deltas[leftRow] += right.weights[rightRow] * backPropagateValue;
                    right.deltas[rightRow] += left.weights[leftRow] * backPropagateValue;
                }
            }
        }
    }

    function multiplyElement(product, left, right) {
        const { weights } = left;
        for (let i = 0; i < weights.length; i++) {
            product.weights[i] = left.weights[i] * right.weights[i];
            product.deltas[i] = 0;
        }
    }

    /**
     * multiplies {left} and {right} weight by {from} deltas into {left} and {right} deltas
     */
    function multiplyElementB(product, left, right) {
        for (let i = 0; i < left.weights.length; i++) {
            left.deltas[i] = right.weights[i] * product.deltas[i];
            right.deltas[i] = left.weights[i] * product.deltas[i];
        }
    }

    /**
     *
     * relu {m} weights to {into} weights
     */
    function relu(product, left) {
        for (let i = 0; i < left.weights.length; i++) {
            product.weights[i] = Math.max(0, left.weights[i]); // relu
            product.deltas[i] = 0;
        }
    }

    /**
     * adds {from} deltas to {m} deltas when {m} weights are above other a threshold of 0
     */
    function reluB(product, left) {
        for (let i = 0; i < product.deltas.length; i++) {
            left.deltas[i] = left.weights[i] > 0 ? product.deltas[i] : 0;
        }
    }

    function rowPluck(product, left, rowPluckIndex) {
        const { columns } = left;
        const rowBase = columns * rowPluckIndex;
        for (let column = 0; column < columns; column++) {
            product.weights[column] = left.weights[rowBase + column];
            product.deltas[column] = 0;
        }
    }

    /**
     * adds {from} deltas into {m} deltas
     */
    function rowPluckB(product, left, rowIndex) {
        const { columns } = left;
        const rowBase = columns * rowIndex;
        for (let column = 0; column < columns; column++) {
            left.deltas[rowBase + column] = product.deltas[column];
        }
    }

    function sigmoid(product, left) {
        // sigmoid nonlinearity
        for (let i = 0; i < left.weights.length; i++) {
            product.weights[i] = 1 / (1 + Math.exp(-left.weights[i]));
            product.deltas[i] = 0;
        }
    }
    // function sig(x) {
    //   // helper function for computing sigmoid
    //   return 1 / (1 + Math.exp(-x));
    // }

    function sigmoidB(product, left) {
        for (let i = 0; i < product.deltas.length; i++) {
            const mwi = product.weights[i];
            left.deltas[i] = mwi * (1 - mwi) * product.deltas[i];
        }
    }

    function softmax(matrix) {
        // probability volume
        const result = new Matrix(matrix.rows, matrix.columns);
        let maxVal = -999999;
        for (let i = 0; i < matrix.weights.length; i++) {
            if (matrix.weights[i] > maxVal) {
                maxVal = matrix.weights[i];
            }
        }
        let s = 0;
        for (let i = 0; i < matrix.weights.length; i++) {
            result.weights[i] = Math.exp(matrix.weights[i] - maxVal);
            s += result.weights[i];
        }
        for (let i = 0; i < matrix.weights.length; i++) {
            result.weights[i] /= s;
        }
        // no backward pass here needed
        // since we will use the computed probabilities outside
        // to set gradients directly on m
        return result;
    }

    function tanh(product, left) {
        // tanh nonlinearity
        for (let i = 0; i < left.weights.length; i++) {
            product.weights[i] = Math.tanh(left.weights[i]);
            product.deltas[i] = 0;
        }
    }

    function tanhB(product, left) {
        for (let i = 0; i < product.deltas.length; i++) {
            // grad for z = tanh(x) is (1 - z^2)
            const mwi = product.weights[i];
            left.deltas[i] = (1 - mwi * mwi) * product.deltas[i];
        }
    }

    class Equation {
        constructor() {
            this.states = [];
            this.inputRow = 0;
        }
        add(left, right) {
            if (left.weights.length !== right.weights.length) {
                throw new Error('misaligned matrices');
            }
            const product = new Matrix(left.rows, left.columns);
            this.states.push({
                name: 'add',
                product,
                left,
                right,
                forwardFn: add,
                backpropagationFn: addB,
            });
            return product;
        }
        allOnes(rows, columns) {
            const product = new Matrix(rows, columns);
            this.states.push({
                name: 'allOnes',
                product,
                left: product,
                forwardFn: allOnes,
                backpropagationFn: () => { },
            });
            return product;
        }
        cloneNegative(matrix) {
            const product = new Matrix(matrix.rows, matrix.columns);
            this.states.push({
                name: 'cloneNegative',
                product,
                left: matrix,
                forwardFn: cloneNegative,
                backpropagationFn: () => { },
            });
            return product;
        }
        /**
         * connects two matrices together by subtract
         */
        subtract(left, right) {
            if (left.weights.length !== right.weights.length) {
                throw new Error('misaligned matrices');
            }
            return this.add(this.add(this.allOnes(left.rows, left.columns), this.cloneNegative(left)), right);
        }
        /**
         * connects two matrices together by multiply
         */
        multiply(left, right) {
            if (left.columns !== right.rows) {
                throw new Error('misaligned matrices');
            }
            const product = new Matrix(left.rows, right.columns);
            this.states.push({
                name: 'multiply',
                product,
                left,
                right,
                forwardFn: multiply,
                backpropagationFn: multiplyB,
            });
            return product;
        }
        /**
         * connects two matrices together by multiplyElement
         */
        multiplyElement(left, right) {
            if (left.weights.length !== right.weights.length) {
                throw new Error('misaligned matrices');
            }
            const product = new Matrix(left.rows, left.columns);
            this.states.push({
                name: 'multiplyElement',
                product,
                left,
                right,
                forwardFn: multiplyElement,
                backpropagationFn: multiplyElementB,
            });
            return product;
        }
        /**
         * connects a matrix to relu
         */
        relu(matrix) {
            const product = new Matrix(matrix.rows, matrix.columns);
            this.states.push({
                name: 'relu',
                product,
                left: matrix,
                forwardFn: relu,
                backpropagationFn: reluB,
            });
            return product;
        }
        /**
         * input a matrix
         */
        input(input) {
            this.states.push({
                name: 'input',
                product: input,
                forwardFn: (product) => {
                    if (!this.inputValue)
                        return;
                    if (this.inputValue.length !== product.weights.length) {
                        throw new Error('this.inputValue is of wrong dimensions');
                    }
                    product.weights = input.weights = this.inputValue;
                },
                backpropagationFn: () => { },
            });
            return input;
        }
        /**
         * connects a matrix via a row
         */
        inputMatrixToRow(matrix) {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            const self = this;
            const product = new Matrix(matrix.columns, 1);
            this.states.push({
                name: 'inputMatrixToRow',
                product,
                left: matrix,
                get right() {
                    return self.inputRow;
                },
                forwardFn: rowPluck,
                backpropagationFn: rowPluckB,
            });
            return product;
        }
        /**
         * connects a matrix to sigmoid
         */
        sigmoid(matrix) {
            const product = new Matrix(matrix.rows, matrix.columns);
            this.states.push({
                name: 'sigmoid',
                product,
                left: matrix,
                forwardFn: sigmoid,
                backpropagationFn: sigmoidB,
            });
            return product;
        }
        /**
         * connects a matrix to tanh
         */
        tanh(matrix) {
            const product = new Matrix(matrix.rows, matrix.columns);
            this.states.push({
                name: 'tanh',
                product,
                left: matrix,
                forwardFn: tanh,
                backpropagationFn: tanhB,
            });
            return product;
        }
        /**
         *
         * Observe a matrix for debugging
         */
        observe(matrix) {
            this.states.push({
                name: 'observe',
                product: new Matrix(),
                forwardFn: () => { },
                backpropagationFn: () => { },
            });
            return matrix;
        }
        /**
         * Run index through equations via forward propagation
         */
        runIndex(rowIndex = 0) {
            this.inputRow = rowIndex;
            let state = this.states[0];
            for (let i = 0, max = this.states.length; i < max; i++) {
                state = this.states[i];
                if (!state.hasOwnProperty('forwardFn'))
                    continue;
                state.forwardFn(state.product, state.left, state.right);
            }
            return state.product;
        }
        /**
         * Run value through equations via forward propagation
         */
        runInput(inputValue) {
            this.inputValue = inputValue;
            let state = this.states[0];
            for (let i = 0, max = this.states.length; i < max; i++) {
                state = this.states[i];
                if (!state.hasOwnProperty('forwardFn'))
                    continue;
                state.forwardFn(state.product, state.left, state.right);
            }
            return state.product;
        }
        /**
         * Run value through equations via back propagation
         */
        backpropagate() {
            let i = this.states.length;
            let state = this.states[0];
            while (i-- > 0) {
                state = this.states[i];
                if (!state.hasOwnProperty('backpropagationFn'))
                    continue;
                state.backpropagationFn(state.product, state.left, state.right);
            }
            return state.product;
        }
        /**
         * Run index through equations via back propagation
         */
        backpropagateIndex(rowIndex = 0) {
            this.inputRow = rowIndex;
            let i = this.states.length;
            let state = this.states[0];
            while (i-- > 0) {
                state = this.states[i];
                if (!state.hasOwnProperty('backpropagationFn'))
                    continue;
                state.backpropagationFn(state.product, state.left, state.right);
            }
            return state.product;
        }
        /**
         * Predict a target value from equation
         */
        predictTarget(input, target) {
            let errorSum = 0;
            const output = this.runInput(input);
            for (let i = 0; i < output.weights.length; i++) {
                const error = output.weights[i] - target[i];
                // set gradients into log probabilities
                errorSum += Math.abs(error);
                // write gradients into log probabilities
                output.deltas[i] = error;
            }
            return errorSum;
        }
        /**
         * Predict a target index from equation
         */
        predictTargetIndex(input, target) {
            const output = this.runIndex(input);
            // set gradients into log probabilities
            const logProbabilities = output; // interpret output as log probabilities
            const probabilities = softmax(output); // compute the softmax probabilities
            // write gradients into log probabilities
            logProbabilities.deltas = probabilities.weights.slice(0);
            logProbabilities.deltas[target] -= 1;
            // accumulate base 2 log prob and do smoothing
            return -Math.log2(probabilities.weights[target]);
        }
    }

    function maxI(matrix) {
        // argmax of array w
        const { weights } = matrix;
        let maxv = weights[0];
        let maxix = 0;
        for (let i = 1; i < weights.length; i++) {
            const v = weights[i];
            if (v < maxv)
                continue;
            maxix = i;
            maxv = v;
        }
        return maxix;
    }

    function sampleI(matrix) {
        // sample argmax from w, assuming w are
        // probabilities that sum to one
        const r = randomFloat(0, 1);
        const w = matrix.weights;
        let x = 0;
        let i = 0;
        while (true) {
            x += w[i];
            if (x > r) {
                return i;
            }
            i++;
        }
    }

    const trainDefaults$1 = {
        iterations: 20000,
        errorThresh: 0.005,
        log: false,
        logPeriod: 10,
        learningRate: 0.01,
        callbackPeriod: 10,
        timeout: Infinity,
    };
    const defaults$1 = () => {
        return {
            inputSize: 20,
            inputRange: 20,
            hiddenLayers: [20, 20],
            outputSize: 20,
            decayRate: 0.999,
            smoothEps: 1e-8,
            regc: 0.000001,
            clipval: 5,
            maxPredictionLength: 100,
            dataFormatter: new DataFormatter(),
        };
    };
    class RNN {
        constructor(options = {}) {
            this.options = { ...defaults$1() };
            this.trainOpts = { ...trainDefaults$1 };
            this.stepCache = {};
            this.runs = 0;
            this.ratioClipped = 0;
            this.model = Object.seal({
                isInitialized: false,
                input: new Matrix(0, 0),
                hiddenLayers: [],
                output: new Matrix(0, 0),
                equations: [],
                allMatrices: [],
                equationConnections: [],
                outputConnector: new RandomMatrix(0, 0, 0.08),
            });
            this.initialLayerInputs = [];
            this.options = { ...this.options, ...options };
            this.updateTrainingOptions({
                ...trainDefaults$1,
            });
            if (options.json) {
                this.fromJSON(options.json);
            }
        }
        initialize() {
            const { dataFormatter } = this.options;
            if (dataFormatter === null || dataFormatter === void 0 ? void 0 : dataFormatter.characters.length) {
                this.options.inputSize = this.options.inputRange = this.options.outputSize =
                    dataFormatter.characters.length;
            }
            this.model = this.mapModel();
        }
        createHiddenLayers() {
            const { hiddenLayers, inputSize } = this.options;
            const hiddenLayersModel = [];
            // 0 is end, so add 1 to offset
            hiddenLayersModel.push(this.getHiddenLayer(hiddenLayers[0], inputSize));
            let prevSize = hiddenLayers[0];
            for (let d = 1; d < hiddenLayers.length; d++) {
                // loop over depths
                const hiddenSize = hiddenLayers[d];
                hiddenLayersModel.push(this.getHiddenLayer(hiddenSize, prevSize));
                prevSize = hiddenSize;
            }
            return hiddenLayersModel;
        }
        getHiddenLayer(hiddenSize, prevSize) {
            return {
                // wxh
                weight: new RandomMatrix(hiddenSize, prevSize, 0.08),
                // whh
                transition: new RandomMatrix(hiddenSize, hiddenSize, 0.08),
                // bhh
                bias: new Matrix(hiddenSize, 1),
            };
        }
        getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
            if (!hiddenLayer.weight || !hiddenLayer.transition || !hiddenLayer.bias) {
                throw new Error('hiddenLayer does not have expected properties');
            }
            const relu = equation.relu.bind(equation);
            const add = equation.add.bind(equation);
            const multiply = equation.multiply.bind(equation);
            return relu(add(add(multiply(hiddenLayer.weight, inputMatrix), multiply(hiddenLayer.transition, previousResult)), hiddenLayer.bias));
        }
        createInputMatrix() {
            const { inputRange, inputSize } = this.options;
            if (inputRange < 1)
                throw new Error('this.options.inputRange not an expected number');
            if (inputSize < 1)
                throw new Error('this.options.inputSize not an expected number');
            // 0 is end, so add 1 to offset
            return new RandomMatrix(inputRange + 1, inputSize, 0.08);
        }
        createOutputMatrices() {
            const { outputSize, hiddenLayers } = this.options;
            const lastHiddenSize = last(hiddenLayers);
            // 0 is end, so add 1 to offset
            return {
                // whd
                outputConnector: new RandomMatrix(outputSize + 1, lastHiddenSize, 0.08),
                // 0 is end, so add 1 to offset
                // bd
                output: new Matrix(outputSize + 1, 1),
            };
        }
        bindEquation() {
            const { model } = this;
            const { hiddenLayers } = this.options;
            const equation = new Equation();
            const outputs = [];
            const equationConnection = model.equationConnections.length > 0
                ? last(model.equationConnections)
                : this.initialLayerInputs;
            // 0 index
            let output = this.getEquation(equation, equation.inputMatrixToRow(model.input), equationConnection[0], model.hiddenLayers[0]);
            outputs.push(output);
            // 1+ indices
            for (let i = 1, max = hiddenLayers.length; i < max; i++) {
                if (!equationConnection[i]) {
                    throw new Error(`Cannot find equation at index ${i}`);
                }
                output = this.getEquation(equation, output, equationConnection[i], model.hiddenLayers[i]);
                outputs.push(output);
            }
            model.equationConnections.push(outputs);
            equation.add(equation.multiply(model.outputConnector, output), model.output);
            model.equations.push(equation);
        }
        mapModel() {
            const allMatrices = [];
            this.initialLayerInputs = this.options.hiddenLayers.map((size) => new Matrix(size, 1));
            const input = this.createInputMatrix();
            allMatrices.push(input);
            const hiddenLayers = this.createHiddenLayers();
            if (!hiddenLayers.length)
                throw new Error('net.hiddenLayers not set');
            for (let i = 0, max = hiddenLayers.length; i < max; i++) {
                const hiddenMatrix = hiddenLayers[i];
                for (const property in hiddenMatrix) {
                    if (!hiddenMatrix.hasOwnProperty(property))
                        continue;
                    allMatrices.push(hiddenMatrix[property]);
                }
            }
            const { output, outputConnector } = this.createOutputMatrices();
            allMatrices.push(outputConnector);
            allMatrices.push(output);
            return Object.seal({
                isInitialized: true,
                input,
                hiddenLayers,
                output,
                equations: [],
                allMatrices,
                equationConnections: [],
                outputConnector,
            });
        }
        trainInput(input) {
            this.runs++;
            const { model } = this;
            const max = input.length;
            let log2ppl = 0;
            let equation;
            while (model.equations.length <= input.length + 1) {
                // last is zero
                this.bindEquation();
            }
            for (let inputIndex = -1, inputMax = input.length; inputIndex < inputMax; inputIndex++) {
                // start and end tokens are zeros
                const equationIndex = inputIndex + 1;
                equation = model.equations[equationIndex];
                const source = inputIndex === -1 ? 0 : input[inputIndex] + 1; // first step: start with START token
                const target = inputIndex === max - 1 ? 0 : input[inputIndex + 1] + 1; // last step: end with END token
                log2ppl += equation.predictTargetIndex(source, target);
            }
            return Math.pow(2, log2ppl / (max - 1)) / 100;
        }
        backpropagate(input) {
            let i = input.length;
            const { model } = this;
            const { equations } = model;
            while (i > 0) {
                equations[i].backpropagateIndex(input[i - 1] + 1);
                i--;
            }
            equations[0].backpropagateIndex(0);
        }
        adjustWeights() {
            const { regc, clipval, decayRate, smoothEps } = this.options;
            const { trainOpts, model, stepCache } = this;
            const { learningRate } = trainOpts;
            const { allMatrices } = model;
            let numClipped = 0;
            let numTot = 0;
            for (let matrixIndex = 0; matrixIndex < allMatrices.length; matrixIndex++) {
                const matrix = allMatrices[matrixIndex];
                const { weights, deltas } = matrix;
                if (!(matrixIndex in stepCache)) {
                    stepCache[matrixIndex] = zeros$1(matrix.rows * matrix.columns);
                }
                const cache = stepCache[matrixIndex];
                for (let i = 0; i < weights.length; i++) {
                    let r = deltas[i];
                    const w = weights[i];
                    // rmsprop adaptive learning rate
                    cache[i] = cache[i] * decayRate + (1 - decayRate) * r * r;
                    // gradient clip
                    if (r > clipval) {
                        r = clipval;
                        numClipped++;
                    }
                    else if (r < -clipval) {
                        r = -clipval;
                        numClipped++;
                    }
                    numTot++;
                    // update (and regularize)
                    weights[i] =
                        w + (-learningRate * r) / Math.sqrt(cache[i] + smoothEps) - regc * w;
                }
            }
            this.ratioClipped = numClipped / numTot;
        }
        get isRunnable() {
            if (this.model && this.model.equations.length === 0) {
                console.error(`No equations bound, did you run train()?`);
                return false;
            }
            return true;
        }
        checkRunnable() {
            if (!this.isRunnable) {
                throw new Error('Network not runnable');
            }
        }
        run(rawInput = [], isSampleI = false, temperature = 1) {
            const maxPredictionLength = this.options.maxPredictionLength +
                (rawInput !== null ? rawInput.length : 0) +
                (this.options.dataFormatter
                    ? this.options.dataFormatter.specialIndexes.length
                    : 0);
            this.checkRunnable();
            const input = this.options.dataFormatter && rawInput.length > 0
                ? this.options.dataFormatter.formatDataIn(rawInput)
                : rawInput;
            const { model } = this;
            const output = [];
            let i = 0;
            while (true) {
                const previousIndex = i === 0 ? 0 : i < input.length ? input[i - 1] + 1 : output[i - 1];
                while (model.equations.length <= i) {
                    this.bindEquation();
                }
                const equation = model.equations[i];
                // sample predicted letter
                const outputMatrix = equation.runIndex(previousIndex);
                const logProbabilities = new Matrix(model.output.rows, model.output.columns);
                copy(logProbabilities, outputMatrix);
                if (temperature !== 1 && isSampleI) {
                    /**
                     * scale log probabilities by temperature and re-normalize
                     * if temperature is high, logProbabilities will go towards zero
                     * and the softmax outputs will be more diffuse. if temperature is
                     * very low, the softmax outputs will be more peaky
                     */
                    for (let j = 0, max = logProbabilities.weights.length; j < max; j++) {
                        logProbabilities.weights[j] /= temperature;
                    }
                }
                const probs = softmax(logProbabilities);
                const nextIndex = isSampleI ? sampleI(probs) : maxI(probs);
                i++;
                if (nextIndex === 0) {
                    // END token predicted, break out
                    break;
                }
                if (i >= maxPredictionLength) {
                    // something is wrong
                    break;
                }
                output.push(nextIndex);
            }
            /**
             * we slice the input length here, not because output contains it, but it will be erroneous as we are sending the
             * network what is contained in input, so the data is essentially guessed by the network what could be next, till it
             * locks in on a value.
             * Kind of like this, values are from input:
             * 0 -> 4 (or in English: "beginning on input" -> "I have no idea? I'll guess what they want next!")
             * 2 -> 2 (oh how interesting, I've narrowed down values...)
             * 1 -> 9 (oh how interesting, I've now know what the values are...)
             * then the output looks like: [4, 2, 9,...]
             * so we then remove the erroneous data to get our true output
             */
            return this.options.dataFormatter.formatDataOut(input, output.slice(input.length).map((value) => value - 1));
        }
        /**
         *
         * Verifies network sizes are initialized
         * If they are not it will initialize them
         */
        verifyIsInitialized() {
            if (!this.model.isInitialized) {
                this.initialize();
            }
        }
        /**
         *
         * @param options
         *    Supports all `trainDefaults` properties
         *    also supports:
         *       learningRate: (number),
         *       momentum: (number),
         *       activation: 'sigmoid', 'relu', 'leaky-relu', 'tanh'
         */
        updateTrainingOptions(options) {
            var _a;
            this.trainOpts = { ...trainDefaults$1, ...options };
            this.validateTrainingOptions(this.trainOpts);
            this.setLogMethod((_a = options.log) !== null && _a !== void 0 ? _a : this.trainOpts.log);
            // TODO: Remove this?
            // this.activation = options.activation || this.activation;
        }
        validateTrainingOptions(options) {
            const validations = {
                iterations: () => {
                    const val = options.iterations;
                    return typeof val === 'number' && val > 0;
                },
                errorThresh: () => {
                    const val = options.errorThresh;
                    return typeof val === 'number' && val > 0 && val < 1;
                },
                log: () => {
                    const val = options.log;
                    return typeof val === 'function' || typeof val === 'boolean';
                },
                logPeriod: () => {
                    const val = options.logPeriod;
                    return typeof val === 'number' && val > 0;
                },
                learningRate: () => {
                    const val = options.learningRate;
                    return typeof val === 'number' && val > 0 && val < 1;
                },
                callback: () => {
                    const val = options.callback;
                    return typeof val === 'function' || val === undefined;
                },
                callbackPeriod: () => {
                    const val = options.callbackPeriod;
                    return typeof val === 'number' && val > 0;
                },
                timeout: () => {
                    const val = options.timeout;
                    return typeof val === 'number' && val > 0;
                },
            };
            for (const p in validations) {
                const v = options;
                if (!validations[p]()) {
                    throw new Error(`[${p}, ${v[p]}] is out of normal training range, your network will probably not train.`);
                }
            }
        }
        setLogMethod(log) {
            if (typeof log === 'function') {
                this.trainOpts.log = log;
            }
            else if (log) {
                this.trainOpts.log = console.log;
            }
            else {
                this.trainOpts.log = false;
            }
        }
        prepTraining(data, options) {
            var _a;
            this.updateTrainingOptions(options);
            const preparedData = this.options.dataFormatter.format(data);
            const endTime = Date.now() + ((_a = this.trainOpts.timeout) !== null && _a !== void 0 ? _a : 0);
            const status = {
                error: 1,
                iterations: 0,
            };
            this.verifyIsInitialized();
            return {
                preparedData,
                status,
                endTime,
            };
        }
        train(data, trainOpts = {}) {
            var _a;
            this.trainOpts = trainOpts = {
                ...trainDefaults$1,
                ...trainOpts,
            };
            const { iterations, errorThresh, logPeriod, callback, callbackPeriod, } = this.trainOpts;
            const log = trainOpts.log === true ? console.log : trainOpts.log;
            let error = Infinity;
            let i;
            let inputs;
            if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.dataFormatter) {
                inputs = this.options.dataFormatter.format(data);
            }
            else if (Array.isArray(data) &&
                Array.isArray(data[0]) &&
                typeof data[0][0] === 'number') {
                inputs = data;
            }
            else {
                throw new Error('training not in expected format of number[][]');
            }
            this.verifyIsInitialized();
            for (i = 0; i < iterations && error > errorThresh; i++) {
                let sum = 0;
                for (let j = 0; j < inputs.length; j++) {
                    const err = this.trainPattern(inputs[j], true);
                    sum += err;
                }
                error = sum / data.length;
                if (isNaN(error)) {
                    throw new Error('Network error rate is unexpected NaN, check network configurations and try again. Most probably input format is not correct or training data is not enough. ');
                }
                if (log && i % logPeriod === 0) {
                    log(`iterations: ${i}, training error: ${error}`);
                }
                if (callback && i % callbackPeriod === 0) {
                    callback({ error, iterations: i });
                }
            }
            return {
                error,
                iterations: i,
            };
        }
        addFormat(data) { }
        formatData(data) {
            const result = [];
            for (let i = 0; i < data.length; i++) {
                result.push(this.options.dataFormatter.formatDataIn(data[i]));
            }
            return result;
        }
        toJSON() {
            if (!this.model.isInitialized) {
                this.initialize();
            }
            const { model, options } = this;
            return {
                type: this.constructor.name,
                options: { ...options, dataFormatter: options.dataFormatter.toJSON() },
                trainOpts: {
                    ...this.trainOpts,
                    timeout: this.trainOpts.timeout === Infinity
                        ? 'Infinity'
                        : this.trainOpts.timeout,
                },
                input: model.input.toJSON(),
                hiddenLayers: model.hiddenLayers.map((hiddenLayer) => {
                    const layers = {};
                    for (const p in hiddenLayer) {
                        if (!hiddenLayer.hasOwnProperty(p))
                            continue;
                        layers[p] = hiddenLayer[p].toJSON();
                    }
                    return layers;
                }),
                outputConnector: this.model.outputConnector.toJSON(),
                output: this.model.output.toJSON(),
            };
        }
        fromJSON(json) {
            const { options } = json;
            const allMatrices = [];
            const input = Matrix.fromJSON(json.input);
            allMatrices.push(input);
            const hiddenLayers = [];
            json.hiddenLayers.forEach((hiddenLayer) => {
                const layers = {};
                for (const p in hiddenLayer) {
                    layers[p] = Matrix.fromJSON(hiddenLayer[p]);
                    allMatrices.push(layers[p]);
                }
                hiddenLayers.push(layers);
            });
            const outputConnector = Matrix.fromJSON(json.outputConnector);
            allMatrices.push(outputConnector);
            const output = Matrix.fromJSON(json.output);
            allMatrices.push(output);
            if (options.dataFormatter) {
                this.options = {
                    ...defaults$1(),
                    ...options,
                    dataFormatter: DataFormatter.fromJSON(options.dataFormatter),
                };
            }
            else {
                this.options = {
                    ...defaults$1(),
                    ...options,
                    dataFormatter: new DataFormatter(),
                };
            }
            this.model = Object.seal({
                isInitialized: true,
                input,
                hiddenLayers,
                output,
                allMatrices,
                outputConnector,
                equations: [],
                equationConnections: [],
            });
            this.initialLayerInputs = this.options.hiddenLayers.map((size) => new Matrix(size, 1));
            this.bindEquation();
            return this;
        }
        toFunction(cb) {
            const { model } = this;
            const { equations } = this.model;
            const equation = equations[1];
            const { states } = equation;
            const jsonString = JSON.stringify(this.toJSON());
            function previousConnectionIndex(m) {
                const connection = model.equationConnections[0];
                const { states } = equations[0];
                for (let i = 0, max = states.length; i < max; i++) {
                    if (states[i].product === m) {
                        return i;
                    }
                }
                return connection.indexOf(m);
            }
            function matrixOrigin(m, stateIndex) {
                for (let i = 0, max = states.length; i < max; i++) {
                    const state = states[i];
                    if (i === stateIndex) {
                        const j = previousConnectionIndex(m);
                        if (j > -1 && (m === state.left || m === state.right)) {
                            return `typeof prevStates[${j}] === 'object' ? prevStates[${j}].product : new Matrix(${m.rows}, ${m.columns})`;
                        }
                        return `new Matrix(${m.rows}, ${m.columns})`;
                    }
                    if (m === state.product)
                        return `states[${i}].product`;
                    if (m === state.right)
                        return `states[${i}].right`;
                    if (m === state.left)
                        return `states[${i}].left`;
                }
                return '';
            }
            function matrixToString(m, stateIndex) {
                if (!m || !m.rows || !m.columns)
                    return 'null';
                if (m === model.input)
                    return `json.input`;
                if (m === model.outputConnector)
                    return `json.outputConnector`;
                if (m === model.output)
                    return `json.output`;
                for (let i = 0, max = model.hiddenLayers.length; i < max; i++) {
                    const hiddenLayer = model.hiddenLayers[i];
                    for (const p in hiddenLayer) {
                        if (!hiddenLayer.hasOwnProperty(p))
                            continue;
                        if (hiddenLayer[p] !== m)
                            continue;
                        return `json.hiddenLayers[${i}].${p}`;
                    }
                }
                return matrixOrigin(m, stateIndex);
            }
            function toInner(fnString) {
                // crude, but should be sufficient for now
                // function() { body }
                const fnParts = fnString.toString().split('{');
                fnParts.shift();
                // body }
                const fnBodyString = fnParts.join('{');
                const fnBodyParts = fnBodyString.split('}');
                fnBodyParts.pop();
                // body
                return fnBodyParts
                    .join('}')
                    .split('\n')
                    .join('\n        ')
                    .replace('product.deltas[i] = 0;', '')
                    .replace('product.deltas[column] = 0;', '')
                    .replace('left.deltas[leftIndex] = 0;', '')
                    .replace('right.deltas[rightIndex] = 0;', '')
                    .replace('product.deltas = left.deltas.slice(0);', '');
            }
            function fileName(fnName) {
                return `src/recurrent/matrix/${fnName.replace(/[A-Z]/g, function (value) {
                return `-${value.toLowerCase()}`;
            })}.js`;
            }
            const statesRaw = [];
            const usedFunctionNames = {};
            const innerFunctionsSwitch = [];
            for (let i = 0, max = states.length; i < max; i++) {
                const state = states[i];
                statesRaw.push(`states[${i}] = {
      name: '${state.forwardFn.name}',
      left: ${state.left ? matrixToString(state.left, i) : 'undefined'},
      right: ${state.right ? matrixToString(state.right, i) : 'undefined'},
      product: ${matrixToString(state.product, i)}
    }`);
                const fnName = state.forwardFn.name;
                if (!usedFunctionNames[fnName]) {
                    usedFunctionNames[fnName] = true;
                    innerFunctionsSwitch.push(`        case '${fnName}': //compiled from ${fileName(fnName)}
          ${toInner(state.forwardFn.toString())}
          break;`);
                }
            }
            const src = `
  if (typeof rawInput === 'undefined') rawInput = [];
  if (typeof isSampleI === 'undefined') isSampleI = false;
  if (typeof temperature === 'undefined') temperature = 1;
  var json = ${jsonString};
  ${this.options.dataFormatter
            ? `${this.options.dataFormatter.toFunctionString()};
  Object.assign(dataFormatter, json.options.dataFormatter);`
            : ''}
  ${this.options.dataFormatter &&
            typeof this.options.dataFormatter.formatDataIn === 'function'
            ? `const formatDataIn = function (input, output) { ${toInner(this.options.dataFormatter.formatDataIn.toString())} }.bind(dataFormatter);`
            : ''}
  ${this.options.dataFormatter !== null &&
            typeof this.options.dataFormatter.formatDataOut === 'function'
            ? `const formatDataOut = function formatDataOut(input, output) { ${toInner(this.options.dataFormatter.formatDataOut.toString())} }.bind(dataFormatter);`
            : ''}
  var maxPredictionLength =
    ${this.options.maxPredictionLength} +
    rawInput.length +
    ${this.options.dataFormatter
            ? this.options.dataFormatter.specialIndexes.length
            : 0};
  var input = ${this.options.dataFormatter &&
            typeof this.options.dataFormatter.formatDataIn === 'function'
            ? 'formatDataIn(rawInput)'
            : 'rawInput'};
  var _i = 0;
  var output = [];
  var states = [];
  var prevStates;
  while (true) {
    var previousIndex = (_i === 0
        ? 0
        : _i < input.length
          ? input[_i - 1] + 1
          : output[_i - 1])
          ;
    var rowPluckIndex = previousIndex;
    prevStates = states;
    states = [];
    ${statesRaw.join(';\n    ')};
    for (var stateIndex = 0, stateMax = ${statesRaw.length}; stateIndex < stateMax; stateIndex++) {
      var state = states[stateIndex];
      var product = state.product;
      var left = state.left;
      var right = state.right;
      switch (state.name) {
${innerFunctionsSwitch.join('\n')}
      }
    }

    var logProbabilities = state.product;
    if (temperature !== 1 && isSampleI) {
      for (var q = 0, nq = logProbabilities.weights.length; q < nq; q++) {
        logProbabilities.weights[q] /= temperature;
      }
    }

    var probs = softmax(logProbabilities);
    var nextIndex = isSampleI ? sampleI(probs) : maxI(probs);

    _i++;
    if (nextIndex === 0) {
      break;
    }
    if (_i >= maxPredictionLength) {
      break;
    }

    output.push(nextIndex);
  }
  ${this.options.dataFormatter &&
            typeof this.options.dataFormatter.formatDataOut === 'function'
            ? 'return formatDataOut(input, output.slice(input.length).map(function(value) { return value - 1; }))'
            : 'return output.slice(input.length).map(function(value) { return value - 1; })'};
  function Matrix(rows, columns) {
    this.rows = rows;
    this.columns = columns;
    this.weights = zeros(rows * columns);
  }
  ${zeros$1.toString()}
  ${softmax.toString().replace('_1.Matrix', 'Matrix')}
  ${randomFloat.toString()}
  ${sampleI.toString()}
  ${maxI.toString()}`;
            // eslint-disable-next-line
            return new Function('rawInput', 'isSampleI', 'temperature', cb ? cb(src) : src);
        }
        trainPattern(input, logErrorRate) {
            const error = this.trainInput(input);
            this.backpropagate(input);
            this.adjustWeights();
            if (logErrorRate) {
                return error;
            }
            return 0;
        }
    }
    function last(values) {
        return values[values.length - 1];
    }

    class GRU extends RNN {
        getHiddenLayer(hiddenSize, prevSize) {
            return getGRUHiddenLayer(hiddenSize, prevSize);
        }
        getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
            return getGRUEquation(equation, inputMatrix, previousResult, hiddenLayer);
        }
    }
    function getGRUHiddenLayer(hiddenSize, prevSize) {
        return {
            // update Gate
            // wzxh
            updateGateInputMatrix: new RandomMatrix(hiddenSize, prevSize, 0.08),
            updateGateHiddenMatrix: new RandomMatrix(hiddenSize, hiddenSize, 0.08),
            updateGateBias: new Matrix(hiddenSize, 1),
            // reset Gate
            // wrxh
            resetGateInputMatrix: new RandomMatrix(hiddenSize, prevSize, 0.08),
            resetGateHiddenMatrix: new RandomMatrix(hiddenSize, hiddenSize, 0.08),
            resetGateBias: new Matrix(hiddenSize, 1),
            // cell write parameters
            // wcxh
            cellWriteInputMatrix: new RandomMatrix(hiddenSize, prevSize, 0.08),
            cellWriteHiddenMatrix: new RandomMatrix(hiddenSize, hiddenSize, 0.08),
            cellWriteBias: new Matrix(hiddenSize, 1),
        };
    }
    function getGRUEquation(equation, inputMatrix, previousResult, hiddenLayer) {
        if (!hiddenLayer.updateGateInputMatrix ||
            !hiddenLayer.updateGateHiddenMatrix ||
            !hiddenLayer.updateGateBias ||
            !hiddenLayer.resetGateInputMatrix ||
            !hiddenLayer.resetGateHiddenMatrix ||
            !hiddenLayer.resetGateBias ||
            !hiddenLayer.cellWriteInputMatrix ||
            !hiddenLayer.cellWriteHiddenMatrix ||
            !hiddenLayer.cellWriteBias) {
            throw new Error('hiddenLayer does not have expected properties');
        }
        const sigmoid = equation.sigmoid.bind(equation);
        const add = equation.add.bind(equation);
        const multiply = equation.multiply.bind(equation);
        const multiplyElement = equation.multiplyElement.bind(equation);
        const tanh = equation.tanh.bind(equation);
        const allOnes = equation.allOnes.bind(equation);
        const cloneNegative = equation.cloneNegative.bind(equation);
        // update gate
        const updateGate = sigmoid(add(add(multiply(hiddenLayer.updateGateInputMatrix, inputMatrix), multiply(hiddenLayer.updateGateHiddenMatrix, previousResult)), hiddenLayer.updateGateBias));
        // reset gate
        const resetGate = sigmoid(add(add(multiply(hiddenLayer.resetGateInputMatrix, inputMatrix), multiply(hiddenLayer.resetGateHiddenMatrix, previousResult)), hiddenLayer.resetGateBias));
        // cell
        const cell = tanh(add(add(multiply(hiddenLayer.cellWriteInputMatrix, inputMatrix), multiply(hiddenLayer.cellWriteHiddenMatrix, multiplyElement(resetGate, previousResult))), hiddenLayer.cellWriteBias));
        // compute hidden state as gated, saturated cell activations
        // negate updateGate
        return add(multiplyElement(add(allOnes(updateGate.rows, updateGate.columns), cloneNegative(updateGate)), cell), multiplyElement(previousResult, updateGate));
    }

    class ArrayLookupTable {
        constructor(data, prop) {
            this.prop = prop;
            this.length = 0;
            this.table = {};
            for (let i = 0; i < data.length; i++) {
                const datum = data[i];
                const ioValue = datum[prop];
                for (let j = 0; j < ioValue.length; j++) {
                    const value = ioValue[j];
                    for (const p in value) {
                        if (!value.hasOwnProperty(p))
                            continue;
                        if (this.table.hasOwnProperty(p))
                            continue;
                        this.table[p] = this.length++;
                    }
                }
            }
        }
    }

    const defaults = () => {
        return {
            ...defaults$1(),
            inputSize: 1,
            hiddenLayers: [20],
            outputSize: 1,
            inputRange: 0,
        };
    };
    class RNNTimeStep extends RNN {
        constructor(options = {}) {
            super();
            this.inputLookupLength = 0;
            this.inputLookup = null;
            this.outputLookup = null;
            this.outputLookupLength = 0;
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            this.model = Object.seal({
                isInitialized: false,
                hiddenLayers: [],
                output: new Matrix(0, 0),
                equations: [],
                allMatrices: [],
                equationConnections: [],
                outputConnector: new RandomMatrix(0, 0, 0.08),
            });
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            this.options = defaults();
            this.options = { ...this.options, ...options };
            this.updateTrainingOptions({
                ...trainDefaults,
                ...options,
            });
            if (options.json) {
                this.fromJSON(options.json);
            }
        }
        createInputMatrix() {
            throw new Error('Input Matrices do not exist on RNNTimeStep');
        }
        createOutputMatrices() {
            const { outputSize } = this.options;
            const lastHiddenSize = last(this.options.hiddenLayers);
            // whd
            const outputConnector = new RandomMatrix(outputSize, lastHiddenSize, 0.08);
            // bd
            const output = new RandomMatrix(outputSize, 1, 0.08);
            return { output, outputConnector };
        }
        bindEquation() {
            const { model, options } = this;
            const { hiddenLayers, inputSize } = options;
            const layers = model.hiddenLayers;
            const equation = new Equation();
            const outputs = [];
            const equationConnection = model.equationConnections.length > 0
                ? model.equationConnections[model.equationConnections.length - 1]
                : this.initialLayerInputs;
            // 0 index
            let output = this.getEquation(equation, equation.input(new Matrix(inputSize, 1)), equationConnection[0], layers[0]);
            outputs.push(output);
            // 1+ indices
            for (let i = 1, max = hiddenLayers.length; i < max; i++) {
                output = this.getEquation(equation, output, equationConnection[i], layers[i]);
                outputs.push(output);
            }
            model.equationConnections.push(outputs);
            equation.add(equation.multiply(model.outputConnector, output), model.output);
            model.equations.push(equation);
        }
        initialize() {
            this.model = this.mapModel();
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        mapModel() {
            const allMatrices = [];
            this.initialLayerInputs = this.options.hiddenLayers.map((size) => new Matrix(size, 1));
            const hiddenLayers = this.createHiddenLayers();
            for (let i = 0, max = hiddenLayers.length; i < max; i++) {
                const hiddenMatrix = hiddenLayers[i];
                for (const property in hiddenMatrix) {
                    if (!hiddenMatrix.hasOwnProperty(property))
                        continue;
                    allMatrices.push(hiddenMatrix[property]);
                }
            }
            const { outputConnector, output } = this.createOutputMatrices();
            allMatrices.push(outputConnector);
            allMatrices.push(output);
            return Object.seal({
                isInitialized: true,
                hiddenLayers,
                output,
                equations: [],
                allMatrices,
                equationConnections: [],
                outputConnector,
            });
        }
        backpropagate() {
            for (let i = this.model.equations.length - 1; i > -1; i--) {
                this.model.equations[i].backpropagate();
            }
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        run(rawInput) {
            const shape = lookup.dataShape(rawInput).join(',');
            switch (shape) {
                case 'array,number':
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-expect-error
                    return this.runArray(rawInput);
                case 'array,array,number':
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-expect-error
                    return this.runArrayOfArray(rawInput);
                case 'object,number':
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-expect-error
                    return this.runObject(rawInput); // Backward compatibility, will be result of `unknown` and need casting.  Better to just use net.runObject() directly
                case 'array,object,number':
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-expect-error
                    return this.runArrayOfObject(rawInput);
                default:
                    throw new Error(`Unrecognized data shape ${shape}`);
            }
        }
        forecast(rawInput, count = 1) {
            const shape = lookup.dataShape(rawInput).join(',');
            switch (shape) {
                case 'array,number':
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-expect-error
                    return this.forecastArray(rawInput, count);
                case 'array,array,number':
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-expect-error
                    return this.forecastArrayOfArray(rawInput, count);
                case 'object,number':
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-expect-error
                    return this.runObject(rawInput);
                case 'array,object,number':
                    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
                    // @ts-expect-error
                    return this.forecastArrayOfObject(rawInput, count);
                default:
                    throw new Error(`Unrecognized data shape ${shape}`);
            }
        }
        forecastArray(input, count = 1) {
            this.checkRunnable();
            const { model } = this;
            const { equations } = model;
            const length = input.length + count;
            while (equations.length <= length) {
                this.bindEquation();
            }
            let lastOutput;
            let equationIndex = 0;
            if (this.options.inputSize === 1) {
                for (let i = 0; i < input.length; i++) {
                    lastOutput = equations[equationIndex++].runInput(Float32Array.from([input[i]]));
                }
            }
            else {
                for (let i = 0; i < input.length; i++) {
                    lastOutput = equations[equationIndex++].runInput(Float32Array.from([]));
                }
            }
            if (!lastOutput) {
                throw new Error('lastOutput not set');
            }
            const result = [lastOutput.weights[0]];
            for (let i = 0, max = count - 1; i < max; i++) {
                lastOutput = equations[equationIndex++].runInput(lastOutput.weights);
                result.push(lastOutput.weights[0]);
            }
            this.end();
            return Float32Array.from(result);
        }
        forecastArrayOfArray(input, count = 1) {
            this.checkRunnable();
            const { model } = this;
            const { equations } = model;
            const length = input.length + count;
            while (equations.length <= length) {
                this.bindEquation();
            }
            let lastOutput;
            let equationIndex = 0;
            for (let i = 0; i < input.length; i++) {
                lastOutput = equations[equationIndex++].runInput(input[i]);
            }
            if (!lastOutput) {
                throw new Error('lastOutput not set');
            }
            const result = [Float32Array.from(lastOutput.weights)];
            for (let i = 0, max = count - 1; i < max; i++) {
                lastOutput = equations[equationIndex++].runInput(lastOutput.weights);
                result.push(Float32Array.from(lastOutput.weights.slice(0)));
            }
            this.end();
            return result;
        }
        forecastArrayOfObject(input, count = 1) {
            if (!this.inputLookup) {
                throw new Error('this.inputLookup not set');
            }
            if (!this.outputLookup) {
                throw new Error('this.outputLookup not set');
            }
            const formattedData = input.map((value) => lookup.toArray(this.inputLookup, value, this.inputLookupLength));
            return this.forecastArrayOfArray(formattedData, count).map((value) => lookup.toObject(this.outputLookup, value));
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        train(data, trainOpts = {}) {
            this.trainOpts = trainOpts = {
                ...trainDefaults$1,
                ...trainOpts,
            };
            // Don't destructure here because this.setSize() can reset this.options.
            if (this.options.inputSize === 1 && this.options.outputSize === 1) {
                this.setSize(data);
            }
            this.verifySize();
            const formattedData = this.formatData(data);
            let error = Infinity;
            let i;
            this.verifyIsInitialized();
            const { iterations, errorThresh, logPeriod, callback, callbackPeriod, } = this.trainOpts;
            const log = trainOpts.log === true ? console.log : trainOpts.log;
            for (i = 0; i < iterations && error > errorThresh; i++) {
                let sum = 0;
                for (let j = 0; j < formattedData.length; j++) {
                    const err = this.trainPattern(formattedData[j], true);
                    sum += err;
                }
                error = sum / formattedData.length;
                if (isNaN(error))
                    throw new Error('Network error rate is unexpected NaN, check network configurations and try again. Most probably input format is not correct or training data is not enough. ');
                if (log && i % logPeriod === 0) {
                    log(`iterations: ${i}, training error: ${error}`);
                }
                if (callback && i % callbackPeriod === 0) {
                    callback({ error, iterations: i });
                }
            }
            return {
                error,
                iterations: i,
            };
        }
        trainArrayOfArray(input) {
            if (input.length < 2) {
                throw new Error('input must be an array of 2 or more');
            }
            const { equations } = this.model;
            while (equations.length < input.length) {
                this.bindEquation();
            }
            let errorSum = 0;
            for (let i = 0, max = input.length - 1; i < max; i++) {
                errorSum += equations[i].predictTarget(input[i], input[i + 1]);
            }
            this.end();
            return errorSum / input.length;
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        trainPattern(input, logErrorRate) {
            const error = this.trainArrayOfArray(input);
            this.backpropagate();
            this.adjustWeights();
            if (logErrorRate) {
                return error;
            }
            return 0;
        }
        setSize(data) {
            let size = 0;
            const dataShape = lookup.dataShape(data).join(',');
            switch (dataShape) {
                case 'array,array,number':
                case 'array,object,number':
                case 'array,datum,array,number':
                case 'array,datum,object,number':
                    size = 1;
                    // probably 1
                    break;
                case 'array,array,array,number':
                    size = data[0][0].length;
                    break;
                case 'array,array,object,number':
                    // inputs and outputs should match
                    size = Object.keys(lookup.toTable2D(data)).length;
                    break;
                case 'array,datum,array,array,number':
                    size = data[0].input[0].length;
                    break;
                case 'array,datum,array,object,number':
                    size = Object.keys(lookup.toInputTable2D(data)).length;
                    break;
                default:
                    throw new Error('unknown data shape or configuration');
            }
            this.options = Object.seal({
                ...this.options,
                inputSize: size,
                outputSize: size,
            });
        }
        verifySize() {
            if (this.options.inputSize || this.options.outputSize) {
                if (this.options.inputSize !== this.options.outputSize) {
                    throw new Error('manually set inputSize and outputSize mismatch');
                }
            }
        }
        runArray(input) {
            this.checkRunnable();
            const { equations } = this.model;
            while (equations.length <= input.length) {
                this.bindEquation();
            }
            let lastOutput;
            for (let i = 0; i < input.length; i++) {
                lastOutput = equations[i].runInput(new Float32Array([input[i]]));
            }
            this.end();
            return lastOutput.weights[0];
        }
        runArrayOfArray(input) {
            this.checkRunnable();
            const { model } = this;
            const { equations } = model;
            while (equations.length <= input.length) {
                this.bindEquation();
            }
            let lastOutput;
            for (let i = 0; i < input.length; i++) {
                const outputMatrix = equations[i].runInput(input[i]);
                lastOutput = outputMatrix.weights;
            }
            this.end();
            return lastOutput !== null && lastOutput !== void 0 ? lastOutput : Float32Array.from([]);
        }
        runObject(input) {
            if (!this.inputLookup) {
                throw new Error('this.inputLookup not set');
            }
            if (!this.outputLookup) {
                throw new Error('this.outputLookup not set');
            }
            if (!this.outputLookupLength) {
                throw new Error('this.outputLookupLength not set');
            }
            if (this.inputLookup === this.outputLookup) {
                const inputArray = lookup.toArrayShort(this.inputLookup, input);
                return lookup.toObjectPartial(this.outputLookup, this.forecastArray(inputArray, this.outputLookupLength - inputArray.length), inputArray.length);
            }
            return lookup.toObject(this.outputLookup, this.forecastArray(lookup.toArray(this.inputLookup, input, this.inputLookupLength), this.outputLookupLength));
        }
        runArrayOfObject(input) {
            if (this.inputLookup === null) {
                throw new Error('this.inputLookup not set');
            }
            if (this.outputLookup === null) {
                throw new Error('this.outputLookup not set');
            }
            const formattedInput = input.map((value) => lookup.toArray(this.inputLookup, value, this.inputLookupLength));
            return this.forecastArrayOfArray(formattedInput, 1).map((value) => lookup.toObject(this.outputLookup, value))[0];
        }
        runArrayOfObjectOfArray(input) {
            if (!this.inputLookup) {
                throw new Error('this.inputLookup not set');
            }
            if (!this.outputLookup) {
                throw new Error('this.outputLookup not set');
            }
            return lookup.toObject(this.outputLookup, this.runArrayOfArray(lookup.toArrays(this.inputLookup, input, this.inputLookupLength)));
        }
        end() {
            this.model.equations[this.model.equations.length - 1].runInput(new Float32Array(this.options.outputSize));
        }
        requireInputOutputOfOne() {
            if (this.options.inputSize !== 1) {
                throw new Error('inputSize must be 1 for this data size');
            }
            if (this.options.outputSize !== 1) {
                throw new Error('outputSize must be 1 for this data size');
            }
        }
        // Handles data shape of 'array,number'
        formatArray(data) {
            const result = [];
            this.requireInputOutputOfOne();
            for (let i = 0; i < data.length; i++) {
                result.push(Float32Array.from([data[i]]));
            }
            return [result];
        }
        // Handles data shape of 'array,array,number'
        formatArrayOfArray(data) {
            const result = [];
            const { inputSize, outputSize } = this.options;
            if (inputSize === 1 && outputSize === 1) {
                for (let i = 0; i < data.length; i++) {
                    result.push(arrayToFloat32Arrays(data[i]));
                }
                return result;
            }
            if (inputSize !== data[0].length) {
                throw new Error('inputSize must match data input size');
            }
            if (outputSize !== data[0].length) {
                throw new Error('outputSize must match data output size');
            }
            for (let i = 0; i < data.length; i++) {
                result.push(Float32Array.from(data[i]));
            }
            return [result];
        }
        // Handles data shape of 'array,object,number'
        formatArrayOfObject(data) {
            this.requireInputOutputOfOne();
            if (!this.inputLookup) {
                const lookupTable = new LookupTable(data);
                this.inputLookup = this.outputLookup = lookupTable.table;
                this.inputLookupLength = this.outputLookupLength = lookupTable.length;
            }
            const result = [];
            for (let i = 0; i < data.length; i++) {
                result.push(objectToFloat32Arrays(data[i]));
            }
            return result;
        }
        // Handles data shape of 'array,object,number' when this.options.inputSize > 1
        formatArrayOfObjectMulti(data) {
            if (!this.inputLookup) {
                const lookupTable = new LookupTable(data);
                this.inputLookup = this.outputLookup = lookupTable.table;
                this.inputLookupLength = this.outputLookupLength = lookupTable.length;
            }
            const result = [];
            for (let i = 0; i < data.length; i++) {
                result.push([
                    objectToFloat32Array(data[i], this.inputLookup, this.inputLookupLength),
                ]);
            }
            return result;
        }
        // Handles data shape of 'array,datum,array,number'
        formatArrayOfDatumOfArray(data) {
            const result = [];
            this.requireInputOutputOfOne();
            for (let i = 0; i < data.length; i++) {
                const datum = data[i];
                result.push(inputOutputArrayToFloat32Arrays(datum.input, datum.output));
            }
            return result;
        }
        // Handles data shape of 'array,datum,object,number'
        formatArrayOfDatumOfObject(data) {
            this.requireInputOutputOfOne();
            if (!this.inputLookup) {
                const inputLookup = new LookupTable(data, 'input');
                this.inputLookup = inputLookup.table;
                this.inputLookupLength = inputLookup.length;
            }
            if (!this.outputLookup) {
                const outputLookup = new LookupTable(data, 'output');
                this.outputLookup = outputLookup.table;
                this.outputLookupLength = outputLookup.length;
            }
            const result = [];
            for (let i = 0; i < data.length; i++) {
                const datum = data[i];
                result.push(inputOutputObjectToFloat32Arrays(datum.input, datum.output));
            }
            return result;
        }
        // Handles data shape of 'array,array,array,number'
        formatArrayOfArrayOfArray(data) {
            const result = [];
            for (let i = 0; i < data.length; i++) {
                result.push(arraysToFloat32Arrays(data[i]));
            }
            return result;
        }
        // Handles data shape of 'array,array,object,number'
        formatArrayOfArrayOfObject(data) {
            if (!this.inputLookup) {
                const lookupTable = new LookupTable(data);
                this.inputLookup = this.outputLookup = lookupTable.table;
                this.inputLookupLength = this.outputLookupLength = lookupTable.length;
            }
            const result = [];
            for (let i = 0; i < data.length; i++) {
                const array = [];
                for (let j = 0; j < data[i].length; j++) {
                    array.push(objectToFloat32Array(data[i][j], this.inputLookup, this.inputLookupLength));
                }
                result.push(array);
            }
            return result;
        }
        // Handles data shape of 'array,datum,array,array,number'
        formatArrayOfDatumOfArrayOfArray(data) {
            const result = [];
            const { inputSize, outputSize } = this.options;
            if (inputSize !== data[0].input[0].length) {
                throw new Error('inputSize must match data input size');
            }
            if (outputSize !== data[0].output[0].length) {
                throw new Error('outputSize must match data output size');
            }
            for (let i = 0; i < data.length; i++) {
                const datum = data[i];
                result.push(inputOutputArraysToFloat32Arrays(datum.input, datum.output));
            }
            return result;
        }
        // 'Handles data shape of array,datum,array,object,number'
        formatArrayOfDatumOfArrayOfObject(data) {
            if (!this.inputLookup) {
                const inputLookup = new ArrayLookupTable(data, 'input');
                this.inputLookup = inputLookup.table;
                this.inputLookupLength = inputLookup.length;
            }
            if (!this.outputLookup) {
                const outputLookup = new ArrayLookupTable(data, 'output');
                this.outputLookup = outputLookup.table;
                this.outputLookupLength = outputLookup.length;
            }
            if (!this.outputLookupLength) {
                throw new Error('this.outputLookupLength not set to usable number');
            }
            const result = [];
            for (let i = 0; i < data.length; i++) {
                const datum = data[i];
                result.push(inputOutputObjectsToFloat32Arrays(datum.input, datum.output, this.inputLookup, this.outputLookup, this.inputLookupLength, this.outputLookupLength));
            }
            return result;
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        formatData(data) {
            const dataShape = lookup.dataShape(data).join(',');
            switch (dataShape) {
                case 'array,number':
                    return this.formatArray(data);
                case 'array,array,number':
                    return this.formatArrayOfArray(data);
                case 'array,object,number':
                    if (this.options.inputSize === 1) {
                        return this.formatArrayOfObject(data);
                    }
                    else {
                        return this.formatArrayOfObjectMulti(data);
                    }
                case 'array,datum,array,number':
                    return this.formatArrayOfDatumOfArray(data);
                case 'array,datum,object,number':
                    return this.formatArrayOfDatumOfObject(data);
                case 'array,array,array,number':
                    return this.formatArrayOfArrayOfArray(data);
                case 'array,array,object,number':
                    return this.formatArrayOfArrayOfObject(data);
                case 'array,datum,array,array,number':
                    return this.formatArrayOfDatumOfArrayOfArray(data);
                case 'array,datum,array,object,number':
                    return this.formatArrayOfDatumOfArrayOfObject(data);
                default:
                    throw new Error('unknown data shape or configuration');
            }
        }
        test(data) {
            // for classification problems
            const misclasses = [];
            // run each pattern through the trained network and collect
            // error and misclassification statistics
            let errorSum = 0;
            const formattedData = this.formatData(data);
            for (let i = 0; i < formattedData.length; i++) {
                const input = formattedData[i];
                const output = this.run(input.splice(0, input.length - 1));
                const target = input[input.length - 1];
                let errors = 0;
                let errorCount = 0;
                for (let j = 0; j < output.length; j++) {
                    errorCount++;
                    const error = target[j] - output[j];
                    // mse
                    errors += error * error;
                }
                errorSum += errors / errorCount;
                const errorsAbs = Math.abs(errors);
                if (errorsAbs > this.trainOpts.errorThresh) {
                    const misclass = data[i];
                    misclasses.push({
                        value: misclass,
                        actual: output,
                    });
                }
            }
            return {
                error: errorSum / formattedData.length,
                misclasses,
                total: formattedData.length,
            };
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        addFormat(value) {
            var _a, _b, _c, _d, _e, _f;
            const dataShape = lookup.dataShape(value).join(',');
            switch (dataShape) {
                case 'array,array,number':
                case 'datum,array,array,number':
                case 'array,number':
                case 'datum,array,number':
                    return;
                case 'datum,object,number': {
                    this.inputLookup = lookup.addKeys(value.input, (_a = this.inputLookup) !== null && _a !== void 0 ? _a : {});
                    if (this.inputLookup) {
                        this.inputLookupLength = Object.keys(this.inputLookup).length;
                    }
                    this.outputLookup = lookup.addKeys(value.output, (_b = this.outputLookup) !== null && _b !== void 0 ? _b : {});
                    if (this.outputLookup) {
                        this.outputLookupLength = Object.keys(this.outputLookup).length;
                    }
                    break;
                }
                case 'object,number': {
                    this.inputLookup = this.outputLookup = lookup.addKeys(value, (_c = this.inputLookup) !== null && _c !== void 0 ? _c : {});
                    if (this.inputLookup) {
                        this.inputLookupLength = this.outputLookupLength = Object.keys(this.inputLookup).length;
                    }
                    break;
                }
                case 'array,object,number': {
                    const typedValue = value;
                    for (let i = 0; i < typedValue.length; i++) {
                        this.inputLookup = this.outputLookup = lookup.addKeys(typedValue[i], (_d = this.inputLookup) !== null && _d !== void 0 ? _d : {});
                        if (this.inputLookup) {
                            this.inputLookupLength = this.outputLookupLength = Object.keys(this.inputLookup).length;
                        }
                    }
                    break;
                }
                case 'datum,array,object,number': {
                    const typedValue = value;
                    const typedInput = typedValue.input;
                    for (let i = 0; i < typedInput.length; i++) {
                        this.inputLookup = lookup.addKeys(typedInput[i], (_e = this.inputLookup) !== null && _e !== void 0 ? _e : {});
                        if (this.inputLookup) {
                            this.inputLookupLength = Object.keys(this.inputLookup).length;
                        }
                    }
                    const typedOutput = typedValue.output;
                    for (let i = 0; i < typedOutput.length; i++) {
                        this.outputLookup = lookup.addKeys(typedOutput[i], (_f = this.outputLookup) !== null && _f !== void 0 ? _f : {});
                        if (this.outputLookup) {
                            this.outputLookupLength = Object.keys(this.outputLookup).length;
                        }
                    }
                    break;
                }
                default:
                    throw new Error('unknown data shape or configuration');
            }
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        toJSON() {
            if (!this.model) {
                this.initialize();
            }
            const { model } = this;
            const options = { ...this.options, ...defaults$1 };
            return {
                type: this.constructor.name,
                options,
                hiddenLayers: model.hiddenLayers.map((hiddenLayer) => {
                    const layers = {};
                    for (const p in hiddenLayer) {
                        if (!hiddenLayer.hasOwnProperty(p))
                            continue;
                        layers[p] = hiddenLayer[p].toJSON();
                    }
                    return layers;
                }),
                outputConnector: model.outputConnector.toJSON(),
                output: model.output.toJSON(),
                inputLookup: this.inputLookup,
                inputLookupLength: this.inputLookupLength,
                outputLookup: this.outputLookup,
                outputLookupLength: this.outputLookupLength,
            };
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        fromJSON(json) {
            const { options } = json;
            const allMatrices = [];
            const hiddenLayers = [];
            // backward compatibility for hiddenSizes
            json.hiddenLayers.forEach((hiddenLayer) => {
                const layers = {};
                for (const p in hiddenLayer) {
                    layers[p] = Matrix.fromJSON(hiddenLayer[p]);
                    allMatrices.push(layers[p]);
                }
                hiddenLayers.push(layers);
            });
            const outputConnector = Matrix.fromJSON(json.outputConnector);
            allMatrices.push(outputConnector);
            const output = Matrix.fromJSON(json.output);
            allMatrices.push(output);
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            // @ts-expect-error
            this.options = { ...defaults(), ...options };
            this.inputLookup = json.inputLookup;
            this.inputLookupLength = json.inputLookupLength;
            this.outputLookup = json.outputLookup;
            this.outputLookupLength = json.outputLookupLength;
            this.model = Object.seal({
                isInitialized: true,
                hiddenLayers,
                output,
                allMatrices,
                outputConnector,
                equations: [],
                equationConnections: [],
            });
            this.initialLayerInputs = options.hiddenLayers.map((size) => new Matrix(size, 1));
            this.bindEquation();
            return this;
        }
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-expect-error
        toFunction(cb) {
            const { model, inputLookup, inputLookupLength, outputLookup, outputLookupLength, } = this;
            const { inputSize } = this.options;
            const { equations } = model;
            const equation = equations[1];
            const { states } = equation;
            const jsonString = JSON.stringify(this.toJSON());
            function previousConnectionIndex(m) {
                const connection = model.equationConnections[0];
                const { states } = equations[0];
                for (let i = 0, max = states.length; i < max; i++) {
                    if (states[i].product === m) {
                        return i;
                    }
                }
                return connection.indexOf(m);
            }
            function matrixOrigin(m, stateIndex) {
                for (let i = 0, max = states.length; i < max; i++) {
                    const state = states[i];
                    if (i === stateIndex) {
                        const j = previousConnectionIndex(m);
                        switch (m) {
                            case state.left:
                                if (j > -1) {
                                    return `typeof prevStates[${j}] === 'object' ? prevStates[${j}].product : new Matrix(${m.rows}, ${m.columns})`;
                                }
                            // eslint-disable-next-line no-fallthrough
                            case state.right:
                                if (j > -1) {
                                    return `typeof prevStates[${j}] === 'object' ? prevStates[${j}].product : new Matrix(${m.rows}, ${m.columns})`;
                                }
                            // eslint-disable-next-line no-fallthrough
                            case state.product:
                                return `new Matrix(${m.rows}, ${m.columns})`;
                            default:
                                throw Error('unknown state');
                        }
                    }
                    if (m === state.product)
                        return `states[${i}].product`;
                    if (m === state.right)
                        return `states[${i}].right`;
                    if (m === state.left)
                        return `states[${i}].left`;
                }
                return '';
            }
            function matrixToString(m, stateIndex) {
                if (!m || !m.rows || !m.columns)
                    return 'null';
                if (m === model.outputConnector)
                    return `json.outputConnector`;
                if (m === model.output)
                    return `json.output`;
                for (let i = 0, max = model.hiddenLayers.length; i < max; i++) {
                    const hiddenLayer = model.hiddenLayers[i];
                    for (const p in hiddenLayer) {
                        if (!hiddenLayer.hasOwnProperty(p))
                            continue;
                        if (hiddenLayer[p] !== m)
                            continue;
                        return `json.hiddenLayers[${i}].${p}`;
                    }
                }
                return matrixOrigin(m, stateIndex);
            }
            function formatInputData() {
                if (!inputLookup)
                    return '';
                if (inputSize === 1) {
                    if (inputLookup === outputLookup) {
                        return `function lookupInput(input) {
            var table = ${JSON.stringify(inputLookup)};
            var result = [];
            for (var p in table) {
              if (!input.hasOwnProperty(p)) break;
              result.push(Float32Array.from([input[p]]));
            }
            return result;
          }`;
                    }
                    return `function lookupInput(input) {
          var table = ${JSON.stringify(inputLookup)};
          var result = [];
          for (var p in table) {
            result.push(Float32Array.from([input[p]]));
          }
          return result;
        }`;
                }
                return `function lookupInput(rawInputs) {
        var table = ${JSON.stringify(inputLookup)};
        var result = [];
        for (var i = 0; i < rawInputs.length; i++) {
          var rawInput = rawInputs[i];
          var input = new Float32Array(${inputLookupLength});
          for (var p in table) {
            input[table[p]] = rawInput.hasOwnProperty(p) ? rawInput[p] : 0;
          }
          result.push(input);
        }
        return result;
      }`;
            }
            function formatOutputData() {
                if (!outputLookup)
                    return '';
                if (inputSize === 1) {
                    if (inputLookup === outputLookup) {
                        return `function lookupOutputPartial(output, input) {
            var table = ${JSON.stringify(outputLookup)};
            var offset = input.length;
            var result = {};
            var i = 0;
            for (var p in table) {
              if (i++ < offset) continue;
              result[p] = output[table[p] - offset][0];
            }
            return result;
          }`;
                    }
                    return `function lookupOutput(output) {
          var table = ${JSON.stringify(outputLookup)};
          var result = {};
          for (var p in table) {
            result[p] = output[table[p]][0];
          }
          return result;
        }`;
                }
                return `function lookupOutput(output) {
        var table = ${JSON.stringify(outputLookup)};
        var result = {};
        for (var p in table) {
          result[p] = output[table[p]];
        }
        return result;
      }`;
            }
            function toInner(fnString) {
                // crude, but should be sufficient for now
                // function() { body }
                // crude, but should be sufficient for now
                // function() { body }
                const fnParts = fnString.toString().split('{');
                fnParts.shift();
                // body }
                const fnBodyString = fnParts.join('{');
                const fnBodyParts = fnBodyString.split('}');
                fnBodyParts.pop();
                // body
                return fnBodyParts
                    .join('}')
                    .split('\n')
                    .join('\n        ')
                    .replace('product.deltas[i] = 0;', '')
                    .replace('product.deltas[column] = 0;', '')
                    .replace('left.deltas[leftIndex] = 0;', '')
                    .replace('right.deltas[rightIndex] = 0;', '')
                    .replace('product.deltas = left.deltas.slice(0);', '');
            }
            function fileName(fnName) {
                return `src/recurrent/matrix/${fnName.replace(/[A-Z]/g, function (value) {
                return `-${value.toLowerCase()}`;
            })}.js`;
            }
            const statesRaw = [];
            const usedFunctionNames = {};
            const innerFunctionsSwitch = [];
            for (let i = 0, max = states.length; i < max; i++) {
                const state = states[i];
                statesRaw.push(`states[${i}] = {
      name: '${state.forwardFn.name}',
      left: ${state.left ? matrixToString(state.left, i) : 'undefined'},
      right: ${state.right ? matrixToString(state.right, i) : 'undefined'},
      product: ${matrixToString(state.product, i)}
    }`);
                const fnName = state.forwardFn.name;
                if (!usedFunctionNames[fnName]) {
                    usedFunctionNames[fnName] = true;
                    if (state.name === 'input') {
                        innerFunctionsSwitch.push(`case '${fnName}':`);
                        innerFunctionsSwitch.push(inputLookup && inputSize === 1
                            ? 'product.weights = _i < input.length ? input[_i]: prevStates[prevStates.length - 1].product.weights;'
                            : inputSize === 1
                                ? 'product.weights = [input[_i]];'
                                : 'product.weights = input[_i];');
                        innerFunctionsSwitch.push('break;');
                    }
                    else {
                        innerFunctionsSwitch.push(`        case '${fnName}':${fnName !== 'forwardFn'
                        ? ` //compiled from ${fileName(fnName)}`
                        : ''}
          ${toInner(state.forwardFn.toString())}
          break;`);
                    }
                }
            }
            const forceForecast = inputSize === 1 && this.outputLookup;
            const src = `
  var input = ${this.inputLookup ? 'lookupInput(rawInput)' : 'rawInput'};
  var json = ${jsonString};
  var output = [];
  var states = [];
  var prevStates;
  var state;
  var max = ${forceForecast
            ? inputLookup === outputLookup
                ? inputLookupLength
                : `input.length + ${outputLookupLength - 1}`
            : 'input.length'};
  for (var _i = 0; _i < max; _i++) {
    prevStates = states;
    states = [];
    ${statesRaw.join(';\n    ')};
    for (var stateIndex = 0, stateMax = ${statesRaw.length}; stateIndex < stateMax; stateIndex++) {
      state = states[stateIndex];
      var product = state.product;
      var left = state.left;
      var right = state.right;

      switch (state.name) {
${innerFunctionsSwitch.join('\n')}
      }
    }
    ${inputSize === 1 && inputLookup
            ? 'if (_i >= input.length - 1) { output.push(state.product.weights); }'
            : 'output = state.product.weights;'}
  }
  ${outputLookup
            ? outputLookup === inputLookup
                ? 'return lookupOutputPartial(output, input)'
                : 'return lookupOutput(output)'
            : inputSize === 1
                ? 'return output[0]'
                : 'return output'};
  ${formatInputData()}
  ${formatOutputData()}

  function Matrix(rows, columns) {
    this.rows = rows;
    this.columns = columns;
    this.weights = new Float32Array(rows * columns);
  }
  ${softmax.toString().replace('_2.default', 'Matrix')}
  ${randomFloat.toString()}
  ${sampleI.toString()}
  ${maxI.toString()}`;
            // eslint-disable-next-line
            return new Function('rawInput', cb ? cb(src) : src);
        }
    }
    const trainDefaults = { ...trainDefaults$1 };

    class GRUTimeStep extends RNNTimeStep {
        getHiddenLayer(hiddenSize, prevSize) {
            return getGRUHiddenLayer(hiddenSize, prevSize);
        }
        getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
            return getGRUEquation(equation, inputMatrix, previousResult, hiddenLayer);
        }
    }

    class LSTM extends RNN {
        getHiddenLayer(hiddenSize, prevSize) {
            return getHiddenLSTMLayer(hiddenSize, prevSize);
        }
        getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
            return getLSTMEquation(equation, inputMatrix, previousResult, hiddenLayer);
        }
    }
    function getHiddenLSTMLayer(hiddenSize, prevSize) {
        return {
            // gates parameters
            // wix
            inputMatrix: new RandomMatrix(hiddenSize, prevSize, 0.08),
            inputHidden: new RandomMatrix(hiddenSize, hiddenSize, 0.08),
            inputBias: new Matrix(hiddenSize, 1),
            // wfx
            forgetMatrix: new RandomMatrix(hiddenSize, prevSize, 0.08),
            forgetHidden: new RandomMatrix(hiddenSize, hiddenSize, 0.08),
            forgetBias: new Matrix(hiddenSize, 1),
            // wox
            outputMatrix: new RandomMatrix(hiddenSize, prevSize, 0.08),
            outputHidden: new RandomMatrix(hiddenSize, hiddenSize, 0.08),
            outputBias: new Matrix(hiddenSize, 1),
            // cell write params
            // wcx
            cellActivationMatrix: new RandomMatrix(hiddenSize, prevSize, 0.08),
            cellActivationHidden: new RandomMatrix(hiddenSize, hiddenSize, 0.08),
            cellActivationBias: new Matrix(hiddenSize, 1),
        };
    }
    function getLSTMEquation(equation, inputMatrix, previousResult, hiddenLayer) {
        if (!hiddenLayer.inputMatrix ||
            !hiddenLayer.inputHidden ||
            !hiddenLayer.inputBias ||
            !hiddenLayer.forgetMatrix ||
            !hiddenLayer.forgetHidden ||
            !hiddenLayer.forgetBias ||
            !hiddenLayer.outputMatrix ||
            !hiddenLayer.outputHidden ||
            !hiddenLayer.outputBias ||
            !hiddenLayer.cellActivationMatrix ||
            !hiddenLayer.cellActivationHidden ||
            !hiddenLayer.cellActivationBias) {
            throw new Error('hiddenLayer does not have expected properties');
        }
        const sigmoid = equation.sigmoid.bind(equation);
        const add = equation.add.bind(equation);
        const multiply = equation.multiply.bind(equation);
        const multiplyElement = equation.multiplyElement.bind(equation);
        const tanh = equation.tanh.bind(equation);
        const inputGate = sigmoid(add(add(multiply(hiddenLayer.inputMatrix, inputMatrix), multiply(hiddenLayer.inputHidden, previousResult)), hiddenLayer.inputBias));
        const forgetGate = sigmoid(add(add(multiply(hiddenLayer.forgetMatrix, inputMatrix), multiply(hiddenLayer.forgetHidden, previousResult)), hiddenLayer.forgetBias));
        // output gate
        const outputGate = sigmoid(add(add(multiply(hiddenLayer.outputMatrix, inputMatrix), multiply(hiddenLayer.outputHidden, previousResult)), hiddenLayer.outputBias));
        // write operation on cells
        const cellWrite = tanh(add(add(multiply(hiddenLayer.cellActivationMatrix, inputMatrix), multiply(hiddenLayer.cellActivationHidden, previousResult)), hiddenLayer.cellActivationBias));
        // compute new cell activation
        const retainCell = multiplyElement(forgetGate, previousResult); // what do we keep from cell
        const writeCell = multiplyElement(inputGate, cellWrite); // what do we write to cell
        const cell = add(retainCell, writeCell); // new cell contents
        // compute hidden state as gated, saturated cell activations
        return multiplyElement(outputGate, tanh(cell));
    }

    class LSTMTimeStep extends RNNTimeStep {
        getHiddenLayer(hiddenSize, prevSize) {
            return getHiddenLSTMLayer(hiddenSize, prevSize);
        }
        getEquation(equation, inputMatrix, previousResult, hiddenLayer) {
            return getLSTMEquation(equation, inputMatrix, previousResult, hiddenLayer);
        }
    }

    /**
     *
     * @param start
     * @param end
     * @returns {Array}
     */
    function range(start, end) {
        const result = [];
        for (; start < end; start++) {
            result.push(start);
        }
        return result;
    }

    function toArray(values) {
        if (Array.isArray(values)) {
            return Float32Array.from(values);
        }
        return Float32Array.from(Object.values(values));
    }

    function drawInput({ pixelX, pixelY, radius, inputs, row, line, fontSize, fontClassName, }) {
        let svg = `<rect
              x="${pixelX / 2 - radius}"
              y="${pixelY / 2 + row * pixelY - radius}"
              width="${2 * radius}"
              height="${2 * radius}"
              stroke="black"
              stroke-width="1"
              fill="${inputs.color}"
              class="${inputs.className}" />
            <line
              x1="${pixelX / 4}"
              y1="${pixelY / 2 + row * pixelY}"
              x2="${pixelX / 2 - radius}"
              y2="${pixelY / 2 + row * pixelY}"
              style="stroke:${line.color};stroke-width:${line.width}"
              class="${line.className}" />`;
        if (inputs.labels) {
            svg += `<text
              x="${pixelX / 8}"
              y="${pixelY / 2 + row * pixelY - 5}"
              fill="black"
              font-size="${fontSize}"
              class="${fontClassName}">${inputs.labels[row]}</text>`;
        }
        return svg;
    }
    function drawNeuron({ pixelX, pixelY, row, column, radius, hidden, }) {
        return `<circle
            cx="${pixelX / 2 + column * pixelX}"
            cy="${pixelY / 2 + row * pixelY}"
            r="${radius}"
            stroke="black"
            stroke-width="1"
            fill="${hidden.color}"
            class="${hidden.className}" />`;
    }
    function drawOutput({ pixelX, pixelY, row, column, line, outputs, radius, }) {
        return `<circle
            cx="${pixelX / 2 + column * pixelX}"
            cy="${pixelY / 2 + row * pixelY}"
            r="${radius}"
            stroke="black"
            stroke-width="1"
            fill="${outputs.color}"
            class="${outputs.className}" />
          <line
            x1="${pixelX / 2 + column * pixelX + radius}"
            y1="${pixelY / 2 + row * pixelY}"
            x2="${pixelX / 2 + column * pixelX + pixelX / 4}"
            y2="${pixelY / 2 + row * pixelY}"
            style="stroke:${line.color};stroke-width:${line.width}"
            class="${line.className}" />`;
    }
    function drawBackwardConnections({ pixelX, pixelY, row, column, radius, lineY, line, previousConnectionIndex, }) {
        return `<line
            x1="${pixelX / 2 + (column - 1) * pixelX + radius}"
            y1="${lineY / 2 + previousConnectionIndex * lineY}"
            x2="${pixelX / 2 + column * pixelX - radius}"
            y2="${pixelY / 2 + row * pixelY}"
            style="stroke:${line.color};stroke-width:${line.width}"
            class="${line.className}" />`;
    }
    function neuralNetworkToInnerSVG(options) {
        const { sizes, height, width } = options;
        let svg = '';
        const pixelX = width / sizes.length;
        for (let column = 0; column < sizes.length; column++) {
            const size = sizes[column];
            const pixelY = height / size;
            for (let row = 0; row < size; row++) {
                if (column === 0) {
                    svg += drawInput({ pixelX, pixelY, row, column, ...options });
                }
                else {
                    if (column === sizes.length - 1) {
                        svg += drawOutput({ pixelX, pixelY, row, column, ...options });
                    }
                    else {
                        svg += drawNeuron({ pixelX, pixelY, row, column, ...options });
                    }
                    const previousSize = sizes[column - 1];
                    const lineY = height / previousSize;
                    for (let previousConnectionIndex = 0; previousConnectionIndex < previousSize; previousConnectionIndex++) {
                        svg += drawBackwardConnections({
                            pixelX,
                            pixelY,
                            row,
                            column,
                            lineY,
                            previousConnectionIndex,
                            ...options,
                        });
                    }
                }
            }
        }
        return svg;
    }
    function drawRecurrentConnections({ pixelX, pixelY, row, column, radius, recurrentLine, }) {
        const moveX = pixelX / 2 + column * pixelX + radius + 1;
        const moveY = pixelY / 2 + row * pixelY;
        const x = moveX - radius * 2 - 2;
        const y = moveY;
        const x1 = x + 100;
        const y1 = y + 50;
        const x2 = moveX - 100;
        const y2 = moveY + 50;
        return `<path
              d="M ${moveX} ${moveY} C ${x1} ${y1}, ${x2} ${y2}, ${x} ${y}"
              stroke="${recurrentLine.color}"
              stroke-width="${recurrentLine.width}"
              fill="transparent"
              stroke-linecap="round"
              marker-end="url(#arrow)"
              class="${recurrentLine.className}" />`;
    }
    function rnnToInnerSVG(options) {
        const { width, height, recurrentLine, sizes, radius } = options;
        const pixelX = width / sizes.length;
        let svg = `<defs>
              <marker id="arrow" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth">
                <path d="M0,0 L0,6 L9,3 z" fill="${recurrentLine.color}" />
              </marker>
            </defs>`;
        svg += neuralNetworkToInnerSVG(options);
        for (let column = 1; column < sizes.length; column++) {
            const size = sizes[column];
            const pixelY = height / size;
            for (let row = 0; row < size; row++) {
                svg += drawRecurrentConnections({
                    pixelX,
                    pixelY,
                    row,
                    column,
                    radius,
                    recurrentLine,
                });
            }
        }
        return svg;
    }
    function getFeedForwardLayers(network) {
        const { options } = network;
        if (!options) {
            throw new Error('options not defined');
        }
        if (!options.inputLayer) {
            throw new Error('options.inputLater not defined');
        }
        if (!options.hiddenLayers) {
            throw new Error('options.hiddenLayers not defined');
        }
        if (options.hiddenLayers.length < 1) {
            throw new Error('options.hiddenLayers is empty');
        }
        if (!options.outputLayer) {
            throw new Error('options.outputLayer not defined');
        }
        const inputLayer = options.inputLayer();
        const hiddenLayers = [];
        hiddenLayers.push(options.hiddenLayers[0](inputLayer, 0));
        for (let i = 1; i < options.hiddenLayers.length; i++) {
            hiddenLayers.push(options.hiddenLayers[i](hiddenLayers[i - 1], i));
        }
        const outputLayer = options.outputLayer(hiddenLayers[hiddenLayers.length - 1], hiddenLayers.length);
        return {
            inputSize: inputLayer.height,
            hiddenLayers: hiddenLayers.map((hiddenLayer) => hiddenLayer.height),
            outputSize: outputLayer.height,
        };
    }
    function getRecurrentLayers(network) {
        const hiddenLayers = [];
        const { options } = network;
        if (!options.inputLayer) {
            throw new Error('inputLayer not defined');
        }
        if (!options.outputLayer) {
            throw new Error('outputLayer not defined');
        }
        const inputLayer = options.inputLayer();
        hiddenLayers.push(options.hiddenLayers[0](inputLayer, recurrentZeros(), 0));
        for (let i = 1; i < options.hiddenLayers.length; i++) {
            hiddenLayers.push(options.hiddenLayers[i](hiddenLayers[i - 1], recurrentZeros(), i));
        }
        const outputLayer = options.outputLayer(hiddenLayers[hiddenLayers.length - 1], -1);
        return {
            inputSize: inputLayer.height,
            hiddenLayers: hiddenLayers.map((hiddenLayer) => hiddenLayer.height),
            outputSize: outputLayer.height,
        };
    }
    function wrapOuterSVG(svgBody, width, height) {
        // language=html
        return `<svg
            xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            version="1.1"
            width="${width}"
            height="${height}">${svgBody}</svg>`;
    }
    function getNeuralNetworkJSONSizes(json) {
        return json.sizes;
    }
    function getNeuralNetworkSizes(net) {
        const { options, sizes } = net;
        const { inputSize, outputSize, hiddenLayers } = options;
        if (!sizes) {
            if (typeof inputSize === 'number' && inputSize < 1) {
                throw new Error('inputSize not set');
            }
            if (typeof outputSize === 'number' && outputSize < 1) {
                throw new Error('outputSize not set');
            }
            if (hiddenLayers === null || hiddenLayers === void 0 ? void 0 : hiddenLayers.some((v) => v < 1)) {
                throw new Error('hiddenLayers not set');
            }
        }
        return typeof inputSize === 'number' &&
            Array.isArray(hiddenLayers) &&
            typeof outputSize === 'number'
            ? [inputSize].concat(hiddenLayers).concat([outputSize])
            : sizes;
    }
    function getRNNSizes(net) {
        const { options } = net;
        const { inputSize, outputSize, hiddenLayers } = options;
        return [inputSize].concat(hiddenLayers).concat([outputSize]);
    }
    function defaultOptions() {
        return {
            line: {
                width: 0.5,
                color: 'black',
                className: 'connection',
            },
            recurrentLine: {
                width: 1,
                color: 'red',
                className: 'recurrence',
            },
            inputs: {
                color: 'rgba(0, 128, 0, 0.5)',
                labels: null,
                className: 'input',
            },
            outputs: {
                color: 'rgba(100, 149, 237, 0.5)',
                className: 'output',
            },
            hidden: {
                color: 'rgba(255, 127, 80, 0.5)',
                className: 'hidden-neuron',
            },
            fontSize: '14px',
            fontClassName: 'label',
            radius: 8,
            width: 400,
            height: 250,
            sizes: [],
        };
    }
    function toSVG(net, options) {
        const mergedOptions = { ...defaultOptions(), ...options };
        const { width, height, inputs } = mergedOptions;
        // Get network size array for NeuralNetwork or NeuralNetworkGPU
        let sizes = [];
        if (net instanceof NeuralNetwork || net instanceof NeuralNetworkGPU) {
            sizes = getNeuralNetworkSizes(net);
        }
        // get network size for Recurrent
        else if (net instanceof Recurrent) {
            const { inputSize, hiddenLayers, outputSize } = getRecurrentLayers(net);
            sizes = [inputSize].concat(hiddenLayers).concat([outputSize]);
        }
        // get network size for FeedForward
        else if (net instanceof FeedForward) {
            const { inputSize, hiddenLayers, outputSize } = getFeedForwardLayers(net);
            sizes = [inputSize].concat(hiddenLayers).concat([outputSize]);
        }
        // handle json, recurrent first
        else if (net instanceof RNN ||
            net instanceof LSTM ||
            net instanceof GRU ||
            net instanceof RNNTimeStep ||
            net instanceof LSTMTimeStep ||
            net instanceof GRUTimeStep) {
            return wrapOuterSVG(rnnToInnerSVG({
                ...mergedOptions,
                sizes: checkSizes(getRNNSizes(net), inputs.labels),
            }), width, height);
        }
        // handle json, NeuralNetwork
        else if (net.hasOwnProperty('type')) {
            switch (net.type) {
                case 'NeuralNetwork':
                case 'NeuralNetworkGPU':
                    return wrapOuterSVG(neuralNetworkToInnerSVG({
                        ...mergedOptions,
                        sizes: checkSizes(getNeuralNetworkJSONSizes(net), inputs.labels),
                    }), width, height);
                case 'RNN':
                case 'GRU':
                case 'LSTM':
                case 'RNNTimeStep':
                case 'GRUTimeStep':
                case 'LSTMTimeStep':
                    return wrapOuterSVG(rnnToInnerSVG({
                        ...mergedOptions,
                        sizes: checkSizes(getRNNSizes(net), inputs.labels),
                    }), width, height);
                default:
                    throw new Error('unrecognized network');
            }
        }
        else if (net.hasOwnProperty('inputSize') &&
            net.hasOwnProperty('hiddenLayers') &&
            net.hasOwnProperty('outputSize')) {
            const { inputSize, hiddenLayers, outputSize } = net;
            sizes = [inputSize, ...hiddenLayers, outputSize];
        }
        else if (net.hasOwnProperty('sizes')) {
            sizes = net.sizes;
        }
        else {
            throw new Error('unrecognized network');
        }
        return wrapOuterSVG(neuralNetworkToInnerSVG({
            ...mergedOptions,
            sizes: checkSizes(sizes, inputs.labels),
        }), width, height);
    }
    function checkSizes(sizes, labels) {
        if (!sizes) {
            throw new Error('sizes not set');
        }
        if (sizes.some((size) => size < 1)) {
            throw new Error('sizes not set correctly');
        }
        if (labels && labels.length !== sizes[0]) {
            throw new Error('not enough labels for inputs');
        }
        return sizes;
    }

    const recurrent = {
        RNNTimeStep,
        LSTMTimeStep,
        GRUTimeStep,
        RNN,
        LSTM,
        GRU,
    };
    const utilities = {
        max,
        mse: mse$1,
        ones: ones$1,
        ones2D,
        random: random$1,
        randomWeight,
        randos,
        range,
        toArray,
        DataFormatter,
        zeros: zeros$1,
        toSVG,
    };

    exports.CrossValidate = CrossValidate;
    exports.FeedForward = FeedForward;
    exports.NeuralNetwork = NeuralNetwork;
    exports.NeuralNetworkGPU = NeuralNetworkGPU;
    exports.Recurrent = Recurrent;
    exports.activation = index$1;
    exports.layer = layer;
    exports.layerTypes = layerTypes;
    exports.likely = likely;
    exports.lookup = lookup;
    exports.praxis = index;
    exports.recurrent = recurrent;
    exports.utilities = utilities;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=browser.js.map

/*! bpAudio.js v2.2.4 | (c) 2013-2020, James Simpson of GoldFire Studios | MIT License | bpAudiojs.com */
!function(){"use strict";var e=function(){this.init()};e.prototype={init:function(){var e=this||n;return e._counter=1e3,e._html5AudioPool=[],e.html5PoolSize=10,e._codecs={},e._bpAudios=[],e._muted=!1,e._volume=1,e._canPlayEvent="canplaythrough",e._navigator="undefined"!=typeof window&&window.navigator?window.navigator:null,e.masterGain=null,e.noAudio=!1,e.usingWebAudio=!0,e.autoSuspend=!0,e.ctx=null,e.autoUnlock=!0,e._setup(),e},volume:function(e){var o=this||n;if(e=parseFloat(e),o.ctx||_(),void 0!==e&&e>=0&&e<=1){if(o._volume=e,o._muted)return o;o.usingWebAudio&&o.masterGain.gain.setValueAtTime(e,n.ctx.currentTime);for(var t=0;t<o._bpAudios.length;t++)if(!o._bpAudios[t]._webAudio)for(var r=o._bpAudios[t]._getSoundIds(),a=0;a<r.length;a++){var u=o._bpAudios[t]._soundById(r[a]);u&&u._node&&(u._node.volume=u._volume*e)}return o}return o._volume},mute:function(e){var o=this||n;o.ctx||_(),o._muted=e,o.usingWebAudio&&o.masterGain.gain.setValueAtTime(e?0:o._volume,n.ctx.currentTime);for(var t=0;t<o._bpAudios.length;t++)if(!o._bpAudios[t]._webAudio)for(var r=o._bpAudios[t]._getSoundIds(),a=0;a<r.length;a++){var u=o._bpAudios[t]._soundById(r[a]);u&&u._node&&(u._node.muted=!!e||u._muted)}return o},stop:function(){for(var e=this||n,o=0;o<e._bpAudios.length;o++)e._bpAudios[o].stop();return e},unload:function(){for(var e=this||n,o=e._bpAudios.length-1;o>=0;o--)e._bpAudios[o].unload();return e.usingWebAudio&&e.ctx&&void 0!==e.ctx.close&&(e.ctx.close(),e.ctx=null,_()),e},codecs:function(e){return(this||n)._codecs[e.replace(/^x-/,"")]},_setup:function(){var e=this||n;if(e.state=e.ctx?e.ctx.state||"suspended":"suspended",e._autoSuspend(),!e.usingWebAudio)if("undefined"!=typeof Audio)try{var o=new Audio;void 0===o.oncanplaythrough&&(e._canPlayEvent="canplay")}catch(n){e.noAudio=!0}else e.noAudio=!0;try{var o=new Audio;o.muted&&(e.noAudio=!0)}catch(e){}return e.noAudio||e._setupCodecs(),e},_setupCodecs:function(){var e=this||n,o=null;try{o="undefined"!=typeof Audio?new Audio:null}catch(n){return e}if(!o||"function"!=typeof o.canPlayType)return e;var t=o.canPlayType("audio/mpeg;").replace(/^no$/,""),r=e._navigator?e._navigator.userAgent:"",a=r.match(/OPR\/(\d+)/g),u=a&&parseInt(a[0].split("/")[1],10)<33,d=-1!==r.indexOf("Safari")&&-1===r.indexOf("Chrome"),i=r.match(/Version\/(.*?) /),_=d&&i&&parseInt(i[1],10)<15;return e._codecs={mp3:!(u||!t&&!o.canPlayType("audio/mp3;").replace(/^no$/,"")),mpeg:!!t,opus:!!o.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/,""),ogg:!!o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),oga:!!o.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),wav:!!(o.canPlayType('audio/wav; codecs="1"')||o.canPlayType("audio/wav")).replace(/^no$/,""),aac:!!o.canPlayType("audio/aac;").replace(/^no$/,""),caf:!!o.canPlayType("audio/x-caf;").replace(/^no$/,""),m4a:!!(o.canPlayType("audio/x-m4a;")||o.canPlayType("audio/m4a;")||o.canPlayType("audio/aac;")).replace(/^no$/,""),m4b:!!(o.canPlayType("audio/x-m4b;")||o.canPlayType("audio/m4b;")||o.canPlayType("audio/aac;")).replace(/^no$/,""),mp4:!!(o.canPlayType("audio/x-mp4;")||o.canPlayType("audio/mp4;")||o.canPlayType("audio/aac;")).replace(/^no$/,""),weba:!(_||!o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,"")),webm:!(_||!o.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/,"")),dolby:!!o.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/,""),flac:!!(o.canPlayType("audio/x-flac;")||o.canPlayType("audio/flac;")).replace(/^no$/,"")},e},_unlockAudio:function(){var e=this||n;if(!e._audioUnlocked&&e.ctx){e._audioUnlocked=!1,e.autoUnlock=!1,e._mobileUnloaded||44100===e.ctx.sampleRate||(e._mobileUnloaded=!0,e.unload()),e._scratchBuffer=e.ctx.createBuffer(1,1,22050);var o=function(n){for(;e._html5AudioPool.length<e.html5PoolSize;)try{var t=new Audio;t._unlocked=!0,e._releaseHtml5Audio(t)}catch(n){e.noAudio=!0;break}for(var r=0;r<e._bpAudios.length;r++)if(!e._bpAudios[r]._webAudio)for(var a=e._bpAudios[r]._getSoundIds(),u=0;u<a.length;u++){var d=e._bpAudios[r]._soundById(a[u]);d&&d._node&&!d._node._unlocked&&(d._node._unlocked=!0,d._node.load())}e._autoResume();var i=e.ctx.createBufferSource();i.buffer=e._scratchBuffer,i.connect(e.ctx.destination),void 0===i.start?i.noteOn(0):i.start(0),"function"==typeof e.ctx.resume&&e.ctx.resume(),i.onended=function(){i.disconnect(0),e._audioUnlocked=!0,document.removeEventListener("touchstart",o,!0),document.removeEventListener("touchend",o,!0),document.removeEventListener("click",o,!0),document.removeEventListener("keydown",o,!0);for(var n=0;n<e._bpAudios.length;n++)e._bpAudios[n]._emit("unlock")}};return document.addEventListener("touchstart",o,!0),document.addEventListener("touchend",o,!0),document.addEventListener("click",o,!0),document.addEventListener("keydown",o,!0),e}},_obtainHtml5Audio:function(){var e=this||n;if(e._html5AudioPool.length)return e._html5AudioPool.pop();var o=(new Audio).play();return o&&"undefined"!=typeof Promise&&(o instanceof Promise||"function"==typeof o.then)&&o.catch(function(){console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.")}),new Audio},_releaseHtml5Audio:function(e){var o=this||n;return e._unlocked&&o._html5AudioPool.push(e),o},_autoSuspend:function(){var e=this;if(e.autoSuspend&&e.ctx&&void 0!==e.ctx.suspend&&n.usingWebAudio){for(var o=0;o<e._bpAudios.length;o++)if(e._bpAudios[o]._webAudio)for(var t=0;t<e._bpAudios[o]._sounds.length;t++)if(!e._bpAudios[o]._sounds[t]._paused)return e;return e._suspendTimer&&clearTimeout(e._suspendTimer),e._suspendTimer=setTimeout(function(){if(e.autoSuspend){e._suspendTimer=null,e.state="suspending";var n=function(){e.state="suspended",e._resumeAfterSuspend&&(delete e._resumeAfterSuspend,e._autoResume())};e.ctx.suspend().then(n,n)}},3e4),e}},_autoResume:function(){var e=this;if(e.ctx&&void 0!==e.ctx.resume&&n.usingWebAudio)return"running"===e.state&&"interrupted"!==e.ctx.state&&e._suspendTimer?(clearTimeout(e._suspendTimer),e._suspendTimer=null):"suspended"===e.state||"running"===e.state&&"interrupted"===e.ctx.state?(e.ctx.resume().then(function(){e.state="running";for(var n=0;n<e._bpAudios.length;n++)e._bpAudios[n]._emit("resume")}),e._suspendTimer&&(clearTimeout(e._suspendTimer),e._suspendTimer=null)):"suspending"===e.state&&(e._resumeAfterSuspend=!0),e}};var n=new e,o=function(e){var n=this;if(!e.src||0===e.src.length)return void console.error("An array of source files must be passed with any new bpAudio.");n.init(e)};o.prototype={init:function(e){var o=this;return n.ctx||_(),o._autoplay=e.autoplay||!1,o._format="string"!=typeof e.format?e.format:[e.format],o._html5=e.html5||!1,o._muted=e.mute||!1,o._loop=e.loop||!1,o._pool=e.pool||5,o._preload="boolean"!=typeof e.preload&&"metadata"!==e.preload||e.preload,o._rate=e.rate||1,o._sprite=e.sprite||{},o._src="string"!=typeof e.src?e.src:[e.src],o._volume=void 0!==e.volume?e.volume:1,o._xhr={method:e.xhr&&e.xhr.method?e.xhr.method:"GET",headers:e.xhr&&e.xhr.headers?e.xhr.headers:null,withCredentials:!(!e.xhr||!e.xhr.withCredentials)&&e.xhr.withCredentials},o._duration=0,o._state="unloaded",o._sounds=[],o._endTimers={},o._queue=[],o._playLock=!1,o._onend=e.onend?[{fn:e.onend}]:[],o._onfade=e.onfade?[{fn:e.onfade}]:[],o._onload=e.onload?[{fn:e.onload}]:[],o._onloaderror=e.onloaderror?[{fn:e.onloaderror}]:[],o._onplayerror=e.onplayerror?[{fn:e.onplayerror}]:[],o._onpause=e.onpause?[{fn:e.onpause}]:[],o._onplay=e.onplay?[{fn:e.onplay}]:[],o._onstop=e.onstop?[{fn:e.onstop}]:[],o._onmute=e.onmute?[{fn:e.onmute}]:[],o._onvolume=e.onvolume?[{fn:e.onvolume}]:[],o._onrate=e.onrate?[{fn:e.onrate}]:[],o._onseek=e.onseek?[{fn:e.onseek}]:[],o._onunlock=e.onunlock?[{fn:e.onunlock}]:[],o._onresume=[],o._webAudio=n.usingWebAudio&&!o._html5,void 0!==n.ctx&&n.ctx&&n.autoUnlock&&n._unlockAudio(),n._bpAudios.push(o),o._autoplay&&o._queue.push({event:"play",action:function(){o.play()}}),o._preload&&"none"!==o._preload&&o.load(),o},load:function(){var e=this,o=null;if(n.noAudio)return void e._emit("loaderror",null,"No audio support.");"string"==typeof e._src&&(e._src=[e._src]);for(var r=0;r<e._src.length;r++){var u,d;if(e._format&&e._format[r])u=e._format[r];else{if("string"!=typeof(d=e._src[r])){e._emit("loaderror",null,"Non-string found in selected audio sources - ignoring.");continue}u=/^data:audio\/([^;,]+);/i.exec(d),u||(u=/\.([^.]+)$/.exec(d.split("?",1)[0])),u&&(u=u[1].toLowerCase())}if(u||console.warn('No file extension was found. Consider using the "format" property or specify an extension.'),u&&n.codecs(u)){o=e._src[r];break}}return o?(e._src=o,e._state="loading","https:"===window.location.protocol&&"http:"===o.slice(0,5)&&(e._html5=!0,e._webAudio=!1),new t(e),e._webAudio&&a(e),e):void e._emit("loaderror",null,"No codec support for selected audio sources.")},play:function(e,o){var t=this,r=null;if("number"==typeof e)r=e,e=null;else{if("string"==typeof e&&"loaded"===t._state&&!t._sprite[e])return null;if(void 0===e&&(e="__default",!t._playLock)){for(var a=0,u=0;u<t._sounds.length;u++)t._sounds[u]._paused&&!t._sounds[u]._ended&&(a++,r=t._sounds[u]._id);1===a?e=null:r=null}}var d=r?t._soundById(r):t._inactiveSound();if(!d)return null;if(r&&!e&&(e=d._sprite||"__default"),"loaded"!==t._state){d._sprite=e,d._ended=!1;var i=d._id;return t._queue.push({event:"play",action:function(){t.play(i)}}),i}if(r&&!d._paused)return o||t._loadQueue("play"),d._id;t._webAudio&&n._autoResume();var _=Math.max(0,d._seek>0?d._seek:t._sprite[e][0]/1e3),s=Math.max(0,(t._sprite[e][0]+t._sprite[e][1])/1e3-_),l=1e3*s/Math.abs(d._rate),c=t._sprite[e][0]/1e3,f=(t._sprite[e][0]+t._sprite[e][1])/1e3;d._sprite=e,d._ended=!1;var p=function(){d._paused=!1,d._seek=_,d._start=c,d._stop=f,d._loop=!(!d._loop&&!t._sprite[e][2])};if(_>=f)return void t._ended(d);var m=d._node;if(t._webAudio){var v=function(){t._playLock=!1,p(),t._refreshBuffer(d);var e=d._muted||t._muted?0:d._volume;m.gain.setValueAtTime(e,n.ctx.currentTime),d._playStart=n.ctx.currentTime,void 0===m.bufferSource.start?d._loop?m.bufferSource.noteGrainOn(0,_,86400):m.bufferSource.noteGrainOn(0,_,s):d._loop?m.bufferSource.start(0,_,86400):m.bufferSource.start(0,_,s),l!==1/0&&(t._endTimers[d._id]=setTimeout(t._ended.bind(t,d),l)),o||setTimeout(function(){t._emit("play",d._id),t._loadQueue()},0)};"running"===n.state&&"interrupted"!==n.ctx.state?v():(t._playLock=!0,t.once("resume",v),t._clearTimer(d._id))}else{var h=function(){m.currentTime=_,m.muted=d._muted||t._muted||n._muted||m.muted,m.volume=d._volume*n.volume(),m.playbackRate=d._rate;try{var r=m.play();if(r&&"undefined"!=typeof Promise&&(r instanceof Promise||"function"==typeof r.then)?(t._playLock=!0,p(),r.then(function(){t._playLock=!1,m._unlocked=!0,o?t._loadQueue():t._emit("play",d._id)}).catch(function(){t._playLock=!1,t._emit("playerror",d._id,"Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."),d._ended=!0,d._paused=!0})):o||(t._playLock=!1,p(),t._emit("play",d._id)),m.playbackRate=d._rate,m.paused)return void t._emit("playerror",d._id,"Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");"__default"!==e||d._loop?t._endTimers[d._id]=setTimeout(t._ended.bind(t,d),l):(t._endTimers[d._id]=function(){t._ended(d),m.removeEventListener("ended",t._endTimers[d._id],!1)},m.addEventListener("ended",t._endTimers[d._id],!1))}catch(e){t._emit("playerror",d._id,e)}};"data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA"===m.src&&(m.src=t._src,m.load());var y=window&&window.ejecta||!m.readyState&&n._navigator.isCocoonJS;if(m.readyState>=3||y)h();else{t._playLock=!0,t._state="loading";var g=function(){t._state="loaded",h(),m.removeEventListener(n._canPlayEvent,g,!1)};m.addEventListener(n._canPlayEvent,g,!1),t._clearTimer(d._id)}}return d._id},pause:function(e){var n=this;if("loaded"!==n._state||n._playLock)return n._queue.push({event:"pause",action:function(){n.pause(e)}}),n;for(var o=n._getSoundIds(e),t=0;t<o.length;t++){n._clearTimer(o[t]);var r=n._soundById(o[t]);if(r&&!r._paused&&(r._seek=n.seek(o[t]),r._rateSeek=0,r._paused=!0,n._stopFade(o[t]),r._node))if(n._webAudio){if(!r._node.bufferSource)continue;void 0===r._node.bufferSource.stop?r._node.bufferSource.noteOff(0):r._node.bufferSource.stop(0),n._cleanBuffer(r._node)}else isNaN(r._node.duration)&&r._node.duration!==1/0||r._node.pause();arguments[1]||n._emit("pause",r?r._id:null)}return n},stop:function(e,n){var o=this;if("loaded"!==o._state||o._playLock)return o._queue.push({event:"stop",action:function(){o.stop(e)}}),o;for(var t=o._getSoundIds(e),r=0;r<t.length;r++){o._clearTimer(t[r]);var a=o._soundById(t[r]);a&&(a._seek=a._start||0,a._rateSeek=0,a._paused=!0,a._ended=!0,o._stopFade(t[r]),a._node&&(o._webAudio?a._node.bufferSource&&(void 0===a._node.bufferSource.stop?a._node.bufferSource.noteOff(0):a._node.bufferSource.stop(0),o._cleanBuffer(a._node)):isNaN(a._node.duration)&&a._node.duration!==1/0||(a._node.currentTime=a._start||0,a._node.pause(),a._node.duration===1/0&&o._clearSound(a._node))),n||o._emit("stop",a._id))}return o},mute:function(e,o){var t=this;if("loaded"!==t._state||t._playLock)return t._queue.push({event:"mute",action:function(){t.mute(e,o)}}),t;if(void 0===o){if("boolean"!=typeof e)return t._muted;t._muted=e}for(var r=t._getSoundIds(o),a=0;a<r.length;a++){var u=t._soundById(r[a]);u&&(u._muted=e,u._interval&&t._stopFade(u._id),t._webAudio&&u._node?u._node.gain.setValueAtTime(e?0:u._volume,n.ctx.currentTime):u._node&&(u._node.muted=!!n._muted||e),t._emit("mute",u._id))}return t},volume:function(){var e,o,t=this,r=arguments;if(0===r.length)return t._volume;if(1===r.length||2===r.length&&void 0===r[1]){t._getSoundIds().indexOf(r[0])>=0?o=parseInt(r[0],10):e=parseFloat(r[0])}else r.length>=2&&(e=parseFloat(r[0]),o=parseInt(r[1],10));var a;if(!(void 0!==e&&e>=0&&e<=1))return a=o?t._soundById(o):t._sounds[0],a?a._volume:0;if("loaded"!==t._state||t._playLock)return t._queue.push({event:"volume",action:function(){t.volume.apply(t,r)}}),t;void 0===o&&(t._volume=e),o=t._getSoundIds(o);for(var u=0;u<o.length;u++)(a=t._soundById(o[u]))&&(a._volume=e,r[2]||t._stopFade(o[u]),t._webAudio&&a._node&&!a._muted?a._node.gain.setValueAtTime(e,n.ctx.currentTime):a._node&&!a._muted&&(a._node.volume=e*n.volume()),t._emit("volume",a._id));return t},fade:function(e,o,t,r){var a=this;if("loaded"!==a._state||a._playLock)return a._queue.push({event:"fade",action:function(){a.fade(e,o,t,r)}}),a;e=Math.min(Math.max(0,parseFloat(e)),1),o=Math.min(Math.max(0,parseFloat(o)),1),t=parseFloat(t),a.volume(e,r);for(var u=a._getSoundIds(r),d=0;d<u.length;d++){var i=a._soundById(u[d]);if(i){if(r||a._stopFade(u[d]),a._webAudio&&!i._muted){var _=n.ctx.currentTime,s=_+t/1e3;i._volume=e,i._node.gain.setValueAtTime(e,_),i._node.gain.linearRampToValueAtTime(o,s)}a._startFadeInterval(i,e,o,t,u[d],void 0===r)}}return a},_startFadeInterval:function(e,n,o,t,r,a){var u=this,d=n,i=o-n,_=Math.abs(i/.01),s=Math.max(4,_>0?t/_:t),l=Date.now();e._fadeTo=o,e._interval=setInterval(function(){var r=(Date.now()-l)/t;l=Date.now(),d+=i*r,d=Math.round(100*d)/100,d=i<0?Math.max(o,d):Math.min(o,d),u._webAudio?e._volume=d:u.volume(d,e._id,!0),a&&(u._volume=d),(o<n&&d<=o||o>n&&d>=o)&&(clearInterval(e._interval),e._interval=null,e._fadeTo=null,u.volume(o,e._id),u._emit("fade",e._id))},s)},_stopFade:function(e){var o=this,t=o._soundById(e);return t&&t._interval&&(o._webAudio&&t._node.gain.cancelScheduledValues(n.ctx.currentTime),clearInterval(t._interval),t._interval=null,o.volume(t._fadeTo,e),t._fadeTo=null,o._emit("fade",e)),o},loop:function(){var e,n,o,t=this,r=arguments;if(0===r.length)return t._loop;if(1===r.length){if("boolean"!=typeof r[0])return!!(o=t._soundById(parseInt(r[0],10)))&&o._loop;e=r[0],t._loop=e}else 2===r.length&&(e=r[0],n=parseInt(r[1],10));for(var a=t._getSoundIds(n),u=0;u<a.length;u++)(o=t._soundById(a[u]))&&(o._loop=e,t._webAudio&&o._node&&o._node.bufferSource&&(o._node.bufferSource.loop=e,e&&(o._node.bufferSource.loopStart=o._start||0,o._node.bufferSource.loopEnd=o._stop,t.playing(a[u])&&(t.pause(a[u],!0),t.play(a[u],!0)))));return t},rate:function(){var e,o,t=this,r=arguments;if(0===r.length)o=t._sounds[0]._id;else if(1===r.length){var a=t._getSoundIds(),u=a.indexOf(r[0]);u>=0?o=parseInt(r[0],10):e=parseFloat(r[0])}else 2===r.length&&(e=parseFloat(r[0]),o=parseInt(r[1],10));var d;if("number"!=typeof e)return d=t._soundById(o),d?d._rate:t._rate;if("loaded"!==t._state||t._playLock)return t._queue.push({event:"rate",action:function(){t.rate.apply(t,r)}}),t;void 0===o&&(t._rate=e),o=t._getSoundIds(o);for(var i=0;i<o.length;i++)if(d=t._soundById(o[i])){t.playing(o[i])&&(d._rateSeek=t.seek(o[i]),d._playStart=t._webAudio?n.ctx.currentTime:d._playStart),d._rate=e,t._webAudio&&d._node&&d._node.bufferSource?d._node.bufferSource.playbackRate.setValueAtTime(e,n.ctx.currentTime):d._node&&(d._node.playbackRate=e);var _=t.seek(o[i]),s=(t._sprite[d._sprite][0]+t._sprite[d._sprite][1])/1e3-_,l=1e3*s/Math.abs(d._rate);!t._endTimers[o[i]]&&d._paused||(t._clearTimer(o[i]),t._endTimers[o[i]]=setTimeout(t._ended.bind(t,d),l)),t._emit("rate",d._id)}return t},seek:function(){var e,o,t=this,r=arguments;if(0===r.length)t._sounds.length&&(o=t._sounds[0]._id);else if(1===r.length){var a=t._getSoundIds(),u=a.indexOf(r[0]);u>=0?o=parseInt(r[0],10):t._sounds.length&&(o=t._sounds[0]._id,e=parseFloat(r[0]))}else 2===r.length&&(e=parseFloat(r[0]),o=parseInt(r[1],10));if(void 0===o)return 0;if("number"==typeof e&&("loaded"!==t._state||t._playLock))return t._queue.push({event:"seek",action:function(){t.seek.apply(t,r)}}),t;var d=t._soundById(o);if(d){if(!("number"==typeof e&&e>=0)){if(t._webAudio){var i=t.playing(o)?n.ctx.currentTime-d._playStart:0,_=d._rateSeek?d._rateSeek-d._seek:0;return d._seek+(_+i*Math.abs(d._rate))}return d._node.currentTime}var s=t.playing(o);s&&t.pause(o,!0),d._seek=e,d._ended=!1,t._clearTimer(o),t._webAudio||!d._node||isNaN(d._node.duration)||(d._node.currentTime=e);var l=function(){s&&t.play(o,!0),t._emit("seek",o)};if(s&&!t._webAudio){var c=function(){t._playLock?setTimeout(c,0):l()};setTimeout(c,0)}else l()}return t},playing:function(e){var n=this;if("number"==typeof e){var o=n._soundById(e);return!!o&&!o._paused}for(var t=0;t<n._sounds.length;t++)if(!n._sounds[t]._paused)return!0;return!1},duration:function(e){var n=this,o=n._duration,t=n._soundById(e);return t&&(o=n._sprite[t._sprite][1]/1e3),o},state:function(){return this._state},unload:function(){for(var e=this,o=e._sounds,t=0;t<o.length;t++)o[t]._paused||e.stop(o[t]._id),e._webAudio||(e._clearSound(o[t]._node),o[t]._node.removeEventListener("error",o[t]._errorFn,!1),o[t]._node.removeEventListener(n._canPlayEvent,o[t]._loadFn,!1),o[t]._node.removeEventListener("ended",o[t]._endFn,!1),n._releaseHtml5Audio(o[t]._node)),delete o[t]._node,e._clearTimer(o[t]._id);var a=n._bpAudios.indexOf(e);a>=0&&n._bpAudios.splice(a,1);var u=!0;for(t=0;t<n._bpAudios.length;t++)if(n._bpAudios[t]._src===e._src||e._src.indexOf(n._bpAudios[t]._src)>=0){u=!1;break}return r&&u&&delete r[e._src],n.noAudio=!1,e._state="unloaded",e._sounds=[],e=null,null},on:function(e,n,o,t){var r=this,a=r["_on"+e];return"function"==typeof n&&a.push(t?{id:o,fn:n,once:t}:{id:o,fn:n}),r},off:function(e,n,o){var t=this,r=t["_on"+e],a=0;if("number"==typeof n&&(o=n,n=null),n||o)for(a=0;a<r.length;a++){var u=o===r[a].id;if(n===r[a].fn&&u||!n&&u){r.splice(a,1);break}}else if(e)t["_on"+e]=[];else{var d=Object.keys(t);for(a=0;a<d.length;a++)0===d[a].indexOf("_on")&&Array.isArray(t[d[a]])&&(t[d[a]]=[])}return t},once:function(e,n,o){var t=this;return t.on(e,n,o,1),t},_emit:function(e,n,o){for(var t=this,r=t["_on"+e],a=r.length-1;a>=0;a--)r[a].id&&r[a].id!==n&&"load"!==e||(setTimeout(function(e){e.call(this,n,o)}.bind(t,r[a].fn),0),r[a].once&&t.off(e,r[a].fn,r[a].id));return t._loadQueue(e),t},_loadQueue:function(e){var n=this;if(n._queue.length>0){var o=n._queue[0];o.event===e&&(n._queue.shift(),n._loadQueue()),e||o.action()}return n},_ended:function(e){var o=this,t=e._sprite;if(!o._webAudio&&e._node&&!e._node.paused&&!e._node.ended&&e._node.currentTime<e._stop)return setTimeout(o._ended.bind(o,e),100),o;var r=!(!e._loop&&!o._sprite[t][2]);if(o._emit("end",e._id),!o._webAudio&&r&&o.stop(e._id,!0).play(e._id),o._webAudio&&r){o._emit("play",e._id),e._seek=e._start||0,e._rateSeek=0,e._playStart=n.ctx.currentTime;var a=1e3*(e._stop-e._start)/Math.abs(e._rate);o._endTimers[e._id]=setTimeout(o._ended.bind(o,e),a)}return o._webAudio&&!r&&(e._paused=!0,e._ended=!0,e._seek=e._start||0,e._rateSeek=0,o._clearTimer(e._id),o._cleanBuffer(e._node),n._autoSuspend()),o._webAudio||r||o.stop(e._id,!0),o},_clearTimer:function(e){var n=this;if(n._endTimers[e]){if("function"!=typeof n._endTimers[e])clearTimeout(n._endTimers[e]);else{var o=n._soundById(e);o&&o._node&&o._node.removeEventListener("ended",n._endTimers[e],!1)}delete n._endTimers[e]}return n},_soundById:function(e){for(var n=this,o=0;o<n._sounds.length;o++)if(e===n._sounds[o]._id)return n._sounds[o];return null},_inactiveSound:function(){var e=this;e._drain();for(var n=0;n<e._sounds.length;n++)if(e._sounds[n]._ended)return e._sounds[n].reset();return new t(e)},_drain:function(){var e=this,n=e._pool,o=0,t=0;if(!(e._sounds.length<n)){for(t=0;t<e._sounds.length;t++)e._sounds[t]._ended&&o++;for(t=e._sounds.length-1;t>=0;t--){if(o<=n)return;e._sounds[t]._ended&&(e._webAudio&&e._sounds[t]._node&&e._sounds[t]._node.disconnect(0),e._sounds.splice(t,1),o--)}}},_getSoundIds:function(e){var n=this;if(void 0===e){for(var o=[],t=0;t<n._sounds.length;t++)o.push(n._sounds[t]._id);return o}return[e]},_refreshBuffer:function(e){var o=this;return e._node.bufferSource=n.ctx.createBufferSource(),e._node.bufferSource.buffer=r[o._src],e._panner?e._node.bufferSource.connect(e._panner):e._node.bufferSource.connect(e._node),e._node.bufferSource.loop=e._loop,e._loop&&(e._node.bufferSource.loopStart=e._start||0,e._node.bufferSource.loopEnd=e._stop||0),e._node.bufferSource.playbackRate.setValueAtTime(e._rate,n.ctx.currentTime),o},_cleanBuffer:function(e){var o=this,t=n._navigator&&n._navigator.vendor.indexOf("Apple")>=0;if(!e.bufferSource)return o;if(n._scratchBuffer&&e.bufferSource&&(e.bufferSource.onended=null,e.bufferSource.disconnect(0),t))try{e.bufferSource.buffer=n._scratchBuffer}catch(e){}return e.bufferSource=null,o},_clearSound:function(e){/MSIE |Trident\//.test(n._navigator&&n._navigator.userAgent)||(e.src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA")}};var t=function(e){this._parent=e,this.init()};t.prototype={init:function(){var e=this,o=e._parent;return e._muted=o._muted,e._loop=o._loop,e._volume=o._volume,e._rate=o._rate,e._seek=0,e._paused=!0,e._ended=!0,e._sprite="__default",e._id=++n._counter,o._sounds.push(e),e.create(),e},create:function(){var e=this,o=e._parent,t=n._muted||e._muted||e._parent._muted?0:e._volume;return o._webAudio?(e._node=void 0===n.ctx.createGain?n.ctx.createGainNode():n.ctx.createGain(),e._node.gain.setValueAtTime(t,n.ctx.currentTime),e._node.paused=!0,e._node.connect(n.masterGain)):n.noAudio||(e._node=n._obtainHtml5Audio(),e._errorFn=e._errorListener.bind(e),e._node.addEventListener("error",e._errorFn,!1),e._loadFn=e._loadListener.bind(e),e._node.addEventListener(n._canPlayEvent,e._loadFn,!1),e._endFn=e._endListener.bind(e),e._node.addEventListener("ended",e._endFn,!1),e._node.src=o._src,e._node.preload=!0===o._preload?"auto":o._preload,e._node.volume=t*n.volume(),e._node.load()),e},reset:function(){var e=this,o=e._parent;return e._muted=o._muted,e._loop=o._loop,e._volume=o._volume,e._rate=o._rate,e._seek=0,e._rateSeek=0,e._paused=!0,e._ended=!0,e._sprite="__default",e._id=++n._counter,e},_errorListener:function(){var e=this;e._parent._emit("loaderror",e._id,e._node.error?e._node.error.code:0),e._node.removeEventListener("error",e._errorFn,!1)},_loadListener:function(){var e=this,o=e._parent;o._duration=Math.ceil(10*e._node.duration)/10,0===Object.keys(o._sprite).length&&(o._sprite={__default:[0,1e3*o._duration]}),"loaded"!==o._state&&(o._state="loaded",o._emit("load"),o._loadQueue()),e._node.removeEventListener(n._canPlayEvent,e._loadFn,!1)},_endListener:function(){var e=this,n=e._parent;n._duration===1/0&&(n._duration=Math.ceil(10*e._node.duration)/10,n._sprite.__default[1]===1/0&&(n._sprite.__default[1]=1e3*n._duration),n._ended(e)),e._node.removeEventListener("ended",e._endFn,!1)}};var r={},a=function(e){var n=e._src;if(r[n])return e._duration=r[n].duration,void i(e);if(/^data:[^;]+;base64,/.test(n)){for(var o=atob(n.split(",")[1]),t=new Uint8Array(o.length),a=0;a<o.length;++a)t[a]=o.charCodeAt(a);d(t.buffer,e)}else{var _=new XMLHttpRequest;_.open(e._xhr.method,n,!0),_.withCredentials=e._xhr.withCredentials,_.responseType="arraybuffer",e._xhr.headers&&Object.keys(e._xhr.headers).forEach(function(n){_.setRequestHeader(n,e._xhr.headers[n])}),_.onload=function(){var n=(_.status+"")[0];if("0"!==n&&"2"!==n&&"3"!==n)return void e._emit("loaderror",null,"Failed loading audio file with status: "+_.status+".");d(_.response,e)},_.onerror=function(){e._webAudio&&(e._html5=!0,e._webAudio=!1,e._sounds=[],delete r[n],e.load())},u(_)}},u=function(e){try{e.send()}catch(n){e.onerror()}},d=function(e,o){var t=function(){o._emit("loaderror",null,"Decoding audio data failed.")},a=function(e){e&&o._sounds.length>0?(r[o._src]=e,i(o,e)):t()};"undefined"!=typeof Promise&&1===n.ctx.decodeAudioData.length?n.ctx.decodeAudioData(e).then(a).catch(t):n.ctx.decodeAudioData(e,a,t)},i=function(e,n){n&&!e._duration&&(e._duration=n.duration),0===Object.keys(e._sprite).length&&(e._sprite={__default:[0,1e3*e._duration]}),"loaded"!==e._state&&(e._state="loaded",e._emit("load"),e._loadQueue())},_=function(){if(n.usingWebAudio){try{"undefined"!=typeof AudioContext?n.ctx=new AudioContext:"undefined"!=typeof webkitAudioContext?n.ctx=new webkitAudioContext:n.usingWebAudio=!1}catch(e){n.usingWebAudio=!1}n.ctx||(n.usingWebAudio=!1);var e=/iP(hone|od|ad)/.test(n._navigator&&n._navigator.platform),o=n._navigator&&n._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),t=o?parseInt(o[1],10):null;if(e&&t&&t<9){var r=/safari/.test(n._navigator&&n._navigator.userAgent.toLowerCase());n._navigator&&!r&&(n.usingWebAudio=!1)}n.usingWebAudio&&(n.masterGain=void 0===n.ctx.createGain?n.ctx.createGainNode():n.ctx.createGain(),n.masterGain.gain.setValueAtTime(n._muted?0:n._volume,n.ctx.currentTime),n.masterGain.connect(n.ctx.destination)),n._setup()}};"function"==typeof define&&define.amd&&define([],function(){return{bpAudio:n,bpAudio:o}}),"undefined"!=typeof exports&&(exports.bpAudio=n,exports.bpAudio=o),"undefined"!=typeof global?(global.bpAudioGlobal=e,global.bpAudio=n,global.bpAudio=o,global.Sound=t):"undefined"!=typeof window&&(window.bpAudioGlobal=e,window.bpAudio=n,window.bpAudio=o,window.Sound=t)}();
/*! Spatial Plugin */
!function(){"use strict";bpAudioGlobal.prototype._pos=[0,0,0],bpAudioGlobal.prototype._orientation=[0,0,-1,0,1,0],bpAudioGlobal.prototype.stereo=function(e){var n=this;if(!n.ctx||!n.ctx.listener)return n;for(var t=n._bpAudios.length-1;t>=0;t--)n._bpAudios[t].stereo(e);return n},bpAudioGlobal.prototype.pos=function(e,n,t){var r=this;return r.ctx&&r.ctx.listener?(n="number"!=typeof n?r._pos[1]:n,t="number"!=typeof t?r._pos[2]:t,"number"!=typeof e?r._pos:(r._pos=[e,n,t],void 0!==r.ctx.listener.positionX?(r.ctx.listener.positionX.setTargetAtTime(r._pos[0],bpAudio.ctx.currentTime,.1),r.ctx.listener.positionY.setTargetAtTime(r._pos[1],bpAudio.ctx.currentTime,.1),r.ctx.listener.positionZ.setTargetAtTime(r._pos[2],bpAudio.ctx.currentTime,.1)):r.ctx.listener.setPosition(r._pos[0],r._pos[1],r._pos[2]),r)):r},bpAudioGlobal.prototype.orientation=function(e,n,t,r,o,i){var a=this;if(!a.ctx||!a.ctx.listener)return a;var p=a._orientation;return n="number"!=typeof n?p[1]:n,t="number"!=typeof t?p[2]:t,r="number"!=typeof r?p[3]:r,o="number"!=typeof o?p[4]:o,i="number"!=typeof i?p[5]:i,"number"!=typeof e?p:(a._orientation=[e,n,t,r,o,i],void 0!==a.ctx.listener.forwardX?(a.ctx.listener.forwardX.setTargetAtTime(e,bpAudio.ctx.currentTime,.1),a.ctx.listener.forwardY.setTargetAtTime(n,bpAudio.ctx.currentTime,.1),a.ctx.listener.forwardZ.setTargetAtTime(t,bpAudio.ctx.currentTime,.1),a.ctx.listener.upX.setTargetAtTime(r,bpAudio.ctx.currentTime,.1),a.ctx.listener.upY.setTargetAtTime(o,bpAudio.ctx.currentTime,.1),a.ctx.listener.upZ.setTargetAtTime(i,bpAudio.ctx.currentTime,.1)):a.ctx.listener.setOrientation(e,n,t,r,o,i),a)},bpAudio.prototype.init=function(e){return function(n){var t=this;return t._orientation=n.orientation||[1,0,0],t._stereo=n.stereo||null,t._pos=n.pos||null,t._pannerAttr={coneInnerAngle:void 0!==n.coneInnerAngle?n.coneInnerAngle:360,coneOuterAngle:void 0!==n.coneOuterAngle?n.coneOuterAngle:360,coneOuterGain:void 0!==n.coneOuterGain?n.coneOuterGain:0,distanceModel:void 0!==n.distanceModel?n.distanceModel:"inverse",maxDistance:void 0!==n.maxDistance?n.maxDistance:1e4,panningModel:void 0!==n.panningModel?n.panningModel:"HRTF",refDistance:void 0!==n.refDistance?n.refDistance:1,rolloffFactor:void 0!==n.rolloffFactor?n.rolloffFactor:1},t._onstereo=n.onstereo?[{fn:n.onstereo}]:[],t._onpos=n.onpos?[{fn:n.onpos}]:[],t._onorientation=n.onorientation?[{fn:n.onorientation}]:[],e.call(this,n)}}(bpAudio.prototype.init),bpAudio.prototype.stereo=function(n,t){var r=this;if(!r._webAudio)return r;if("loaded"!==r._state)return r._queue.push({event:"stereo",action:function(){r.stereo(n,t)}}),r;var o=void 0===bpAudio.ctx.createStereoPanner?"spatial":"stereo";if(void 0===t){if("number"!=typeof n)return r._stereo;r._stereo=n,r._pos=[n,0,0]}for(var i=r._getSoundIds(t),a=0;a<i.length;a++){var p=r._soundById(i[a]);if(p){if("number"!=typeof n)return p._stereo;p._stereo=n,p._pos=[n,0,0],p._node&&(p._pannerAttr.panningModel="equalpower",p._panner&&p._panner.pan||e(p,o),"spatial"===o?void 0!==p._panner.positionX?(p._panner.positionX.setValueAtTime(n,bpAudio.ctx.currentTime),p._panner.positionY.setValueAtTime(0,bpAudio.ctx.currentTime),p._panner.positionZ.setValueAtTime(0,bpAudio.ctx.currentTime)):p._panner.setPosition(n,0,0):p._panner.pan.setValueAtTime(n,bpAudio.ctx.currentTime)),r._emit("stereo",p._id)}}return r},bpAudio.prototype.pos=function(n,t,r,o){var i=this;if(!i._webAudio)return i;if("loaded"!==i._state)return i._queue.push({event:"pos",action:function(){i.pos(n,t,r,o)}}),i;if(t="number"!=typeof t?0:t,r="number"!=typeof r?-.5:r,void 0===o){if("number"!=typeof n)return i._pos;i._pos=[n,t,r]}for(var a=i._getSoundIds(o),p=0;p<a.length;p++){var s=i._soundById(a[p]);if(s){if("number"!=typeof n)return s._pos;s._pos=[n,t,r],s._node&&(s._panner&&!s._panner.pan||e(s,"spatial"),void 0!==s._panner.positionX?(s._panner.positionX.setValueAtTime(n,bpAudio.ctx.currentTime),s._panner.positionY.setValueAtTime(t,bpAudio.ctx.currentTime),s._panner.positionZ.setValueAtTime(r,bpAudio.ctx.currentTime)):s._panner.setPosition(n,t,r)),i._emit("pos",s._id)}}return i},bpAudio.prototype.orientation=function(n,t,r,o){var i=this;if(!i._webAudio)return i;if("loaded"!==i._state)return i._queue.push({event:"orientation",action:function(){i.orientation(n,t,r,o)}}),i;if(t="number"!=typeof t?i._orientation[1]:t,r="number"!=typeof r?i._orientation[2]:r,void 0===o){if("number"!=typeof n)return i._orientation;i._orientation=[n,t,r]}for(var a=i._getSoundIds(o),p=0;p<a.length;p++){var s=i._soundById(a[p]);if(s){if("number"!=typeof n)return s._orientation;s._orientation=[n,t,r],s._node&&(s._panner||(s._pos||(s._pos=i._pos||[0,0,-.5]),e(s,"spatial")),void 0!==s._panner.orientationX?(s._panner.orientationX.setValueAtTime(n,bpAudio.ctx.currentTime),s._panner.orientationY.setValueAtTime(t,bpAudio.ctx.currentTime),s._panner.orientationZ.setValueAtTime(r,bpAudio.ctx.currentTime)):s._panner.setOrientation(n,t,r)),i._emit("orientation",s._id)}}return i},bpAudio.prototype.pannerAttr=function(){var n,t,r,o=this,i=arguments;if(!o._webAudio)return o;if(0===i.length)return o._pannerAttr;if(1===i.length){if("object"!=typeof i[0])return r=o._soundById(parseInt(i[0],10)),r?r._pannerAttr:o._pannerAttr;n=i[0],void 0===t&&(n.pannerAttr||(n.pannerAttr={coneInnerAngle:n.coneInnerAngle,coneOuterAngle:n.coneOuterAngle,coneOuterGain:n.coneOuterGain,distanceModel:n.distanceModel,maxDistance:n.maxDistance,refDistance:n.refDistance,rolloffFactor:n.rolloffFactor,panningModel:n.panningModel}),o._pannerAttr={coneInnerAngle:void 0!==n.pannerAttr.coneInnerAngle?n.pannerAttr.coneInnerAngle:o._coneInnerAngle,coneOuterAngle:void 0!==n.pannerAttr.coneOuterAngle?n.pannerAttr.coneOuterAngle:o._coneOuterAngle,coneOuterGain:void 0!==n.pannerAttr.coneOuterGain?n.pannerAttr.coneOuterGain:o._coneOuterGain,distanceModel:void 0!==n.pannerAttr.distanceModel?n.pannerAttr.distanceModel:o._distanceModel,maxDistance:void 0!==n.pannerAttr.maxDistance?n.pannerAttr.maxDistance:o._maxDistance,refDistance:void 0!==n.pannerAttr.refDistance?n.pannerAttr.refDistance:o._refDistance,rolloffFactor:void 0!==n.pannerAttr.rolloffFactor?n.pannerAttr.rolloffFactor:o._rolloffFactor,panningModel:void 0!==n.pannerAttr.panningModel?n.pannerAttr.panningModel:o._panningModel})}else 2===i.length&&(n=i[0],t=parseInt(i[1],10));for(var a=o._getSoundIds(t),p=0;p<a.length;p++)if(r=o._soundById(a[p])){var s=r._pannerAttr;s={coneInnerAngle:void 0!==n.coneInnerAngle?n.coneInnerAngle:s.coneInnerAngle,coneOuterAngle:void 0!==n.coneOuterAngle?n.coneOuterAngle:s.coneOuterAngle,coneOuterGain:void 0!==n.coneOuterGain?n.coneOuterGain:s.coneOuterGain,distanceModel:void 0!==n.distanceModel?n.distanceModel:s.distanceModel,maxDistance:void 0!==n.maxDistance?n.maxDistance:s.maxDistance,refDistance:void 0!==n.refDistance?n.refDistance:s.refDistance,rolloffFactor:void 0!==n.rolloffFactor?n.rolloffFactor:s.rolloffFactor,panningModel:void 0!==n.panningModel?n.panningModel:s.panningModel};var c=r._panner;c||(r._pos||(r._pos=o._pos||[0,0,-.5]),e(r,"spatial"),c=r._panner),c.coneInnerAngle=s.coneInnerAngle,c.coneOuterAngle=s.coneOuterAngle,c.coneOuterGain=s.coneOuterGain,c.distanceModel=s.distanceModel,c.maxDistance=s.maxDistance,c.refDistance=s.refDistance,c.rolloffFactor=s.rolloffFactor,c.panningModel=s.panningModel}return o},Sound.prototype.init=function(e){return function(){var n=this,t=n._parent;n._orientation=t._orientation,n._stereo=t._stereo,n._pos=t._pos,n._pannerAttr=t._pannerAttr,e.call(this),n._stereo?t.stereo(n._stereo):n._pos&&t.pos(n._pos[0],n._pos[1],n._pos[2],n._id)}}(Sound.prototype.init),Sound.prototype.reset=function(e){return function(){var n=this,t=n._parent;return n._orientation=t._orientation,n._stereo=t._stereo,n._pos=t._pos,n._pannerAttr=t._pannerAttr,n._stereo?t.stereo(n._stereo):n._pos?t.pos(n._pos[0],n._pos[1],n._pos[2],n._id):n._panner&&(n._panner.disconnect(0),n._panner=void 0,t._refreshBuffer(n)),e.call(this)}}(Sound.prototype.reset);var e=function(e,n){n=n||"spatial","spatial"===n?(e._panner=bpAudio.ctx.createPanner(),e._panner.coneInnerAngle=e._pannerAttr.coneInnerAngle,e._panner.coneOuterAngle=e._pannerAttr.coneOuterAngle,e._panner.coneOuterGain=e._pannerAttr.coneOuterGain,e._panner.distanceModel=e._pannerAttr.distanceModel,e._panner.maxDistance=e._pannerAttr.maxDistance,e._panner.refDistance=e._pannerAttr.refDistance,e._panner.rolloffFactor=e._pannerAttr.rolloffFactor,e._panner.panningModel=e._pannerAttr.panningModel,void 0!==e._panner.positionX?(e._panner.positionX.setValueAtTime(e._pos[0],bpAudio.ctx.currentTime),e._panner.positionY.setValueAtTime(e._pos[1],bpAudio.ctx.currentTime),e._panner.positionZ.setValueAtTime(e._pos[2],bpAudio.ctx.currentTime)):e._panner.setPosition(e._pos[0],e._pos[1],e._pos[2]),void 0!==e._panner.orientationX?(e._panner.orientationX.setValueAtTime(e._orientation[0],bpAudio.ctx.currentTime),e._panner.orientationY.setValueAtTime(e._orientation[1],bpAudio.ctx.currentTime),e._panner.orientationZ.setValueAtTime(e._orientation[2],bpAudio.ctx.currentTime)):e._panner.setOrientation(e._orientation[0],e._orientation[1],e._orientation[2])):(e._panner=bpAudio.ctx.createStereoPanner(),e._panner.pan.setValueAtTime(e._stereo,bpAudio.ctx.currentTime)),e._panner.connect(e._node),e._paused||e._parent.pause(e._id,!0).play(e._id,!0)}}();

!function(e){if("object"==typeof exports)module.exports=e();else if("function"==typeof define&&define.amd)define(e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.S=e()}}(function(){var define,module,exports;return function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}({1:[function(_dereq_,module,exports){function count(self,substr){var count=0;var pos=self.indexOf(substr);while(pos>=0){count+=1;pos=self.indexOf(substr,pos+1)}return count}module.exports=count},{}],2:[function(_dereq_,module,exports){function splitLeft(self,sep,maxSplit,limit){if(typeof maxSplit==="undefined"){var maxSplit=-1}var splitResult=self.split(sep);var splitPart1=splitResult.slice(0,maxSplit);var splitPart2=splitResult.slice(maxSplit);if(splitPart2.length===0){splitResult=splitPart1}else{splitResult=splitPart1.concat(splitPart2.join(sep))}if(typeof limit==="undefined"){return splitResult}else if(limit<0){return splitResult.slice(limit)}else{return splitResult.slice(0,limit)}}module.exports=splitLeft},{}],3:[function(_dereq_,module,exports){function splitRight(self,sep,maxSplit,limit){if(typeof maxSplit==="undefined"){var maxSplit=-1}if(typeof limit==="undefined"){var limit=0}var splitResult=[self];for(var i=self.length-1;i>=0;i--){if(splitResult[0].slice(i).indexOf(sep)===0&&(splitResult.length<=maxSplit||maxSplit===-1)){splitResult.splice(1,0,splitResult[0].slice(i+sep.length));splitResult[0]=splitResult[0].slice(0,i)}}if(limit>=0){return splitResult.slice(-limit)}else{return splitResult.slice(0,-limit)}}module.exports=splitRight},{}],4:[function(_dereq_,module,exports){!function(){"use strict";var VERSION="3.3.3";var ENTITIES={};var latin_map={"":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"A","":"AA","":"AE","":"AE","":"AE","":"AO","":"AU","":"AV","":"AV","":"AY","":"B","":"B","":"B","":"B","":"B","":"B","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"C","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"D","":"DZ","":"DZ","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"E","":"ET","":"F","":"F","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"G","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"H","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"I","":"D","":"F","":"G","":"R","":"S","":"T","":"IS","":"J","":"J","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"K","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"L","":"LJ","":"M","":"M","":"M","":"M","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"N","":"NJ","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"O","":"OI","":"OO","":"E","":"O","":"OU","":"P","":"P","":"P","":"P","":"P","":"P","":"P","":"Q","":"Q","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"R","":"C","":"E","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"S","":"SS","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"T","":"A","":"L","":"M","":"V","":"TZ","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"U","":"V","":"V","":"V","":"V","":"VY","":"W","":"W","":"W","":"W","":"W","":"W","":"W","":"X","":"X","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Y","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"Z","":"IJ","":"OE","":"A","":"AE","":"B","":"B","":"C","":"D","":"E","":"F","":"G","":"G","":"H","":"I","":"R","":"J","":"K","":"L","":"L","":"M","":"N","":"O","":"OE","":"O","":"OU","":"P","":"R","":"N","":"R","":"S","":"T","":"E","":"R","":"U","":"V","":"W","":"Y","":"Z","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"a","":"aa","":"ae","":"ae","":"ae","":"ao","":"au","":"av","":"av","":"ay","":"b","":"b","":"b","":"b","":"b","":"b","":"b","":"b","":"o","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"c","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"d","":"i","":"j","":"j","":"j","":"dz","":"dz","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"e","":"et","":"f","":"f","":"f","":"f","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"g","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"h","":"hv","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"i","":"d","":"f","":"g","":"r","":"s","":"t","":"is","":"j","":"j","":"j","":"j","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"k","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"l","":"lj","":"s","":"s","":"s","":"s","":"m","":"m","":"m","":"m","":"m","":"m","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"n","":"nj","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"o","":"oi","":"oo","":"e","":"e","":"o","":"o","":"ou","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"p","":"q","":"q","":"q","":"q","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"r","":"c","":"c","":"e","":"r","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"s","":"g","":"ss","":"o","":"o","":"u","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"t","":"th","":"a","":"ae","":"e","":"g","":"h","":"h","":"h","":"i","":"k","":"l","":"m","":"m","":"oe","":"r","":"r","":"r","":"r","":"t","":"v","":"w","":"y","":"tz","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"u","":"ue","":"um","":"v","":"v","":"v","":"v","":"v","":"v","":"v","":"vy","":"w","":"w","":"w","":"w","":"w","":"w","":"w","":"w","":"x","":"x","":"x","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"y","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"z","":"ff","":"ffi","":"ffl","":"fi","":"fl","":"ij","":"oe","":"st","":"a","":"e","":"i","":"j","":"o","":"r","":"u","":"v","":"x"};function initialize(object,s){if(s!==null&&s!==undefined){if(typeof s==="string")object.s=s;else object.s=s.toString()}else{object.s=s}object.orig=s;if(s!==null&&s!==undefined){if(object.__defineGetter__){object.__defineGetter__("length",function(){return object.s.length})}else{object.length=s.length}}else{object.length=-1}}function S(s){initialize(this,s)}var __nsp=String.prototype;var __sp=S.prototype={between:function(left,right){var s=this.s;var startPos=s.indexOf(left);var endPos=s.indexOf(right,startPos+left.length);if(endPos==-1&&right!=null)return new this.constructor("");else if(endPos==-1&&right==null)return new this.constructor(s.substring(startPos+left.length));else return new this.constructor(s.slice(startPos+left.length,endPos))},camelize:function(){var s=this.trim().s.replace(/(\-|_|\s)+(.)?/g,function(mathc,sep,c){return c?c.toUpperCase():""});return new this.constructor(s)},capitalize:function(){return new this.constructor(this.s.substr(0,1).toUpperCase()+this.s.substring(1).toLowerCase())},charAt:function(index){return this.s.charAt(index)},chompLeft:function(prefix){var s=this.s;if(s.indexOf(prefix)===0){s=s.slice(prefix.length);return new this.constructor(s)}else{return this}},chompRight:function(suffix){if(this.endsWith(suffix)){var s=this.s;s=s.slice(0,s.length-suffix.length);return new this.constructor(s)}else{return this}},collapseWhitespace:function(){var s=this.s.replace(/[\s\xa0]+/g," ").replace(/^\s+|\s+$/g,"");return new this.constructor(s)},contains:function(ss){return this.s.indexOf(ss)>=0},count:function(ss){return _dereq_("./_count")(this.s,ss)},dasherize:function(){var s=this.trim().s.replace(/[_\s]+/g,"-").replace(/([A-Z])/g,"-$1").replace(/-+/g,"-").toLowerCase();return new this.constructor(s)},equalsIgnoreCase:function(prefix){var s=this.s;return s.toLowerCase()==prefix.toLowerCase()},latinise:function(){var s=this.replace(/[^A-Za-z0-9\[\] ]/g,function(x){return latin_map[x]||x});return new this.constructor(s)},decodeHtmlEntities:function(){var s=this.s;s=s.replace(/&#(\d+);?/g,function(_,code){return String.fromCharCode(code)}).replace(/&#[xX]([A-Fa-f0-9]+);?/g,function(_,hex){return String.fromCharCode(parseInt(hex,16))}).replace(/&([^;\W]+;?)/g,function(m,e){var ee=e.replace(/;$/,"");var target=ENTITIES[e]||e.match(/;$/)&&ENTITIES[ee];if(typeof target==="number"){return String.fromCharCode(target)}else if(typeof target==="string"){return target}else{return m}});return new this.constructor(s)},endsWith:function(){var suffixes=Array.prototype.slice.call(arguments,0);for(var i=0;i<suffixes.length;++i){var l=this.s.length-suffixes[i].length;if(l>=0&&this.s.indexOf(suffixes[i],l)===l)return true}return false},escapeHTML:function(){return new this.constructor(this.s.replace(/[&<>"']/g,function(m){return"&"+reversedEscapeChars[m]+";"}))},ensureLeft:function(prefix){var s=this.s;if(s.indexOf(prefix)===0){return this}else{return new this.constructor(prefix+s)}},ensureRight:function(suffix){var s=this.s;if(this.endsWith(suffix)){return this}else{return new this.constructor(s+suffix)}},humanize:function(){if(this.s===null||this.s===undefined)return new this.constructor("");var s=this.underscore().replace(/_id$/,"").replace(/_/g," ").trim().capitalize();return new this.constructor(s)},isAlpha:function(){return!/[^a-z\xDF-\xFF]|^$/.test(this.s.toLowerCase())},isAlphaNumeric:function(){return!/[^0-9a-z\xDF-\xFF]/.test(this.s.toLowerCase())},isEmpty:function(){return this.s===null||this.s===undefined?true:/^[\s\xa0]*$/.test(this.s)},isLower:function(){return this.isAlpha()&&this.s.toLowerCase()===this.s},isNumeric:function(){return!/[^0-9]/.test(this.s)},isUpper:function(){return this.isAlpha()&&this.s.toUpperCase()===this.s},left:function(N){if(N>=0){var s=this.s.substr(0,N);return new this.constructor(s)}else{return this.right(-N)}},lines:function(){return this.replaceAll("\r\n","\n").s.split("\n")},pad:function(len,ch){if(ch==null)ch=" ";if(this.s.length>=len)return new this.constructor(this.s);len=len-this.s.length;var left=Array(Math.ceil(len/2)+1).join(ch);var right=Array(Math.floor(len/2)+1).join(ch);return new this.constructor(left+this.s+right)},padLeft:function(len,ch){if(ch==null)ch=" ";if(this.s.length>=len)return new this.constructor(this.s);return new this.constructor(Array(len-this.s.length+1).join(ch)+this.s)},padRight:function(len,ch){if(ch==null)ch=" ";if(this.s.length>=len)return new this.constructor(this.s);return new this.constructor(this.s+Array(len-this.s.length+1).join(ch))},parseCSV:function(delimiter,qualifier,escape,lineDelimiter){delimiter=delimiter||",";escape=escape||"\\";if(typeof qualifier=="undefined")qualifier='"';var i=0,fieldBuffer=[],fields=[],len=this.s.length,inField=false,inUnqualifiedString=false,self=this;var ca=function(i){return self.s.charAt(i)};if(typeof lineDelimiter!=="undefined")var rows=[];if(!qualifier)inField=true;while(i<len){var current=ca(i);switch(current){case escape:if(inField&&(escape!==qualifier||ca(i+1)===qualifier)){i+=1;fieldBuffer.push(ca(i));break}if(escape!==qualifier)break;case qualifier:inField=!inField;break;case delimiter:if(inUnqualifiedString){inField=false;inUnqualifiedString=false}if(inField&&qualifier)fieldBuffer.push(current);else{fields.push(fieldBuffer.join(""));fieldBuffer.length=0}break;case lineDelimiter:if(inUnqualifiedString){inField=false;inUnqualifiedString=false;fields.push(fieldBuffer.join(""));rows.push(fields);fields=[];fieldBuffer.length=0}else if(inField){fieldBuffer.push(current)}else{if(rows){fields.push(fieldBuffer.join(""));rows.push(fields);fields=[];fieldBuffer.length=0}}break;case" ":if(inField)fieldBuffer.push(current);break;default:if(inField)fieldBuffer.push(current);else if(current!==qualifier){fieldBuffer.push(current);inField=true;inUnqualifiedString=true}break}i+=1}fields.push(fieldBuffer.join(""));if(rows){rows.push(fields);return rows}return fields},replaceAll:function(ss,r){var s=this.s.split(ss).join(r);return new this.constructor(s)},splitLeft:function(sep,maxSplit,limit){return _dereq_("./_splitLeft")(this.s,sep,maxSplit,limit)},splitRight:function(sep,maxSplit,limit){return _dereq_("./_splitRight")(this.s,sep,maxSplit,limit)},strip:function(){var ss=this.s;for(var i=0,n=arguments.length;i<n;i++){ss=ss.split(arguments[i]).join("")}return new this.constructor(ss)},stripLeft:function(chars){var regex;var pattern;var ss=ensureString(this.s);if(chars===undefined){pattern=/^\s+/g}else{regex=escapeRegExp(chars);pattern=new RegExp("^["+regex+"]+","g")}return new this.constructor(ss.replace(pattern,""))},stripRight:function(chars){var regex;var pattern;var ss=ensureString(this.s);if(chars===undefined){pattern=/\s+$/g}else{regex=escapeRegExp(chars);pattern=new RegExp("["+regex+"]+$","g")}return new this.constructor(ss.replace(pattern,""))},right:function(N){if(N>=0){var s=this.s.substr(this.s.length-N,N);return new this.constructor(s)}else{return this.left(-N)}},setValue:function(s){initialize(this,s);return this},slugify:function(){var sl=new S(new S(this.s).latinise().s.replace(/[^\w\s-]/g,"").toLowerCase()).dasherize().s;if(sl.charAt(0)==="-")sl=sl.substr(1);return new this.constructor(sl)},startsWith:function(){var prefixes=Array.prototype.slice.call(arguments,0);for(var i=0;i<prefixes.length;++i){if(this.s.lastIndexOf(prefixes[i],0)===0)return true}return false},stripPunctuation:function(){return new this.constructor(this.s.replace(/[^\w\s]|_/g,"").replace(/\s+/g," "))},stripTags:function(){var s=this.s,args=arguments.length>0?arguments:[""];multiArgs(args,function(tag){s=s.replace(RegExp("</?"+tag+"[^<>]*>","gi"),"")});return new this.constructor(s)},template:function(values,opening,closing){var s=this.s;var opening=opening||Export.TMPL_OPEN;var closing=closing||Export.TMPL_CLOSE;var open=opening.replace(/[-[\]()*\s]/g,"\\$&").replace(/\$/g,"\\$");var close=closing.replace(/[-[\]()*\s]/g,"\\$&").replace(/\$/g,"\\$");var r=new RegExp(open+"(.+?)"+close,"g");var matches=s.match(r)||[];matches.forEach(function(match){var key=match.substring(opening.length,match.length-closing.length).trim();var value=typeof values[key]=="undefined"?"":values[key];s=s.replace(match,value)});return new this.constructor(s)},times:function(n){return new this.constructor(new Array(n+1).join(this.s))},titleCase:function(){var s=this.s;if(s){s=s.replace(/(^[a-z]| [a-z]|-[a-z]|_[a-z])/g,function($1){return $1.toUpperCase()})}return new this.constructor(s)},toBoolean:function(){if(typeof this.orig==="string"){var s=this.s.toLowerCase();return s==="true"||s==="yes"||s==="on"||s==="1"}else return this.orig===true||this.orig===1},toFloat:function(precision){var num=parseFloat(this.s);if(precision)return parseFloat(num.toFixed(precision));else return num},toInt:function(){return/^\s*-?0x/i.test(this.s)?parseInt(this.s,16):parseInt(this.s,10)},trim:function(){var s;if(typeof __nsp.trim==="undefined")s=this.s.replace(/(^\s*|\s*$)/g,"");else s=this.s.trim();return new this.constructor(s)},trimLeft:function(){var s;if(__nsp.trimLeft)s=this.s.trimLeft();else s=this.s.replace(/(^\s*)/g,"");return new this.constructor(s)},trimRight:function(){var s;if(__nsp.trimRight)s=this.s.trimRight();else s=this.s.replace(/\s+$/,"");return new this.constructor(s)},truncate:function(length,pruneStr){var str=this.s;length=~~length;pruneStr=pruneStr||"...";if(str.length<=length)return new this.constructor(str);var tmpl=function(c){return c.toUpperCase()!==c.toLowerCase()?"A":" "},template=str.slice(0,length+1).replace(/.(?=\W*\w*$)/g,tmpl);if(template.slice(template.length-2).match(/\w\w/))template=template.replace(/\s*\S+$/,"");else template=new S(template.slice(0,template.length-1)).trimRight().s;return(template+pruneStr).length>str.length?new S(str):new S(str.slice(0,template.length)+pruneStr)},toCSV:function(){var delim=",",qualifier='"',escape="\\",encloseNumbers=true,keys=false;var dataArray=[];function hasVal(it){return it!==null&&it!==""}if(typeof arguments[0]==="object"){delim=arguments[0].delimiter||delim;delim=arguments[0].separator||delim;qualifier=arguments[0].qualifier||qualifier;encloseNumbers=!!arguments[0].encloseNumbers;escape=arguments[0].escape||escape;keys=!!arguments[0].keys}else if(typeof arguments[0]==="string"){delim=arguments[0]}if(typeof arguments[1]==="string")qualifier=arguments[1];if(arguments[1]===null)qualifier=null;if(this.orig instanceof Array)dataArray=this.orig;else{for(var key in this.orig)if(this.orig.hasOwnProperty(key))if(keys)dataArray.push(key);else dataArray.push(this.orig[key])}var rep=escape+qualifier;var buildString=[];for(var i=0;i<dataArray.length;++i){var shouldQualify=hasVal(qualifier);if(typeof dataArray[i]=="number")shouldQualify&=encloseNumbers;if(shouldQualify)buildString.push(qualifier);if(dataArray[i]!==null&&dataArray[i]!==undefined){var d=new S(dataArray[i]).replaceAll(qualifier,rep).s;buildString.push(d)}else buildString.push("");if(shouldQualify)buildString.push(qualifier);if(delim)buildString.push(delim)}buildString.length=buildString.length-1;return new this.constructor(buildString.join(""))},toString:function(){return this.s},underscore:function(){var s=this.trim().s.replace(/([a-z\d])([A-Z]+)/g,"$1_$2").replace(/([A-Z\d]+)([A-Z][a-z])/g,"$1_$2").replace(/[-\s]+/g,"_").toLowerCase();return new this.constructor(s)},unescapeHTML:function(){return new this.constructor(this.s.replace(/\&([^;]+);/g,function(entity,entityCode){var match;if(entityCode in escapeChars){return escapeChars[entityCode]}else if(match=entityCode.match(/^#x([\da-fA-F]+)$/)){return String.fromCharCode(parseInt(match[1],16))}else if(match=entityCode.match(/^#(\d+)$/)){return String.fromCharCode(~~match[1])}else{return entity}}))},valueOf:function(){return this.s.valueOf()},wrapHTML:function(tagName,tagAttrs){var s=this.s,el=tagName==null?"span":tagName,elAttr="",wrapped="";if(typeof tagAttrs=="object")for(var prop in tagAttrs)elAttr+=" "+prop+'="'+new this.constructor(tagAttrs[prop]).escapeHTML()+'"';s=wrapped.concat("<",el,elAttr,">",this,"</",el,">");return new this.constructor(s)}};var methodsAdded=[];function extendPrototype(){for(var name in __sp){(function(name){var func=__sp[name];if(!__nsp.hasOwnProperty(name)){methodsAdded.push(name);__nsp[name]=function(){String.prototype.s=this;return func.apply(this,arguments)}}})(name)}}function restorePrototype(){for(var i=0;i<methodsAdded.length;++i)delete String.prototype[methodsAdded[i]];methodsAdded.length=0}var nativeProperties=getNativeStringProperties();for(var name in nativeProperties){(function(name){var stringProp=__nsp[name];if(typeof stringProp=="function"){if(!__sp[name]){if(nativeProperties[name]==="string"){__sp[name]=function(){return new this.constructor(stringProp.apply(this,arguments))}}else{__sp[name]=stringProp}}}})(name)}__sp.repeat=__sp.times;__sp.include=__sp.contains;__sp.toInteger=__sp.toInt;__sp.toBool=__sp.toBoolean;__sp.decodeHTMLEntities=__sp.decodeHtmlEntities;__sp.constructor=S;function getNativeStringProperties(){var names=getNativeStringPropertyNames();var retObj={};for(var i=0;i<names.length;++i){var name=names[i];if(name==="to"||name==="toEnd")continue;var func=__nsp[name];try{var type=typeof func.apply("teststring");retObj[name]=type}catch(e){}}return retObj}function getNativeStringPropertyNames(){var results=[];if(Object.getOwnPropertyNames){results=Object.getOwnPropertyNames(__nsp);results.splice(results.indexOf("valueOf"),1);results.splice(results.indexOf("toString"),1);return results}else{var stringNames={};var objectNames=[];for(var name in String.prototype)stringNames[name]=name;for(var name in Object.prototype)delete stringNames[name];for(var name in stringNames){results.push(name)}return results}}function Export(str){return new S(str)}Export.extendPrototype=extendPrototype;Export.restorePrototype=restorePrototype;Export.VERSION=VERSION;Export.TMPL_OPEN="{{";Export.TMPL_CLOSE="}}";Export.ENTITIES=ENTITIES;if(typeof module!=="undefined"&&typeof module.exports!=="undefined"){module.exports=Export}else{if(typeof define==="function"&&define.amd){define([],function(){return Export})}else{window.S=Export}}function multiArgs(args,fn){var result=[],i;for(i=0;i<args.length;i++){result.push(args[i]);if(fn)fn.call(args,args[i],i)}return result}var escapeChars={lt:"<",gt:">",quot:'"',apos:"'",amp:"&"};function escapeRegExp(s){var c;var i;var ret=[];var re=/^[A-Za-z0-9]+$/;s=ensureString(s);for(i=0;i<s.length;++i){c=s.charAt(i);if(re.test(c)){ret.push(c)}else{if(c==="\\000"){ret.push("\\000")}else{ret.push("\\"+c)}}}return ret.join("")}function ensureString(string){return string==null?"":""+string}var reversedEscapeChars={};for(var key in escapeChars){reversedEscapeChars[escapeChars[key]]=key}ENTITIES={amp:"&",gt:">",lt:"<",quot:'"',apos:"'",AElig:198,Aacute:193,Acirc:194,Agrave:192,Aring:197,Atilde:195,Auml:196,Ccedil:199,ETH:208,Eacute:201,Ecirc:202,Egrave:200,Euml:203,Iacute:205,Icirc:206,Igrave:204,Iuml:207,Ntilde:209,Oacute:211,Ocirc:212,Ograve:210,Oslash:216,Otilde:213,Ouml:214,THORN:222,Uacute:218,Ucirc:219,Ugrave:217,Uuml:220,Yacute:221,aacute:225,acirc:226,aelig:230,agrave:224,aring:229,atilde:227,auml:228,ccedil:231,eacute:233,ecirc:234,egrave:232,eth:240,euml:235,iacute:237,icirc:238,igrave:236,iuml:239,ntilde:241,oacute:243,ocirc:244,ograve:242,oslash:248,otilde:245,ouml:246,szlig:223,thorn:254,uacute:250,ucirc:251,ugrave:249,uuml:252,yacute:253,yuml:255,copy:169,reg:174,nbsp:160,iexcl:161,cent:162,pound:163,curren:164,yen:165,brvbar:166,sect:167,uml:168,ordf:170,laquo:171,not:172,shy:173,macr:175,deg:176,plusmn:177,sup1:185,sup2:178,sup3:179,acute:180,micro:181,para:182,middot:183,cedil:184,ordm:186,raquo:187,frac14:188,frac12:189,frac34:190,iquest:191,times:215,divide:247,"OElig;":338,"oelig;":339,"Scaron;":352,"scaron;":353,"Yuml;":376,"fnof;":402,"circ;":710,"tilde;":732,"Alpha;":913,"Beta;":914,"Gamma;":915,"Delta;":916,"Epsilon;":917,"Zeta;":918,"Eta;":919,"Theta;":920,"Iota;":921,"Kappa;":922,"Lambda;":923,"Mu;":924,"Nu;":925,"Xi;":926,"Omicron;":927,"Pi;":928,"Rho;":929,"Sigma;":931,"Tau;":932,"Upsilon;":933,"Phi;":934,"Chi;":935,"Psi;":936,"Omega;":937,"alpha;":945,"beta;":946,"gamma;":947,"delta;":948,"epsilon;":949,"zeta;":950,"eta;":951,"theta;":952,"iota;":953,"kappa;":954,"lambda;":955,"mu;":956,"nu;":957,"xi;":958,"omicron;":959,"pi;":960,"rho;":961,"sigmaf;":962,"sigma;":963,"tau;":964,"upsilon;":965,"phi;":966,"chi;":967,"psi;":968,"omega;":969,"thetasym;":977,"upsih;":978,"piv;":982,"ensp;":8194,"emsp;":8195,"thinsp;":8201,"zwnj;":8204,"zwj;":8205,"lrm;":8206,"rlm;":8207,"ndash;":8211,"mdash;":8212,"lsquo;":8216,"rsquo;":8217,"sbquo;":8218,"ldquo;":8220,"rdquo;":8221,"bdquo;":8222,"dagger;":8224,"Dagger;":8225,"bull;":8226,"hellip;":8230,"permil;":8240,"prime;":8242,"Prime;":8243,"lsaquo;":8249,"rsaquo;":8250,"oline;":8254,"frasl;":8260,"euro;":8364,"image;":8465,"weierp;":8472,"real;":8476,"trade;":8482,"alefsym;":8501,"larr;":8592,"uarr;":8593,"rarr;":8594,"darr;":8595,"harr;":8596,"crarr;":8629,"lArr;":8656,"uArr;":8657,"rArr;":8658,"dArr;":8659,"hArr;":8660,"forall;":8704,"part;":8706,"exist;":8707,"empty;":8709,"nabla;":8711,"isin;":8712,"notin;":8713,"ni;":8715,"prod;":8719,"sum;":8721,"minus;":8722,"lowast;":8727,"radic;":8730,"prop;":8733,"infin;":8734,"ang;":8736,"and;":8743,"or;":8744,"cap;":8745,"cup;":8746,"int;":8747,"there4;":8756,"sim;":8764,"cong;":8773,"asymp;":8776,"ne;":8800,"equiv;":8801,"le;":8804,"ge;":8805,"sub;":8834,"sup;":8835,"nsub;":8836,"sube;":8838,"supe;":8839,"oplus;":8853,"otimes;":8855,"perp;":8869,"sdot;":8901,"lceil;":8968,"rceil;":8969,"lfloor;":8970,"rfloor;":8971,"lang;":9001,"rang;":9002,"loz;":9674,"spades;":9824,"clubs;":9827,"hearts;":9829,"diams;":9830}}.call(this)},{"./_count":1,"./_splitLeft":2,"./_splitRight":3}]},{},[4])(4)});

/**
 * @license
 * toolkit <https://toolkit.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://toolkit.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(){function n(n,t,r){switch(r.length){case 0:return n.call(t);case 1:return n.call(t,r[0]);case 2:return n.call(t,r[0],r[1]);case 3:return n.call(t,r[0],r[1],r[2])}return n.apply(t,r)}function t(n,t,r,e){for(var u=-1,i=null==n?0:n.length;++u<i;){var o=n[u];t(e,o,r(o),n)}return e}function r(n,t){for(var r=-1,e=null==n?0:n.length;++r<e&&t(n[r],r,n)!==!1;);return n}function e(n,t){for(var r=null==n?0:n.length;r--&&t(n[r],r,n)!==!1;);return n}function u(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(!t(n[r],r,n))return!1;
  return!0}function i(n,t){for(var r=-1,e=null==n?0:n.length,u=0,i=[];++r<e;){var o=n[r];t(o,r,n)&&(i[u++]=o)}return i}function o(n,t){return!!(null==n?0:n.length)&&y(n,t,0)>-1}function f(n,t,r){for(var e=-1,u=null==n?0:n.length;++e<u;)if(r(t,n[e]))return!0;return!1}function c(n,t){for(var r=-1,e=null==n?0:n.length,u=Array(e);++r<e;)u[r]=t(n[r],r,n);return u}function a(n,t){for(var r=-1,e=t.length,u=n.length;++r<e;)n[u+r]=t[r];return n}function l(n,t,r,e){var u=-1,i=null==n?0:n.length;for(e&&i&&(r=n[++u]);++u<i;)r=t(r,n[u],u,n);
  return r}function s(n,t,r,e){var u=null==n?0:n.length;for(e&&u&&(r=n[--u]);u--;)r=t(r,n[u],u,n);return r}function h(n,t){for(var r=-1,e=null==n?0:n.length;++r<e;)if(t(n[r],r,n))return!0;return!1}function p(n){return n.split("")}function _(n){return n.match($t)||[]}function v(n,t,r){var e;return r(n,function(n,r,u){if(t(n,r,u))return e=r,!1}),e}function g(n,t,r,e){for(var u=n.length,i=r+(e?1:-1);e?i--:++i<u;)if(t(n[i],i,n))return i;return-1}function y(n,t,r){return t===t?Z(n,t,r):g(n,b,r)}function d(n,t,r,e){
  for(var u=r-1,i=n.length;++u<i;)if(e(n[u],t))return u;return-1}function b(n){return n!==n}function w(n,t){var r=null==n?0:n.length;return r?k(n,t)/r:Cn}function m(n){return function(t){return null==t?X:t[n]}}function x(n){return function(t){return null==n?X:n[t]}}function j(n,t,r,e,u){return u(n,function(n,u,i){r=e?(e=!1,n):t(r,n,u,i)}),r}function A(n,t){var r=n.length;for(n.sort(t);r--;)n[r]=n[r].value;return n}function k(n,t){for(var r,e=-1,u=n.length;++e<u;){var i=t(n[e]);i!==X&&(r=r===X?i:r+i);
  }return r}function O(n,t){for(var r=-1,e=Array(n);++r<n;)e[r]=t(r);return e}function I(n,t){return c(t,function(t){return[t,n[t]]})}function R(n){return n?n.slice(0,H(n)+1).replace(Lt,""):n}function z(n){return function(t){return n(t)}}function E(n,t){return c(t,function(t){return n[t]})}function S(n,t){return n.has(t)}function W(n,t){for(var r=-1,e=n.length;++r<e&&y(t,n[r],0)>-1;);return r}function L(n,t){for(var r=n.length;r--&&y(t,n[r],0)>-1;);return r}function C(n,t){for(var r=n.length,e=0;r--;)n[r]===t&&++e;
  return e}function U(n){return"\\"+Yr[n]}function B(n,t){return null==n?X:n[t]}function T(n){return Nr.test(n)}function $(n){return Pr.test(n)}function D(n){for(var t,r=[];!(t=n.next()).done;)r.push(t.value);return r}function M(n){var t=-1,r=Array(n.size);return n.forEach(function(n,e){r[++t]=[e,n]}),r}function F(n,t){return function(r){return n(t(r))}}function N(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){var o=n[r];o!==t&&o!==cn||(n[r]=cn,i[u++]=r)}return i}function P(n){var t=-1,r=Array(n.size);
  return n.forEach(function(n){r[++t]=n}),r}function q(n){var t=-1,r=Array(n.size);return n.forEach(function(n){r[++t]=[n,n]}),r}function Z(n,t,r){for(var e=r-1,u=n.length;++e<u;)if(n[e]===t)return e;return-1}function K(n,t,r){for(var e=r+1;e--;)if(n[e]===t)return e;return e}function V(n){return T(n)?J(n):_e(n)}function G(n){return T(n)?Y(n):p(n)}function H(n){for(var t=n.length;t--&&Ct.test(n.charAt(t)););return t}function J(n){for(var t=Mr.lastIndex=0;Mr.test(n);)++t;return t}function Y(n){return n.match(Mr)||[];
  }function Q(n){return n.match(Fr)||[]}var X,nn="4.17.21",tn=200,rn="Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",en="Expected a function",un="Invalid `variable` option passed into `_.template`",on="__toolkit_hash_undefined__",fn=500,cn="__toolkit_placeholder__",an=1,ln=2,sn=4,hn=1,pn=2,_n=1,vn=2,gn=4,yn=8,dn=16,bn=32,wn=64,mn=128,xn=256,jn=512,An=30,kn="...",On=800,In=16,Rn=1,zn=2,En=3,Sn=1/0,Wn=9007199254740991,Ln=1.7976931348623157e308,Cn=NaN,Un=4294967295,Bn=Un-1,Tn=Un>>>1,$n=[["ary",mn],["bind",_n],["bindKey",vn],["curry",yn],["curryRight",dn],["flip",jn],["partial",bn],["partialRight",wn],["rearg",xn]],Dn="[object Arguments]",Mn="[object Array]",Fn="[object AsyncFunction]",Nn="[object Boolean]",Pn="[object Date]",qn="[object DOMException]",Zn="[object Error]",Kn="[object Function]",Vn="[object GeneratorFunction]",Gn="[object Map]",Hn="[object Number]",Jn="[object Null]",Yn="[object Object]",Qn="[object Promise]",Xn="[object Proxy]",nt="[object RegExp]",tt="[object Set]",rt="[object String]",et="[object Symbol]",ut="[object Undefined]",it="[object WeakMap]",ot="[object WeakSet]",ft="[object ArrayBuffer]",ct="[object DataView]",at="[object Float32Array]",lt="[object Float64Array]",st="[object Int8Array]",ht="[object Int16Array]",pt="[object Int32Array]",_t="[object Uint8Array]",vt="[object Uint8ClampedArray]",gt="[object Uint16Array]",yt="[object Uint32Array]",dt=/\b__p \+= '';/g,bt=/\b(__p \+=) '' \+/g,wt=/(__e\(.*?\)|\b__t\)) \+\n'';/g,mt=/&(?:amp|lt|gt|quot|#39);/g,xt=/[&<>"']/g,jt=RegExp(mt.source),At=RegExp(xt.source),kt=/<%-([\s\S]+?)%>/g,Ot=/<%([\s\S]+?)%>/g,It=/<%=([\s\S]+?)%>/g,Rt=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,zt=/^\w*$/,Et=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,St=/[\\^$.*+?()[\]{}|]/g,Wt=RegExp(St.source),Lt=/^\s+/,Ct=/\s/,Ut=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,Bt=/\{\n\/\* \[wrapped with (.+)\] \*/,Tt=/,? & /,$t=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,Dt=/[()=,{}\[\]\/\s]/,Mt=/\\(\\)?/g,Ft=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,Nt=/\w*$/,Pt=/^[-+]0x[0-9a-f]+$/i,qt=/^0b[01]+$/i,Zt=/^\[object .+?Constructor\]$/,Kt=/^0o[0-7]+$/i,Vt=/^(?:0|[1-9]\d*)$/,Gt=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,Ht=/($^)/,Jt=/['\n\r\u2028\u2029\\]/g,Yt="\\ud800-\\udfff",Qt="\\u0300-\\u036f",Xt="\\ufe20-\\ufe2f",nr="\\u20d0-\\u20ff",tr=Qt+Xt+nr,rr="\\u2700-\\u27bf",er="a-z\\xdf-\\xf6\\xf8-\\xff",ur="\\xac\\xb1\\xd7\\xf7",ir="\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",or="\\u2000-\\u206f",fr=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",cr="A-Z\\xc0-\\xd6\\xd8-\\xde",ar="\\ufe0e\\ufe0f",lr=ur+ir+or+fr,sr="['\u2019]",hr="["+Yt+"]",pr="["+lr+"]",_r="["+tr+"]",vr="\\d+",gr="["+rr+"]",yr="["+er+"]",dr="[^"+Yt+lr+vr+rr+er+cr+"]",br="\\ud83c[\\udffb-\\udfff]",wr="(?:"+_r+"|"+br+")",mr="[^"+Yt+"]",xr="(?:\\ud83c[\\udde6-\\uddff]){2}",jr="[\\ud800-\\udbff][\\udc00-\\udfff]",Ar="["+cr+"]",kr="\\u200d",Or="(?:"+yr+"|"+dr+")",Ir="(?:"+Ar+"|"+dr+")",Rr="(?:"+sr+"(?:d|ll|m|re|s|t|ve))?",zr="(?:"+sr+"(?:D|LL|M|RE|S|T|VE))?",Er=wr+"?",Sr="["+ar+"]?",Wr="(?:"+kr+"(?:"+[mr,xr,jr].join("|")+")"+Sr+Er+")*",Lr="\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",Cr="\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",Ur=Sr+Er+Wr,Br="(?:"+[gr,xr,jr].join("|")+")"+Ur,Tr="(?:"+[mr+_r+"?",_r,xr,jr,hr].join("|")+")",$r=RegExp(sr,"g"),Dr=RegExp(_r,"g"),Mr=RegExp(br+"(?="+br+")|"+Tr+Ur,"g"),Fr=RegExp([Ar+"?"+yr+"+"+Rr+"(?="+[pr,Ar,"$"].join("|")+")",Ir+"+"+zr+"(?="+[pr,Ar+Or,"$"].join("|")+")",Ar+"?"+Or+"+"+Rr,Ar+"+"+zr,Cr,Lr,vr,Br].join("|"),"g"),Nr=RegExp("["+kr+Yt+tr+ar+"]"),Pr=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,qr=["Array","Buffer","DataView","Date","Error","Float32Array","Float64Array","Function","Int8Array","Int16Array","Int32Array","Map","Math","Object","Promise","RegExp","Set","String","Symbol","TypeError","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","WeakMap","_","clearTimeout","isFinite","parseInt","setTimeout"],Zr=-1,Kr={};
  Kr[at]=Kr[lt]=Kr[st]=Kr[ht]=Kr[pt]=Kr[_t]=Kr[vt]=Kr[gt]=Kr[yt]=!0,Kr[Dn]=Kr[Mn]=Kr[ft]=Kr[Nn]=Kr[ct]=Kr[Pn]=Kr[Zn]=Kr[Kn]=Kr[Gn]=Kr[Hn]=Kr[Yn]=Kr[nt]=Kr[tt]=Kr[rt]=Kr[it]=!1;var Vr={};Vr[Dn]=Vr[Mn]=Vr[ft]=Vr[ct]=Vr[Nn]=Vr[Pn]=Vr[at]=Vr[lt]=Vr[st]=Vr[ht]=Vr[pt]=Vr[Gn]=Vr[Hn]=Vr[Yn]=Vr[nt]=Vr[tt]=Vr[rt]=Vr[et]=Vr[_t]=Vr[vt]=Vr[gt]=Vr[yt]=!0,Vr[Zn]=Vr[Kn]=Vr[it]=!1;var Gr={"\xc0":"A","\xc1":"A","\xc2":"A","\xc3":"A","\xc4":"A","\xc5":"A","\xe0":"a","\xe1":"a","\xe2":"a","\xe3":"a","\xe4":"a","\xe5":"a",
  "\xc7":"C","\xe7":"c","\xd0":"D","\xf0":"d","\xc8":"E","\xc9":"E","\xca":"E","\xcb":"E","\xe8":"e","\xe9":"e","\xea":"e","\xeb":"e","\xcc":"I","\xcd":"I","\xce":"I","\xcf":"I","\xec":"i","\xed":"i","\xee":"i","\xef":"i","\xd1":"N","\xf1":"n","\xd2":"O","\xd3":"O","\xd4":"O","\xd5":"O","\xd6":"O","\xd8":"O","\xf2":"o","\xf3":"o","\xf4":"o","\xf5":"o","\xf6":"o","\xf8":"o","\xd9":"U","\xda":"U","\xdb":"U","\xdc":"U","\xf9":"u","\xfa":"u","\xfb":"u","\xfc":"u","\xdd":"Y","\xfd":"y","\xff":"y","\xc6":"Ae",
  "\xe6":"ae","\xde":"Th","\xfe":"th","\xdf":"ss","\u0100":"A","\u0102":"A","\u0104":"A","\u0101":"a","\u0103":"a","\u0105":"a","\u0106":"C","\u0108":"C","\u010a":"C","\u010c":"C","\u0107":"c","\u0109":"c","\u010b":"c","\u010d":"c","\u010e":"D","\u0110":"D","\u010f":"d","\u0111":"d","\u0112":"E","\u0114":"E","\u0116":"E","\u0118":"E","\u011a":"E","\u0113":"e","\u0115":"e","\u0117":"e","\u0119":"e","\u011b":"e","\u011c":"G","\u011e":"G","\u0120":"G","\u0122":"G","\u011d":"g","\u011f":"g","\u0121":"g",
  "\u0123":"g","\u0124":"H","\u0126":"H","\u0125":"h","\u0127":"h","\u0128":"I","\u012a":"I","\u012c":"I","\u012e":"I","\u0130":"I","\u0129":"i","\u012b":"i","\u012d":"i","\u012f":"i","\u0131":"i","\u0134":"J","\u0135":"j","\u0136":"K","\u0137":"k","\u0138":"k","\u0139":"L","\u013b":"L","\u013d":"L","\u013f":"L","\u0141":"L","\u013a":"l","\u013c":"l","\u013e":"l","\u0140":"l","\u0142":"l","\u0143":"N","\u0145":"N","\u0147":"N","\u014a":"N","\u0144":"n","\u0146":"n","\u0148":"n","\u014b":"n","\u014c":"O",
  "\u014e":"O","\u0150":"O","\u014d":"o","\u014f":"o","\u0151":"o","\u0154":"R","\u0156":"R","\u0158":"R","\u0155":"r","\u0157":"r","\u0159":"r","\u015a":"S","\u015c":"S","\u015e":"S","\u0160":"S","\u015b":"s","\u015d":"s","\u015f":"s","\u0161":"s","\u0162":"T","\u0164":"T","\u0166":"T","\u0163":"t","\u0165":"t","\u0167":"t","\u0168":"U","\u016a":"U","\u016c":"U","\u016e":"U","\u0170":"U","\u0172":"U","\u0169":"u","\u016b":"u","\u016d":"u","\u016f":"u","\u0171":"u","\u0173":"u","\u0174":"W","\u0175":"w",
  "\u0176":"Y","\u0177":"y","\u0178":"Y","\u0179":"Z","\u017b":"Z","\u017d":"Z","\u017a":"z","\u017c":"z","\u017e":"z","\u0132":"IJ","\u0133":"ij","\u0152":"Oe","\u0153":"oe","\u0149":"'n","\u017f":"s"},Hr={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},Jr={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"',"&#39;":"'"},Yr={"\\":"\\","'":"'","\n":"n","\r":"r","\u2028":"u2028","\u2029":"u2029"},Qr=parseFloat,Xr=parseInt,ne="object"==typeof global&&global&&global.Object===Object&&global,te="object"==typeof self&&self&&self.Object===Object&&self,re=ne||te||Function("return this")(),ee="object"==typeof exports&&exports&&!exports.nodeType&&exports,ue=ee&&"object"==typeof module&&module&&!module.nodeType&&module,ie=ue&&ue.exports===ee,oe=ie&&ne.process,fe=function(){
  try{var n=ue&&ue.require&&ue.require("util").types;return n?n:oe&&oe.binding&&oe.binding("util")}catch(n){}}(),ce=fe&&fe.isArrayBuffer,ae=fe&&fe.isDate,le=fe&&fe.isMap,se=fe&&fe.isRegExp,he=fe&&fe.isSet,pe=fe&&fe.isTypedArray,_e=m("length"),ve=x(Gr),ge=x(Hr),ye=x(Jr),de=function p(x){function Z(n){if(cc(n)&&!bh(n)&&!(n instanceof Ct)){if(n instanceof Y)return n;if(bl.call(n,"__wrapped__"))return eo(n)}return new Y(n)}function J(){}function Y(n,t){this.__wrapped__=n,this.__actions__=[],this.__chain__=!!t,
  this.__index__=0,this.__values__=X}function Ct(n){this.__wrapped__=n,this.__actions__=[],this.__dir__=1,this.__filtered__=!1,this.__iteratees__=[],this.__takeCount__=Un,this.__views__=[]}function $t(){var n=new Ct(this.__wrapped__);return n.__actions__=Tu(this.__actions__),n.__dir__=this.__dir__,n.__filtered__=this.__filtered__,n.__iteratees__=Tu(this.__iteratees__),n.__takeCount__=this.__takeCount__,n.__views__=Tu(this.__views__),n}function Yt(){if(this.__filtered__){var n=new Ct(this);n.__dir__=-1,
  n.__filtered__=!0}else n=this.clone(),n.__dir__*=-1;return n}function Qt(){var n=this.__wrapped__.value(),t=this.__dir__,r=bh(n),e=t<0,u=r?n.length:0,i=Oi(0,u,this.__views__),o=i.start,f=i.end,c=f-o,a=e?f:o-1,l=this.__iteratees__,s=l.length,h=0,p=Hl(c,this.__takeCount__);if(!r||!e&&u==c&&p==c)return wu(n,this.__actions__);var _=[];n:for(;c--&&h<p;){a+=t;for(var v=-1,g=n[a];++v<s;){var y=l[v],d=y.iteratee,b=y.type,w=d(g);if(b==zn)g=w;else if(!w){if(b==Rn)continue n;break n}}_[h++]=g}return _}function Xt(n){
  var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function nr(){this.__data__=is?is(null):{},this.size=0}function tr(n){var t=this.has(n)&&delete this.__data__[n];return this.size-=t?1:0,t}function rr(n){var t=this.__data__;if(is){var r=t[n];return r===on?X:r}return bl.call(t,n)?t[n]:X}function er(n){var t=this.__data__;return is?t[n]!==X:bl.call(t,n)}function ur(n,t){var r=this.__data__;return this.size+=this.has(n)?0:1,r[n]=is&&t===X?on:t,this}function ir(n){
  var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){var e=n[t];this.set(e[0],e[1])}}function or(){this.__data__=[],this.size=0}function fr(n){var t=this.__data__,r=Wr(t,n);return!(r<0)&&(r==t.length-1?t.pop():Ll.call(t,r,1),--this.size,!0)}function cr(n){var t=this.__data__,r=Wr(t,n);return r<0?X:t[r][1]}function ar(n){return Wr(this.__data__,n)>-1}function lr(n,t){var r=this.__data__,e=Wr(r,n);return e<0?(++this.size,r.push([n,t])):r[e][1]=t,this}function sr(n){var t=-1,r=null==n?0:n.length;for(this.clear();++t<r;){
  var e=n[t];this.set(e[0],e[1])}}function hr(){this.size=0,this.__data__={hash:new Xt,map:new(ts||ir),string:new Xt}}function pr(n){var t=xi(this,n).delete(n);return this.size-=t?1:0,t}function _r(n){return xi(this,n).get(n)}function vr(n){return xi(this,n).has(n)}function gr(n,t){var r=xi(this,n),e=r.size;return r.set(n,t),this.size+=r.size==e?0:1,this}function yr(n){var t=-1,r=null==n?0:n.length;for(this.__data__=new sr;++t<r;)this.add(n[t])}function dr(n){return this.__data__.set(n,on),this}function br(n){
  return this.__data__.has(n)}function wr(n){this.size=(this.__data__=new ir(n)).size}function mr(){this.__data__=new ir,this.size=0}function xr(n){var t=this.__data__,r=t.delete(n);return this.size=t.size,r}function jr(n){return this.__data__.get(n)}function Ar(n){return this.__data__.has(n)}function kr(n,t){var r=this.__data__;if(r instanceof ir){var e=r.__data__;if(!ts||e.length<tn-1)return e.push([n,t]),this.size=++r.size,this;r=this.__data__=new sr(e)}return r.set(n,t),this.size=r.size,this}function Or(n,t){
  var r=bh(n),e=!r&&dh(n),u=!r&&!e&&mh(n),i=!r&&!e&&!u&&Oh(n),o=r||e||u||i,f=o?O(n.length,hl):[],c=f.length;for(var a in n)!t&&!bl.call(n,a)||o&&("length"==a||u&&("offset"==a||"parent"==a)||i&&("buffer"==a||"byteLength"==a||"byteOffset"==a)||Ci(a,c))||f.push(a);return f}function Ir(n){var t=n.length;return t?n[tu(0,t-1)]:X}function Rr(n,t){return Xi(Tu(n),Mr(t,0,n.length))}function zr(n){return Xi(Tu(n))}function Er(n,t,r){(r===X||Gf(n[t],r))&&(r!==X||t in n)||Br(n,t,r)}function Sr(n,t,r){var e=n[t];
  bl.call(n,t)&&Gf(e,r)&&(r!==X||t in n)||Br(n,t,r)}function Wr(n,t){for(var r=n.length;r--;)if(Gf(n[r][0],t))return r;return-1}function Lr(n,t,r,e){return ys(n,function(n,u,i){t(e,n,r(n),i)}),e}function Cr(n,t){return n&&$u(t,Pc(t),n)}function Ur(n,t){return n&&$u(t,qc(t),n)}function Br(n,t,r){"__proto__"==t&&Tl?Tl(n,t,{configurable:!0,enumerable:!0,value:r,writable:!0}):n[t]=r}function Tr(n,t){for(var r=-1,e=t.length,u=il(e),i=null==n;++r<e;)u[r]=i?X:Mc(n,t[r]);return u}function Mr(n,t,r){return n===n&&(r!==X&&(n=n<=r?n:r),
  t!==X&&(n=n>=t?n:t)),n}function Fr(n,t,e,u,i,o){var f,c=t&an,a=t&ln,l=t&sn;if(e&&(f=i?e(n,u,i,o):e(n)),f!==X)return f;if(!fc(n))return n;var s=bh(n);if(s){if(f=zi(n),!c)return Tu(n,f)}else{var h=zs(n),p=h==Kn||h==Vn;if(mh(n))return Iu(n,c);if(h==Yn||h==Dn||p&&!i){if(f=a||p?{}:Ei(n),!c)return a?Mu(n,Ur(f,n)):Du(n,Cr(f,n))}else{if(!Vr[h])return i?n:{};f=Si(n,h,c)}}o||(o=new wr);var _=o.get(n);if(_)return _;o.set(n,f),kh(n)?n.forEach(function(r){f.add(Fr(r,t,e,r,n,o))}):jh(n)&&n.forEach(function(r,u){
  f.set(u,Fr(r,t,e,u,n,o))});var v=l?a?di:yi:a?qc:Pc,g=s?X:v(n);return r(g||n,function(r,u){g&&(u=r,r=n[u]),Sr(f,u,Fr(r,t,e,u,n,o))}),f}function Nr(n){var t=Pc(n);return function(r){return Pr(r,n,t)}}function Pr(n,t,r){var e=r.length;if(null==n)return!e;for(n=ll(n);e--;){var u=r[e],i=t[u],o=n[u];if(o===X&&!(u in n)||!i(o))return!1}return!0}function Gr(n,t,r){if("function"!=typeof n)throw new pl(en);return Ws(function(){n.apply(X,r)},t)}function Hr(n,t,r,e){var u=-1,i=o,a=!0,l=n.length,s=[],h=t.length;
  if(!l)return s;r&&(t=c(t,z(r))),e?(i=f,a=!1):t.length>=tn&&(i=S,a=!1,t=new yr(t));n:for(;++u<l;){var p=n[u],_=null==r?p:r(p);if(p=e||0!==p?p:0,a&&_===_){for(var v=h;v--;)if(t[v]===_)continue n;s.push(p)}else i(t,_,e)||s.push(p)}return s}function Jr(n,t){var r=!0;return ys(n,function(n,e,u){return r=!!t(n,e,u)}),r}function Yr(n,t,r){for(var e=-1,u=n.length;++e<u;){var i=n[e],o=t(i);if(null!=o&&(f===X?o===o&&!bc(o):r(o,f)))var f=o,c=i}return c}function ne(n,t,r,e){var u=n.length;for(r=kc(r),r<0&&(r=-r>u?0:u+r),
  e=e===X||e>u?u:kc(e),e<0&&(e+=u),e=r>e?0:Oc(e);r<e;)n[r++]=t;return n}function te(n,t){var r=[];return ys(n,function(n,e,u){t(n,e,u)&&r.push(n)}),r}function ee(n,t,r,e,u){var i=-1,o=n.length;for(r||(r=Li),u||(u=[]);++i<o;){var f=n[i];t>0&&r(f)?t>1?ee(f,t-1,r,e,u):a(u,f):e||(u[u.length]=f)}return u}function ue(n,t){return n&&bs(n,t,Pc)}function oe(n,t){return n&&ws(n,t,Pc)}function fe(n,t){return i(t,function(t){return uc(n[t])})}function _e(n,t){t=ku(t,n);for(var r=0,e=t.length;null!=n&&r<e;)n=n[no(t[r++])];
  return r&&r==e?n:X}function de(n,t,r){var e=t(n);return bh(n)?e:a(e,r(n))}function we(n){return null==n?n===X?ut:Jn:Bl&&Bl in ll(n)?ki(n):Ki(n)}function me(n,t){return n>t}function xe(n,t){return null!=n&&bl.call(n,t)}function je(n,t){return null!=n&&t in ll(n)}function Ae(n,t,r){return n>=Hl(t,r)&&n<Gl(t,r)}function ke(n,t,r){for(var e=r?f:o,u=n[0].length,i=n.length,a=i,l=il(i),s=1/0,h=[];a--;){var p=n[a];a&&t&&(p=c(p,z(t))),s=Hl(p.length,s),l[a]=!r&&(t||u>=120&&p.length>=120)?new yr(a&&p):X}p=n[0];
  var _=-1,v=l[0];n:for(;++_<u&&h.length<s;){var g=p[_],y=t?t(g):g;if(g=r||0!==g?g:0,!(v?S(v,y):e(h,y,r))){for(a=i;--a;){var d=l[a];if(!(d?S(d,y):e(n[a],y,r)))continue n}v&&v.push(y),h.push(g)}}return h}function Oe(n,t,r,e){return ue(n,function(n,u,i){t(e,r(n),u,i)}),e}function Ie(t,r,e){r=ku(r,t),t=Gi(t,r);var u=null==t?t:t[no(jo(r))];return null==u?X:n(u,t,e)}function Re(n){return cc(n)&&we(n)==Dn}function ze(n){return cc(n)&&we(n)==ft}function Ee(n){return cc(n)&&we(n)==Pn}function Se(n,t,r,e,u){
  return n===t||(null==n||null==t||!cc(n)&&!cc(t)?n!==n&&t!==t:We(n,t,r,e,Se,u))}function We(n,t,r,e,u,i){var o=bh(n),f=bh(t),c=o?Mn:zs(n),a=f?Mn:zs(t);c=c==Dn?Yn:c,a=a==Dn?Yn:a;var l=c==Yn,s=a==Yn,h=c==a;if(h&&mh(n)){if(!mh(t))return!1;o=!0,l=!1}if(h&&!l)return i||(i=new wr),o||Oh(n)?pi(n,t,r,e,u,i):_i(n,t,c,r,e,u,i);if(!(r&hn)){var p=l&&bl.call(n,"__wrapped__"),_=s&&bl.call(t,"__wrapped__");if(p||_){var v=p?n.value():n,g=_?t.value():t;return i||(i=new wr),u(v,g,r,e,i)}}return!!h&&(i||(i=new wr),vi(n,t,r,e,u,i));
  }function Le(n){return cc(n)&&zs(n)==Gn}function Ce(n,t,r,e){var u=r.length,i=u,o=!e;if(null==n)return!i;for(n=ll(n);u--;){var f=r[u];if(o&&f[2]?f[1]!==n[f[0]]:!(f[0]in n))return!1}for(;++u<i;){f=r[u];var c=f[0],a=n[c],l=f[1];if(o&&f[2]){if(a===X&&!(c in n))return!1}else{var s=new wr;if(e)var h=e(a,l,c,n,t,s);if(!(h===X?Se(l,a,hn|pn,e,s):h))return!1}}return!0}function Ue(n){return!(!fc(n)||Di(n))&&(uc(n)?kl:Zt).test(to(n))}function Be(n){return cc(n)&&we(n)==nt}function Te(n){return cc(n)&&zs(n)==tt;
  }function $e(n){return cc(n)&&oc(n.length)&&!!Kr[we(n)]}function De(n){return"function"==typeof n?n:null==n?La:"object"==typeof n?bh(n)?Ze(n[0],n[1]):qe(n):Fa(n)}function Me(n){if(!Mi(n))return Vl(n);var t=[];for(var r in ll(n))bl.call(n,r)&&"constructor"!=r&&t.push(r);return t}function Fe(n){if(!fc(n))return Zi(n);var t=Mi(n),r=[];for(var e in n)("constructor"!=e||!t&&bl.call(n,e))&&r.push(e);return r}function Ne(n,t){return n<t}function Pe(n,t){var r=-1,e=Hf(n)?il(n.length):[];return ys(n,function(n,u,i){
  e[++r]=t(n,u,i)}),e}function qe(n){var t=ji(n);return 1==t.length&&t[0][2]?Ni(t[0][0],t[0][1]):function(r){return r===n||Ce(r,n,t)}}function Ze(n,t){return Bi(n)&&Fi(t)?Ni(no(n),t):function(r){var e=Mc(r,n);return e===X&&e===t?Nc(r,n):Se(t,e,hn|pn)}}function Ke(n,t,r,e,u){n!==t&&bs(t,function(i,o){if(u||(u=new wr),fc(i))Ve(n,t,o,r,Ke,e,u);else{var f=e?e(Ji(n,o),i,o+"",n,t,u):X;f===X&&(f=i),Er(n,o,f)}},qc)}function Ve(n,t,r,e,u,i,o){var f=Ji(n,r),c=Ji(t,r),a=o.get(c);if(a)return Er(n,r,a),X;var l=i?i(f,c,r+"",n,t,o):X,s=l===X;
  if(s){var h=bh(c),p=!h&&mh(c),_=!h&&!p&&Oh(c);l=c,h||p||_?bh(f)?l=f:Jf(f)?l=Tu(f):p?(s=!1,l=Iu(c,!0)):_?(s=!1,l=Wu(c,!0)):l=[]:gc(c)||dh(c)?(l=f,dh(f)?l=Rc(f):fc(f)&&!uc(f)||(l=Ei(c))):s=!1}s&&(o.set(c,l),u(l,c,e,i,o),o.delete(c)),Er(n,r,l)}function Ge(n,t){var r=n.length;if(r)return t+=t<0?r:0,Ci(t,r)?n[t]:X}function He(n,t,r){t=t.length?c(t,function(n){return bh(n)?function(t){return _e(t,1===n.length?n[0]:n)}:n}):[La];var e=-1;return t=c(t,z(mi())),A(Pe(n,function(n,r,u){return{criteria:c(t,function(t){
  return t(n)}),index:++e,value:n}}),function(n,t){return Cu(n,t,r)})}function Je(n,t){return Ye(n,t,function(t,r){return Nc(n,r)})}function Ye(n,t,r){for(var e=-1,u=t.length,i={};++e<u;){var o=t[e],f=_e(n,o);r(f,o)&&fu(i,ku(o,n),f)}return i}function Qe(n){return function(t){return _e(t,n)}}function Xe(n,t,r,e){var u=e?d:y,i=-1,o=t.length,f=n;for(n===t&&(t=Tu(t)),r&&(f=c(n,z(r)));++i<o;)for(var a=0,l=t[i],s=r?r(l):l;(a=u(f,s,a,e))>-1;)f!==n&&Ll.call(f,a,1),Ll.call(n,a,1);return n}function nu(n,t){for(var r=n?t.length:0,e=r-1;r--;){
  var u=t[r];if(r==e||u!==i){var i=u;Ci(u)?Ll.call(n,u,1):yu(n,u)}}return n}function tu(n,t){return n+Nl(Ql()*(t-n+1))}function ru(n,t,r,e){for(var u=-1,i=Gl(Fl((t-n)/(r||1)),0),o=il(i);i--;)o[e?i:++u]=n,n+=r;return o}function eu(n,t){var r="";if(!n||t<1||t>Wn)return r;do t%2&&(r+=n),t=Nl(t/2),t&&(n+=n);while(t);return r}function uu(n,t){return Ls(Vi(n,t,La),n+"")}function iu(n){return Ir(ra(n))}function ou(n,t){var r=ra(n);return Xi(r,Mr(t,0,r.length))}function fu(n,t,r,e){if(!fc(n))return n;t=ku(t,n);
  for(var u=-1,i=t.length,o=i-1,f=n;null!=f&&++u<i;){var c=no(t[u]),a=r;if("__proto__"===c||"constructor"===c||"prototype"===c)return n;if(u!=o){var l=f[c];a=e?e(l,c,f):X,a===X&&(a=fc(l)?l:Ci(t[u+1])?[]:{})}Sr(f,c,a),f=f[c]}return n}function cu(n){return Xi(ra(n))}function au(n,t,r){var e=-1,u=n.length;t<0&&(t=-t>u?0:u+t),r=r>u?u:r,r<0&&(r+=u),u=t>r?0:r-t>>>0,t>>>=0;for(var i=il(u);++e<u;)i[e]=n[e+t];return i}function lu(n,t){var r;return ys(n,function(n,e,u){return r=t(n,e,u),!r}),!!r}function su(n,t,r){
  var e=0,u=null==n?e:n.length;if("number"==typeof t&&t===t&&u<=Tn){for(;e<u;){var i=e+u>>>1,o=n[i];null!==o&&!bc(o)&&(r?o<=t:o<t)?e=i+1:u=i}return u}return hu(n,t,La,r)}function hu(n,t,r,e){var u=0,i=null==n?0:n.length;if(0===i)return 0;t=r(t);for(var o=t!==t,f=null===t,c=bc(t),a=t===X;u<i;){var l=Nl((u+i)/2),s=r(n[l]),h=s!==X,p=null===s,_=s===s,v=bc(s);if(o)var g=e||_;else g=a?_&&(e||h):f?_&&h&&(e||!p):c?_&&h&&!p&&(e||!v):!p&&!v&&(e?s<=t:s<t);g?u=l+1:i=l}return Hl(i,Bn)}function pu(n,t){for(var r=-1,e=n.length,u=0,i=[];++r<e;){
  var o=n[r],f=t?t(o):o;if(!r||!Gf(f,c)){var c=f;i[u++]=0===o?0:o}}return i}function _u(n){return"number"==typeof n?n:bc(n)?Cn:+n}function vu(n){if("string"==typeof n)return n;if(bh(n))return c(n,vu)+"";if(bc(n))return vs?vs.call(n):"";var t=n+"";return"0"==t&&1/n==-Sn?"-0":t}function gu(n,t,r){var e=-1,u=o,i=n.length,c=!0,a=[],l=a;if(r)c=!1,u=f;else if(i>=tn){var s=t?null:ks(n);if(s)return P(s);c=!1,u=S,l=new yr}else l=t?[]:a;n:for(;++e<i;){var h=n[e],p=t?t(h):h;if(h=r||0!==h?h:0,c&&p===p){for(var _=l.length;_--;)if(l[_]===p)continue n;
  t&&l.push(p),a.push(h)}else u(l,p,r)||(l!==a&&l.push(p),a.push(h))}return a}function yu(n,t){return t=ku(t,n),n=Gi(n,t),null==n||delete n[no(jo(t))]}function du(n,t,r,e){return fu(n,t,r(_e(n,t)),e)}function bu(n,t,r,e){for(var u=n.length,i=e?u:-1;(e?i--:++i<u)&&t(n[i],i,n););return r?au(n,e?0:i,e?i+1:u):au(n,e?i+1:0,e?u:i)}function wu(n,t){var r=n;return r instanceof Ct&&(r=r.value()),l(t,function(n,t){return t.func.apply(t.thisArg,a([n],t.args))},r)}function mu(n,t,r){var e=n.length;if(e<2)return e?gu(n[0]):[];
  for(var u=-1,i=il(e);++u<e;)for(var o=n[u],f=-1;++f<e;)f!=u&&(i[u]=Hr(i[u]||o,n[f],t,r));return gu(ee(i,1),t,r)}function xu(n,t,r){for(var e=-1,u=n.length,i=t.length,o={};++e<u;){r(o,n[e],e<i?t[e]:X)}return o}function ju(n){return Jf(n)?n:[]}function Au(n){return"function"==typeof n?n:La}function ku(n,t){return bh(n)?n:Bi(n,t)?[n]:Cs(Ec(n))}function Ou(n,t,r){var e=n.length;return r=r===X?e:r,!t&&r>=e?n:au(n,t,r)}function Iu(n,t){if(t)return n.slice();var r=n.length,e=zl?zl(r):new n.constructor(r);
  return n.copy(e),e}function Ru(n){var t=new n.constructor(n.byteLength);return new Rl(t).set(new Rl(n)),t}function zu(n,t){return new n.constructor(t?Ru(n.buffer):n.buffer,n.byteOffset,n.byteLength)}function Eu(n){var t=new n.constructor(n.source,Nt.exec(n));return t.lastIndex=n.lastIndex,t}function Su(n){return _s?ll(_s.call(n)):{}}function Wu(n,t){return new n.constructor(t?Ru(n.buffer):n.buffer,n.byteOffset,n.length)}function Lu(n,t){if(n!==t){var r=n!==X,e=null===n,u=n===n,i=bc(n),o=t!==X,f=null===t,c=t===t,a=bc(t);
  if(!f&&!a&&!i&&n>t||i&&o&&c&&!f&&!a||e&&o&&c||!r&&c||!u)return 1;if(!e&&!i&&!a&&n<t||a&&r&&u&&!e&&!i||f&&r&&u||!o&&u||!c)return-1}return 0}function Cu(n,t,r){for(var e=-1,u=n.criteria,i=t.criteria,o=u.length,f=r.length;++e<o;){var c=Lu(u[e],i[e]);if(c){if(e>=f)return c;return c*("desc"==r[e]?-1:1)}}return n.index-t.index}function Uu(n,t,r,e){for(var u=-1,i=n.length,o=r.length,f=-1,c=t.length,a=Gl(i-o,0),l=il(c+a),s=!e;++f<c;)l[f]=t[f];for(;++u<o;)(s||u<i)&&(l[r[u]]=n[u]);for(;a--;)l[f++]=n[u++];return l;
  }function Bu(n,t,r,e){for(var u=-1,i=n.length,o=-1,f=r.length,c=-1,a=t.length,l=Gl(i-f,0),s=il(l+a),h=!e;++u<l;)s[u]=n[u];for(var p=u;++c<a;)s[p+c]=t[c];for(;++o<f;)(h||u<i)&&(s[p+r[o]]=n[u++]);return s}function Tu(n,t){var r=-1,e=n.length;for(t||(t=il(e));++r<e;)t[r]=n[r];return t}function $u(n,t,r,e){var u=!r;r||(r={});for(var i=-1,o=t.length;++i<o;){var f=t[i],c=e?e(r[f],n[f],f,r,n):X;c===X&&(c=n[f]),u?Br(r,f,c):Sr(r,f,c)}return r}function Du(n,t){return $u(n,Is(n),t)}function Mu(n,t){return $u(n,Rs(n),t);
  }function Fu(n,r){return function(e,u){var i=bh(e)?t:Lr,o=r?r():{};return i(e,n,mi(u,2),o)}}function Nu(n){return uu(function(t,r){var e=-1,u=r.length,i=u>1?r[u-1]:X,o=u>2?r[2]:X;for(i=n.length>3&&"function"==typeof i?(u--,i):X,o&&Ui(r[0],r[1],o)&&(i=u<3?X:i,u=1),t=ll(t);++e<u;){var f=r[e];f&&n(t,f,e,i)}return t})}function Pu(n,t){return function(r,e){if(null==r)return r;if(!Hf(r))return n(r,e);for(var u=r.length,i=t?u:-1,o=ll(r);(t?i--:++i<u)&&e(o[i],i,o)!==!1;);return r}}function qu(n){return function(t,r,e){
  for(var u=-1,i=ll(t),o=e(t),f=o.length;f--;){var c=o[n?f:++u];if(r(i[c],c,i)===!1)break}return t}}function Zu(n,t,r){function e(){return(this&&this!==re&&this instanceof e?i:n).apply(u?r:this,arguments)}var u=t&_n,i=Gu(n);return e}function Ku(n){return function(t){t=Ec(t);var r=T(t)?G(t):X,e=r?r[0]:t.charAt(0),u=r?Ou(r,1).join(""):t.slice(1);return e[n]()+u}}function Vu(n){return function(t){return l(Ra(ca(t).replace($r,"")),n,"")}}function Gu(n){return function(){var t=arguments;switch(t.length){
  case 0:return new n;case 1:return new n(t[0]);case 2:return new n(t[0],t[1]);case 3:return new n(t[0],t[1],t[2]);case 4:return new n(t[0],t[1],t[2],t[3]);case 5:return new n(t[0],t[1],t[2],t[3],t[4]);case 6:return new n(t[0],t[1],t[2],t[3],t[4],t[5]);case 7:return new n(t[0],t[1],t[2],t[3],t[4],t[5],t[6])}var r=gs(n.prototype),e=n.apply(r,t);return fc(e)?e:r}}function Hu(t,r,e){function u(){for(var o=arguments.length,f=il(o),c=o,a=wi(u);c--;)f[c]=arguments[c];var l=o<3&&f[0]!==a&&f[o-1]!==a?[]:N(f,a);
  return o-=l.length,o<e?oi(t,r,Qu,u.placeholder,X,f,l,X,X,e-o):n(this&&this!==re&&this instanceof u?i:t,this,f)}var i=Gu(t);return u}function Ju(n){return function(t,r,e){var u=ll(t);if(!Hf(t)){var i=mi(r,3);t=Pc(t),r=function(n){return i(u[n],n,u)}}var o=n(t,r,e);return o>-1?u[i?t[o]:o]:X}}function Yu(n){return gi(function(t){var r=t.length,e=r,u=Y.prototype.thru;for(n&&t.reverse();e--;){var i=t[e];if("function"!=typeof i)throw new pl(en);if(u&&!o&&"wrapper"==bi(i))var o=new Y([],!0)}for(e=o?e:r;++e<r;){
  i=t[e];var f=bi(i),c="wrapper"==f?Os(i):X;o=c&&$i(c[0])&&c[1]==(mn|yn|bn|xn)&&!c[4].length&&1==c[9]?o[bi(c[0])].apply(o,c[3]):1==i.length&&$i(i)?o[f]():o.thru(i)}return function(){var n=arguments,e=n[0];if(o&&1==n.length&&bh(e))return o.plant(e).value();for(var u=0,i=r?t[u].apply(this,n):e;++u<r;)i=t[u].call(this,i);return i}})}function Qu(n,t,r,e,u,i,o,f,c,a){function l(){for(var y=arguments.length,d=il(y),b=y;b--;)d[b]=arguments[b];if(_)var w=wi(l),m=C(d,w);if(e&&(d=Uu(d,e,u,_)),i&&(d=Bu(d,i,o,_)),
  y-=m,_&&y<a){return oi(n,t,Qu,l.placeholder,r,d,N(d,w),f,c,a-y)}var x=h?r:this,j=p?x[n]:n;return y=d.length,f?d=Hi(d,f):v&&y>1&&d.reverse(),s&&c<y&&(d.length=c),this&&this!==re&&this instanceof l&&(j=g||Gu(j)),j.apply(x,d)}var s=t&mn,h=t&_n,p=t&vn,_=t&(yn|dn),v=t&jn,g=p?X:Gu(n);return l}function Xu(n,t){return function(r,e){return Oe(r,n,t(e),{})}}function ni(n,t){return function(r,e){var u;if(r===X&&e===X)return t;if(r!==X&&(u=r),e!==X){if(u===X)return e;"string"==typeof r||"string"==typeof e?(r=vu(r),
  e=vu(e)):(r=_u(r),e=_u(e)),u=n(r,e)}return u}}function ti(t){return gi(function(r){return r=c(r,z(mi())),uu(function(e){var u=this;return t(r,function(t){return n(t,u,e)})})})}function ri(n,t){t=t===X?" ":vu(t);var r=t.length;if(r<2)return r?eu(t,n):t;var e=eu(t,Fl(n/V(t)));return T(t)?Ou(G(e),0,n).join(""):e.slice(0,n)}function ei(t,r,e,u){function i(){for(var r=-1,c=arguments.length,a=-1,l=u.length,s=il(l+c),h=this&&this!==re&&this instanceof i?f:t;++a<l;)s[a]=u[a];for(;c--;)s[a++]=arguments[++r];
  return n(h,o?e:this,s)}var o=r&_n,f=Gu(t);return i}function ui(n){return function(t,r,e){return e&&"number"!=typeof e&&Ui(t,r,e)&&(r=e=X),t=Ac(t),r===X?(r=t,t=0):r=Ac(r),e=e===X?t<r?1:-1:Ac(e),ru(t,r,e,n)}}function ii(n){return function(t,r){return"string"==typeof t&&"string"==typeof r||(t=Ic(t),r=Ic(r)),n(t,r)}}function oi(n,t,r,e,u,i,o,f,c,a){var l=t&yn,s=l?o:X,h=l?X:o,p=l?i:X,_=l?X:i;t|=l?bn:wn,t&=~(l?wn:bn),t&gn||(t&=~(_n|vn));var v=[n,t,u,p,s,_,h,f,c,a],g=r.apply(X,v);return $i(n)&&Ss(g,v),g.placeholder=e,
  Yi(g,n,t)}function fi(n){var t=al[n];return function(n,r){if(n=Ic(n),r=null==r?0:Hl(kc(r),292),r&&Zl(n)){var e=(Ec(n)+"e").split("e");return e=(Ec(t(e[0]+"e"+(+e[1]+r)))+"e").split("e"),+(e[0]+"e"+(+e[1]-r))}return t(n)}}function ci(n){return function(t){var r=zs(t);return r==Gn?M(t):r==tt?q(t):I(t,n(t))}}function ai(n,t,r,e,u,i,o,f){var c=t&vn;if(!c&&"function"!=typeof n)throw new pl(en);var a=e?e.length:0;if(a||(t&=~(bn|wn),e=u=X),o=o===X?o:Gl(kc(o),0),f=f===X?f:kc(f),a-=u?u.length:0,t&wn){var l=e,s=u;
  e=u=X}var h=c?X:Os(n),p=[n,t,r,e,u,l,s,i,o,f];if(h&&qi(p,h),n=p[0],t=p[1],r=p[2],e=p[3],u=p[4],f=p[9]=p[9]===X?c?0:n.length:Gl(p[9]-a,0),!f&&t&(yn|dn)&&(t&=~(yn|dn)),t&&t!=_n)_=t==yn||t==dn?Hu(n,t,f):t!=bn&&t!=(_n|bn)||u.length?Qu.apply(X,p):ei(n,t,r,e);else var _=Zu(n,t,r);return Yi((h?ms:Ss)(_,p),n,t)}function li(n,t,r,e){return n===X||Gf(n,gl[r])&&!bl.call(e,r)?t:n}function si(n,t,r,e,u,i){return fc(n)&&fc(t)&&(i.set(t,n),Ke(n,t,X,si,i),i.delete(t)),n}function hi(n){return gc(n)?X:n}function pi(n,t,r,e,u,i){
  var o=r&hn,f=n.length,c=t.length;if(f!=c&&!(o&&c>f))return!1;var a=i.get(n),l=i.get(t);if(a&&l)return a==t&&l==n;var s=-1,p=!0,_=r&pn?new yr:X;for(i.set(n,t),i.set(t,n);++s<f;){var v=n[s],g=t[s];if(e)var y=o?e(g,v,s,t,n,i):e(v,g,s,n,t,i);if(y!==X){if(y)continue;p=!1;break}if(_){if(!h(t,function(n,t){if(!S(_,t)&&(v===n||u(v,n,r,e,i)))return _.push(t)})){p=!1;break}}else if(v!==g&&!u(v,g,r,e,i)){p=!1;break}}return i.delete(n),i.delete(t),p}function _i(n,t,r,e,u,i,o){switch(r){case ct:if(n.byteLength!=t.byteLength||n.byteOffset!=t.byteOffset)return!1;
  n=n.buffer,t=t.buffer;case ft:return!(n.byteLength!=t.byteLength||!i(new Rl(n),new Rl(t)));case Nn:case Pn:case Hn:return Gf(+n,+t);case Zn:return n.name==t.name&&n.message==t.message;case nt:case rt:return n==t+"";case Gn:var f=M;case tt:var c=e&hn;if(f||(f=P),n.size!=t.size&&!c)return!1;var a=o.get(n);if(a)return a==t;e|=pn,o.set(n,t);var l=pi(f(n),f(t),e,u,i,o);return o.delete(n),l;case et:if(_s)return _s.call(n)==_s.call(t)}return!1}function vi(n,t,r,e,u,i){var o=r&hn,f=yi(n),c=f.length;if(c!=yi(t).length&&!o)return!1;
  for(var a=c;a--;){var l=f[a];if(!(o?l in t:bl.call(t,l)))return!1}var s=i.get(n),h=i.get(t);if(s&&h)return s==t&&h==n;var p=!0;i.set(n,t),i.set(t,n);for(var _=o;++a<c;){l=f[a];var v=n[l],g=t[l];if(e)var y=o?e(g,v,l,t,n,i):e(v,g,l,n,t,i);if(!(y===X?v===g||u(v,g,r,e,i):y)){p=!1;break}_||(_="constructor"==l)}if(p&&!_){var d=n.constructor,b=t.constructor;d!=b&&"constructor"in n&&"constructor"in t&&!("function"==typeof d&&d instanceof d&&"function"==typeof b&&b instanceof b)&&(p=!1)}return i.delete(n),
  i.delete(t),p}function gi(n){return Ls(Vi(n,X,_o),n+"")}function yi(n){return de(n,Pc,Is)}function di(n){return de(n,qc,Rs)}function bi(n){for(var t=n.name+"",r=fs[t],e=bl.call(fs,t)?r.length:0;e--;){var u=r[e],i=u.func;if(null==i||i==n)return u.name}return t}function wi(n){return(bl.call(Z,"placeholder")?Z:n).placeholder}function mi(){var n=Z.iteratee||Ca;return n=n===Ca?De:n,arguments.length?n(arguments[0],arguments[1]):n}function xi(n,t){var r=n.__data__;return Ti(t)?r["string"==typeof t?"string":"hash"]:r.map;
  }function ji(n){for(var t=Pc(n),r=t.length;r--;){var e=t[r],u=n[e];t[r]=[e,u,Fi(u)]}return t}function Ai(n,t){var r=B(n,t);return Ue(r)?r:X}function ki(n){var t=bl.call(n,Bl),r=n[Bl];try{n[Bl]=X;var e=!0}catch(n){}var u=xl.call(n);return e&&(t?n[Bl]=r:delete n[Bl]),u}function Oi(n,t,r){for(var e=-1,u=r.length;++e<u;){var i=r[e],o=i.size;switch(i.type){case"drop":n+=o;break;case"dropRight":t-=o;break;case"take":t=Hl(t,n+o);break;case"takeRight":n=Gl(n,t-o)}}return{start:n,end:t}}function Ii(n){var t=n.match(Bt);
  return t?t[1].split(Tt):[]}function Ri(n,t,r){t=ku(t,n);for(var e=-1,u=t.length,i=!1;++e<u;){var o=no(t[e]);if(!(i=null!=n&&r(n,o)))break;n=n[o]}return i||++e!=u?i:(u=null==n?0:n.length,!!u&&oc(u)&&Ci(o,u)&&(bh(n)||dh(n)))}function zi(n){var t=n.length,r=new n.constructor(t);return t&&"string"==typeof n[0]&&bl.call(n,"index")&&(r.index=n.index,r.input=n.input),r}function Ei(n){return"function"!=typeof n.constructor||Mi(n)?{}:gs(El(n))}function Si(n,t,r){var e=n.constructor;switch(t){case ft:return Ru(n);
  case Nn:case Pn:return new e(+n);case ct:return zu(n,r);case at:case lt:case st:case ht:case pt:case _t:case vt:case gt:case yt:return Wu(n,r);case Gn:return new e;case Hn:case rt:return new e(n);case nt:return Eu(n);case tt:return new e;case et:return Su(n)}}function Wi(n,t){var r=t.length;if(!r)return n;var e=r-1;return t[e]=(r>1?"& ":"")+t[e],t=t.join(r>2?", ":" "),n.replace(Ut,"{\n/* [wrapped with "+t+"] */\n")}function Li(n){return bh(n)||dh(n)||!!(Cl&&n&&n[Cl])}function Ci(n,t){var r=typeof n;
  return t=null==t?Wn:t,!!t&&("number"==r||"symbol"!=r&&Vt.test(n))&&n>-1&&n%1==0&&n<t}function Ui(n,t,r){if(!fc(r))return!1;var e=typeof t;return!!("number"==e?Hf(r)&&Ci(t,r.length):"string"==e&&t in r)&&Gf(r[t],n)}function Bi(n,t){if(bh(n))return!1;var r=typeof n;return!("number"!=r&&"symbol"!=r&&"boolean"!=r&&null!=n&&!bc(n))||(zt.test(n)||!Rt.test(n)||null!=t&&n in ll(t))}function Ti(n){var t=typeof n;return"string"==t||"number"==t||"symbol"==t||"boolean"==t?"__proto__"!==n:null===n}function $i(n){
  var t=bi(n),r=Z[t];if("function"!=typeof r||!(t in Ct.prototype))return!1;if(n===r)return!0;var e=Os(r);return!!e&&n===e[0]}function Di(n){return!!ml&&ml in n}function Mi(n){var t=n&&n.constructor;return n===("function"==typeof t&&t.prototype||gl)}function Fi(n){return n===n&&!fc(n)}function Ni(n,t){return function(r){return null!=r&&(r[n]===t&&(t!==X||n in ll(r)))}}function Pi(n){var t=Cf(n,function(n){return r.size===fn&&r.clear(),n}),r=t.cache;return t}function qi(n,t){var r=n[1],e=t[1],u=r|e,i=u<(_n|vn|mn),o=e==mn&&r==yn||e==mn&&r==xn&&n[7].length<=t[8]||e==(mn|xn)&&t[7].length<=t[8]&&r==yn;
  if(!i&&!o)return n;e&_n&&(n[2]=t[2],u|=r&_n?0:gn);var f=t[3];if(f){var c=n[3];n[3]=c?Uu(c,f,t[4]):f,n[4]=c?N(n[3],cn):t[4]}return f=t[5],f&&(c=n[5],n[5]=c?Bu(c,f,t[6]):f,n[6]=c?N(n[5],cn):t[6]),f=t[7],f&&(n[7]=f),e&mn&&(n[8]=null==n[8]?t[8]:Hl(n[8],t[8])),null==n[9]&&(n[9]=t[9]),n[0]=t[0],n[1]=u,n}function Zi(n){var t=[];if(null!=n)for(var r in ll(n))t.push(r);return t}function Ki(n){return xl.call(n)}function Vi(t,r,e){return r=Gl(r===X?t.length-1:r,0),function(){for(var u=arguments,i=-1,o=Gl(u.length-r,0),f=il(o);++i<o;)f[i]=u[r+i];
  i=-1;for(var c=il(r+1);++i<r;)c[i]=u[i];return c[r]=e(f),n(t,this,c)}}function Gi(n,t){return t.length<2?n:_e(n,au(t,0,-1))}function Hi(n,t){for(var r=n.length,e=Hl(t.length,r),u=Tu(n);e--;){var i=t[e];n[e]=Ci(i,r)?u[i]:X}return n}function Ji(n,t){if(("constructor"!==t||"function"!=typeof n[t])&&"__proto__"!=t)return n[t]}function Yi(n,t,r){var e=t+"";return Ls(n,Wi(e,ro(Ii(e),r)))}function Qi(n){var t=0,r=0;return function(){var e=Jl(),u=In-(e-r);if(r=e,u>0){if(++t>=On)return arguments[0]}else t=0;
  return n.apply(X,arguments)}}function Xi(n,t){var r=-1,e=n.length,u=e-1;for(t=t===X?e:t;++r<t;){var i=tu(r,u),o=n[i];n[i]=n[r],n[r]=o}return n.length=t,n}function no(n){if("string"==typeof n||bc(n))return n;var t=n+"";return"0"==t&&1/n==-Sn?"-0":t}function to(n){if(null!=n){try{return dl.call(n)}catch(n){}try{return n+""}catch(n){}}return""}function ro(n,t){return r($n,function(r){var e="_."+r[0];t&r[1]&&!o(n,e)&&n.push(e)}),n.sort()}function eo(n){if(n instanceof Ct)return n.clone();var t=new Y(n.__wrapped__,n.__chain__);
  return t.__actions__=Tu(n.__actions__),t.__index__=n.__index__,t.__values__=n.__values__,t}function uo(n,t,r){t=(r?Ui(n,t,r):t===X)?1:Gl(kc(t),0);var e=null==n?0:n.length;if(!e||t<1)return[];for(var u=0,i=0,o=il(Fl(e/t));u<e;)o[i++]=au(n,u,u+=t);return o}function io(n){for(var t=-1,r=null==n?0:n.length,e=0,u=[];++t<r;){var i=n[t];i&&(u[e++]=i)}return u}function oo(){var n=arguments.length;if(!n)return[];for(var t=il(n-1),r=arguments[0],e=n;e--;)t[e-1]=arguments[e];return a(bh(r)?Tu(r):[r],ee(t,1));
  }function fo(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===X?1:kc(t),au(n,t<0?0:t,e)):[]}function co(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===X?1:kc(t),t=e-t,au(n,0,t<0?0:t)):[]}function ao(n,t){return n&&n.length?bu(n,mi(t,3),!0,!0):[]}function lo(n,t){return n&&n.length?bu(n,mi(t,3),!0):[]}function so(n,t,r,e){var u=null==n?0:n.length;return u?(r&&"number"!=typeof r&&Ui(n,t,r)&&(r=0,e=u),ne(n,t,r,e)):[]}function ho(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=null==r?0:kc(r);
  return u<0&&(u=Gl(e+u,0)),g(n,mi(t,3),u)}function po(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e-1;return r!==X&&(u=kc(r),u=r<0?Gl(e+u,0):Hl(u,e-1)),g(n,mi(t,3),u,!0)}function _o(n){return(null==n?0:n.length)?ee(n,1):[]}function vo(n){return(null==n?0:n.length)?ee(n,Sn):[]}function go(n,t){return(null==n?0:n.length)?(t=t===X?1:kc(t),ee(n,t)):[]}function yo(n){for(var t=-1,r=null==n?0:n.length,e={};++t<r;){var u=n[t];e[u[0]]=u[1]}return e}function bo(n){return n&&n.length?n[0]:X}function wo(n,t,r){
  var e=null==n?0:n.length;if(!e)return-1;var u=null==r?0:kc(r);return u<0&&(u=Gl(e+u,0)),y(n,t,u)}function mo(n){return(null==n?0:n.length)?au(n,0,-1):[]}function xo(n,t){return null==n?"":Kl.call(n,t)}function jo(n){var t=null==n?0:n.length;return t?n[t-1]:X}function Ao(n,t,r){var e=null==n?0:n.length;if(!e)return-1;var u=e;return r!==X&&(u=kc(r),u=u<0?Gl(e+u,0):Hl(u,e-1)),t===t?K(n,t,u):g(n,b,u,!0)}function ko(n,t){return n&&n.length?Ge(n,kc(t)):X}function Oo(n,t){return n&&n.length&&t&&t.length?Xe(n,t):n;
  }function Io(n,t,r){return n&&n.length&&t&&t.length?Xe(n,t,mi(r,2)):n}function Ro(n,t,r){return n&&n.length&&t&&t.length?Xe(n,t,X,r):n}function zo(n,t){var r=[];if(!n||!n.length)return r;var e=-1,u=[],i=n.length;for(t=mi(t,3);++e<i;){var o=n[e];t(o,e,n)&&(r.push(o),u.push(e))}return nu(n,u),r}function Eo(n){return null==n?n:Xl.call(n)}function So(n,t,r){var e=null==n?0:n.length;return e?(r&&"number"!=typeof r&&Ui(n,t,r)?(t=0,r=e):(t=null==t?0:kc(t),r=r===X?e:kc(r)),au(n,t,r)):[]}function Wo(n,t){
  return su(n,t)}function Lo(n,t,r){return hu(n,t,mi(r,2))}function Co(n,t){var r=null==n?0:n.length;if(r){var e=su(n,t);if(e<r&&Gf(n[e],t))return e}return-1}function Uo(n,t){return su(n,t,!0)}function Bo(n,t,r){return hu(n,t,mi(r,2),!0)}function To(n,t){if(null==n?0:n.length){var r=su(n,t,!0)-1;if(Gf(n[r],t))return r}return-1}function $o(n){return n&&n.length?pu(n):[]}function Do(n,t){return n&&n.length?pu(n,mi(t,2)):[]}function Mo(n){var t=null==n?0:n.length;return t?au(n,1,t):[]}function Fo(n,t,r){
  return n&&n.length?(t=r||t===X?1:kc(t),au(n,0,t<0?0:t)):[]}function No(n,t,r){var e=null==n?0:n.length;return e?(t=r||t===X?1:kc(t),t=e-t,au(n,t<0?0:t,e)):[]}function Po(n,t){return n&&n.length?bu(n,mi(t,3),!1,!0):[]}function qo(n,t){return n&&n.length?bu(n,mi(t,3)):[]}function Zo(n){return n&&n.length?gu(n):[]}function Ko(n,t){return n&&n.length?gu(n,mi(t,2)):[]}function Vo(n,t){return t="function"==typeof t?t:X,n&&n.length?gu(n,X,t):[]}function Go(n){if(!n||!n.length)return[];var t=0;return n=i(n,function(n){
  if(Jf(n))return t=Gl(n.length,t),!0}),O(t,function(t){return c(n,m(t))})}function Ho(t,r){if(!t||!t.length)return[];var e=Go(t);return null==r?e:c(e,function(t){return n(r,X,t)})}function Jo(n,t){return xu(n||[],t||[],Sr)}function Yo(n,t){return xu(n||[],t||[],fu)}function Qo(n){var t=Z(n);return t.__chain__=!0,t}function Xo(n,t){return t(n),n}function nf(n,t){return t(n)}function tf(){return Qo(this)}function rf(){return new Y(this.value(),this.__chain__)}function ef(){this.__values__===X&&(this.__values__=jc(this.value()));
  var n=this.__index__>=this.__values__.length;return{done:n,value:n?X:this.__values__[this.__index__++]}}function uf(){return this}function of(n){for(var t,r=this;r instanceof J;){var e=eo(r);e.__index__=0,e.__values__=X,t?u.__wrapped__=e:t=e;var u=e;r=r.__wrapped__}return u.__wrapped__=n,t}function ff(){var n=this.__wrapped__;if(n instanceof Ct){var t=n;return this.__actions__.length&&(t=new Ct(this)),t=t.reverse(),t.__actions__.push({func:nf,args:[Eo],thisArg:X}),new Y(t,this.__chain__)}return this.thru(Eo);
  }function cf(){return wu(this.__wrapped__,this.__actions__)}function af(n,t,r){var e=bh(n)?u:Jr;return r&&Ui(n,t,r)&&(t=X),e(n,mi(t,3))}function lf(n,t){return(bh(n)?i:te)(n,mi(t,3))}function sf(n,t){return ee(yf(n,t),1)}function hf(n,t){return ee(yf(n,t),Sn)}function pf(n,t,r){return r=r===X?1:kc(r),ee(yf(n,t),r)}function _f(n,t){return(bh(n)?r:ys)(n,mi(t,3))}function vf(n,t){return(bh(n)?e:ds)(n,mi(t,3))}function gf(n,t,r,e){n=Hf(n)?n:ra(n),r=r&&!e?kc(r):0;var u=n.length;return r<0&&(r=Gl(u+r,0)),
  dc(n)?r<=u&&n.indexOf(t,r)>-1:!!u&&y(n,t,r)>-1}function yf(n,t){return(bh(n)?c:Pe)(n,mi(t,3))}function df(n,t,r,e){return null==n?[]:(bh(t)||(t=null==t?[]:[t]),r=e?X:r,bh(r)||(r=null==r?[]:[r]),He(n,t,r))}function bf(n,t,r){var e=bh(n)?l:j,u=arguments.length<3;return e(n,mi(t,4),r,u,ys)}function wf(n,t,r){var e=bh(n)?s:j,u=arguments.length<3;return e(n,mi(t,4),r,u,ds)}function mf(n,t){return(bh(n)?i:te)(n,Uf(mi(t,3)))}function xf(n){return(bh(n)?Ir:iu)(n)}function jf(n,t,r){return t=(r?Ui(n,t,r):t===X)?1:kc(t),
  (bh(n)?Rr:ou)(n,t)}function Af(n){return(bh(n)?zr:cu)(n)}function kf(n){if(null==n)return 0;if(Hf(n))return dc(n)?V(n):n.length;var t=zs(n);return t==Gn||t==tt?n.size:Me(n).length}function Of(n,t,r){var e=bh(n)?h:lu;return r&&Ui(n,t,r)&&(t=X),e(n,mi(t,3))}function If(n,t){if("function"!=typeof t)throw new pl(en);return n=kc(n),function(){if(--n<1)return t.apply(this,arguments)}}function Rf(n,t,r){return t=r?X:t,t=n&&null==t?n.length:t,ai(n,mn,X,X,X,X,t)}function zf(n,t){var r;if("function"!=typeof t)throw new pl(en);
  return n=kc(n),function(){return--n>0&&(r=t.apply(this,arguments)),n<=1&&(t=X),r}}function Ef(n,t,r){t=r?X:t;var e=ai(n,yn,X,X,X,X,X,t);return e.placeholder=Ef.placeholder,e}function Sf(n,t,r){t=r?X:t;var e=ai(n,dn,X,X,X,X,X,t);return e.placeholder=Sf.placeholder,e}function Wf(n,t,r){function e(t){var r=h,e=p;return h=p=X,d=t,v=n.apply(e,r)}function u(n){return d=n,g=Ws(f,t),b?e(n):v}function i(n){var r=n-y,e=n-d,u=t-r;return w?Hl(u,_-e):u}function o(n){var r=n-y,e=n-d;return y===X||r>=t||r<0||w&&e>=_;
  }function f(){var n=fh();return o(n)?c(n):(g=Ws(f,i(n)),X)}function c(n){return g=X,m&&h?e(n):(h=p=X,v)}function a(){g!==X&&As(g),d=0,h=y=p=g=X}function l(){return g===X?v:c(fh())}function s(){var n=fh(),r=o(n);if(h=arguments,p=this,y=n,r){if(g===X)return u(y);if(w)return As(g),g=Ws(f,t),e(y)}return g===X&&(g=Ws(f,t)),v}var h,p,_,v,g,y,d=0,b=!1,w=!1,m=!0;if("function"!=typeof n)throw new pl(en);return t=Ic(t)||0,fc(r)&&(b=!!r.leading,w="maxWait"in r,_=w?Gl(Ic(r.maxWait)||0,t):_,m="trailing"in r?!!r.trailing:m),
  s.cancel=a,s.flush=l,s}function Lf(n){return ai(n,jn)}function Cf(n,t){if("function"!=typeof n||null!=t&&"function"!=typeof t)throw new pl(en);var r=function(){var e=arguments,u=t?t.apply(this,e):e[0],i=r.cache;if(i.has(u))return i.get(u);var o=n.apply(this,e);return r.cache=i.set(u,o)||i,o};return r.cache=new(Cf.Cache||sr),r}function Uf(n){if("function"!=typeof n)throw new pl(en);return function(){var t=arguments;switch(t.length){case 0:return!n.call(this);case 1:return!n.call(this,t[0]);case 2:
  return!n.call(this,t[0],t[1]);case 3:return!n.call(this,t[0],t[1],t[2])}return!n.apply(this,t)}}function Bf(n){return zf(2,n)}function Tf(n,t){if("function"!=typeof n)throw new pl(en);return t=t===X?t:kc(t),uu(n,t)}function $f(t,r){if("function"!=typeof t)throw new pl(en);return r=null==r?0:Gl(kc(r),0),uu(function(e){var u=e[r],i=Ou(e,0,r);return u&&a(i,u),n(t,this,i)})}function Df(n,t,r){var e=!0,u=!0;if("function"!=typeof n)throw new pl(en);return fc(r)&&(e="leading"in r?!!r.leading:e,u="trailing"in r?!!r.trailing:u),
  Wf(n,t,{leading:e,maxWait:t,trailing:u})}function Mf(n){return Rf(n,1)}function Ff(n,t){return ph(Au(t),n)}function Nf(){if(!arguments.length)return[];var n=arguments[0];return bh(n)?n:[n]}function Pf(n){return Fr(n,sn)}function qf(n,t){return t="function"==typeof t?t:X,Fr(n,sn,t)}function Zf(n){return Fr(n,an|sn)}function Kf(n,t){return t="function"==typeof t?t:X,Fr(n,an|sn,t)}function Vf(n,t){return null==t||Pr(n,t,Pc(t))}function Gf(n,t){return n===t||n!==n&&t!==t}function Hf(n){return null!=n&&oc(n.length)&&!uc(n);
  }function Jf(n){return cc(n)&&Hf(n)}function Yf(n){return n===!0||n===!1||cc(n)&&we(n)==Nn}function Qf(n){return cc(n)&&1===n.nodeType&&!gc(n)}function Xf(n){if(null==n)return!0;if(Hf(n)&&(bh(n)||"string"==typeof n||"function"==typeof n.splice||mh(n)||Oh(n)||dh(n)))return!n.length;var t=zs(n);if(t==Gn||t==tt)return!n.size;if(Mi(n))return!Me(n).length;for(var r in n)if(bl.call(n,r))return!1;return!0}function nc(n,t){return Se(n,t)}function tc(n,t,r){r="function"==typeof r?r:X;var e=r?r(n,t):X;return e===X?Se(n,t,X,r):!!e;
  }function rc(n){if(!cc(n))return!1;var t=we(n);return t==Zn||t==qn||"string"==typeof n.message&&"string"==typeof n.name&&!gc(n)}function ec(n){return"number"==typeof n&&Zl(n)}function uc(n){if(!fc(n))return!1;var t=we(n);return t==Kn||t==Vn||t==Fn||t==Xn}function ic(n){return"number"==typeof n&&n==kc(n)}function oc(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=Wn}function fc(n){var t=typeof n;return null!=n&&("object"==t||"function"==t)}function cc(n){return null!=n&&"object"==typeof n}function ac(n,t){
  return n===t||Ce(n,t,ji(t))}function lc(n,t,r){return r="function"==typeof r?r:X,Ce(n,t,ji(t),r)}function sc(n){return vc(n)&&n!=+n}function hc(n){if(Es(n))throw new fl(rn);return Ue(n)}function pc(n){return null===n}function _c(n){return null==n}function vc(n){return"number"==typeof n||cc(n)&&we(n)==Hn}function gc(n){if(!cc(n)||we(n)!=Yn)return!1;var t=El(n);if(null===t)return!0;var r=bl.call(t,"constructor")&&t.constructor;return"function"==typeof r&&r instanceof r&&dl.call(r)==jl}function yc(n){
  return ic(n)&&n>=-Wn&&n<=Wn}function dc(n){return"string"==typeof n||!bh(n)&&cc(n)&&we(n)==rt}function bc(n){return"symbol"==typeof n||cc(n)&&we(n)==et}function wc(n){return n===X}function mc(n){return cc(n)&&zs(n)==it}function xc(n){return cc(n)&&we(n)==ot}function jc(n){if(!n)return[];if(Hf(n))return dc(n)?G(n):Tu(n);if(Ul&&n[Ul])return D(n[Ul]());var t=zs(n);return(t==Gn?M:t==tt?P:ra)(n)}function Ac(n){if(!n)return 0===n?n:0;if(n=Ic(n),n===Sn||n===-Sn){return(n<0?-1:1)*Ln}return n===n?n:0}function kc(n){
  var t=Ac(n),r=t%1;return t===t?r?t-r:t:0}function Oc(n){return n?Mr(kc(n),0,Un):0}function Ic(n){if("number"==typeof n)return n;if(bc(n))return Cn;if(fc(n)){var t="function"==typeof n.valueOf?n.valueOf():n;n=fc(t)?t+"":t}if("string"!=typeof n)return 0===n?n:+n;n=R(n);var r=qt.test(n);return r||Kt.test(n)?Xr(n.slice(2),r?2:8):Pt.test(n)?Cn:+n}function Rc(n){return $u(n,qc(n))}function zc(n){return n?Mr(kc(n),-Wn,Wn):0===n?n:0}function Ec(n){return null==n?"":vu(n)}function Sc(n,t){var r=gs(n);return null==t?r:Cr(r,t);
  }function Wc(n,t){return v(n,mi(t,3),ue)}function Lc(n,t){return v(n,mi(t,3),oe)}function Cc(n,t){return null==n?n:bs(n,mi(t,3),qc)}function Uc(n,t){return null==n?n:ws(n,mi(t,3),qc)}function Bc(n,t){return n&&ue(n,mi(t,3))}function Tc(n,t){return n&&oe(n,mi(t,3))}function $c(n){return null==n?[]:fe(n,Pc(n))}function Dc(n){return null==n?[]:fe(n,qc(n))}function Mc(n,t,r){var e=null==n?X:_e(n,t);return e===X?r:e}function Fc(n,t){return null!=n&&Ri(n,t,xe)}function Nc(n,t){return null!=n&&Ri(n,t,je);
  }function Pc(n){return Hf(n)?Or(n):Me(n)}function qc(n){return Hf(n)?Or(n,!0):Fe(n)}function Zc(n,t){var r={};return t=mi(t,3),ue(n,function(n,e,u){Br(r,t(n,e,u),n)}),r}function Kc(n,t){var r={};return t=mi(t,3),ue(n,function(n,e,u){Br(r,e,t(n,e,u))}),r}function Vc(n,t){return Gc(n,Uf(mi(t)))}function Gc(n,t){if(null==n)return{};var r=c(di(n),function(n){return[n]});return t=mi(t),Ye(n,r,function(n,r){return t(n,r[0])})}function Hc(n,t,r){t=ku(t,n);var e=-1,u=t.length;for(u||(u=1,n=X);++e<u;){var i=null==n?X:n[no(t[e])];
  i===X&&(e=u,i=r),n=uc(i)?i.call(n):i}return n}function Jc(n,t,r){return null==n?n:fu(n,t,r)}function Yc(n,t,r,e){return e="function"==typeof e?e:X,null==n?n:fu(n,t,r,e)}function Qc(n,t,e){var u=bh(n),i=u||mh(n)||Oh(n);if(t=mi(t,4),null==e){var o=n&&n.constructor;e=i?u?new o:[]:fc(n)&&uc(o)?gs(El(n)):{}}return(i?r:ue)(n,function(n,r,u){return t(e,n,r,u)}),e}function Xc(n,t){return null==n||yu(n,t)}function na(n,t,r){return null==n?n:du(n,t,Au(r))}function ta(n,t,r,e){return e="function"==typeof e?e:X,
  null==n?n:du(n,t,Au(r),e)}function ra(n){return null==n?[]:E(n,Pc(n))}function ea(n){return null==n?[]:E(n,qc(n))}function ua(n,t,r){return r===X&&(r=t,t=X),r!==X&&(r=Ic(r),r=r===r?r:0),t!==X&&(t=Ic(t),t=t===t?t:0),Mr(Ic(n),t,r)}function ia(n,t,r){return t=Ac(t),r===X?(r=t,t=0):r=Ac(r),n=Ic(n),Ae(n,t,r)}function oa(n,t,r){if(r&&"boolean"!=typeof r&&Ui(n,t,r)&&(t=r=X),r===X&&("boolean"==typeof t?(r=t,t=X):"boolean"==typeof n&&(r=n,n=X)),n===X&&t===X?(n=0,t=1):(n=Ac(n),t===X?(t=n,n=0):t=Ac(t)),n>t){
  var e=n;n=t,t=e}if(r||n%1||t%1){var u=Ql();return Hl(n+u*(t-n+Qr("1e-"+((u+"").length-1))),t)}return tu(n,t)}function fa(n){return Qh(Ec(n).toLowerCase())}function ca(n){return n=Ec(n),n&&n.replace(Gt,ve).replace(Dr,"")}function aa(n,t,r){n=Ec(n),t=vu(t);var e=n.length;r=r===X?e:Mr(kc(r),0,e);var u=r;return r-=t.length,r>=0&&n.slice(r,u)==t}function la(n){return n=Ec(n),n&&At.test(n)?n.replace(xt,ge):n}function sa(n){return n=Ec(n),n&&Wt.test(n)?n.replace(St,"\\$&"):n}function ha(n,t,r){n=Ec(n),t=kc(t);
  var e=t?V(n):0;if(!t||e>=t)return n;var u=(t-e)/2;return ri(Nl(u),r)+n+ri(Fl(u),r)}function pa(n,t,r){n=Ec(n),t=kc(t);var e=t?V(n):0;return t&&e<t?n+ri(t-e,r):n}function _a(n,t,r){n=Ec(n),t=kc(t);var e=t?V(n):0;return t&&e<t?ri(t-e,r)+n:n}function va(n,t,r){return r||null==t?t=0:t&&(t=+t),Yl(Ec(n).replace(Lt,""),t||0)}function ga(n,t,r){return t=(r?Ui(n,t,r):t===X)?1:kc(t),eu(Ec(n),t)}function ya(){var n=arguments,t=Ec(n[0]);return n.length<3?t:t.replace(n[1],n[2])}function da(n,t,r){return r&&"number"!=typeof r&&Ui(n,t,r)&&(t=r=X),
  (r=r===X?Un:r>>>0)?(n=Ec(n),n&&("string"==typeof t||null!=t&&!Ah(t))&&(t=vu(t),!t&&T(n))?Ou(G(n),0,r):n.split(t,r)):[]}function ba(n,t,r){return n=Ec(n),r=null==r?0:Mr(kc(r),0,n.length),t=vu(t),n.slice(r,r+t.length)==t}function wa(n,t,r){var e=Z.templateSettings;r&&Ui(n,t,r)&&(t=X),n=Ec(n),t=Sh({},t,e,li);var u,i,o=Sh({},t.imports,e.imports,li),f=Pc(o),c=E(o,f),a=0,l=t.interpolate||Ht,s="__p += '",h=sl((t.escape||Ht).source+"|"+l.source+"|"+(l===It?Ft:Ht).source+"|"+(t.evaluate||Ht).source+"|$","g"),p="//# sourceURL="+(bl.call(t,"sourceURL")?(t.sourceURL+"").replace(/\s/g," "):"toolkit.templateSources["+ ++Zr+"]")+"\n";
  n.replace(h,function(t,r,e,o,f,c){return e||(e=o),s+=n.slice(a,c).replace(Jt,U),r&&(u=!0,s+="' +\n__e("+r+") +\n'"),f&&(i=!0,s+="';\n"+f+";\n__p += '"),e&&(s+="' +\n((__t = ("+e+")) == null ? '' : __t) +\n'"),a=c+t.length,t}),s+="';\n";var _=bl.call(t,"variable")&&t.variable;if(_){if(Dt.test(_))throw new fl(un)}else s="with (obj) {\n"+s+"\n}\n";s=(i?s.replace(dt,""):s).replace(bt,"$1").replace(wt,"$1;"),s="function("+(_||"obj")+") {\n"+(_?"":"obj || (obj = {});\n")+"var __t, __p = ''"+(u?", __e = _.escape":"")+(i?", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n":";\n")+s+"return __p\n}";
  var v=Xh(function(){return cl(f,p+"return "+s).apply(X,c)});if(v.source=s,rc(v))throw v;return v}function ma(n){return Ec(n).toLowerCase()}function xa(n){return Ec(n).toUpperCase()}function ja(n,t,r){if(n=Ec(n),n&&(r||t===X))return R(n);if(!n||!(t=vu(t)))return n;var e=G(n),u=G(t);return Ou(e,W(e,u),L(e,u)+1).join("")}function Aa(n,t,r){if(n=Ec(n),n&&(r||t===X))return n.slice(0,H(n)+1);if(!n||!(t=vu(t)))return n;var e=G(n);return Ou(e,0,L(e,G(t))+1).join("")}function ka(n,t,r){if(n=Ec(n),n&&(r||t===X))return n.replace(Lt,"");
  if(!n||!(t=vu(t)))return n;var e=G(n);return Ou(e,W(e,G(t))).join("")}function Oa(n,t){var r=An,e=kn;if(fc(t)){var u="separator"in t?t.separator:u;r="length"in t?kc(t.length):r,e="omission"in t?vu(t.omission):e}n=Ec(n);var i=n.length;if(T(n)){var o=G(n);i=o.length}if(r>=i)return n;var f=r-V(e);if(f<1)return e;var c=o?Ou(o,0,f).join(""):n.slice(0,f);if(u===X)return c+e;if(o&&(f+=c.length-f),Ah(u)){if(n.slice(f).search(u)){var a,l=c;for(u.global||(u=sl(u.source,Ec(Nt.exec(u))+"g")),u.lastIndex=0;a=u.exec(l);)var s=a.index;
  c=c.slice(0,s===X?f:s)}}else if(n.indexOf(vu(u),f)!=f){var h=c.lastIndexOf(u);h>-1&&(c=c.slice(0,h))}return c+e}function Ia(n){return n=Ec(n),n&&jt.test(n)?n.replace(mt,ye):n}function Ra(n,t,r){return n=Ec(n),t=r?X:t,t===X?$(n)?Q(n):_(n):n.match(t)||[]}function za(t){var r=null==t?0:t.length,e=mi();return t=r?c(t,function(n){if("function"!=typeof n[1])throw new pl(en);return[e(n[0]),n[1]]}):[],uu(function(e){for(var u=-1;++u<r;){var i=t[u];if(n(i[0],this,e))return n(i[1],this,e)}})}function Ea(n){
  return Nr(Fr(n,an))}function Sa(n){return function(){return n}}function Wa(n,t){return null==n||n!==n?t:n}function La(n){return n}function Ca(n){return De("function"==typeof n?n:Fr(n,an))}function Ua(n){return qe(Fr(n,an))}function Ba(n,t){return Ze(n,Fr(t,an))}function Ta(n,t,e){var u=Pc(t),i=fe(t,u);null!=e||fc(t)&&(i.length||!u.length)||(e=t,t=n,n=this,i=fe(t,Pc(t)));var o=!(fc(e)&&"chain"in e&&!e.chain),f=uc(n);return r(i,function(r){var e=t[r];n[r]=e,f&&(n.prototype[r]=function(){var t=this.__chain__;
  if(o||t){var r=n(this.__wrapped__);return(r.__actions__=Tu(this.__actions__)).push({func:e,args:arguments,thisArg:n}),r.__chain__=t,r}return e.apply(n,a([this.value()],arguments))})}),n}function $a(){return re._===this&&(re._=Al),this}function Da(){}function Ma(n){return n=kc(n),uu(function(t){return Ge(t,n)})}function Fa(n){return Bi(n)?m(no(n)):Qe(n)}function Na(n){return function(t){return null==n?X:_e(n,t)}}function Pa(){return[]}function qa(){return!1}function Za(){return{}}function Ka(){return"";
  }function Va(){return!0}function Ga(n,t){if(n=kc(n),n<1||n>Wn)return[];var r=Un,e=Hl(n,Un);t=mi(t),n-=Un;for(var u=O(e,t);++r<n;)t(r);return u}function Ha(n){return bh(n)?c(n,no):bc(n)?[n]:Tu(Cs(Ec(n)))}function Ja(n){var t=++wl;return Ec(n)+t}function Ya(n){return n&&n.length?Yr(n,La,me):X}function Qa(n,t){return n&&n.length?Yr(n,mi(t,2),me):X}function Xa(n){return w(n,La)}function nl(n,t){return w(n,mi(t,2))}function tl(n){return n&&n.length?Yr(n,La,Ne):X}function rl(n,t){return n&&n.length?Yr(n,mi(t,2),Ne):X;
  }function el(n){return n&&n.length?k(n,La):0}function ul(n,t){return n&&n.length?k(n,mi(t,2)):0}x=null==x?re:be.defaults(re.Object(),x,be.pick(re,qr));var il=x.Array,ol=x.Date,fl=x.Error,cl=x.Function,al=x.Math,ll=x.Object,sl=x.RegExp,hl=x.String,pl=x.TypeError,_l=il.prototype,vl=cl.prototype,gl=ll.prototype,yl=x["__core-js_shared__"],dl=vl.toString,bl=gl.hasOwnProperty,wl=0,ml=function(){var n=/[^.]+$/.exec(yl&&yl.keys&&yl.keys.IE_PROTO||"");return n?"Symbol(src)_1."+n:""}(),xl=gl.toString,jl=dl.call(ll),Al=re._,kl=sl("^"+dl.call(bl).replace(St,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),Ol=ie?x.Buffer:X,Il=x.Symbol,Rl=x.Uint8Array,zl=Ol?Ol.allocUnsafe:X,El=F(ll.getPrototypeOf,ll),Sl=ll.create,Wl=gl.propertyIsEnumerable,Ll=_l.splice,Cl=Il?Il.isConcatSpreadable:X,Ul=Il?Il.iterator:X,Bl=Il?Il.toStringTag:X,Tl=function(){
  try{var n=Ai(ll,"defineProperty");return n({},"",{}),n}catch(n){}}(),$l=x.clearTimeout!==re.clearTimeout&&x.clearTimeout,Dl=ol&&ol.now!==re.Date.now&&ol.now,Ml=x.setTimeout!==re.setTimeout&&x.setTimeout,Fl=al.ceil,Nl=al.floor,Pl=ll.getOwnPropertySymbols,ql=Ol?Ol.isBuffer:X,Zl=x.isFinite,Kl=_l.join,Vl=F(ll.keys,ll),Gl=al.max,Hl=al.min,Jl=ol.now,Yl=x.parseInt,Ql=al.random,Xl=_l.reverse,ns=Ai(x,"DataView"),ts=Ai(x,"Map"),rs=Ai(x,"Promise"),es=Ai(x,"Set"),us=Ai(x,"WeakMap"),is=Ai(ll,"create"),os=us&&new us,fs={},cs=to(ns),as=to(ts),ls=to(rs),ss=to(es),hs=to(us),ps=Il?Il.prototype:X,_s=ps?ps.valueOf:X,vs=ps?ps.toString:X,gs=function(){
  function n(){}return function(t){if(!fc(t))return{};if(Sl)return Sl(t);n.prototype=t;var r=new n;return n.prototype=X,r}}();Z.templateSettings={escape:kt,evaluate:Ot,interpolate:It,variable:"",imports:{_:Z}},Z.prototype=J.prototype,Z.prototype.constructor=Z,Y.prototype=gs(J.prototype),Y.prototype.constructor=Y,Ct.prototype=gs(J.prototype),Ct.prototype.constructor=Ct,Xt.prototype.clear=nr,Xt.prototype.delete=tr,Xt.prototype.get=rr,Xt.prototype.has=er,Xt.prototype.set=ur,ir.prototype.clear=or,ir.prototype.delete=fr,
  ir.prototype.get=cr,ir.prototype.has=ar,ir.prototype.set=lr,sr.prototype.clear=hr,sr.prototype.delete=pr,sr.prototype.get=_r,sr.prototype.has=vr,sr.prototype.set=gr,yr.prototype.add=yr.prototype.push=dr,yr.prototype.has=br,wr.prototype.clear=mr,wr.prototype.delete=xr,wr.prototype.get=jr,wr.prototype.has=Ar,wr.prototype.set=kr;var ys=Pu(ue),ds=Pu(oe,!0),bs=qu(),ws=qu(!0),ms=os?function(n,t){return os.set(n,t),n}:La,xs=Tl?function(n,t){return Tl(n,"toString",{configurable:!0,enumerable:!1,value:Sa(t),
  writable:!0})}:La,js=uu,As=$l||function(n){return re.clearTimeout(n)},ks=es&&1/P(new es([,-0]))[1]==Sn?function(n){return new es(n)}:Da,Os=os?function(n){return os.get(n)}:Da,Is=Pl?function(n){return null==n?[]:(n=ll(n),i(Pl(n),function(t){return Wl.call(n,t)}))}:Pa,Rs=Pl?function(n){for(var t=[];n;)a(t,Is(n)),n=El(n);return t}:Pa,zs=we;(ns&&zs(new ns(new ArrayBuffer(1)))!=ct||ts&&zs(new ts)!=Gn||rs&&zs(rs.resolve())!=Qn||es&&zs(new es)!=tt||us&&zs(new us)!=it)&&(zs=function(n){var t=we(n),r=t==Yn?n.constructor:X,e=r?to(r):"";
  if(e)switch(e){case cs:return ct;case as:return Gn;case ls:return Qn;case ss:return tt;case hs:return it}return t});var Es=yl?uc:qa,Ss=Qi(ms),Ws=Ml||function(n,t){return re.setTimeout(n,t)},Ls=Qi(xs),Cs=Pi(function(n){var t=[];return 46===n.charCodeAt(0)&&t.push(""),n.replace(Et,function(n,r,e,u){t.push(e?u.replace(Mt,"$1"):r||n)}),t}),Us=uu(function(n,t){return Jf(n)?Hr(n,ee(t,1,Jf,!0)):[]}),Bs=uu(function(n,t){var r=jo(t);return Jf(r)&&(r=X),Jf(n)?Hr(n,ee(t,1,Jf,!0),mi(r,2)):[]}),Ts=uu(function(n,t){
  var r=jo(t);return Jf(r)&&(r=X),Jf(n)?Hr(n,ee(t,1,Jf,!0),X,r):[]}),$s=uu(function(n){var t=c(n,ju);return t.length&&t[0]===n[0]?ke(t):[]}),Ds=uu(function(n){var t=jo(n),r=c(n,ju);return t===jo(r)?t=X:r.pop(),r.length&&r[0]===n[0]?ke(r,mi(t,2)):[]}),Ms=uu(function(n){var t=jo(n),r=c(n,ju);return t="function"==typeof t?t:X,t&&r.pop(),r.length&&r[0]===n[0]?ke(r,X,t):[]}),Fs=uu(Oo),Ns=gi(function(n,t){var r=null==n?0:n.length,e=Tr(n,t);return nu(n,c(t,function(n){return Ci(n,r)?+n:n}).sort(Lu)),e}),Ps=uu(function(n){
  return gu(ee(n,1,Jf,!0))}),qs=uu(function(n){var t=jo(n);return Jf(t)&&(t=X),gu(ee(n,1,Jf,!0),mi(t,2))}),Zs=uu(function(n){var t=jo(n);return t="function"==typeof t?t:X,gu(ee(n,1,Jf,!0),X,t)}),Ks=uu(function(n,t){return Jf(n)?Hr(n,t):[]}),Vs=uu(function(n){return mu(i(n,Jf))}),Gs=uu(function(n){var t=jo(n);return Jf(t)&&(t=X),mu(i(n,Jf),mi(t,2))}),Hs=uu(function(n){var t=jo(n);return t="function"==typeof t?t:X,mu(i(n,Jf),X,t)}),Js=uu(Go),Ys=uu(function(n){var t=n.length,r=t>1?n[t-1]:X;return r="function"==typeof r?(n.pop(),
  r):X,Ho(n,r)}),Qs=gi(function(n){var t=n.length,r=t?n[0]:0,e=this.__wrapped__,u=function(t){return Tr(t,n)};return!(t>1||this.__actions__.length)&&e instanceof Ct&&Ci(r)?(e=e.slice(r,+r+(t?1:0)),e.__actions__.push({func:nf,args:[u],thisArg:X}),new Y(e,this.__chain__).thru(function(n){return t&&!n.length&&n.push(X),n})):this.thru(u)}),Xs=Fu(function(n,t,r){bl.call(n,r)?++n[r]:Br(n,r,1)}),nh=Ju(ho),th=Ju(po),rh=Fu(function(n,t,r){bl.call(n,r)?n[r].push(t):Br(n,r,[t])}),eh=uu(function(t,r,e){var u=-1,i="function"==typeof r,o=Hf(t)?il(t.length):[];
  return ys(t,function(t){o[++u]=i?n(r,t,e):Ie(t,r,e)}),o}),uh=Fu(function(n,t,r){Br(n,r,t)}),ih=Fu(function(n,t,r){n[r?0:1].push(t)},function(){return[[],[]]}),oh=uu(function(n,t){if(null==n)return[];var r=t.length;return r>1&&Ui(n,t[0],t[1])?t=[]:r>2&&Ui(t[0],t[1],t[2])&&(t=[t[0]]),He(n,ee(t,1),[])}),fh=Dl||function(){return re.Date.now()},ch=uu(function(n,t,r){var e=_n;if(r.length){var u=N(r,wi(ch));e|=bn}return ai(n,e,t,r,u)}),ah=uu(function(n,t,r){var e=_n|vn;if(r.length){var u=N(r,wi(ah));e|=bn;
  }return ai(t,e,n,r,u)}),lh=uu(function(n,t){return Gr(n,1,t)}),sh=uu(function(n,t,r){return Gr(n,Ic(t)||0,r)});Cf.Cache=sr;var hh=js(function(t,r){r=1==r.length&&bh(r[0])?c(r[0],z(mi())):c(ee(r,1),z(mi()));var e=r.length;return uu(function(u){for(var i=-1,o=Hl(u.length,e);++i<o;)u[i]=r[i].call(this,u[i]);return n(t,this,u)})}),ph=uu(function(n,t){return ai(n,bn,X,t,N(t,wi(ph)))}),_h=uu(function(n,t){return ai(n,wn,X,t,N(t,wi(_h)))}),vh=gi(function(n,t){return ai(n,xn,X,X,X,t)}),gh=ii(me),yh=ii(function(n,t){
  return n>=t}),dh=Re(function(){return arguments}())?Re:function(n){return cc(n)&&bl.call(n,"callee")&&!Wl.call(n,"callee")},bh=il.isArray,wh=ce?z(ce):ze,mh=ql||qa,xh=ae?z(ae):Ee,jh=le?z(le):Le,Ah=se?z(se):Be,kh=he?z(he):Te,Oh=pe?z(pe):$e,Ih=ii(Ne),Rh=ii(function(n,t){return n<=t}),zh=Nu(function(n,t){if(Mi(t)||Hf(t))return $u(t,Pc(t),n),X;for(var r in t)bl.call(t,r)&&Sr(n,r,t[r])}),Eh=Nu(function(n,t){$u(t,qc(t),n)}),Sh=Nu(function(n,t,r,e){$u(t,qc(t),n,e)}),Wh=Nu(function(n,t,r,e){$u(t,Pc(t),n,e);
  }),Lh=gi(Tr),Ch=uu(function(n,t){n=ll(n);var r=-1,e=t.length,u=e>2?t[2]:X;for(u&&Ui(t[0],t[1],u)&&(e=1);++r<e;)for(var i=t[r],o=qc(i),f=-1,c=o.length;++f<c;){var a=o[f],l=n[a];(l===X||Gf(l,gl[a])&&!bl.call(n,a))&&(n[a]=i[a])}return n}),Uh=uu(function(t){return t.push(X,si),n(Mh,X,t)}),Bh=Xu(function(n,t,r){null!=t&&"function"!=typeof t.toString&&(t=xl.call(t)),n[t]=r},Sa(La)),Th=Xu(function(n,t,r){null!=t&&"function"!=typeof t.toString&&(t=xl.call(t)),bl.call(n,t)?n[t].push(r):n[t]=[r]},mi),$h=uu(Ie),Dh=Nu(function(n,t,r){
  Ke(n,t,r)}),Mh=Nu(function(n,t,r,e){Ke(n,t,r,e)}),Fh=gi(function(n,t){var r={};if(null==n)return r;var e=!1;t=c(t,function(t){return t=ku(t,n),e||(e=t.length>1),t}),$u(n,di(n),r),e&&(r=Fr(r,an|ln|sn,hi));for(var u=t.length;u--;)yu(r,t[u]);return r}),Nh=gi(function(n,t){return null==n?{}:Je(n,t)}),Ph=ci(Pc),qh=ci(qc),Zh=Vu(function(n,t,r){return t=t.toLowerCase(),n+(r?fa(t):t)}),Kh=Vu(function(n,t,r){return n+(r?"-":"")+t.toLowerCase()}),Vh=Vu(function(n,t,r){return n+(r?" ":"")+t.toLowerCase()}),Gh=Ku("toLowerCase"),Hh=Vu(function(n,t,r){
  return n+(r?"_":"")+t.toLowerCase()}),Jh=Vu(function(n,t,r){return n+(r?" ":"")+Qh(t)}),Yh=Vu(function(n,t,r){return n+(r?" ":"")+t.toUpperCase()}),Qh=Ku("toUpperCase"),Xh=uu(function(t,r){try{return n(t,X,r)}catch(n){return rc(n)?n:new fl(n)}}),np=gi(function(n,t){return r(t,function(t){t=no(t),Br(n,t,ch(n[t],n))}),n}),tp=Yu(),rp=Yu(!0),ep=uu(function(n,t){return function(r){return Ie(r,n,t)}}),up=uu(function(n,t){return function(r){return Ie(n,r,t)}}),ip=ti(c),op=ti(u),fp=ti(h),cp=ui(),ap=ui(!0),lp=ni(function(n,t){
  return n+t},0),sp=fi("ceil"),hp=ni(function(n,t){return n/t},1),pp=fi("floor"),_p=ni(function(n,t){return n*t},1),vp=fi("round"),gp=ni(function(n,t){return n-t},0);return Z.after=If,Z.ary=Rf,Z.assign=zh,Z.assignIn=Eh,Z.assignInWith=Sh,Z.assignWith=Wh,Z.at=Lh,Z.before=zf,Z.bind=ch,Z.bindAll=np,Z.bindKey=ah,Z.castArray=Nf,Z.chain=Qo,Z.chunk=uo,Z.compact=io,Z.concat=oo,Z.cond=za,Z.conforms=Ea,Z.constant=Sa,Z.countBy=Xs,Z.create=Sc,Z.curry=Ef,Z.curryRight=Sf,Z.debounce=Wf,Z.defaults=Ch,Z.defaultsDeep=Uh,
  Z.defer=lh,Z.delay=sh,Z.difference=Us,Z.differenceBy=Bs,Z.differenceWith=Ts,Z.drop=fo,Z.dropRight=co,Z.dropRightWhile=ao,Z.dropWhile=lo,Z.fill=so,Z.filter=lf,Z.flatMap=sf,Z.flatMapDeep=hf,Z.flatMapDepth=pf,Z.flatten=_o,Z.flattenDeep=vo,Z.flattenDepth=go,Z.flip=Lf,Z.flow=tp,Z.flowRight=rp,Z.fromPairs=yo,Z.functions=$c,Z.functionsIn=Dc,Z.groupBy=rh,Z.initial=mo,Z.intersection=$s,Z.intersectionBy=Ds,Z.intersectionWith=Ms,Z.invert=Bh,Z.invertBy=Th,Z.invokeMap=eh,Z.iteratee=Ca,Z.keyBy=uh,Z.keys=Pc,Z.keysIn=qc,
  Z.map=yf,Z.mapKeys=Zc,Z.mapValues=Kc,Z.matches=Ua,Z.matchesProperty=Ba,Z.memoize=Cf,Z.merge=Dh,Z.mergeWith=Mh,Z.method=ep,Z.methodOf=up,Z.mixin=Ta,Z.negate=Uf,Z.nthArg=Ma,Z.omit=Fh,Z.omitBy=Vc,Z.once=Bf,Z.orderBy=df,Z.over=ip,Z.overArgs=hh,Z.overEvery=op,Z.overSome=fp,Z.partial=ph,Z.partialRight=_h,Z.partition=ih,Z.pick=Nh,Z.pickBy=Gc,Z.property=Fa,Z.propertyOf=Na,Z.pull=Fs,Z.pullAll=Oo,Z.pullAllBy=Io,Z.pullAllWith=Ro,Z.pullAt=Ns,Z.range=cp,Z.rangeRight=ap,Z.rearg=vh,Z.reject=mf,Z.remove=zo,Z.rest=Tf,
  Z.reverse=Eo,Z.sampleSize=jf,Z.set=Jc,Z.setWith=Yc,Z.shuffle=Af,Z.slice=So,Z.sortBy=oh,Z.sortedUniq=$o,Z.sortedUniqBy=Do,Z.split=da,Z.spread=$f,Z.tail=Mo,Z.take=Fo,Z.takeRight=No,Z.takeRightWhile=Po,Z.takeWhile=qo,Z.tap=Xo,Z.throttle=Df,Z.thru=nf,Z.toArray=jc,Z.toPairs=Ph,Z.toPairsIn=qh,Z.toPath=Ha,Z.toPlainObject=Rc,Z.transform=Qc,Z.unary=Mf,Z.union=Ps,Z.unionBy=qs,Z.unionWith=Zs,Z.uniq=Zo,Z.uniqBy=Ko,Z.uniqWith=Vo,Z.unset=Xc,Z.unzip=Go,Z.unzipWith=Ho,Z.update=na,Z.updateWith=ta,Z.values=ra,Z.valuesIn=ea,
  Z.without=Ks,Z.words=Ra,Z.wrap=Ff,Z.xor=Vs,Z.xorBy=Gs,Z.xorWith=Hs,Z.zip=Js,Z.zipObject=Jo,Z.zipObjectDeep=Yo,Z.zipWith=Ys,Z.entries=Ph,Z.entriesIn=qh,Z.extend=Eh,Z.extendWith=Sh,Ta(Z,Z),Z.add=lp,Z.attempt=Xh,Z.camelCase=Zh,Z.capitalize=fa,Z.ceil=sp,Z.clamp=ua,Z.clone=Pf,Z.cloneDeep=Zf,Z.cloneDeepWith=Kf,Z.cloneWith=qf,Z.conformsTo=Vf,Z.deburr=ca,Z.defaultTo=Wa,Z.divide=hp,Z.endsWith=aa,Z.eq=Gf,Z.escape=la,Z.escapeRegExp=sa,Z.every=af,Z.find=nh,Z.findIndex=ho,Z.findKey=Wc,Z.findLast=th,Z.findLastIndex=po,
  Z.findLastKey=Lc,Z.floor=pp,Z.forEach=_f,Z.forEachRight=vf,Z.forIn=Cc,Z.forInRight=Uc,Z.forOwn=Bc,Z.forOwnRight=Tc,Z.get=Mc,Z.gt=gh,Z.gte=yh,Z.has=Fc,Z.hasIn=Nc,Z.head=bo,Z.identity=La,Z.includes=gf,Z.indexOf=wo,Z.inRange=ia,Z.invoke=$h,Z.isArguments=dh,Z.isArray=bh,Z.isArrayBuffer=wh,Z.isArrayLike=Hf,Z.isArrayLikeObject=Jf,Z.isBoolean=Yf,Z.isBuffer=mh,Z.isDate=xh,Z.isElement=Qf,Z.isEmpty=Xf,Z.isEqual=nc,Z.isEqualWith=tc,Z.isError=rc,Z.isFinite=ec,Z.isFunction=uc,Z.isInteger=ic,Z.isLength=oc,Z.isMap=jh,
  Z.isMatch=ac,Z.isMatchWith=lc,Z.isNaN=sc,Z.isNative=hc,Z.isNil=_c,Z.isNull=pc,Z.isNumber=vc,Z.isObject=fc,Z.isObjectLike=cc,Z.isPlainObject=gc,Z.isRegExp=Ah,Z.isSafeInteger=yc,Z.isSet=kh,Z.isString=dc,Z.isSymbol=bc,Z.isTypedArray=Oh,Z.isUndefined=wc,Z.isWeakMap=mc,Z.isWeakSet=xc,Z.join=xo,Z.kebabCase=Kh,Z.last=jo,Z.lastIndexOf=Ao,Z.lowerCase=Vh,Z.lowerFirst=Gh,Z.lt=Ih,Z.lte=Rh,Z.max=Ya,Z.maxBy=Qa,Z.mean=Xa,Z.meanBy=nl,Z.min=tl,Z.minBy=rl,Z.stubArray=Pa,Z.stubFalse=qa,Z.stubObject=Za,Z.stubString=Ka,
  Z.stubTrue=Va,Z.multiply=_p,Z.nth=ko,Z.noConflict=$a,Z.noop=Da,Z.now=fh,Z.pad=ha,Z.padEnd=pa,Z.padStart=_a,Z.parseInt=va,Z.random=oa,Z.reduce=bf,Z.reduceRight=wf,Z.repeat=ga,Z.replace=ya,Z.result=Hc,Z.round=vp,Z.runInContext=p,Z.sample=xf,Z.size=kf,Z.snakeCase=Hh,Z.some=Of,Z.sortedIndex=Wo,Z.sortedIndexBy=Lo,Z.sortedIndexOf=Co,Z.sortedLastIndex=Uo,Z.sortedLastIndexBy=Bo,Z.sortedLastIndexOf=To,Z.startCase=Jh,Z.startsWith=ba,Z.subtract=gp,Z.sum=el,Z.sumBy=ul,Z.template=wa,Z.times=Ga,Z.toFinite=Ac,Z.toInteger=kc,
  Z.toLength=Oc,Z.toLower=ma,Z.toNumber=Ic,Z.toSafeInteger=zc,Z.toString=Ec,Z.toUpper=xa,Z.trim=ja,Z.trimEnd=Aa,Z.trimStart=ka,Z.truncate=Oa,Z.unescape=Ia,Z.uniqueId=Ja,Z.upperCase=Yh,Z.upperFirst=Qh,Z.each=_f,Z.eachRight=vf,Z.first=bo,Ta(Z,function(){var n={};return ue(Z,function(t,r){bl.call(Z.prototype,r)||(n[r]=t)}),n}(),{chain:!1}),Z.VERSION=nn,r(["bind","bindKey","curry","curryRight","partial","partialRight"],function(n){Z[n].placeholder=Z}),r(["drop","take"],function(n,t){Ct.prototype[n]=function(r){
  r=r===X?1:Gl(kc(r),0);var e=this.__filtered__&&!t?new Ct(this):this.clone();return e.__filtered__?e.__takeCount__=Hl(r,e.__takeCount__):e.__views__.push({size:Hl(r,Un),type:n+(e.__dir__<0?"Right":"")}),e},Ct.prototype[n+"Right"]=function(t){return this.reverse()[n](t).reverse()}}),r(["filter","map","takeWhile"],function(n,t){var r=t+1,e=r==Rn||r==En;Ct.prototype[n]=function(n){var t=this.clone();return t.__iteratees__.push({iteratee:mi(n,3),type:r}),t.__filtered__=t.__filtered__||e,t}}),r(["head","last"],function(n,t){
  var r="take"+(t?"Right":"");Ct.prototype[n]=function(){return this[r](1).value()[0]}}),r(["initial","tail"],function(n,t){var r="drop"+(t?"":"Right");Ct.prototype[n]=function(){return this.__filtered__?new Ct(this):this[r](1)}}),Ct.prototype.compact=function(){return this.filter(La)},Ct.prototype.find=function(n){return this.filter(n).head()},Ct.prototype.findLast=function(n){return this.reverse().find(n)},Ct.prototype.invokeMap=uu(function(n,t){return"function"==typeof n?new Ct(this):this.map(function(r){
  return Ie(r,n,t)})}),Ct.prototype.reject=function(n){return this.filter(Uf(mi(n)))},Ct.prototype.slice=function(n,t){n=kc(n);var r=this;return r.__filtered__&&(n>0||t<0)?new Ct(r):(n<0?r=r.takeRight(-n):n&&(r=r.drop(n)),t!==X&&(t=kc(t),r=t<0?r.dropRight(-t):r.take(t-n)),r)},Ct.prototype.takeRightWhile=function(n){return this.reverse().takeWhile(n).reverse()},Ct.prototype.toArray=function(){return this.take(Un)},ue(Ct.prototype,function(n,t){var r=/^(?:filter|find|map|reject)|While$/.test(t),e=/^(?:head|last)$/.test(t),u=Z[e?"take"+("last"==t?"Right":""):t],i=e||/^find/.test(t);
  u&&(Z.prototype[t]=function(){var t=this.__wrapped__,o=e?[1]:arguments,f=t instanceof Ct,c=o[0],l=f||bh(t),s=function(n){var t=u.apply(Z,a([n],o));return e&&h?t[0]:t};l&&r&&"function"==typeof c&&1!=c.length&&(f=l=!1);var h=this.__chain__,p=!!this.__actions__.length,_=i&&!h,v=f&&!p;if(!i&&l){t=v?t:new Ct(this);var g=n.apply(t,o);return g.__actions__.push({func:nf,args:[s],thisArg:X}),new Y(g,h)}return _&&v?n.apply(this,o):(g=this.thru(s),_?e?g.value()[0]:g.value():g)})}),r(["pop","push","shift","sort","splice","unshift"],function(n){
  var t=_l[n],r=/^(?:push|sort|unshift)$/.test(n)?"tap":"thru",e=/^(?:pop|shift)$/.test(n);Z.prototype[n]=function(){var n=arguments;if(e&&!this.__chain__){var u=this.value();return t.apply(bh(u)?u:[],n)}return this[r](function(r){return t.apply(bh(r)?r:[],n)})}}),ue(Ct.prototype,function(n,t){var r=Z[t];if(r){var e=r.name+"";bl.call(fs,e)||(fs[e]=[]),fs[e].push({name:t,func:r})}}),fs[Qu(X,vn).name]=[{name:"wrapper",func:X}],Ct.prototype.clone=$t,Ct.prototype.reverse=Yt,Ct.prototype.value=Qt,Z.prototype.at=Qs,
  Z.prototype.chain=tf,Z.prototype.commit=rf,Z.prototype.next=ef,Z.prototype.plant=of,Z.prototype.reverse=ff,Z.prototype.toJSON=Z.prototype.valueOf=Z.prototype.value=cf,Z.prototype.first=Z.prototype.head,Ul&&(Z.prototype[Ul]=uf),Z},be=de();"function"==typeof define&&"object"==typeof define.amd&&define.amd?(re._=be,define(function(){return be})):ue?((ue.exports=be)._=be,ee._=be):re._=be}).call(this);

  !function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).bpHttp=t()}(this,(function(){"use strict";function e(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function t(t){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?e(Object(r),!0).forEach((function(e){a(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):e(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}function n(e){return n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},n(e)}function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function i(e,t,n){return t&&o(e.prototype,t),n&&o(e,n),Object.defineProperty(e,"prototype",{writable:!1}),e}function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){return c(e)||function(e,t){var n=null==e?null:"undefined"!=typeof Symbol&&e[Symbol.iterator]||e["@@iterator"];if(null==n)return;var r,o,i=[],a=!0,s=!1;try{for(n=n.call(e);!(a=(r=n.next()).done)&&(i.push(r.value),!t||i.length!==t);a=!0);}catch(e){s=!0,o=e}finally{try{a||null==n.return||n.return()}finally{if(s)throw o}}return i}(e,t)||l(e,t)||p()}function u(e){return function(e){if(Array.isArray(e))return d(e)}(e)||f(e)||l(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function c(e){if(Array.isArray(e))return e}function f(e){if("undefined"!=typeof Symbol&&null!=e[Symbol.iterator]||null!=e["@@iterator"])return Array.from(e)}function l(e,t){if(e){if("string"==typeof e)return d(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?d(e,t):void 0}}function d(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r}function p(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function h(e,t){return function(){return e.apply(t,arguments)}}var m,y=Object.prototype.toString,v=Object.getPrototypeOf,b=(m=Object.create(null),function(e){var t=y.call(e);return m[t]||(m[t]=t.slice(8,-1).toLowerCase())}),g=function(e){return e=e.toLowerCase(),function(t){return b(t)===e}},w=function(e){return function(t){return n(t)===e}},O=Array.isArray,E=w("undefined");var S=g("ArrayBuffer");var R=w("string"),A=w("function"),j=w("number"),T=function(e){return null!==e&&"object"===n(e)},P=function(e){if("object"!==b(e))return!1;var t=v(e);return!(null!==t&&t!==Object.prototype&&null!==Object.getPrototypeOf(t)||Symbol.toStringTag in e||Symbol.iterator in e)},N=g("Date"),x=g("File"),C=g("Blob"),k=g("FileList"),_=g("URLSearchParams");function F(e,t){var r,o,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=i.allOwnKeys,s=void 0!==a&&a;if(null!=e)if("object"!==n(e)&&(e=[e]),O(e))for(r=0,o=e.length;r<o;r++)t.call(null,e[r],r,e);else{var u,c=s?Object.getOwnPropertyNames(e):Object.keys(e),f=c.length;for(r=0;r<f;r++)u=c[r],t.call(null,e[u],u,e)}}function U(e,t){t=t.toLowerCase();for(var n,r=Object.keys(e),o=r.length;o-- >0;)if(t===(n=r[o]).toLowerCase())return n;return null}var D="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof self?self:"undefined"!=typeof window?window:global,B=function(e){return!E(e)&&e!==D};var L,I=(L="undefined"!=typeof Uint8Array&&v(Uint8Array),function(e){return L&&e instanceof L}),q=g("HTMLFormElement"),z=function(e){var t=Object.prototype.hasOwnProperty;return function(e,n){return t.call(e,n)}}(),M=g("RegExp"),H=function(e,t){var n=Object.getOwnPropertyDescriptors(e),r={};F(n,(function(n,o){var i;!1!==(i=t(n,o,e))&&(r[o]=i||n)})),Object.defineProperties(e,r)},J="abcdefghijklmnopqrstuvwxyz",W="0123456789",K={DIGIT:W,ALPHA:J,ALPHA_DIGIT:J+J.toUpperCase()+W};var V=g("AsyncFunction"),G={isArray:O,isArrayBuffer:S,isBuffer:function(e){return null!==e&&!E(e)&&null!==e.constructor&&!E(e.constructor)&&A(e.constructor.isBuffer)&&e.constructor.isBuffer(e)},isFormData:function(e){var t;return e&&("function"==typeof FormData&&e instanceof FormData||A(e.append)&&("formdata"===(t=b(e))||"object"===t&&A(e.toString)&&"[object FormData]"===e.toString()))},isArrayBufferView:function(e){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(e):e&&e.buffer&&S(e.buffer)},isString:R,isNumber:j,isBoolean:function(e){return!0===e||!1===e},isObject:T,isPlainObject:P,isUndefined:E,isDate:N,isFile:x,isBlob:C,isRegExp:M,isFunction:A,isStream:function(e){return T(e)&&A(e.pipe)},isURLSearchParams:_,isTypedArray:I,isFileList:k,forEach:F,merge:function e(){for(var t=B(this)&&this||{},n=t.caseless,r={},o=function(t,o){var i=n&&U(r,o)||o;P(r[i])&&P(t)?r[i]=e(r[i],t):P(t)?r[i]=e({},t):O(t)?r[i]=t.slice():r[i]=t},i=0,a=arguments.length;i<a;i++)arguments[i]&&F(arguments[i],o);return r},extend:function(e,t,n){var r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=r.allOwnKeys;return F(t,(function(t,r){n&&A(t)?e[r]=h(t,n):e[r]=t}),{allOwnKeys:o}),e},trim:function(e){return e.trim?e.trim():e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,"")},stripBOM:function(e){return 65279===e.charCodeAt(0)&&(e=e.slice(1)),e},inherits:function(e,t,n,r){e.prototype=Object.create(t.prototype,r),e.prototype.constructor=e,Object.defineProperty(e,"super",{value:t.prototype}),n&&Object.assign(e.prototype,n)},toFlatObject:function(e,t,n,r){var o,i,a,s={};if(t=t||{},null==e)return t;do{for(i=(o=Object.getOwnPropertyNames(e)).length;i-- >0;)a=o[i],r&&!r(a,e,t)||s[a]||(t[a]=e[a],s[a]=!0);e=!1!==n&&v(e)}while(e&&(!n||n(e,t))&&e!==Object.prototype);return t},kindOf:b,kindOfTest:g,endsWith:function(e,t,n){e=String(e),(void 0===n||n>e.length)&&(n=e.length),n-=t.length;var r=e.indexOf(t,n);return-1!==r&&r===n},toArray:function(e){if(!e)return null;if(O(e))return e;var t=e.length;if(!j(t))return null;for(var n=new Array(t);t-- >0;)n[t]=e[t];return n},forEachEntry:function(e,t){for(var n,r=(e&&e[Symbol.iterator]).call(e);(n=r.next())&&!n.done;){var o=n.value;t.call(e,o[0],o[1])}},matchAll:function(e,t){for(var n,r=[];null!==(n=e.exec(t));)r.push(n);return r},isHTMLForm:q,hasOwnProperty:z,hasOwnProp:z,reduceDescriptors:H,freezeMethods:function(e){H(e,(function(t,n){if(A(e)&&-1!==["arguments","caller","callee"].indexOf(n))return!1;var r=e[n];A(r)&&(t.enumerable=!1,"writable"in t?t.writable=!1:t.set||(t.set=function(){throw Error("Can not rewrite read-only method '"+n+"'")}))}))},toObjectSet:function(e,t){var n={},r=function(e){e.forEach((function(e){n[e]=!0}))};return O(e)?r(e):r(String(e).split(t)),n},toCamelCase:function(e){return e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,(function(e,t,n){return t.toUpperCase()+n}))},noop:function(){},toFiniteNumber:function(e,t){return e=+e,Number.isFinite(e)?e:t},findKey:U,global:D,isContextDefined:B,ALPHABET:K,generateString:function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:16,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:K.ALPHA_DIGIT,n="",r=t.length;e--;)n+=t[Math.random()*r|0];return n},isSpecCompliantForm:function(e){return!!(e&&A(e.append)&&"FormData"===e[Symbol.toStringTag]&&e[Symbol.iterator])},toJSONObject:function(e){var t=new Array(10);return function e(n,r){if(T(n)){if(t.indexOf(n)>=0)return;if(!("toJSON"in n)){t[r]=n;var o=O(n)?[]:{};return F(n,(function(t,n){var i=e(t,r+1);!E(i)&&(o[n]=i)})),t[r]=void 0,o}}return n}(e,0)},isAsyncFn:V,isThenable:function(e){return e&&(T(e)||A(e))&&A(e.then)&&A(e.catch)}};function X(e,t,n,r,o){Error.call(this),Error.captureStackTrace?Error.captureStackTrace(this,this.constructor):this.stack=(new Error).stack,this.message=e,this.name="bpHttpError",t&&(this.code=t),n&&(this.config=n),r&&(this.request=r),o&&(this.response=o)}G.inherits(X,Error,{toJSON:function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:G.toJSONObject(this.config),code:this.code,status:this.response&&this.response.status?this.response.status:null}}});var $=X.prototype,Q={};["ERR_BAD_OPTION_VALUE","ERR_BAD_OPTION","ECONNABORTED","ETIMEDOUT","ERR_NETWORK","ERR_FR_TOO_MANY_REDIRECTS","ERR_DEPRECATED","ERR_BAD_RESPONSE","ERR_BAD_REQUEST","ERR_CANCELED","ERR_NOT_SUPPORT","ERR_INVALID_URL"].forEach((function(e){Q[e]={value:e}})),Object.defineProperties(X,Q),Object.defineProperty($,"isbpHttpError",{value:!0}),X.from=function(e,t,n,r,o,i){var a=Object.create($);return G.toFlatObject(e,a,(function(e){return e!==Error.prototype}),(function(e){return"isbpHttpError"!==e})),X.call(a,e.message,t,n,r,o),a.cause=e,a.name=e.name,i&&Object.assign(a,i),a};function Z(e){return G.isPlainObject(e)||G.isArray(e)}function Y(e){return G.endsWith(e,"[]")?e.slice(0,-2):e}function ee(e,t,n){return e?e.concat(t).map((function(e,t){return e=Y(e),!n&&t?"["+e+"]":e})).join(n?".":""):t}var te=G.toFlatObject(G,{},null,(function(e){return/^is[A-Z]/.test(e)}));function ne(e,t,r){if(!G.isObject(e))throw new TypeError("target must be an object");t=t||new FormData;var o=(r=G.toFlatObject(r,{metaTokens:!0,dots:!1,indexes:!1},!1,(function(e,t){return!G.isUndefined(t[e])}))).metaTokens,i=r.visitor||f,a=r.dots,s=r.indexes,u=(r.Blob||"undefined"!=typeof Blob&&Blob)&&G.isSpecCompliantForm(t);if(!G.isFunction(i))throw new TypeError("visitor must be a function");function c(e){if(null===e)return"";if(G.isDate(e))return e.toISOString();if(!u&&G.isBlob(e))throw new X("Blob is not supported. Use a Buffer instead.");return G.isArrayBuffer(e)||G.isTypedArray(e)?u&&"function"==typeof Blob?new Blob([e]):Buffer.from(e):e}function f(e,r,i){var u=e;if(e&&!i&&"object"===n(e))if(G.endsWith(r,"{}"))r=o?r:r.slice(0,-2),e=JSON.stringify(e);else if(G.isArray(e)&&function(e){return G.isArray(e)&&!e.some(Z)}(e)||(G.isFileList(e)||G.endsWith(r,"[]"))&&(u=G.toArray(e)))return r=Y(r),u.forEach((function(e,n){!G.isUndefined(e)&&null!==e&&t.append(!0===s?ee([r],n,a):null===s?r:r+"[]",c(e))})),!1;return!!Z(e)||(t.append(ee(i,r,a),c(e)),!1)}var l=[],d=Object.assign(te,{defaultVisitor:f,convertValue:c,isVisitable:Z});if(!G.isObject(e))throw new TypeError("data must be an object");return function e(n,r){if(!G.isUndefined(n)){if(-1!==l.indexOf(n))throw Error("Circular reference detected in "+r.join("."));l.push(n),G.forEach(n,(function(n,o){!0===(!(G.isUndefined(n)||null===n)&&i.call(t,n,G.isString(o)?o.trim():o,r,d))&&e(n,r?r.concat(o):[o])})),l.pop()}}(e),t}function re(e){var t={"!":"%21","'":"%27","(":"%28",")":"%29","~":"%7E","%20":"+","%00":"\0"};return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g,(function(e){return t[e]}))}function oe(e,t){this._pairs=[],e&&ne(e,this,t)}var ie=oe.prototype;function ae(e){return encodeURIComponent(e).replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}function se(e,t,n){if(!t)return e;var r,o=n&&n.encode||ae,i=n&&n.serialize;if(r=i?i(t,n):G.isURLSearchParams(t)?t.toString():new oe(t,n).toString(o)){var a=e.indexOf("#");-1!==a&&(e=e.slice(0,a)),e+=(-1===e.indexOf("?")?"?":"&")+r}return e}ie.append=function(e,t){this._pairs.push([e,t])},ie.toString=function(e){var t=e?function(t){return e.call(this,t,re)}:re;return this._pairs.map((function(e){return t(e[0])+"="+t(e[1])}),"").join("&")};var ue,ce=function(){function e(){r(this,e),this.handlers=[]}return i(e,[{key:"use",value:function(e,t,n){return this.handlers.push({fulfilled:e,rejected:t,synchronous:!!n&&n.synchronous,runWhen:n?n.runWhen:null}),this.handlers.length-1}},{key:"eject",value:function(e){this.handlers[e]&&(this.handlers[e]=null)}},{key:"clear",value:function(){this.handlers&&(this.handlers=[])}},{key:"forEach",value:function(e){G.forEach(this.handlers,(function(t){null!==t&&e(t)}))}}]),e}(),fe={silentJSONParsing:!0,forcedJSONParsing:!0,clarifyTimeoutError:!1},le={isBrowser:!0,classes:{URLSearchParams:"undefined"!=typeof URLSearchParams?URLSearchParams:oe,FormData:"undefined"!=typeof FormData?FormData:null,Blob:"undefined"!=typeof Blob?Blob:null},protocols:["http","https","file","blob","url","data"]},de="undefined"!=typeof window&&"undefined"!=typeof document,pe=(ue="undefined"!=typeof navigator&&navigator.product,de&&["ReactNative","NativeScript","NS"].indexOf(ue)<0),he="undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope&&"function"==typeof self.importScripts,me=t(t({},Object.freeze({__proto__:null,hasBrowserEnv:de,hasStandardBrowserWebWorkerEnv:he,hasStandardBrowserEnv:pe})),le);function ye(e){function t(e,n,r,o){var i=e[o++],a=Number.isFinite(+i),s=o>=e.length;return i=!i&&G.isArray(r)?r.length:i,s?(G.hasOwnProp(r,i)?r[i]=[r[i],n]:r[i]=n,!a):(r[i]&&G.isObject(r[i])||(r[i]=[]),t(e,n,r[i],o)&&G.isArray(r[i])&&(r[i]=function(e){var t,n,r={},o=Object.keys(e),i=o.length;for(t=0;t<i;t++)r[n=o[t]]=e[n];return r}(r[i])),!a)}if(G.isFormData(e)&&G.isFunction(e.entries)){var n={};return G.forEachEntry(e,(function(e,r){t(function(e){return G.matchAll(/\w+|\[(\w*)]/g,e).map((function(e){return"[]"===e[0]?"":e[1]||e[0]}))}(e),r,n,0)})),n}return null}var ve={transitional:fe,adapter:["xhr","http"],transformRequest:[function(e,t){var n,r=t.getContentType()||"",o=r.indexOf("application/json")>-1,i=G.isObject(e);if(i&&G.isHTMLForm(e)&&(e=new FormData(e)),G.isFormData(e))return o&&o?JSON.stringify(ye(e)):e;if(G.isArrayBuffer(e)||G.isBuffer(e)||G.isStream(e)||G.isFile(e)||G.isBlob(e))return e;if(G.isArrayBufferView(e))return e.buffer;if(G.isURLSearchParams(e))return t.setContentType("application/x-www-form-urlencoded;charset=utf-8",!1),e.toString();if(i){if(r.indexOf("application/x-www-form-urlencoded")>-1)return function(e,t){return ne(e,new me.classes.URLSearchParams,Object.assign({visitor:function(e,t,n,r){return me.isNode&&G.isBuffer(e)?(this.append(t,e.toString("base64")),!1):r.defaultVisitor.apply(this,arguments)}},t))}(e,this.formSerializer).toString();if((n=G.isFileList(e))||r.indexOf("multipart/form-data")>-1){var a=this.env&&this.env.FormData;return ne(n?{"files[]":e}:e,a&&new a,this.formSerializer)}}return i||o?(t.setContentType("application/json",!1),function(e,t,n){if(G.isString(e))try{return(t||JSON.parse)(e),G.trim(e)}catch(e){if("SyntaxError"!==e.name)throw e}return(n||JSON.stringify)(e)}(e)):e}],transformResponse:[function(e){var t=this.transitional||ve.transitional,n=t&&t.forcedJSONParsing,r="json"===this.responseType;if(e&&G.isString(e)&&(n&&!this.responseType||r)){var o=!(t&&t.silentJSONParsing)&&r;try{return JSON.parse(e)}catch(e){if(o){if("SyntaxError"===e.name)throw X.from(e,X.ERR_BAD_RESPONSE,this,null,this.response);throw e}}}return e}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,maxBodyLength:-1,env:{FormData:me.classes.FormData,Blob:me.classes.Blob},validateStatus:function(e){return e>=200&&e<300},headers:{common:{Accept:"application/json, text/plain, */*","Content-Type":void 0}}};G.forEach(["delete","get","head","post","put","patch"],(function(e){ve.headers[e]={}}));var be=ve,ge=G.toObjectSet(["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"]),we=Symbol("internals");function Oe(e){return e&&String(e).trim().toLowerCase()}function Ee(e){return!1===e||null==e?e:G.isArray(e)?e.map(Ee):String(e)}function Se(e,t,n,r,o){return G.isFunction(r)?r.call(this,t,n):(o&&(t=n),G.isString(t)?G.isString(r)?-1!==t.indexOf(r):G.isRegExp(r)?r.test(t):void 0:void 0)}var Re=function(e,t){function n(e){r(this,n),e&&this.set(e)}return i(n,[{key:"set",value:function(e,t,n){var r=this;function o(e,t,n){var o=Oe(t);if(!o)throw new Error("header name must be a non-empty string");var i=G.findKey(r,o);(!i||void 0===r[i]||!0===n||void 0===n&&!1!==r[i])&&(r[i||t]=Ee(e))}var i,a,s,u,c,f=function(e,t){return G.forEach(e,(function(e,n){return o(e,n,t)}))};return G.isPlainObject(e)||e instanceof this.constructor?f(e,t):G.isString(e)&&(e=e.trim())&&!/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim())?f((c={},(i=e)&&i.split("\n").forEach((function(e){u=e.indexOf(":"),a=e.substring(0,u).trim().toLowerCase(),s=e.substring(u+1).trim(),!a||c[a]&&ge[a]||("set-cookie"===a?c[a]?c[a].push(s):c[a]=[s]:c[a]=c[a]?c[a]+", "+s:s)})),c),t):null!=e&&o(t,e,n),this}},{key:"get",value:function(e,t){if(e=Oe(e)){var n=G.findKey(this,e);if(n){var r=this[n];if(!t)return r;if(!0===t)return function(e){for(var t,n=Object.create(null),r=/([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;t=r.exec(e);)n[t[1]]=t[2];return n}(r);if(G.isFunction(t))return t.call(this,r,n);if(G.isRegExp(t))return t.exec(r);throw new TypeError("parser must be boolean|regexp|function")}}}},{key:"has",value:function(e,t){if(e=Oe(e)){var n=G.findKey(this,e);return!(!n||void 0===this[n]||t&&!Se(0,this[n],n,t))}return!1}},{key:"delete",value:function(e,t){var n=this,r=!1;function o(e){if(e=Oe(e)){var o=G.findKey(n,e);!o||t&&!Se(0,n[o],o,t)||(delete n[o],r=!0)}}return G.isArray(e)?e.forEach(o):o(e),r}},{key:"clear",value:function(e){for(var t=Object.keys(this),n=t.length,r=!1;n--;){var o=t[n];e&&!Se(0,this[o],o,e,!0)||(delete this[o],r=!0)}return r}},{key:"normalize",value:function(e){var t=this,n={};return G.forEach(this,(function(r,o){var i=G.findKey(n,o);if(i)return t[i]=Ee(r),void delete t[o];var a=e?function(e){return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g,(function(e,t,n){return t.toUpperCase()+n}))}(o):String(o).trim();a!==o&&delete t[o],t[a]=Ee(r),n[a]=!0})),this}},{key:"concat",value:function(){for(var e,t=arguments.length,n=new Array(t),r=0;r<t;r++)n[r]=arguments[r];return(e=this.constructor).concat.apply(e,[this].concat(n))}},{key:"toJSON",value:function(e){var t=Object.create(null);return G.forEach(this,(function(n,r){null!=n&&!1!==n&&(t[r]=e&&G.isArray(n)?n.join(", "):n)})),t}},{key:Symbol.iterator,value:function(){return Object.entries(this.toJSON())[Symbol.iterator]()}},{key:"toString",value:function(){return Object.entries(this.toJSON()).map((function(e){var t=s(e,2);return t[0]+": "+t[1]})).join("\n")}},{key:Symbol.toStringTag,get:function(){return"bpHttpHeaders"}}],[{key:"from",value:function(e){return e instanceof this?e:new this(e)}},{key:"concat",value:function(e){for(var t=new this(e),n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];return r.forEach((function(e){return t.set(e)})),t}},{key:"accessor",value:function(e){var t=(this[we]=this[we]={accessors:{}}).accessors,n=this.prototype;function r(e){var r=Oe(e);t[r]||(!function(e,t){var n=G.toCamelCase(" "+t);["get","set","has"].forEach((function(r){Object.defineProperty(e,r+n,{value:function(e,n,o){return this[r].call(this,t,e,n,o)},configurable:!0})}))}(n,e),t[r]=!0)}return G.isArray(e)?e.forEach(r):r(e),this}}]),n}();Re.accessor(["Content-Type","Content-Length","Accept","Accept-Encoding","User-Agent","Authorization"]),G.reduceDescriptors(Re.prototype,(function(e,t){var n=e.value,r=t[0].toUpperCase()+t.slice(1);return{get:function(){return n},set:function(e){this[r]=e}}})),G.freezeMethods(Re);var Ae=Re;function je(e,t){var n=this||be,r=t||n,o=Ae.from(r.headers),i=r.data;return G.forEach(e,(function(e){i=e.call(n,i,o.normalize(),t?t.status:void 0)})),o.normalize(),i}function Te(e){return!(!e||!e.__CANCEL__)}function Pe(e,t,n){X.call(this,null==e?"canceled":e,X.ERR_CANCELED,t,n),this.name="CanceledError"}G.inherits(Pe,X,{__CANCEL__:!0});var Ne=me.hasStandardBrowserEnv?{write:function(e,t,n,r,o,i){var a=[e+"="+encodeURIComponent(t)];G.isNumber(n)&&a.push("expires="+new Date(n).toGMTString()),G.isString(r)&&a.push("path="+r),G.isString(o)&&a.push("domain="+o),!0===i&&a.push("secure"),document.cookie=a.join("; ")},read:function(e){var t=document.cookie.match(new RegExp("(^|;\\s*)("+e+")=([^;]*)"));return t?decodeURIComponent(t[3]):null},remove:function(e){this.write(e,"",Date.now()-864e5)}}:{write:function(){},read:function(){return null},remove:function(){}};function xe(e,t){return e&&!/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t)?function(e,t){return t?e.replace(/\/+$/,"")+"/"+t.replace(/^\/+/,""):e}(e,t):t}var Ce=me.hasStandardBrowserEnv?function(){var e,t=/(msie|trident)/i.test(navigator.userAgent),n=document.createElement("a");function r(e){var r=e;return t&&(n.setAttribute("href",r),r=n.href),n.setAttribute("href",r),{href:n.href,protocol:n.protocol?n.protocol.replace(/:$/,""):"",host:n.host,search:n.search?n.search.replace(/^\?/,""):"",hash:n.hash?n.hash.replace(/^#/,""):"",hostname:n.hostname,port:n.port,pathname:"/"===n.pathname.charAt(0)?n.pathname:"/"+n.pathname}}return e=r(window.location.href),function(t){var n=G.isString(t)?r(t):t;return n.protocol===e.protocol&&n.host===e.host}}():function(){return!0};function ke(e,t){var n=0,r=function(e,t){e=e||10;var n,r=new Array(e),o=new Array(e),i=0,a=0;return t=void 0!==t?t:1e3,function(s){var u=Date.now(),c=o[a];n||(n=u),r[i]=s,o[i]=u;for(var f=a,l=0;f!==i;)l+=r[f++],f%=e;if((i=(i+1)%e)===a&&(a=(a+1)%e),!(u-n<t)){var d=c&&u-c;return d?Math.round(1e3*l/d):void 0}}}(50,250);return function(o){var i=o.loaded,a=o.lengthComputable?o.total:void 0,s=i-n,u=r(s);n=i;var c={loaded:i,total:a,progress:a?i/a:void 0,bytes:s,rate:u||void 0,estimated:u&&a&&i<=a?(a-i)/u:void 0,event:o};c[t?"download":"upload"]=!0,e(c)}}var _e={http:null,xhr:"undefined"!=typeof XMLHttpRequest&&function(e){return new Promise((function(t,n){var r,o,i,a=e.data,s=Ae.from(e.headers).normalize(),d=e.responseType,h=e.withXSRFToken;function m(){e.cancelToken&&e.cancelToken.unsubscribe(r),e.signal&&e.signal.removeEventListener("abort",r)}if(G.isFormData(a))if(me.hasStandardBrowserEnv||me.hasStandardBrowserWebWorkerEnv)s.setContentType(!1);else if(!1!==(o=s.getContentType())){var y=o?o.split(";").map((function(e){return e.trim()})).filter(Boolean):[],v=c(i=y)||f(i)||l(i)||p(),b=v[0],g=v.slice(1);s.setContentType([b||"multipart/form-data"].concat(u(g)).join("; "))}var w=new XMLHttpRequest;if(e.auth){var O=e.auth.username||"",E=e.auth.password?unescape(encodeURIComponent(e.auth.password)):"";s.set("Authorization","Basic "+btoa(O+":"+E))}var S=xe(e.baseURL,e.url);function R(){if(w){var r=Ae.from("getAllResponseHeaders"in w&&w.getAllResponseHeaders());!function(e,t,n){var r=n.config.validateStatus;n.status&&r&&!r(n.status)?t(new X("Request failed with status code "+n.status,[X.ERR_BAD_REQUEST,X.ERR_BAD_RESPONSE][Math.floor(n.status/100)-4],n.config,n.request,n)):e(n)}((function(e){t(e),m()}),(function(e){n(e),m()}),{data:d&&"text"!==d&&"json"!==d?w.response:w.responseText,status:w.status,statusText:w.statusText,headers:r,config:e,request:w}),w=null}}if(w.open(e.method.toUpperCase(),se(S,e.params,e.paramsSerializer),!0),w.timeout=e.timeout,"onloadend"in w?w.onloadend=R:w.onreadystatechange=function(){w&&4===w.readyState&&(0!==w.status||w.responseURL&&0===w.responseURL.indexOf("file:"))&&setTimeout(R)},w.onabort=function(){w&&(n(new X("Request aborted",X.ECONNABORTED,e,w)),w=null)},w.onerror=function(){n(new X("Network Error",X.ERR_NETWORK,e,w)),w=null},w.ontimeout=function(){var t=e.timeout?"timeout of "+e.timeout+"ms exceeded":"timeout exceeded",r=e.transitional||fe;e.timeoutErrorMessage&&(t=e.timeoutErrorMessage),n(new X(t,r.clarifyTimeoutError?X.ETIMEDOUT:X.ECONNABORTED,e,w)),w=null},me.hasStandardBrowserEnv&&(h&&G.isFunction(h)&&(h=h(e)),h||!1!==h&&Ce(S))){var A=e.xsrfHeaderName&&e.xsrfCookieName&&Ne.read(e.xsrfCookieName);A&&s.set(e.xsrfHeaderName,A)}void 0===a&&s.setContentType(null),"setRequestHeader"in w&&G.forEach(s.toJSON(),(function(e,t){w.setRequestHeader(t,e)})),G.isUndefined(e.withCredentials)||(w.withCredentials=!!e.withCredentials),d&&"json"!==d&&(w.responseType=e.responseType),"function"==typeof e.onDownloadProgress&&w.addEventListener("progress",ke(e.onDownloadProgress,!0)),"function"==typeof e.onUploadProgress&&w.upload&&w.upload.addEventListener("progress",ke(e.onUploadProgress)),(e.cancelToken||e.signal)&&(r=function(t){w&&(n(!t||t.type?new Pe(null,e,w):t),w.abort(),w=null)},e.cancelToken&&e.cancelToken.subscribe(r),e.signal&&(e.signal.aborted?r():e.signal.addEventListener("abort",r)));var j,T=(j=/^([-+\w]{1,25})(:?\/\/|:)/.exec(S))&&j[1]||"";T&&-1===me.protocols.indexOf(T)?n(new X("Unsupported protocol "+T+":",X.ERR_BAD_REQUEST,e)):w.send(a||null)}))}};G.forEach(_e,(function(e,t){if(e){try{Object.defineProperty(e,"name",{value:t})}catch(e){}Object.defineProperty(e,"adapterName",{value:t})}}));var Fe=function(e){return"- ".concat(e)},Ue=function(e){return G.isFunction(e)||null===e||!1===e},De=function(e){for(var t,n,r=(e=G.isArray(e)?e:[e]).length,o={},i=0;i<r;i++){var a=void 0;if(n=t=e[i],!Ue(t)&&void 0===(n=_e[(a=String(t)).toLowerCase()]))throw new X("Unknown adapter '".concat(a,"'"));if(n)break;o[a||"#"+i]=n}if(!n){var u=Object.entries(o).map((function(e){var t=s(e,2),n=t[0],r=t[1];return"adapter ".concat(n," ")+(!1===r?"is not supported by the environment":"is not available in the build")}));throw new X("There is no suitable adapter to dispatch the request "+(r?u.length>1?"since :\n"+u.map(Fe).join("\n"):" "+Fe(u[0]):"as no adapter specified"),"ERR_NOT_SUPPORT")}return n};function Be(e){if(e.cancelToken&&e.cancelToken.throwIfRequested(),e.signal&&e.signal.aborted)throw new Pe(null,e)}function Le(e){return Be(e),e.headers=Ae.from(e.headers),e.data=je.call(e,e.transformRequest),-1!==["post","put","patch"].indexOf(e.method)&&e.headers.setContentType("application/x-www-form-urlencoded",!1),De(e.adapter||be.adapter)(e).then((function(t){return Be(e),t.data=je.call(e,e.transformResponse,t),t.headers=Ae.from(t.headers),t}),(function(t){return Te(t)||(Be(e),t&&t.response&&(t.response.data=je.call(e,e.transformResponse,t.response),t.response.headers=Ae.from(t.response.headers))),Promise.reject(t)}))}var Ie=function(e){return e instanceof Ae?e.toJSON():e};function qe(e,t){t=t||{};var n={};function r(e,t,n){return G.isPlainObject(e)&&G.isPlainObject(t)?G.merge.call({caseless:n},e,t):G.isPlainObject(t)?G.merge({},t):G.isArray(t)?t.slice():t}function o(e,t,n){return G.isUndefined(t)?G.isUndefined(e)?void 0:r(void 0,e,n):r(e,t,n)}function i(e,t){if(!G.isUndefined(t))return r(void 0,t)}function a(e,t){return G.isUndefined(t)?G.isUndefined(e)?void 0:r(void 0,e):r(void 0,t)}function s(n,o,i){return i in t?r(n,o):i in e?r(void 0,n):void 0}var u={url:i,method:i,data:i,baseURL:a,transformRequest:a,transformResponse:a,paramsSerializer:a,timeout:a,timeoutMessage:a,withCredentials:a,withXSRFToken:a,adapter:a,responseType:a,xsrfCookieName:a,xsrfHeaderName:a,onUploadProgress:a,onDownloadProgress:a,decompress:a,maxContentLength:a,maxBodyLength:a,beforeRedirect:a,transport:a,httpAgent:a,httpsAgent:a,cancelToken:a,socketPath:a,responseEncoding:a,validateStatus:s,headers:function(e,t){return o(Ie(e),Ie(t),!0)}};return G.forEach(Object.keys(Object.assign({},e,t)),(function(r){var i=u[r]||o,a=i(e[r],t[r],r);G.isUndefined(a)&&i!==s||(n[r]=a)})),n}var ze="1.6.2",Me={};["object","boolean","number","function","string","symbol"].forEach((function(e,t){Me[e]=function(r){return n(r)===e||"a"+(t<1?"n ":" ")+e}}));var He={};Me.transitional=function(e,t,n){function r(e,t){return"[bpHttp v1.6.2] Transitional option '"+e+"'"+t+(n?". "+n:"")}return function(n,o,i){if(!1===e)throw new X(r(o," has been removed"+(t?" in "+t:"")),X.ERR_DEPRECATED);return t&&!He[o]&&(He[o]=!0,console.warn(r(o," has been deprecated since v"+t+" and will be removed in the near future"))),!e||e(n,o,i)}};var Je={assertOptions:function(e,t,r){if("object"!==n(e))throw new X("options must be an object",X.ERR_BAD_OPTION_VALUE);for(var o=Object.keys(e),i=o.length;i-- >0;){var a=o[i],s=t[a];if(s){var u=e[a],c=void 0===u||s(u,a,e);if(!0!==c)throw new X("option "+a+" must be "+c,X.ERR_BAD_OPTION_VALUE)}else if(!0!==r)throw new X("Unknown option "+a,X.ERR_BAD_OPTION)}},validators:Me},We=Je.validators,Ke=function(){function e(t){r(this,e),this.defaults=t,this.interceptors={request:new ce,response:new ce}}return i(e,[{key:"request",value:function(e,t){"string"==typeof e?(t=t||{}).url=e:t=e||{};var n=t=qe(this.defaults,t),r=n.transitional,o=n.paramsSerializer,i=n.headers;void 0!==r&&Je.assertOptions(r,{silentJSONParsing:We.transitional(We.boolean),forcedJSONParsing:We.transitional(We.boolean),clarifyTimeoutError:We.transitional(We.boolean)},!1),null!=o&&(G.isFunction(o)?t.paramsSerializer={serialize:o}:Je.assertOptions(o,{encode:We.function,serialize:We.function},!0)),t.method=(t.method||this.defaults.method||"get").toLowerCase();var a=i&&G.merge(i.common,i[t.method]);i&&G.forEach(["delete","get","head","post","put","patch","common"],(function(e){delete i[e]})),t.headers=Ae.concat(a,i);var s=[],u=!0;this.interceptors.request.forEach((function(e){"function"==typeof e.runWhen&&!1===e.runWhen(t)||(u=u&&e.synchronous,s.unshift(e.fulfilled,e.rejected))}));var c,f=[];this.interceptors.response.forEach((function(e){f.push(e.fulfilled,e.rejected)}));var l,d=0;if(!u){var p=[Le.bind(this),void 0];for(p.unshift.apply(p,s),p.push.apply(p,f),l=p.length,c=Promise.resolve(t);d<l;)c=c.then(p[d++],p[d++]);return c}l=s.length;var h=t;for(d=0;d<l;){var m=s[d++],y=s[d++];try{h=m(h)}catch(e){y.call(this,e);break}}try{c=Le.call(this,h)}catch(e){return Promise.reject(e)}for(d=0,l=f.length;d<l;)c=c.then(f[d++],f[d++]);return c}},{key:"getUri",value:function(e){return se(xe((e=qe(this.defaults,e)).baseURL,e.url),e.params,e.paramsSerializer)}}]),e}();G.forEach(["delete","get","head","options"],(function(e){Ke.prototype[e]=function(t,n){return this.request(qe(n||{},{method:e,url:t,data:(n||{}).data}))}})),G.forEach(["post","put","patch"],(function(e){function t(t){return function(n,r,o){return this.request(qe(o||{},{method:e,headers:t?{"Content-Type":"multipart/form-data"}:{},url:n,data:r}))}}Ke.prototype[e]=t(),Ke.prototype[e+"Form"]=t(!0)}));var Ve=Ke,Ge=function(){function e(t){if(r(this,e),"function"!=typeof t)throw new TypeError("executor must be a function.");var n;this.promise=new Promise((function(e){n=e}));var o=this;this.promise.then((function(e){if(o._listeners){for(var t=o._listeners.length;t-- >0;)o._listeners[t](e);o._listeners=null}})),this.promise.then=function(e){var t,n=new Promise((function(e){o.subscribe(e),t=e})).then(e);return n.cancel=function(){o.unsubscribe(t)},n},t((function(e,t,r){o.reason||(o.reason=new Pe(e,t,r),n(o.reason))}))}return i(e,[{key:"throwIfRequested",value:function(){if(this.reason)throw this.reason}},{key:"subscribe",value:function(e){this.reason?e(this.reason):this._listeners?this._listeners.push(e):this._listeners=[e]}},{key:"unsubscribe",value:function(e){if(this._listeners){var t=this._listeners.indexOf(e);-1!==t&&this._listeners.splice(t,1)}}}],[{key:"source",value:function(){var t;return{token:new e((function(e){t=e})),cancel:t}}}]),e}();var Xe={Continue:100,SwitchingProtocols:101,Processing:102,EarlyHints:103,Ok:200,Created:201,Accepted:202,NonAuthoritativeInformation:203,NoContent:204,ResetContent:205,PartialContent:206,MultiStatus:207,AlreadyReported:208,ImUsed:226,MultipleChoices:300,MovedPermanently:301,Found:302,SeeOther:303,NotModified:304,UseProxy:305,Unused:306,TemporaryRedirect:307,PermanentRedirect:308,BadRequest:400,Unauthorized:401,PaymentRequired:402,Forbidden:403,NotFound:404,MethodNotAllowed:405,NotAcceptable:406,ProxyAuthenticationRequired:407,RequestTimeout:408,Conflict:409,Gone:410,LengthRequired:411,PreconditionFailed:412,PayloadTooLarge:413,UriTooLong:414,UnsupportedMediaType:415,RangeNotSatisfiable:416,ExpectationFailed:417,ImATeapot:418,MisdirectedRequest:421,UnprocessableEntity:422,Locked:423,FailedDependency:424,TooEarly:425,UpgradeRequired:426,PreconditionRequired:428,TooManyRequests:429,RequestHeaderFieldsTooLarge:431,UnavailableForLegalReasons:451,InternalServerError:500,NotImplemented:501,BadGateway:502,ServiceUnavailable:503,GatewayTimeout:504,HttpVersionNotSupported:505,VariantAlsoNegotiates:506,InsufficientStorage:507,LoopDetected:508,NotExtended:510,NetworkAuthenticationRequired:511};Object.entries(Xe).forEach((function(e){var t=s(e,2),n=t[0],r=t[1];Xe[r]=n}));var $e=Xe;var Qe=function e(t){var n=new Ve(t),r=h(Ve.prototype.request,n);return G.extend(r,Ve.prototype,n,{allOwnKeys:!0}),G.extend(r,n,null,{allOwnKeys:!0}),r.create=function(n){return e(qe(t,n))},r}(be);return Qe.bpHttp=Ve,Qe.CanceledError=Pe,Qe.CancelToken=Ge,Qe.isCancel=Te,Qe.VERSION=ze,Qe.toFormData=ne,Qe.bpHttpError=X,Qe.Cancel=Qe.CanceledError,Qe.all=function(e){return Promise.all(e)},Qe.spread=function(e){return function(t){return e.apply(null,t)}},Qe.isbpHttpError=function(e){return G.isObject(e)&&!0===e.isbpHttpError},Qe.mergeConfig=qe,Qe.bpHttpHeaders=Ae,Qe.formToJSON=function(e){return ye(G.isHTMLForm(e)?new FormData(e):e)},Qe.getAdapter=De,Qe.HttpStatusCode=$e,Qe.default=Qe,Qe}));
//# sourceMappingURL=bpHttp.min.js.map

/**
  @license
  Apache License 2.0 https://github.com/ReactiveX/bpRC/blob/master/LICENSE.txt
 **/
/**
  @license
  Apache License 2.0 https://github.com/ReactiveX/bpRC/blob/master/LICENSE.txt
 **/
/*
 *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
*****************************************************************************/
(function(g,y){"object"===typeof exports&&"undefined"!==typeof module?y(exports):"function"===typeof define&&define.amd?define("bpRC",["exports"],y):y(g.bpRC={})})(this,function(g){function y(b,a){function c(){this.constructor=b}if("function"!==typeof a&&null!==a)throw new TypeError("Class extends value "+String(a)+" is not a constructor or null");Ta(b,a);b.prototype=null===a?Object.create(a):(c.prototype=a.prototype,new c)}function Zd(b,a){var c={},d;for(d in b)Object.prototype.hasOwnProperty.call(b,
  d)&&0>a.indexOf(d)&&(c[d]=b[d]);if(null!=b&&"function"===typeof Object.getOwnPropertySymbols){var e=0;for(d=Object.getOwnPropertySymbols(b);e<d.length;e++)0>a.indexOf(d[e])&&Object.prototype.propertyIsEnumerable.call(b,d[e])&&(c[d[e]]=b[d[e]])}return c}function $d(b,a,c,d){function e(a){return a instanceof c?a:new c(function(b){b(a)})}return new (c||(c=Promise))(function(c,h){function f(a){try{z(d.next(a))}catch(v){h(v)}}function k(a){try{z(d["throw"](a))}catch(v){h(v)}}function z(a){a.done?c(a.value):
  e(a.value).then(f,k)}z((d=d.apply(b,a||[])).next())})}function Ua(b,a){function c(a){return function(b){return d([a,b])}}function d(c){if(f)throw new TypeError("Generator is already executing.");for(;e;)try{if(f=1,h&&(l=c[0]&2?h["return"]:c[0]?h["throw"]||((l=h["return"])&&l.call(h),0):h.next)&&!(l=l.call(h,c[1])).done)return l;if(h=0,l)c=[c[0]&2,l.value];switch(c[0]){case 0:case 1:l=c;break;case 4:return e.label++,{value:c[1],done:!1};case 5:e.label++;h=c[1];c=[0];continue;case 7:c=e.ops.pop();e.trys.pop();
  continue;default:if(!(l=e.trys,l=0<l.length&&l[l.length-1])&&(6===c[0]||2===c[0])){e=0;continue}if(3===c[0]&&(!l||c[1]>l[0]&&c[1]<l[3]))e.label=c[1];else if(6===c[0]&&e.label<l[1])e.label=l[1],l=c;else if(l&&e.label<l[2])e.label=l[2],e.ops.push(c);else{l[2]&&e.ops.pop();e.trys.pop();continue}}c=a.call(b,e)}catch(p){c=[6,p],h=0}finally{f=l=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}var e={label:0,sent:function(){if(l[0]&1)throw l[1];return l[1]},trys:[],ops:[]},f,h,l,k;return k=
  {next:c(0),"throw":c(1),"return":c(2)},"function"===typeof Symbol&&(k[Symbol.iterator]=function(){return this}),k}function F(b){var a="function"===typeof Symbol&&Symbol.iterator,c=a&&b[a],d=0;if(c)return c.call(b);if(b&&"number"===typeof b.length)return{next:function(){b&&d>=b.length&&(b=void 0);return{value:b&&b[d++],done:!b}}};throw new TypeError(a?"Object is not iterable.":"Symbol.iterator is not defined.");}function w(b,a){var c="function"===typeof Symbol&&b[Symbol.iterator];if(!c)return b;b=
  c.call(b);var d,e=[],f;try{for(;(void 0===a||0<a--)&&!(d=b.next()).done;)e.push(d.value)}catch(h){f={error:h}}finally{try{d&&!d.done&&(c=b["return"])&&c.call(b)}finally{if(f)throw f.error;}}return e}function x(b,a,c){if(c||2===arguments.length)for(var d=0,e=a.length,f;d<e;d++)!f&&d in a||(f||(f=Array.prototype.slice.call(a,0,d)),f[d]=a[d]);return b.concat(f||Array.prototype.slice.call(a))}function ca(b){return this instanceof ca?(this.v=b,this):new ca(b)}function ae(b,a,c){function d(a){k[a]&&(z[a]=
  function(c){return new Promise(function(b,d){1<p.push([a,c,b,d])||e(a,c)})})}function e(a,c){try{var b=k[a](c);b.value instanceof ca?Promise.resolve(b.value.v).then(f,h):l(p[0][2],b)}catch(u){l(p[0][3],u)}}function f(a){e("next",a)}function h(a){e("throw",a)}function l(a,c){(a(c),p.shift(),p.length)&&e(p[0][0],p[0][1])}if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var k=c.apply(b,a||[]),z,p=[];return z={},d("next"),d("throw"),d("return"),z[Symbol.asyncIterator]=
  function(){return this},z}function be(b){function a(a){e[a]=b[a]&&function(d){return new Promise(function(e,f){d=b[a](d);c(e,f,d.done,d.value)})}}function c(a,c,b,d){Promise.resolve(d).then(function(c){a({value:c,done:b})},c)}if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var d=b[Symbol.asyncIterator],e;return d?d.call(b):(b="function"===typeof F?F(b):b[Symbol.iterator](),e={},a("next"),a("throw"),a("return"),e[Symbol.asyncIterator]=function(){return this},e)}
  function t(b){return"function"===typeof b}function R(b){b=b(function(a){Error.call(a);a.stack=Error().stack});b.prototype=Object.create(Error.prototype);return b.prototype.constructor=b}function M(b,a){b&&(a=b.indexOf(a),0<=a&&b.splice(a,1))}function Ib(b){return b instanceof D||b&&"closed"in b&&t(b.remove)&&t(b.add)&&t(b.unsubscribe)}function Jb(b){da.setTimeout(function(){var a=S.onUnhandledError;if(a)a(b);else throw b;})}function C(){}function J(b,a,c){return{kind:b,value:a,error:c}}function Ba(b){if(S.useDeprecatedSynchronousErrorHandling){var a=
  !U;a&&(U={errorThrown:!1,error:null});b();if(a&&(a=U,b=a.errorThrown,a=a.error,U=null,b))throw a;}else b()}function Ca(b){S.useDeprecatedSynchronousErrorHandling?S.useDeprecatedSynchronousErrorHandling&&U&&(U.errorThrown=!0,U.error=b):Jb(b)}function Wa(b,a){var c=S.onStoppedNotification;c&&da.setTimeout(function(){return c(b,a)})}function E(b){return b}function Xa(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return Kb(b)}function Kb(b){return 0===b.length?E:1===b.length?b[0]:function(a){return b.reduce(function(a,
  b){return b(a)},a)}}function Lb(b){var a;return null!==(a=null!==b&&void 0!==b?b:S.Promise)&&void 0!==a?a:Promise}function ce(b){var a;(a=b&&b instanceof na)||(a=b&&t(b.next)&&t(b.error)&&t(b.complete)&&Ib(b));return a}function n(b){return function(a){if(t(null===a||void 0===a?void 0:a.lift))return a.lift(function(a){try{return b(a,this)}catch(d){this.error(d)}});throw new TypeError("Unable to lift unknown Observable type");}}function m(b,a,c,d,e){return new Ya(b,a,c,d,e)}function Za(){return n(function(b,
  a){var c=null;b._refCount++;var d=m(a,void 0,void 0,void 0,function(){if(!b||0>=b._refCount||0<--b._refCount)c=null;else{var d=b._connection,f=c;c=null;!d||f&&d!==f||d.unsubscribe();a.unsubscribe()}});b.subscribe(d);d.closed||(c=b.connect())})}function Mb(b){return new r(function(a){var c=b||Da,d=c.now(),e=0,f=function(){a.closed||(e=N.requestAnimationFrame(function(h){e=0;var l=c.now();a.next({timestamp:b?l:h,elapsed:l-d});f()}))};f();return function(){e&&N.cancelAnimationFrame(e)}})}function Nb(b){return b in
  $a?(delete $a[b],!0):!1}function de(b){return new r(function(a){return b.schedule(function(){return a.complete()})})}function Ea(b){return b&&t(b.schedule)}function oa(b){return t(b[b.length-1])?b.pop():void 0}function O(b){return Ea(b[b.length-1])?b.pop():void 0}function Ob(b){return Symbol.asyncIterator&&t(null===b||void 0===b?void 0:b[Symbol.asyncIterator])}function Pb(b){return new TypeError("You provided "+(null!==b&&"object"===typeof b?"an invalid object":"'"+b+"'")+" where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.")}
  function Qb(b){return t(null===b||void 0===b?void 0:b[ab])}function Rb(b){return ae(this,arguments,function(){var a,c,d,e;return Ua(this,function(f){switch(f.label){case 0:a=b.getReader(),f.label=1;case 1:f.trys.push([1,,9,10]),f.label=2;case 2:return[4,ca(a.read())];case 3:return c=f.sent(),d=c.value,(e=c.done)?[4,ca(void 0)]:[3,5];case 4:return[2,f.sent()];case 5:return[4,ca(d)];case 6:return[4,f.sent()];case 7:return f.sent(),[3,2];case 8:return[3,10];case 9:return a.releaseLock(),[7];case 10:return[2]}})})}
  function q(b){if(b instanceof r)return b;if(null!=b){if(t(b[pa]))return ee(b);if(bb(b))return fe(b);if(t(null===b||void 0===b?void 0:b.then))return ge(b);if(Ob(b))return Sb(b);if(Qb(b))return he(b);if(t(null===b||void 0===b?void 0:b.getReader))return Sb(Rb(b))}throw Pb(b);}function ee(b){return new r(function(a){var c=b[pa]();if(t(c.subscribe))return c.subscribe(a);throw new TypeError("Provided object does not correctly implement Symbol.observable");})}function fe(b){return new r(function(a){for(var c=
  0;c<b.length&&!a.closed;c++)a.next(b[c]);a.complete()})}function ge(b){return new r(function(a){b.then(function(c){a.closed||(a.next(c),a.complete())},function(c){return a.error(c)}).then(null,Jb)})}function he(b){return new r(function(a){var c,d;try{for(var e=F(b),f=e.next();!f.done;f=e.next())if(a.next(f.value),a.closed)return}catch(h){c={error:h}}finally{try{f&&!f.done&&(d=e.return)&&d.call(e)}finally{if(c)throw c.error;}}a.complete()})}function Sb(b){return new r(function(a){ie(b,a).catch(function(c){return a.error(c)})})}
  function ie(b,a){var c,d,e,f;return $d(this,void 0,void 0,function(){var h,l;return Ua(this,function(k){switch(k.label){case 0:k.trys.push([0,5,6,11]),c=be(b),k.label=1;case 1:return[4,c.next()];case 2:if(d=k.sent(),d.done)return[3,4];h=d.value;a.next(h);if(a.closed)return[2];k.label=3;case 3:return[3,1];case 4:return[3,11];case 5:return l=k.sent(),e={error:l},[3,11];case 6:return k.trys.push([6,,9,10]),d&&!d.done&&(f=c.return)?[4,f.call(c)]:[3,8];case 7:k.sent(),k.label=8;case 8:return[3,10];case 9:if(e)throw e.error;
  return[7];case 10:return[7];case 11:return a.complete(),[2]}})})}function G(b,a,c,d,e){void 0===d&&(d=0);void 0===e&&(e=!1);a=a.schedule(function(){c();e?b.add(this.schedule(null,d)):this.unsubscribe()},d);b.add(a);if(!e)return a}function qa(b,a){void 0===a&&(a=0);return n(function(c,d){c.subscribe(m(d,function(c){return G(d,b,function(){return d.next(c)},a)},function(){return G(d,b,function(){return d.complete()},a)},function(c){return G(d,b,function(){return d.error(c)},a)}))})}function ra(b,a){void 0===
  a&&(a=0);return n(function(c,d){d.add(b.schedule(function(){return c.subscribe(d)},a))})}function je(b,a){return new r(function(c){var d=0;return a.schedule(function(){d===b.length?c.complete():(c.next(b[d++]),c.closed||this.schedule())})})}function Tb(b,a){return new r(function(c){var d;G(c,a,function(){d=b[ab]();G(c,a,function(){var a,b,h;try{a=d.next(),b=a.value,h=a.done}catch(l){c.error(l);return}h?c.complete():c.next(b)},0,!0)});return function(){return t(null===d||void 0===d?void 0:d.return)&&
  d.return()}})}function Ub(b,a){if(!b)throw Error("Iterable cannot be null");return new r(function(c){G(c,a,function(){var d=b[Symbol.asyncIterator]();G(c,a,function(){d.next().then(function(a){a.done?c.complete():c.next(a.value)})},0,!0)})})}function Vb(b,a){if(null!=b){if(t(b[pa]))return q(b).pipe(ra(a),qa(a));if(bb(b))return je(b,a);if(t(null===b||void 0===b?void 0:b.then))return q(b).pipe(ra(a),qa(a));if(Ob(b))return Ub(b,a);if(Qb(b))return Tb(b,a);if(t(null===b||void 0===b?void 0:b.getReader))return Ub(Rb(b),
  a)}throw Pb(b);}function P(b,a){return a?Vb(b,a):q(b)}function cb(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];a=O(b);return P(b,a)}function Wb(b,a){var c=t(b)?b:function(){return b},d=function(a){return a.error(c())};return new r(a?function(c){return a.schedule(d,0,c)}:d)}function Fa(b,a){var c,d,e,f=b.kind,h=b.value;b=b.error;if("string"!==typeof f)throw new TypeError('Invalid notification, missing "kind"');"N"===f?null===(c=a.next)||void 0===c?void 0:c.call(a,h):"E"===f?null===(d=
  a.error)||void 0===d?void 0:d.call(a,b):null===(e=a.complete)||void 0===e?void 0:e.call(a)}function db(b){return b instanceof Date&&!isNaN(b)}function eb(b,a){b=db(b)?{first:b}:"number"===typeof b?{each:b}:b;var c=b.first,d=b.each,e=b.with,f=void 0===e?ke:e,e=b.scheduler,h=void 0===e?null!==a&&void 0!==a?a:I:e;a=b.meta;var l=void 0===a?null:a;if(null==c&&null==d)throw new TypeError("No timeout provided.");return n(function(a,b){var e,k,z=null,g=0,u=function(a){k=G(b,h,function(){try{e.unsubscribe(),
  q(f({meta:l,lastValue:z,seen:g})).subscribe(b)}catch(V){b.error(V)}},a)};e=a.subscribe(m(b,function(a){null===k||void 0===k?void 0:k.unsubscribe();g++;b.next(z=a);0<d&&u(d)},void 0,void 0,function(){(null===k||void 0===k?0:k.closed)||(null===k||void 0===k?void 0:k.unsubscribe());z=null}));!g&&u(null!=c?"number"===typeof c?c:+c-h.now():d)})}function ke(b){throw new Xb(b);}function Q(b,a){return n(function(c,d){var e=0;c.subscribe(m(d,function(c){d.next(b.call(a,c,e++))}))})}function W(b){return Q(function(a){return le(a)?
  b.apply(void 0,x([],w(a))):b(a)})}function Ga(b,a,c,d){if(c)if(Ea(c))d=c;else return function(){for(var e=[],f=0;f<arguments.length;f++)e[f]=arguments[f];return Ga(b,a,d).apply(this,e).pipe(W(c))};return d?function(){for(var c=[],f=0;f<arguments.length;f++)c[f]=arguments[f];return Ga(b,a).apply(this,c).pipe(ra(d),qa(d))}:function(){for(var c=this,d=[],h=0;h<arguments.length;h++)d[h]=arguments[h];var l=new fb,k=!0;return new r(function(e){e=l.subscribe(e);if(k){var f=k=!1,h=!1;a.apply(c,x(x([],w(d)),
  [function(){for(var a=[],c=0;c<arguments.length;c++)a[c]=arguments[c];if(b&&(c=a.shift(),null!=c)){l.error(c);return}l.next(1<a.length?a:a[0]);h=!0;f&&l.complete()}]));h&&l.complete();f=!0}return e})}}function Yb(b){if(1===b.length){var a=b[0];if(me(a))return{args:a,keys:null};if(a&&"object"===typeof a&&ne(a)===oe)return b=pe(a),{args:b.map(function(c){return a[c]}),keys:b}}return{args:b,keys:null}}function Zb(b,a){return b.reduce(function(c,b,e){return c[b]=a[e],c},{})}function $b(){for(var b=[],
  a=0;a<arguments.length;a++)b[a]=arguments[a];var c=O(b),a=oa(b),b=Yb(b),d=b.args,e=b.keys;if(0===d.length)return P([],c);c=new r(ac(d,c,e?function(a){return Zb(e,a)}:E));return a?c.pipe(W(a)):c}function ac(b,a,c){void 0===c&&(c=E);return function(d){bc(a,function(){for(var e=b.length,f=Array(e),h=e,l=e,k=function(e){bc(a,function(){var k=!1;P(b[e],a).subscribe(m(d,function(a){f[e]=a;k||(k=!0,l--);l||d.next(c(f.slice()))},function(){--h||d.complete()}))},d)},g=0;g<e;g++)k(g)},d)}}function bc(b,a,c){b?
  G(c,b,a):a()}function gb(b,a,c,d,e,f,h,l){var k=[],g=0,p=0,v=!1,B=function(a){return g<d?n(a):k.push(a)},n=function(b){f&&a.next(b);g++;var l=!1;q(c(b,p++)).subscribe(m(a,function(c){null===e||void 0===e?void 0:e(c);f?B(c):a.next(c)},function(){l=!0},void 0,function(){if(l)try{g--;for(var c=function(){var c=k.shift();h?G(a,h,function(){return n(c)}):n(c)};k.length&&g<d;)c();!v||k.length||g||a.complete()}catch(X){a.error(X)}}))};b.subscribe(m(a,B,function(){v=!0;!v||k.length||g||a.complete()}));return function(){null===
  l||void 0===l?void 0:l()}}function H(b,a,c){void 0===c&&(c=Infinity);if(t(a))return H(function(c,e){return Q(function(b,d){return a(c,b,e,d)})(q(b(c,e)))},c);"number"===typeof a&&(c=a);return n(function(a,e){return gb(a,e,b,c)})}function sa(b){void 0===b&&(b=Infinity);return H(E,b)}function Ha(){return sa(1)}function ta(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return Ha()(P(b,O(b)))}function Ia(b){return new r(function(a){q(b()).subscribe(a)})}function hb(b,a,c,d){t(c)&&(d=c,c=
  void 0);if(d)return hb(b,a,c).pipe(W(d));d=w(qe(b)?re.map(function(d){return function(e){return b[d](a,e,c)}}):se(b)?te.map(cc(b,a)):ue(b)?ve.map(cc(b,a)):[],2);var e=d[0],f=d[1];if(!e&&bb(b))return H(function(b){return hb(b,a,c)})(q(b));if(!e)throw new TypeError("Invalid event target");return new r(function(a){var c=function(){for(var c=[],b=0;b<arguments.length;b++)c[b]=arguments[b];return a.next(1<c.length?c:c[0])};e(c);return function(){return f(c)}})}function cc(b,a){return function(c){return function(d){return b[c](a,
  d)}}}function se(b){return t(b.addListener)&&t(b.removeListener)}function ue(b){return t(b.on)&&t(b.off)}function qe(b){return t(b.addEventListener)&&t(b.removeEventListener)}function dc(b,a,c){return c?dc(b,a).pipe(W(c)):new r(function(c){var d=function(){for(var a=[],b=0;b<arguments.length;b++)a[b]=arguments[b];return c.next(1===a.length?a[0]:a)},f=b(d);return t(a)?function(){return a(d,f)}:void 0})}function Y(b,a,c){void 0===b&&(b=0);void 0===c&&(c=ib);var d=-1;null!=a&&(Ea(a)?c=a:d=a);return new r(function(a){var e=
  db(b)?+b-c.now():b;0>e&&(e=0);var h=0;return c.schedule(function(){a.closed||(a.next(h++),0<=d?this.schedule(void 0,d):a.complete())},e)})}function ec(b,a){void 0===b&&(b=0);void 0===a&&(a=I);0>b&&(b=0);return Y(b,b,a)}function Z(b){return 1===b.length&&we(b[0])?b[0]:b}function fc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];var c=Z(b);return new r(function(a){var b=0,d=function(){if(b<c.length){var e=void 0;try{e=q(c[b++])}catch(k){d();return}var f=new Ya(a,void 0,C,C);e.subscribe(f);
  f.add(d)}else a.complete()};d()})}function gc(b,a){return function(c,d){return!b.call(a,c,d)}}function K(b,a){return n(function(c,d){var e=0;c.subscribe(m(d,function(c){return b.call(a,c,e++)&&d.next(c)}))})}function hc(b){return function(a){for(var c=[],d=function(d){c.push(q(b[d]).subscribe(m(a,function(b){if(c){for(var e=0;e<c.length;e++)e!==d&&c[e].unsubscribe();c=null}a.next(b)})))},e=0;c&&!a.closed&&e<b.length;e++)d(e)}}function jb(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];
  var c=oa(b),d=Z(b);return d.length?new r(function(a){var b=d.map(function(){return[]}),e=d.map(function(){return!1});a.add(function(){b=e=null});for(var l=function(f){q(d[f]).subscribe(m(a,function(d){b[f].push(d);b.every(function(a){return a.length})&&(d=b.map(function(a){return a.shift()}),a.next(c?c.apply(void 0,x([],w(d))):d),b.some(function(a,c){return!a.length&&e[c]})&&a.complete())},function(){e[f]=!0;!b[f].length&&a.complete()}))},k=0;!a.closed&&k<d.length;k++)l(k);return function(){b=e=null}}):
  L}function kb(b){return n(function(a,c){var d=!1,e=null,f=null,h=!1,l=function(){null===f||void 0===f?void 0:f.unsubscribe();f=null;if(d){d=!1;var a=e;e=null;c.next(a)}h&&c.complete()},k=function(){f=null;h&&c.complete()};a.subscribe(m(c,function(a){d=!0;e=a;f||q(b(a)).subscribe(f=m(c,l,k))},function(){h=!0;d&&f&&!f.closed||c.complete()}))})}function ic(b,a){void 0===a&&(a=I);return kb(function(){return Y(b,a)})}function jc(b){return n(function(a,c){var d=[];a.subscribe(m(c,function(a){return d.push(a)},
  function(){c.next(d);c.complete()}));q(b).subscribe(m(c,function(){var a=d;d=[];c.next(a)},C));return function(){d=null}})}function kc(b,a){void 0===a&&(a=null);a=null!==a&&void 0!==a?a:b;return n(function(c,d){var e=[],f=0;c.subscribe(m(d,function(c){var h,k,g,p,v=null;0===f++%a&&e.push([]);try{for(var m=F(e),n=m.next();!n.done;n=m.next()){var u=n.value;u.push(c);b<=u.length&&(v=null!==v&&void 0!==v?v:[],v.push(u))}}catch(X){h={error:X}}finally{try{n&&!n.done&&(k=m.return)&&k.call(m)}finally{if(h)throw h.error;
  }}if(v)try{for(var ea=F(v),V=ea.next();!V.done;V=ea.next())u=V.value,M(e,u),d.next(u)}catch(X){g={error:X}}finally{try{V&&!V.done&&(p=ea.return)&&p.call(ea)}finally{if(g)throw g.error;}}},function(){var a,c;try{for(var b=F(e),f=b.next();!f.done;f=b.next())d.next(f.value)}catch(p){a={error:p}}finally{try{f&&!f.done&&(c=b.return)&&c.call(b)}finally{if(a)throw a.error;}}d.complete()},void 0,function(){e=null}))})}function lc(b){for(var a,c,d=[],e=1;e<arguments.length;e++)d[e-1]=arguments[e];var f=null!==
  (a=O(d))&&void 0!==a?a:I,h=null!==(c=d[0])&&void 0!==c?c:null,l=d[1]||Infinity;return n(function(a,c){var d=[],e=!1,k=function(a){var b=a.buffer;a.subs.unsubscribe();M(d,a);c.next(b);e&&g()},g=function(){if(d){var a=new D;c.add(a);var e={buffer:[],subs:a};d.push(e);G(a,f,function(){return k(e)},b)}};null!==h&&0<=h?G(c,f,g,h,!0):e=!0;g();var z=m(c,function(a){var c,b,e=d.slice();try{for(var f=F(e),h=f.next();!h.done;h=f.next()){var g=h.value,p=g.buffer;p.push(a);l<=p.length&&k(g)}}catch(ze){c={error:ze}}finally{try{h&&
  !h.done&&(b=f.return)&&b.call(f)}finally{if(c)throw c.error;}}},function(){for(;null===d||void 0===d?0:d.length;)c.next(d.shift().buffer);null===z||void 0===z?void 0:z.unsubscribe();c.complete();c.unsubscribe()},void 0,function(){return d=null});a.subscribe(z)})}function mc(b,a){return n(function(c,d){var e=[];q(b).subscribe(m(d,function(c){var b=[];e.push(b);var f=new D;f.add(q(a(c)).subscribe(m(d,function(){M(e,b);d.next(b);f.unsubscribe()},C)))},C));c.subscribe(m(d,function(a){var c,b;try{for(var d=
  F(e),f=d.next();!f.done;f=d.next())f.value.push(a)}catch(p){c={error:p}}finally{try{f&&!f.done&&(b=d.return)&&b.call(d)}finally{if(c)throw c.error;}}},function(){for(;0<e.length;)d.next(e.shift());d.complete()}))})}function nc(b){return n(function(a,c){var d=null,e=null,f=function(){null===e||void 0===e?void 0:e.unsubscribe();var a=d;d=[];a&&c.next(a);q(b()).subscribe(e=m(c,f,C))};f();a.subscribe(m(c,function(a){return null===d||void 0===d?void 0:d.push(a)},function(){d&&c.next(d);c.complete()},void 0,
  function(){return d=e=null}))})}function lb(b){return n(function(a,c){var d=null,e=!1,f,d=a.subscribe(m(c,void 0,void 0,function(h){f=q(b(h,lb(b)(a)));d?(d.unsubscribe(),d=null,f.subscribe(c)):e=!0}));e&&(d.unsubscribe(),d=null,f.subscribe(c))})}function oc(b,a,c,d,e){return function(f,h){var l=c,k=a,g=0;f.subscribe(m(h,function(a){var c=g++;k=l?b(k,a,c):(l=!0,a);d&&h.next(k)},e&&function(){l&&h.next(k);h.complete()}))}}function fa(b,a){return n(oc(b,a,2<=arguments.length,!1,!0))}function mb(){return n(function(b,
  a){fa(Ae,[])(b).subscribe(a)})}function pc(b,a){return Xa(mb(),H(function(a){return b(a)}),a?W(a):E)}function Ja(b){return pc($b,b)}function nb(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return(a=oa(b))?Xa(nb.apply(void 0,x([],w(b))),W(a)):n(function(a,d){ac(x([a],w(Z(b))))(d)})}function qc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return nb.apply(void 0,x([],w(b)))}function Ka(b,a){return t(a)?H(b,a,1):H(b,1)}function rc(b,a){return t(a)?Ka(function(){return b},
  a):Ka(function(){return b})}function sc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];var c=O(b);return n(function(a,e){Ha()(P(x([a],w(b)),c)).subscribe(e)})}function tc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return sc.apply(void 0,x([],w(b)))}function Be(b){return new r(function(a){return b.subscribe(a)})}function La(b,a){void 0===a&&(a=Ce);var c=a.connector;return n(function(a,e){var d=c();q(b(Be(d))).subscribe(e);e.add(a.subscribe(d))})}function uc(b){return fa(function(a,
  c,d){return!b||b(c,d)?a+1:a},0)}function vc(b){return n(function(a,c){var d=!1,e=null,f=null,h=function(){null===f||void 0===f?void 0:f.unsubscribe();f=null;if(d){d=!1;var a=e;e=null;c.next(a)}};a.subscribe(m(c,function(a){null===f||void 0===f?void 0:f.unsubscribe();d=!0;e=a;f=m(c,h,C);q(b(a)).subscribe(f)},function(){h();c.complete()},void 0,function(){e=f=null}))})}function wc(b,a){void 0===a&&(a=I);return n(function(c,d){function e(){var c=l+b,e=a.now();e<c?(f=this.schedule(void 0,c-e),d.add(f)):
  k()}var f=null,h=null,l=null,k=function(){if(f){f.unsubscribe();f=null;var a=h;h=null;d.next(a)}};c.subscribe(m(d,function(c){h=c;l=a.now();f||(f=a.schedule(e,b),d.add(f))},function(){k();d.complete()},void 0,function(){h=f=null}))})}function ua(b){return n(function(a,c){var d=!1;a.subscribe(m(c,function(a){d=!0;c.next(a)},function(){d||c.next(b);c.complete()}))})}function ga(b){return 0>=b?function(){return L}:n(function(a,c){var d=0;a.subscribe(m(c,function(a){++d<=b&&(c.next(a),b<=d&&c.complete())}))})}
  function ob(){return n(function(b,a){b.subscribe(m(a,C))})}function pb(b){return Q(function(){return b})}function Ma(b,a){return a?function(c){return ta(a.pipe(ga(1),ob()),c.pipe(Ma(b)))}:H(function(a,d){return q(b(a,d)).pipe(ga(1),pb(a))})}function xc(b,a){void 0===a&&(a=I);var c=Y(b,a);return Ma(function(){return c})}function yc(){return n(function(b,a){b.subscribe(m(a,function(c){return Fa(c,a)}))})}function zc(b,a){return n(function(c,d){var e=new Set;c.subscribe(m(d,function(a){var c=b?b(a):
  a;e.has(c)||(e.add(c),d.next(a))}));a&&q(a).subscribe(m(d,function(){return e.clear()},C))})}function qb(b,a){void 0===a&&(a=E);b=null!==b&&void 0!==b?b:De;return n(function(c,d){var e,f=!0;c.subscribe(m(d,function(c){var h=a(c);if(f||!b(e,h))f=!1,e=h,d.next(c)}))})}function De(b,a){return b===a}function Ac(b,a){return qb(function(c,d){return a?a(c[b],d[b]):c[b]===d[b]})}function va(b){void 0===b&&(b=Ee);return n(function(a,c){var d=!1;a.subscribe(m(c,function(a){d=!0;c.next(a)},function(){return d?
  c.complete():c.error(b())}))})}function Ee(){return new aa}function Bc(b,a){if(0>b)throw new rb;var c=2<=arguments.length;return function(d){return d.pipe(K(function(a,c){return c===b}),ga(1),c?ua(a):va(function(){return new rb}))}}function Cc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return function(a){return ta(a,cb.apply(void 0,x([],w(b))))}}function Dc(b,a){return n(function(c,d){var e=0;c.subscribe(m(d,function(f){b.call(a,f,e++,c)||(d.next(!1),d.complete())},function(){d.next(!0);
  d.complete()}))})}function Na(b,a){return a?function(c){return c.pipe(Na(function(c,e){return q(b(c,e)).pipe(Q(function(b,d){return a(c,b,e,d)}))}))}:n(function(a,d){var c=0,f=null,h=!1;a.subscribe(m(d,function(a){f||(f=m(d,void 0,function(){f=null;h&&d.complete()}),q(b(a,c++)).subscribe(f))},function(){h=!0;!f&&d.complete()}))})}function Oa(){return Na(E)}function Ec(b,a,c){void 0===a&&(a=Infinity);a=1>(a||0)?Infinity:a;return n(function(d,e){return gb(d,e,b,a,void 0,!0,c)})}function Fc(b){return n(function(a,
  c){try{a.subscribe(c)}finally{c.add(b)}})}function Gc(b,a){return n(Hc(b,a,"value"))}function Hc(b,a,c){var d="index"===c;return function(c,f){var e=0;c.subscribe(m(f,function(h){var l=e++;b.call(a,h,l,c)&&(f.next(d?l:h),f.complete())},function(){f.next(d?-1:void 0);f.complete()}))}}function Ic(b,a){return n(Hc(b,a,"index"))}function Jc(b,a){var c=2<=arguments.length;return function(d){return d.pipe(b?K(function(a,c){return b(a,c,d)}):E,ga(1),c?ua(a):va(function(){return new aa}))}}function Kc(b,
  a,c,d){return n(function(e,f){function h(a,c){var b=new r(function(a){v++;var b=c.subscribe(a);return function(){b.unsubscribe();0===--v&&n&&Va.unsubscribe()}});b.key=a;return b}var l;a&&"function"!==typeof a?(c=a.duration,l=a.element,d=a.connector):l=a;var k=new Map,g=function(a){k.forEach(a);a(f)},p=function(a){return g(function(c){return c.error(a)})},v=0,n=!1,Va=new Ya(f,function(a){try{var e=b(a),g=k.get(e);if(!g){k.set(e,g=d?d():new A);var z=h(e,g);f.next(z);if(c){var v=m(g,function(){g.complete();
  null===v||void 0===v?void 0:v.unsubscribe()},void 0,void 0,function(){return k.delete(e)});Va.add(q(c(z)).subscribe(v))}}g.next(l?l(a):a)}catch(xe){p(xe)}},function(){return g(function(a){return a.complete()})},p,function(){return k.clear()},function(){n=!0;return 0===v});e.subscribe(Va)})}function Lc(){return n(function(b,a){b.subscribe(m(a,function(){a.next(!1);a.complete()},function(){a.next(!0);a.complete()}))})}function sb(b){return 0>=b?function(){return L}:n(function(a,c){var d=[];a.subscribe(m(c,
  function(a){d.push(a);b<d.length&&d.shift()},function(){var a,b;try{for(var h=F(d),l=h.next();!l.done;l=h.next())c.next(l.value)}catch(k){a={error:k}}finally{try{l&&!l.done&&(b=h.return)&&b.call(h)}finally{if(a)throw a.error;}}c.complete()},void 0,function(){d=null}))})}function Mc(b,a){var c=2<=arguments.length;return function(d){return d.pipe(b?K(function(a,c){return b(a,c,d)}):E,sb(1),c?ua(a):va(function(){return new aa}))}}function Nc(){return n(function(b,a){b.subscribe(m(a,function(c){a.next(Pa.createNext(c))},
  function(){a.next(Pa.createComplete());a.complete()},function(c){a.next(Pa.createError(c));a.complete()}))})}function Oc(b){return fa(t(b)?function(a,c){return 0<b(a,c)?a:c}:function(a,c){return a>c?a:c})}function Pc(b,a,c){void 0===c&&(c=Infinity);if(t(a))return H(function(){return b},a,c);"number"===typeof a&&(c=a);return H(function(){return b},c)}function Qc(b,a,c){void 0===c&&(c=Infinity);return n(function(d,e){var f=a;return gb(d,e,function(a,c){return b(f,a,c)},c,function(a){f=a},!1,void 0,
  function(){return f=null})})}function Rc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];var c=O(b),d="number"===typeof b[b.length-1]?b.pop():Infinity,b=Z(b);return n(function(a,f){sa(d)(P(x([a],w(b)),c)).subscribe(f)})}function Sc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return Rc.apply(void 0,x([],w(b)))}function Tc(b){return fa(t(b)?function(a,c){return 0>b(a,c)?a:c}:function(a,c){return a<c?a:c})}function Qa(b,a){var c=t(b)?b:function(){return b};return t(a)?La(a,
  {connector:c}):function(a){return new Ra(a,c)}}function Uc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];var c=Z(b);return function(a){return fc.apply(void 0,x([a],w(c)))}}function Vc(){return n(function(b,a){var c,d=!1;b.subscribe(m(a,function(b){var e=c;c=b;d&&a.next([e,b]);d=!0}))})}function Wc(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];var c=b.length;if(0===c)throw Error("list of properties cannot be empty.");return Q(function(a){var d=a;for(a=0;a<c;a++)if(d=null===
  d||void 0===d?void 0:d[b[a]],"undefined"===typeof d)return;return d})}function Xc(b){return b?function(a){return La(b)(a)}:function(a){return Qa(new A)(a)}}function Yc(b){return function(a){var c=new Zc(b);return new Ra(a,function(){return c})}}function $c(){return function(b){var a=new fb;return new Ra(b,function(){return a})}}function ad(b,a,c,d){c&&!t(c)&&(d=c);var e=t(c)?c:void 0;return function(c){return Qa(new ha(b,a,d),e)(c)}}function tb(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];
  return b.length?n(function(a,d){hc(x([a],w(b)))(d)}):E}function bd(b){var a,c=Infinity,d;null!=b&&("object"===typeof b?(a=b.count,c=void 0===a?Infinity:a,d=b.delay):c=b);return 0>=c?function(){return L}:n(function(a,b){var e=0,f,k=function(){null===f||void 0===f?void 0:f.unsubscribe();f=null;if(null!=d){var a="number"===typeof d?Y(d):q(d(e)),c=m(b,function(){c.unsubscribe();g()});a.subscribe(c)}else g()},g=function(){var d=!1;f=a.subscribe(m(b,void 0,function(){++e<c?f?k():d=!0:b.complete()}));d&&
  k()};g()})}function cd(b){return n(function(a,c){var d,e=!1,f,h=!1,l=!1,k=function(){f||(f=new A,q(b(f)).subscribe(m(c,function(){d?g():e=!0},function(){h=!0;l&&h&&c.complete()})));return f},g=function(){l=!1;d=a.subscribe(m(c,void 0,function(){(l=!0,h)&&(c.complete(),!0)||k().next()}));e&&(d.unsubscribe(),d=null,e=!1,g())};g()})}function dd(b){void 0===b&&(b=Infinity);b=b&&"object"===typeof b?b:{count:b};var a=b.count,c=void 0===a?Infinity:a,d=b.delay;b=b.resetOnSuccess;var e=void 0===b?!1:b;return 0>=
  c?E:n(function(a,b){var f=0,h,g=function(){var l=!1;h=a.subscribe(m(b,function(a){e&&(f=0);b.next(a)},void 0,function(a){if(f++<c){var e=function(){h?(h.unsubscribe(),h=null,g()):l=!0};if(null!=d){a="number"===typeof d?Y(d):q(d(a,f));var k=m(b,function(){k.unsubscribe();e()},function(){b.complete()});a.subscribe(k)}else e()}else b.error(a)}));l&&(h.unsubscribe(),h=null,g())};g()})}function ed(b){return n(function(a,c){var d,e=!1,f,h=function(){d=a.subscribe(m(c,void 0,void 0,function(a){f||(f=new A,
  q(b(f)).subscribe(m(c,function(){return d?h():e=!0})));f&&f.next(a)}));e&&(d.unsubscribe(),d=null,e=!1,h())};h()})}function ub(b){return n(function(a,c){var d=!1,e=null;a.subscribe(m(c,function(a){d=!0;e=a}));q(b).subscribe(m(c,function(){if(d){d=!1;var a=e;e=null;c.next(a)}},C))})}function fd(b,a){void 0===a&&(a=I);return ub(ec(b,a))}function gd(b,a){return n(oc(b,a,2<=arguments.length,!0))}function hd(b,a){void 0===a&&(a=function(a,b){return a===b});return n(function(c,d){var e={buffer:[],complete:!1},
  f={buffer:[],complete:!1},h=function(c,b){var e=m(d,function(e){var f=b.buffer,h=b.complete;0===f.length?h?(d.next(!1),d.complete()):c.buffer.push(e):a(e,f.shift())||(d.next(!1),d.complete())},function(){c.complete=!0;var a=b.buffer;b.complete&&(d.next(0===a.length),d.complete());null===e||void 0===e?void 0:e.unsubscribe()});return e};c.subscribe(h(e,f));q(b).subscribe(h(f,e))})}function vb(b){void 0===b&&(b={});var a=b.connector,c=void 0===a?function(){return new A}:a,a=b.resetOnError,d=void 0===
  a?!0:a,a=b.resetOnComplete,e=void 0===a?!0:a;b=b.resetOnRefCountZero;var f=void 0===b?!0:b;return function(a){var b,h,g,p=0,v=!1,m=!1,t=function(){null===h||void 0===h?void 0:h.unsubscribe();h=void 0},u=function(){t();b=g=void 0;v=m=!1},ea=function(){var a=b;u();null===a||void 0===a?void 0:a.unsubscribe()};return n(function(a,l){p++;m||v||t();var k=g=null!==g&&void 0!==g?g:c();l.add(function(){p--;0!==p||m||v||(h=wb(ea,f))});k.subscribe(l);!b&&0<p&&(b=new ia({next:function(a){return k.next(a)},error:function(a){m=
  !0;t();h=wb(u,d,a);k.error(a)},complete:function(){v=!0;t();h=wb(u,e);k.complete()}}),q(a).subscribe(b))})(a)}}function wb(b,a){for(var c=[],d=2;d<arguments.length;d++)c[d-2]=arguments[d];if(!0===a)b();else if(!1!==a){var e=new ia({next:function(){e.unsubscribe();b()}});return q(a.apply(void 0,x([],w(c)))).subscribe(e)}}function id(b,a,c){var d,e;d=!1;b&&"object"===typeof b?(d=b.bufferSize,e=void 0===d?Infinity:d,d=b.windowTime,a=void 0===d?Infinity:d,d=b.refCount,d=void 0===d?!1:d,c=b.scheduler):
  e=null!==b&&void 0!==b?b:Infinity;return vb({connector:function(){return new ha(e,a,c)},resetOnError:!0,resetOnComplete:!1,resetOnRefCountZero:d})}function jd(b){return n(function(a,c){var d=!1,e,f=!1,h=0;a.subscribe(m(c,function(l){f=!0;if(!b||b(l,h++,a))d&&c.error(new kd("Too many matching values")),d=!0,e=l},function(){d?(c.next(e),c.complete()):c.error(f?new ld("No matching values"):new aa)}))})}function md(b){return K(function(a,c){return b<=c})}function nd(b){return 0>=b?E:n(function(a,c){var d=
  Array(b),e=0;a.subscribe(m(c,function(a){var f=e++;if(f<b)d[f]=a;else{var f=f%b,l=d[f];d[f]=a;c.next(l)}}));return function(){d=null}})}function od(b){return n(function(a,c){var d=!1,e=m(c,function(){null===e||void 0===e?void 0:e.unsubscribe();d=!0},C);q(b).subscribe(e);a.subscribe(m(c,function(a){return d&&c.next(a)}))})}function pd(b){return n(function(a,c){var d=!1,e=0;a.subscribe(m(c,function(a){return(d||(d=!b(a,e++)))&&c.next(a)}))})}function qd(){for(var b=[],a=0;a<arguments.length;a++)b[a]=
  arguments[a];var c=O(b);return n(function(a,e){(c?ta(b,a,c):ta(b,a)).subscribe(e)})}function ja(b,a){return n(function(c,d){var e=null,f=0,h=!1;c.subscribe(m(d,function(c){null===e||void 0===e?void 0:e.unsubscribe();var l=0,g=f++;q(b(c,g)).subscribe(e=m(d,function(b){return d.next(a?a(c,b,g,l++):b)},function(){e=null;h&&!e&&d.complete()}))},function(){(h=!0,!e)&&d.complete()}))})}function rd(){return ja(E)}function sd(b,a){return t(a)?ja(function(){return b},a):ja(function(){return b})}function td(b,
  a){return n(function(c,d){var e=a;ja(function(a,c){return b(e,a,c)},function(a,c){return e=c,c})(c).subscribe(d);return function(){e=null}})}function ud(b){return n(function(a,c){q(b).subscribe(m(c,function(){return c.complete()},C));!c.closed&&a.subscribe(c)})}function vd(b,a){void 0===a&&(a=!1);return n(function(c,d){var e=0;c.subscribe(m(d,function(c){var f=b(c,e++);(f||a)&&d.next(c);!f&&d.complete()}))})}function wd(b,a,c){var d=t(b)||a||c?{next:b,error:a,complete:c}:b;return d?n(function(a,c){var b;
  null===(b=d.subscribe)||void 0===b?void 0:b.call(d);var e=!0;a.subscribe(m(c,function(a){var b;null===(b=d.next)||void 0===b?void 0:b.call(d,a);c.next(a)},function(){var a;e=!1;null===(a=d.complete)||void 0===a?void 0:a.call(d);c.complete()},function(a){var b;e=!1;null===(b=d.error)||void 0===b?void 0:b.call(d,a);c.error(a)},function(){var a,c;e&&(null===(a=d.unsubscribe)||void 0===a?void 0:a.call(d));null===(c=d.finalize)||void 0===c?void 0:c.call(d)}))}):E}function xb(b,a){return n(function(c,d){var e=
  null!==a&&void 0!==a?a:{},f=e.leading,h=void 0===f?!0:f,e=e.trailing,l=void 0===e?!1:e,g=!1,z=null,p=null,v=!1,n=function(){null===p||void 0===p?void 0:p.unsubscribe();p=null;l&&(u(),v&&d.complete())},t=function(){p=null;v&&d.complete()},u=function(){if(g){g=!1;var a=z;z=null;d.next(a);!v&&(p=q(b(a)).subscribe(m(d,n,t)))}};c.subscribe(m(d,function(a){g=!0;z=a;(!p||p.closed)&&(h?u():p=q(b(a)).subscribe(m(d,n,t)))},function(){v=!0;l&&g&&p&&!p.closed||d.complete()}))})}function xd(b,a,c){void 0===a&&
  (a=I);var d=Y(b,a);return xb(function(){return d},c)}function yd(b){void 0===b&&(b=I);return n(function(a,c){var d=b.now();a.subscribe(m(c,function(a){var e=b.now(),h=e-d;d=e;c.next(new Fe(a,h))}))})}function zd(b,a,c){var d,e;c=null!==c&&void 0!==c?c:ib;db(b)?d=b:"number"===typeof b&&(e=b);if(a)b=function(){return a};else throw new TypeError("No observable provided to switch to");if(null==d&&null==e)throw new TypeError("No timeout provided.");return eb({first:d,each:e,scheduler:c,with:b})}function Ad(b){void 0===
  b&&(b=ka);return Q(function(a){return{value:a,timestamp:b.now()}})}function Bd(b){return n(function(a,c){var d=new A;c.next(d.asObservable());var e=function(a){d.error(a);c.error(a)};a.subscribe(m(c,function(a){return null===d||void 0===d?void 0:d.next(a)},function(){d.complete();c.complete()},e));q(b).subscribe(m(c,function(){d.complete();c.next(d=new A)},C,e));return function(){null===d||void 0===d?void 0:d.unsubscribe();d=null}})}function Cd(b,a){void 0===a&&(a=0);var c=0<a?a:b;return n(function(a,
  e){var d=[new A],h=0;e.next(d[0].asObservable());a.subscribe(m(e,function(a){var f,l;try{for(var g=F(d),v=g.next();!v.done;v=g.next())v.value.next(a)}catch(B){f={error:B}}finally{try{v&&!v.done&&(l=g.return)&&l.call(g)}finally{if(f)throw f.error;}}a=h-b+1;0<=a&&0===a%c&&d.shift().complete();0===++h%c&&(a=new A,d.push(a),e.next(a.asObservable()))},function(){for(;0<d.length;)d.shift().complete();e.complete()},function(a){for(;0<d.length;)d.shift().error(a);e.error(a)},function(){d=null}))})}function Dd(b){for(var a,
  c,d=[],e=1;e<arguments.length;e++)d[e-1]=arguments[e];var f=null!==(a=O(d))&&void 0!==a?a:I,h=null!==(c=d[0])&&void 0!==c?c:null,g=d[1]||Infinity;return n(function(a,c){var d=[],e=!1,l=function(a){var c=a.subs;a.window.complete();c.unsubscribe();M(d,a);e&&k()},k=function(){if(d){var a=new D;c.add(a);var e=new A,h={window:e,subs:a,seen:0};d.push(h);c.next(e.asObservable());G(a,f,function(){return l(h)},b)}};null!==h&&0<=h?G(c,f,k,h,!0):e=!0;k();var n=function(a){d.slice().forEach(function(c){return a(c.window)});
  a(c);c.unsubscribe()};a.subscribe(m(c,function(a){d.slice().forEach(function(c){c.window.next(a);g<=++c.seen&&l(c)})},function(){return n(function(a){return a.complete()})},function(a){return n(function(c){return c.error(a)})}));return function(){d=null}})}function Ed(b,a){return n(function(c,d){var e=[],f=function(a){for(;0<e.length;)e.shift().error(a);d.error(a)};q(b).subscribe(m(d,function(c){var b=new A;e.push(b);var h=new D,g;try{g=q(a(c))}catch(p){f(p);return}d.next(b.asObservable());h.add(g.subscribe(m(d,
  function(){M(e,b);b.complete();h.unsubscribe()},C,f)))},C));c.subscribe(m(d,function(a){var c,b,d=e.slice();try{for(var f=F(d),h=f.next();!h.done;h=f.next())h.value.next(a)}catch(B){c={error:B}}finally{try{h&&!h.done&&(b=f.return)&&b.call(f)}finally{if(c)throw c.error;}}},function(){for(;0<e.length;)e.shift().complete();d.complete()},f,function(){for(;0<e.length;)e.shift().unsubscribe()}))})}function Fd(b){return n(function(a,c){var d,e,f=function(a){d.error(a);c.error(a)},h=function(){null===e||
  void 0===e?void 0:e.unsubscribe();null===d||void 0===d?void 0:d.complete();d=new A;c.next(d.asObservable());var a;try{a=q(b())}catch(k){f(k);return}a.subscribe(e=m(c,h,h,f))};h();a.subscribe(m(c,function(a){return d.next(a)},function(){d.complete();c.complete()},f,function(){null===e||void 0===e?void 0:e.unsubscribe();d=null}))})}function Gd(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];var c=oa(b);return n(function(a,e){for(var d=b.length,h=Array(d),g=b.map(function(){return!1}),k=
  !1,n=function(a){q(b[a]).subscribe(m(e,function(c){h[a]=c;k||g[a]||(g[a]=!0,(k=g.every(E))&&(g=null))},C))},p=0;p<d;p++)n(p);a.subscribe(m(e,function(a){k&&(a=x([a],w(h)),e.next(c?c.apply(void 0,x([],w(a))):a))}))})}function Hd(b){return pc(jb,b)}function Id(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return n(function(a,d){jb.apply(void 0,x([a],w(b))).subscribe(d)})}function Jd(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return Id.apply(void 0,x([],w(b)))}function Kd(b,
  a){for(var c=0,d=a.length;c<d;c++)for(var e=a[c],f=Object.getOwnPropertyNames(e.prototype),h=0,g=f.length;h<g;h++){var k=f[h];b.prototype[k]=e.prototype[k]}}function Ld(b){switch(b.responseType){case "json":return"response"in b?b.response:JSON.parse(b.responseText);case "document":return b.responseXML;default:return"response"in b?b.response:b.responseText}}function Ge(b,a){return ba({method:"GET",url:b,headers:a})}function He(b,a,c){return ba({method:"POST",url:b,body:a,headers:c})}function Ie(b,
  a){return ba({method:"DELETE",url:b,headers:a})}function Je(b,a,c){return ba({method:"PUT",url:b,body:a,headers:c})}function Ke(b,a,c){return ba({method:"PATCH",url:b,body:a,headers:c})}function Le(b,a){return Me(ba({method:"GET",url:b,headers:a}))}function Ne(b){return new r(function(a){var c,d,e=T({async:!0,crossDomain:!1,withCredentials:!1,method:"GET",timeout:0,responseType:"json"},b),f=e.queryParams,h=e.body,g=e.headers,k=e.url;if(!k)throw new TypeError("url is required");if(f){var m;if(k.includes("?")){k=
  k.split("?");if(2<k.length)throw new TypeError("invalid url");m=new URLSearchParams(k[1]);(new URLSearchParams(f)).forEach(function(a,c){return m.set(c,a)});k=k[0]+"?"+m}else m=new URLSearchParams(f),k=k+"?"+m}f={};if(g)for(var p in g)g.hasOwnProperty(p)&&(f[p.toLowerCase()]=g[p]);var n=e.crossDomain;n||"x-requested-with"in f||(f["x-requested-with"]="XMLHttpRequest");var t=e.xsrfCookieName,g=e.xsrfHeaderName;(e.withCredentials||!n)&&t&&g&&(n=null!==(d=null===(c=null===document||void 0===document?
  void 0:document.cookie.match(new RegExp("(^|;\\s*)("+t+")\x3d([^;]*)")))||void 0===c?void 0:c.pop())&&void 0!==d?d:"")&&(f[g]=n);c=Oe(h,f);var q=T(T({},e),{url:k,headers:f,body:c}),u;u=b.createXHR?b.createXHR():new XMLHttpRequest;var r=b.progressSubscriber,e=b.includeDownloadProgress,e=void 0===e?!1:e;d=b.includeUploadProgress;d=void 0===d?!1:d;h=function(c,b){u.addEventListener(c,function(){var c,d=b();null===(c=null===r||void 0===r?void 0:r.error)||void 0===c?void 0:c.call(r,d);a.error(d)})};h("timeout",
  function(){return new Md(u,q)});h("abort",function(){return new wa("aborted",u,q)});var w=function(c,b,d){c.addEventListener(b,function(c){a.next(new yb(c,u,q,d+"_"+c.type))})};d&&[zb,Ab,Nd].forEach(function(a){return w(u.upload,a,Pe)});r&&[zb,Ab].forEach(function(a){return u.upload.addEventListener(a,function(a){var c;return null===(c=null===r||void 0===r?void 0:r.next)||void 0===c?void 0:c.call(r,a)})});e&&[zb,Ab].forEach(function(a){return w(u,a,Od)});var x=function(c){a.error(new wa("ajax error"+
  (c?" "+c:""),u,q))};u.addEventListener("error",function(a){var c;null===(c=null===r||void 0===r?void 0:r.error)||void 0===c?void 0:c.call(r,a);x()});u.addEventListener(Nd,function(c){var b,d,e=u.status;if(400>e){null===(b=null===r||void 0===r?void 0:r.complete)||void 0===b?void 0:b.call(r);b=void 0;try{b=new yb(c,u,q,Od+"_"+c.type)}catch(ye){a.error(ye);return}a.next(b);a.complete()}else null===(d=null===r||void 0===r?void 0:r.error)||void 0===d?void 0:d.call(r,c),x(e)});e=q.user;d=q.method;h=q.async;
  e?u.open(d,k,h,e,q.password):u.open(d,k,h);h&&(u.timeout=q.timeout,u.responseType=q.responseType);"withCredentials"in u&&(u.withCredentials=q.withCredentials);for(p in f)f.hasOwnProperty(p)&&u.setRequestHeader(p,f[p]);c?u.send(c):u.send();return function(){u&&4!==u.readyState&&u.abort()}})}function Oe(b,a){var c;if(!b||"string"===typeof b||"undefined"!==typeof FormData&&b instanceof FormData||"undefined"!==typeof URLSearchParams&&b instanceof URLSearchParams||Bb(b,"ArrayBuffer")||Bb(b,"File")||Bb(b,
  "Blob")||"undefined"!==typeof ReadableStream&&b instanceof ReadableStream)return b;if("undefined"!==typeof ArrayBuffer&&ArrayBuffer.isView(b))return b.buffer;if("object"===typeof b)return a["content-type"]=null!==(c=a["content-type"])&&void 0!==c?c:"application/json;charset\x3dutf-8",JSON.stringify(b);throw new TypeError("Unknown body type");}function Bb(b,a){return Qe.call(b)==="[object "+a+"]"}var Ta=function(b,a){Ta=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(a,b){a.__proto__=
  b}||function(a,b){for(var c in b)Object.prototype.hasOwnProperty.call(b,c)&&(a[c]=b[c])};return Ta(b,a)},T=function(){T=Object.assign||function(b){for(var a,c=1,d=arguments.length;c<d;c++){a=arguments[c];for(var e in a)Object.prototype.hasOwnProperty.call(a,e)&&(b[e]=a[e])}return b};return T.apply(this,arguments)},Sa=R(function(b){return function(a){b(this);this.message=a?a.length+" errors occurred during unsubscription:\n"+a.map(function(a,b){return b+1+") "+a.toString()}).join("\n  "):"";this.name=
  "UnsubscriptionError";this.errors=a}}),D=function(){function b(a){this.initialTeardown=a;this.closed=!1;this._finalizers=this._parentage=null}b.prototype.unsubscribe=function(){var a,c,b,e,f;if(!this.closed){this.closed=!0;var h=this._parentage;if(h)if(this._parentage=null,Array.isArray(h))try{for(var g=F(h),k=g.next();!k.done;k=g.next())k.value.remove(this)}catch(B){a={error:B}}finally{try{k&&!k.done&&(c=g.return)&&c.call(g)}finally{if(a)throw a.error;}}else h.remove(this);a=this.initialTeardown;
  if(t(a))try{a()}catch(B){f=B instanceof Sa?B.errors:[B]}if(a=this._finalizers){this._finalizers=null;try{for(var m=F(a),p=m.next();!p.done;p=m.next()){var n=p.value;try{a=n,t(a)?a():a.unsubscribe()}catch(B){f=null!==f&&void 0!==f?f:[],B instanceof Sa?f=x(x([],w(f)),w(B.errors)):f.push(B)}}}catch(B){b={error:B}}finally{try{p&&!p.done&&(e=m.return)&&e.call(m)}finally{if(b)throw b.error;}}}if(f)throw new Sa(f);}};b.prototype.add=function(a){var c;if(a&&a!==this)if(this.closed)t(a)?a():a.unsubscribe();
  else{if(a instanceof b){if(a.closed||a._hasParent(this))return;a._addParent(this)}(this._finalizers=null!==(c=this._finalizers)&&void 0!==c?c:[]).push(a)}};b.prototype._hasParent=function(a){var c=this._parentage;return c===a||Array.isArray(c)&&c.includes(a)};b.prototype._addParent=function(a){var c=this._parentage;this._parentage=Array.isArray(c)?(c.push(a),c):c?[c,a]:a};b.prototype._removeParent=function(a){var c=this._parentage;c===a?this._parentage=null:Array.isArray(c)&&M(c,a)};b.prototype.remove=
  function(a){var c=this._finalizers;c&&M(c,a);a instanceof b&&a._removeParent(this)};b.EMPTY=function(){var a=new b;a.closed=!0;return a}();return b}(),Pd=D.EMPTY,S={onUnhandledError:null,onStoppedNotification:null,Promise:void 0,useDeprecatedSynchronousErrorHandling:!1,useDeprecatedNextContext:!1},da={setTimeout:function(b,a){for(var c=[],d=2;d<arguments.length;d++)c[d-2]=arguments[d];d=da.delegate;return(null===d||void 0===d?0:d.setTimeout)?d.setTimeout.apply(d,x([b,a],w(c))):setTimeout.apply(void 0,
  x([b,a],w(c)))},clearTimeout:function(b){var a=da.delegate;return((null===a||void 0===a?void 0:a.clearTimeout)||clearTimeout)(b)},delegate:void 0},xa=J("C",void 0,void 0),U=null,na=function(b){function a(a){var c=b.call(this)||this;c.isStopped=!1;a?(c.destination=a,Ib(a)&&a.add(c)):c.destination=Re;return c}y(a,b);a.create=function(a,b,e){return new ia(a,b,e)};a.prototype.next=function(a){this.isStopped?Wa(J("N",a,void 0),this):this._next(a)};a.prototype.error=function(a){this.isStopped?Wa(J("E",
  void 0,a),this):(this.isStopped=!0,this._error(a))};a.prototype.complete=function(){this.isStopped?Wa(xa,this):(this.isStopped=!0,this._complete())};a.prototype.unsubscribe=function(){this.closed||(this.isStopped=!0,b.prototype.unsubscribe.call(this),this.destination=null)};a.prototype._next=function(a){this.destination.next(a)};a.prototype._error=function(a){try{this.destination.error(a)}finally{this.unsubscribe()}};a.prototype._complete=function(){try{this.destination.complete()}finally{this.unsubscribe()}};
  return a}(D),Cb=Function.prototype.bind,Se=function(){function b(a){this.partialObserver=a}b.prototype.next=function(a){var c=this.partialObserver;if(c.next)try{c.next(a)}catch(d){Ca(d)}};b.prototype.error=function(a){var c=this.partialObserver;if(c.error)try{c.error(a)}catch(d){Ca(d)}else Ca(a)};b.prototype.complete=function(){var a=this.partialObserver;if(a.complete)try{a.complete()}catch(c){Ca(c)}};return b}(),ia=function(b){function a(a,d,e){var c=b.call(this)||this;t(a)||!a?a={next:null!==a&&
  void 0!==a?a:void 0,error:null!==d&&void 0!==d?d:void 0,complete:null!==e&&void 0!==e?e:void 0}:c&&S.useDeprecatedNextContext&&(d=Object.create(a),d.unsubscribe=function(){return c.unsubscribe()},a={next:a.next&&Cb.call(a.next,d),error:a.error&&Cb.call(a.error,d),complete:a.complete&&Cb.call(a.complete,d)});c.destination=new Se(a);return c}y(a,b);return a}(na),Re={closed:!0,next:C,error:function(b){throw b;},complete:C},pa="function"===typeof Symbol&&Symbol.observable||"@@observable",r=function(){function b(a){a&&
  (this._subscribe=a)}b.prototype.lift=function(a){var c=new b;c.source=this;c.operator=a;return c};b.prototype.subscribe=function(a,c,b){var d=this,f=ce(a)?a:new ia(a,c,b);Ba(function(){var a=d.operator,c=d.source;f.add(a?a.call(f,c):c?d._subscribe(f):d._trySubscribe(f))});return f};b.prototype._trySubscribe=function(a){try{return this._subscribe(a)}catch(c){a.error(c)}};b.prototype.forEach=function(a,c){var b=this;c=Lb(c);return new c(function(c,d){var e=new ia({next:function(c){try{a(c)}catch(k){d(k),
  e.unsubscribe()}},error:d,complete:c});b.subscribe(e)})};b.prototype._subscribe=function(a){var c;return null===(c=this.source)||void 0===c?void 0:c.subscribe(a)};b.prototype[pa]=function(){return this};b.prototype.pipe=function(){for(var a=[],c=0;c<arguments.length;c++)a[c]=arguments[c];return Kb(a)(this)};b.prototype.toPromise=function(a){var c=this;a=Lb(a);return new a(function(a,b){var d;c.subscribe(function(a){return d=a},function(a){return b(a)},function(){return a(d)})})};b.create=function(a){return new b(a)};
  return b}(),Ya=function(b){function a(a,d,e,f,h,g){var c=b.call(this,a)||this;c.onFinalize=h;c.shouldUnsubscribe=g;c._next=d?function(c){try{d(c)}catch(p){a.error(p)}}:b.prototype._next;c._error=f?function(c){try{f(c)}catch(p){a.error(p)}finally{this.unsubscribe()}}:b.prototype._error;c._complete=e?function(){try{e()}catch(z){a.error(z)}finally{this.unsubscribe()}}:b.prototype._complete;return c}y(a,b);a.prototype.unsubscribe=function(){var a;if(!this.shouldUnsubscribe||this.shouldUnsubscribe()){var d=
  this.closed;b.prototype.unsubscribe.call(this);!d&&(null===(a=this.onFinalize)||void 0===a?void 0:a.call(this))}};return a}(na),Ra=function(b){function a(a,d){var c=b.call(this)||this;c.source=a;c.subjectFactory=d;c._subject=null;c._refCount=0;c._connection=null;t(null===a||void 0===a?void 0:a.lift)&&(c.lift=a.lift);return c}y(a,b);a.prototype._subscribe=function(a){return this.getSubject().subscribe(a)};a.prototype.getSubject=function(){var a=this._subject;if(!a||a.isStopped)this._subject=this.subjectFactory();
  return this._subject};a.prototype._teardown=function(){this._refCount=0;var a=this._connection;this._subject=this._connection=null;null===a||void 0===a?void 0:a.unsubscribe()};a.prototype.connect=function(){var a=this,b=this._connection;if(!b){var b=this._connection=new D,e=this.getSubject();b.add(this.source.subscribe(m(e,void 0,function(){a._teardown();e.complete()},function(b){a._teardown();e.error(b)},function(){return a._teardown()})));b.closed&&(this._connection=null,b=D.EMPTY)}return b};a.prototype.refCount=
  function(){return Za()(this)};return a}(r),Da={now:function(){return(Da.delegate||performance).now()},delegate:void 0},N={schedule:function(b){var a=requestAnimationFrame,c=cancelAnimationFrame,d=N.delegate;d&&(a=d.requestAnimationFrame,c=d.cancelAnimationFrame);var e=a(function(a){c=void 0;b(a)});return new D(function(){return null===c||void 0===c?void 0:c(e)})},requestAnimationFrame:function(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];a=N.delegate;return((null===a||void 0===a?void 0:
  a.requestAnimationFrame)||requestAnimationFrame).apply(void 0,x([],w(b)))},cancelAnimationFrame:function(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];a=N.delegate;return((null===a||void 0===a?void 0:a.cancelAnimationFrame)||cancelAnimationFrame).apply(void 0,x([],w(b)))},delegate:void 0},Te=Mb(),Qd=R(function(b){return function(){b(this);this.name="ObjectUnsubscribedError";this.message="object unsubscribed"}}),A=function(b){function a(){var a=b.call(this)||this;a.closed=!1;a.currentObservers=
  null;a.observers=[];a.isStopped=!1;a.hasError=!1;a.thrownError=null;return a}y(a,b);a.prototype.lift=function(a){var b=new Db(this,this);b.operator=a;return b};a.prototype._throwIfClosed=function(){if(this.closed)throw new Qd;};a.prototype.next=function(a){var b=this;Ba(function(){var c,d;b._throwIfClosed();if(!b.isStopped){b.currentObservers||(b.currentObservers=Array.from(b.observers));try{for(var h=F(b.currentObservers),g=h.next();!g.done;g=h.next())g.value.next(a)}catch(k){c={error:k}}finally{try{g&&
  !g.done&&(d=h.return)&&d.call(h)}finally{if(c)throw c.error;}}}})};a.prototype.error=function(a){var b=this;Ba(function(){b._throwIfClosed();if(!b.isStopped){b.hasError=b.isStopped=!0;b.thrownError=a;for(var c=b.observers;c.length;)c.shift().error(a)}})};a.prototype.complete=function(){var a=this;Ba(function(){a._throwIfClosed();if(!a.isStopped){a.isStopped=!0;for(var b=a.observers;b.length;)b.shift().complete()}})};a.prototype.unsubscribe=function(){this.isStopped=this.closed=!0;this.observers=this.currentObservers=
  null};Object.defineProperty(a.prototype,"observed",{get:function(){var a;return 0<(null===(a=this.observers)||void 0===a?void 0:a.length)},enumerable:!1,configurable:!0});a.prototype._trySubscribe=function(a){this._throwIfClosed();return b.prototype._trySubscribe.call(this,a)};a.prototype._subscribe=function(a){this._throwIfClosed();this._checkFinalizedStatuses(a);return this._innerSubscribe(a)};a.prototype._innerSubscribe=function(a){var b=this,c=this.isStopped,f=this.observers;if(this.hasError||
  c)return Pd;this.currentObservers=null;f.push(a);return new D(function(){b.currentObservers=null;M(f,a)})};a.prototype._checkFinalizedStatuses=function(a){var b=this.thrownError,c=this.isStopped;this.hasError?a.error(b):c&&a.complete()};a.prototype.asObservable=function(){var a=new r;a.source=this;return a};a.create=function(a,b){return new Db(a,b)};return a}(r),Db=function(b){function a(a,d){var c=b.call(this)||this;c.destination=a;c.source=d;return c}y(a,b);a.prototype.next=function(a){var b,c;
  null===(c=null===(b=this.destination)||void 0===b?void 0:b.next)||void 0===c?void 0:c.call(b,a)};a.prototype.error=function(a){var b,c;null===(c=null===(b=this.destination)||void 0===b?void 0:b.error)||void 0===c?void 0:c.call(b,a)};a.prototype.complete=function(){var a,b;null===(b=null===(a=this.destination)||void 0===a?void 0:a.complete)||void 0===b?void 0:b.call(a)};a.prototype._subscribe=function(a){var b,c;return null!==(c=null===(b=this.source)||void 0===b?void 0:b.subscribe(a))&&void 0!==c?
  c:Pd};return a}(A),Zc=function(b){function a(a){var c=b.call(this)||this;c._value=a;return c}y(a,b);Object.defineProperty(a.prototype,"value",{get:function(){return this.getValue()},enumerable:!1,configurable:!0});a.prototype._subscribe=function(a){var c=b.prototype._subscribe.call(this,a);!c.closed&&a.next(this._value);return c};a.prototype.getValue=function(){var a=this.thrownError,b=this._value;if(this.hasError)throw a;this._throwIfClosed();return b};a.prototype.next=function(a){b.prototype.next.call(this,
  this._value=a)};return a}(A),ka={now:function(){return(ka.delegate||Date).now()},delegate:void 0},ha=function(b){function a(a,d,e){void 0===a&&(a=Infinity);void 0===d&&(d=Infinity);void 0===e&&(e=ka);var c=b.call(this)||this;c._bufferSize=a;c._windowTime=d;c._timestampProvider=e;c._buffer=[];c._infiniteTimeWindow=Infinity===d;c._bufferSize=Math.max(1,a);c._windowTime=Math.max(1,d);return c}y(a,b);a.prototype.next=function(a){var c=this._buffer,e=this._infiniteTimeWindow,f=this._timestampProvider,
  h=this._windowTime;this.isStopped||(c.push(a),!e&&c.push(f.now()+h));this._trimBuffer();b.prototype.next.call(this,a)};a.prototype._subscribe=function(a){this._throwIfClosed();this._trimBuffer();for(var b=this._innerSubscribe(a),c=this._infiniteTimeWindow,f=this._buffer.slice(),h=0;h<f.length&&!a.closed;h+=c?1:2)a.next(f[h]);this._checkFinalizedStatuses(a);return b};a.prototype._trimBuffer=function(){var a=this._bufferSize,b=this._timestampProvider,e=this._buffer,f=this._infiniteTimeWindow,h=(f?1:
  2)*a;Infinity>a&&h<e.length&&e.splice(0,e.length-h);if(!f){a=b.now();b=0;for(f=1;f<e.length&&e[f]<=a;f+=2)b=f;b&&e.splice(0,b+1)}};return a}(A),fb=function(b){function a(){var a=null!==b&&b.apply(this,arguments)||this;a._value=null;a._hasValue=!1;a._isComplete=!1;return a}y(a,b);a.prototype._checkFinalizedStatuses=function(a){var b=this._hasValue,c=this._value,f=this.thrownError,h=this.isStopped,g=this._isComplete;if(this.hasError)a.error(f);else if(h||g)b&&a.next(c),a.complete()};a.prototype.next=
  function(a){this.isStopped||(this._value=a,this._hasValue=!0)};a.prototype.complete=function(){var a=this._hasValue,d=this._value;this._isComplete||(this._isComplete=!0,a&&b.prototype.next.call(this,d),b.prototype.complete.call(this))};return a}(A),la={setInterval:function(b,a){for(var c=[],d=2;d<arguments.length;d++)c[d-2]=arguments[d];d=la.delegate;return(null===d||void 0===d?0:d.setInterval)?d.setInterval.apply(d,x([b,a],w(c))):setInterval.apply(void 0,x([b,a],w(c)))},clearInterval:function(b){var a=
  la.delegate;return((null===a||void 0===a?void 0:a.clearInterval)||clearInterval)(b)},delegate:void 0},ya=function(b){function a(a,d){var c=b.call(this,a,d)||this;c.scheduler=a;c.work=d;c.pending=!1;return c}y(a,b);a.prototype.schedule=function(a,b){var c;void 0===b&&(b=0);if(this.closed)return this;this.state=a;a=this.id;var d=this.scheduler;null!=a&&(this.id=this.recycleAsyncId(d,a,b));this.pending=!0;this.delay=b;this.id=null!==(c=this.id)&&void 0!==c?c:this.requestAsyncId(d,this.id,b);return this};
  a.prototype.requestAsyncId=function(a,b,e){void 0===e&&(e=0);return la.setInterval(a.flush.bind(a,this),e)};a.prototype.recycleAsyncId=function(a,b,e){void 0===e&&(e=0);if(null!=e&&this.delay===e&&!1===this.pending)return b;null!=b&&la.clearInterval(b)};a.prototype.execute=function(a,b){if(this.closed)return Error("executing a cancelled action");this.pending=!1;if(a=this._execute(a,b))return a;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))};a.prototype._execute=
  function(a,b){b=!1;var c;try{this.work(a)}catch(f){b=!0,c=f?f:Error("Scheduled action threw falsy error")}if(b)return this.unsubscribe(),c};a.prototype.unsubscribe=function(){if(!this.closed){var a=this.id,d=this.scheduler,e=d.actions;this.work=this.state=this.scheduler=null;this.pending=!1;M(e,this);null!=a&&(this.id=this.recycleAsyncId(d,a,null));this.delay=null;b.prototype.unsubscribe.call(this)}};return a}(function(b){function a(a,d){return b.call(this)||this}y(a,b);a.prototype.schedule=function(a,
  b){return this};return a}(D)),Ue=1,Eb,$a={},Ve=function(b){var a=Ue++;$a[a]=!0;Eb||(Eb=Promise.resolve());Eb.then(function(){return Nb(a)&&b()});return a},We=function(b){Nb(b)},ma={setImmediate:function(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];a=ma.delegate;return((null===a||void 0===a?void 0:a.setImmediate)||Ve).apply(void 0,x([],w(b)))},clearImmediate:function(b){var a=ma.delegate;return((null===a||void 0===a?void 0:a.clearImmediate)||We)(b)},delegate:void 0},Xe=function(b){function a(a,
  d){var c=b.call(this,a,d)||this;c.scheduler=a;c.work=d;return c}y(a,b);a.prototype.requestAsyncId=function(a,d,e){void 0===e&&(e=0);if(null!==e&&0<e)return b.prototype.requestAsyncId.call(this,a,d,e);a.actions.push(this);return a._scheduled||(a._scheduled=ma.setImmediate(a.flush.bind(a,void 0)))};a.prototype.recycleAsyncId=function(a,d,e){var c;void 0===e&&(e=0);if(null!=e?0<e:0<this.delay)return b.prototype.recycleAsyncId.call(this,a,d,e);e=a.actions;null!=d&&(null===(c=e[e.length-1])||void 0===
  c?void 0:c.id)!==d&&(ma.clearImmediate(d),a._scheduled===d&&(a._scheduled=void 0))};return a}(ya),Fb=function(){function b(a,c){void 0===c&&(c=b.now);this.schedulerActionCtor=a;this.now=c}b.prototype.schedule=function(a,b,d){void 0===b&&(b=0);return(new this.schedulerActionCtor(this,a)).schedule(d,b)};b.now=ka.now;return b}(),za=function(b){function a(a,d){void 0===d&&(d=Fb.now);a=b.call(this,a,d)||this;a.actions=[];a._active=!1;return a}y(a,b);a.prototype.flush=function(a){var b=this.actions;if(this._active)b.push(a);
  else{var c;this._active=!0;do if(c=a.execute(a.state,a.delay))break;while(a=b.shift());this._active=!1;if(c){for(;a=b.shift();)a.unsubscribe();throw c;}}};return a}(Fb),Rd=new (function(b){function a(){return null!==b&&b.apply(this,arguments)||this}y(a,b);a.prototype.flush=function(a){this._active=!0;var b=this._scheduled;this._scheduled=void 0;var c=this.actions,f;a=a||c.shift();do if(f=a.execute(a.state,a.delay))break;while((a=c[0])&&a.id===b&&c.shift());this._active=!1;if(f){for(;(a=c[0])&&a.id===
  b&&c.shift();)a.unsubscribe();throw f;}};return a}(za))(Xe),I=new za(ya),ib=I,Ye=function(b){function a(a,d){var c=b.call(this,a,d)||this;c.scheduler=a;c.work=d;return c}y(a,b);a.prototype.schedule=function(a,d){void 0===d&&(d=0);if(0<d)return b.prototype.schedule.call(this,a,d);this.delay=d;this.state=a;this.scheduler.flush(this);return this};a.prototype.execute=function(a,d){return 0<d||this.closed?b.prototype.execute.call(this,a,d):this._execute(a,d)};a.prototype.requestAsyncId=function(a,d,e){void 0===
  e&&(e=0);if(null!=e&&0<e||null==e&&0<this.delay)return b.prototype.requestAsyncId.call(this,a,d,e);a.flush(this);return 0};return a}(ya),Sd=new (function(b){function a(){return null!==b&&b.apply(this,arguments)||this}y(a,b);return a}(za))(Ye),Ze=function(b){function a(a,d){var c=b.call(this,a,d)||this;c.scheduler=a;c.work=d;return c}y(a,b);a.prototype.requestAsyncId=function(a,d,e){void 0===e&&(e=0);if(null!==e&&0<e)return b.prototype.requestAsyncId.call(this,a,d,e);a.actions.push(this);return a._scheduled||
  (a._scheduled=N.requestAnimationFrame(function(){return a.flush(void 0)}))};a.prototype.recycleAsyncId=function(a,d,e){var c;void 0===e&&(e=0);if(null!=e?0<e:0<this.delay)return b.prototype.recycleAsyncId.call(this,a,d,e);e=a.actions;null!=d&&(null===(c=e[e.length-1])||void 0===c?void 0:c.id)!==d&&(N.cancelAnimationFrame(d),a._scheduled=void 0)};return a}(ya),Td=new (function(b){function a(){return null!==b&&b.apply(this,arguments)||this}y(a,b);a.prototype.flush=function(a){this._active=!0;var b=
  this._scheduled;this._scheduled=void 0;var c=this.actions,f;a=a||c.shift();do if(f=a.execute(a.state,a.delay))break;while((a=c[0])&&a.id===b&&c.shift());this._active=!1;if(f){for(;(a=c[0])&&a.id===b&&c.shift();)a.unsubscribe();throw f;}};return a}(za))(Ze),Ud=function(b){function a(a,d){void 0===a&&(a=Gb);void 0===d&&(d=Infinity);var c=b.call(this,a,function(){return c.frame})||this;c.maxFrames=d;c.frame=0;c.index=-1;return c}y(a,b);a.prototype.flush=function(){for(var a=this.actions,b=this.maxFrames,
  e,f;(f=a[0])&&f.delay<=b&&!(a.shift(),this.frame=f.delay,e=f.execute(f.state,f.delay)););if(e){for(;f=a.shift();)f.unsubscribe();throw e;}};a.frameTimeFactor=10;return a}(za),Gb=function(b){function a(a,d,e){void 0===e&&(e=a.index+=1);var c=b.call(this,a,d)||this;c.scheduler=a;c.work=d;c.index=e;c.active=!0;c.index=a.index=e;return c}y(a,b);a.prototype.schedule=function(c,d){void 0===d&&(d=0);if(Number.isFinite(d)){if(!this.id)return b.prototype.schedule.call(this,c,d);this.active=!1;var e=new a(this.scheduler,
  this.work);this.add(e);return e.schedule(c,d)}return D.EMPTY};a.prototype.requestAsyncId=function(b,d,e){void 0===e&&(e=0);this.delay=b.frame+e;b=b.actions;b.push(this);b.sort(a.sortActions);return 1};a.prototype.recycleAsyncId=function(a,b,e){};a.prototype._execute=function(a,d){if(!0===this.active)return b.prototype._execute.call(this,a,d)};a.sortActions=function(a,b){return a.delay===b.delay?a.index===b.index?0:a.index>b.index?1:-1:a.delay>b.delay?1:-1};return a}(ya),L=new r(function(b){return b.complete()}),
  bb=function(b){return b&&"number"===typeof b.length&&"function"!==typeof b},ab;ab="function"===typeof Symbol&&Symbol.iterator?Symbol.iterator:"@@iterator";(function(b){b.NEXT="N";b.ERROR="E";b.COMPLETE="C"})(g.NotificationKind||(g.NotificationKind={}));var Pa=function(){function b(a,b,d){this.kind=a;this.value=b;this.error=d;this.hasValue="N"===a}b.prototype.observe=function(a){return Fa(this,a)};b.prototype.do=function(a,b,d){var c=this.kind,f=this.value,h=this.error;return"N"===c?null===a||void 0===
  a?void 0:a(f):"E"===c?null===b||void 0===b?void 0:b(h):null===d||void 0===d?void 0:d()};b.prototype.accept=function(a,b,d){return t(null===a||void 0===a?void 0:a.next)?this.observe(a):this.do(a,b,d)};b.prototype.toObservable=function(){var a=this.kind,b=this.value,d=this.error,b="N"===a?cb(b):"E"===a?Wb(function(){return d}):"C"===a?L:0;if(!b)throw new TypeError("Unexpected notification kind "+a);return b};b.createNext=function(a){return new b("N",a)};b.createError=function(a){return new b("E",void 0,
  a)};b.createComplete=function(){return b.completeNotification};b.completeNotification=new b("C");return b}(),aa=R(function(b){return function(){b(this);this.name="EmptyError";this.message="no elements in sequence"}}),rb=R(function(b){return function(){b(this);this.name="ArgumentOutOfRangeError";this.message="argument out of range"}}),ld=R(function(b){return function(a){b(this);this.name="NotFoundError";this.message=a}}),kd=R(function(b){return function(a){b(this);this.name="SequenceError";this.message=
  a}}),Xb=R(function(b){return function(a){void 0===a&&(a=null);b(this);this.message="Timeout has occurred";this.name="TimeoutError";this.info=a}}),le=Array.isArray,me=Array.isArray,ne=Object.getPrototypeOf,oe=Object.prototype,pe=Object.keys,$e={connector:function(){return new A},resetOnDisconnect:!0},te=["addListener","removeListener"],re=["addEventListener","removeEventListener"],ve=["on","off"],Vd=new r(C),we=Array.isArray,Ae=function(b,a){return b.push(a),b},Ce={connector:function(){return new A}},
  Fe=function(){return function(b,a){this.value=b;this.interval=a}}(),af=Object.freeze({audit:kb,auditTime:ic,buffer:jc,bufferCount:kc,bufferTime:lc,bufferToggle:mc,bufferWhen:nc,catchError:lb,combineAll:Ja,combineLatestAll:Ja,combineLatest:nb,combineLatestWith:qc,concat:sc,concatAll:Ha,concatMap:Ka,concatMapTo:rc,concatWith:tc,connect:La,count:uc,debounce:vc,debounceTime:wc,defaultIfEmpty:ua,delay:xc,delayWhen:Ma,dematerialize:yc,distinct:zc,distinctUntilChanged:qb,distinctUntilKeyChanged:Ac,elementAt:Bc,
  endWith:Cc,every:Dc,exhaust:Oa,exhaustAll:Oa,exhaustMap:Na,expand:Ec,filter:K,finalize:Fc,find:Gc,findIndex:Ic,first:Jc,groupBy:Kc,ignoreElements:ob,isEmpty:Lc,last:Mc,map:Q,mapTo:pb,materialize:Nc,max:Oc,merge:Rc,mergeAll:sa,flatMap:H,mergeMap:H,mergeMapTo:Pc,mergeScan:Qc,mergeWith:Sc,min:Tc,multicast:Qa,observeOn:qa,onErrorResumeNext:Uc,pairwise:Vc,partition:function(b,a){return function(c){return[K(b,a)(c),K(gc(b,a))(c)]}},pluck:Wc,publish:Xc,publishBehavior:Yc,publishLast:$c,publishReplay:ad,
  race:function(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];return tb.apply(void 0,x([],w(Z(b))))},raceWith:tb,reduce:fa,repeat:bd,repeatWhen:cd,retry:dd,retryWhen:ed,refCount:Za,sample:ub,sampleTime:fd,scan:gd,sequenceEqual:hd,share:vb,shareReplay:id,single:jd,skip:md,skipLast:nd,skipUntil:od,skipWhile:pd,startWith:qd,subscribeOn:ra,switchAll:rd,switchMap:ja,switchMapTo:sd,switchScan:td,take:ga,takeLast:sb,takeUntil:ud,takeWhile:vd,tap:wd,throttle:xb,throttleTime:xd,throwIfEmpty:va,
  timeInterval:yd,timeout:eb,timeoutWith:zd,timestamp:Ad,toArray:mb,window:Bd,windowCount:Cd,windowTime:Dd,windowToggle:Ed,windowWhen:Fd,withLatestFrom:Gd,zip:Id,zipAll:Hd,zipWith:Jd}),Aa=function(){return function(b,a){void 0===a&&(a=Infinity);this.subscribedFrame=b;this.unsubscribedFrame=a}}(),Wd=function(){function b(){this.subscriptions=[]}b.prototype.logSubscribedFrame=function(){this.subscriptions.push(new Aa(this.scheduler.now()));return this.subscriptions.length-1};b.prototype.logUnsubscribedFrame=
  function(a){var b=this.subscriptions;b[a]=new Aa(b[a].subscribedFrame,this.scheduler.now())};return b}(),Hb=function(b){function a(a,d){var c=b.call(this,function(a){var b=this,c=b.logSubscribedFrame(),d=new D;d.add(new D(function(){b.logUnsubscribedFrame(c)}));b.scheduleMessages(a);return d})||this;c.messages=a;c.subscriptions=[];c.scheduler=d;return c}y(a,b);a.prototype.scheduleMessages=function(a){for(var b=this.messages.length,c=0;c<b;c++){var f=this.messages[c];a.add(this.scheduler.schedule(function(a){Fa(a.message.notification,
  a.subscriber)},f.frame,{message:f,subscriber:a}))}};return a}(r);Kd(Hb,[Wd]);var Xd=function(b){function a(a,d){var c=b.call(this)||this;c.messages=a;c.subscriptions=[];c.scheduler=d;return c}y(a,b);a.prototype._subscribe=function(a){var c=this,e=c.logSubscribedFrame(),f=new D;f.add(new D(function(){c.logUnsubscribedFrame(e)}));f.add(b.prototype._subscribe.call(this,a));return f};a.prototype.setup=function(){for(var a=this,b=a.messages.length,e=function(b){(function(){var c=a.messages[b],d=c.notification;
  a.scheduler.schedule(function(){Fa(d,a)},c.frame)})()},f=0;f<b;f++)e(f)};return a}(A);Kd(Xd,[Wd]);var bf=function(b){function a(a){var c=b.call(this,Gb,750)||this;c.assertDeepEqual=a;c.hotObservables=[];c.coldObservables=[];c.flushTests=[];c.runMode=!1;return c}y(a,b);a.prototype.createTime=function(b){b=this.runMode?b.trim().indexOf("|"):b.indexOf("|");if(-1===b)throw Error('marble diagram for time should have a completion marker "|"');return b*a.frameTimeFactor};a.prototype.createColdObservable=
  function(b,d,e){if(-1!==b.indexOf("^"))throw Error('cold observable cannot have subscription offset "^"');if(-1!==b.indexOf("!"))throw Error('cold observable cannot have unsubscription marker "!"');b=a.parseMarbles(b,d,e,void 0,this.runMode);b=new Hb(b,this);this.coldObservables.push(b);return b};a.prototype.createHotObservable=function(b,d,e){if(-1!==b.indexOf("!"))throw Error('hot observable cannot have unsubscription marker "!"');b=a.parseMarbles(b,d,e,void 0,this.runMode);b=new Xd(b,this);this.hotObservables.push(b);
  return b};a.prototype.materializeInnerObservable=function(a,b){var c=this,d=[];a.subscribe({next:function(a){d.push({frame:c.frame-b,notification:J("N",a,void 0)})},error:function(a){d.push({frame:c.frame-b,notification:J("E",void 0,a)})},complete:function(){d.push({frame:c.frame-b,notification:xa})}});return d};a.prototype.expectObservable=function(b,d){var c=this;void 0===d&&(d=null);var f=[],g={actual:f,ready:!1};d=a.parseMarblesAsSubscriptions(d,this.runMode);var l=Infinity===d.subscribedFrame?
  0:d.subscribedFrame;d=d.unsubscribedFrame;var k;this.schedule(function(){k=b.subscribe({next:function(a){a=a instanceof r?c.materializeInnerObservable(a,c.frame):a;f.push({frame:c.frame,notification:J("N",a,void 0)})},error:function(a){f.push({frame:c.frame,notification:J("E",void 0,a)})},complete:function(){f.push({frame:c.frame,notification:xa})}})},l);Infinity!==d&&this.schedule(function(){return k.unsubscribe()},d);this.flushTests.push(g);var m=this.runMode;return{toBe:function(b,c,d){g.ready=
  !0;g.expected=a.parseMarbles(b,c,d,!0,m)},toEqual:function(a){g.ready=!0;g.expected=[];c.schedule(function(){k=a.subscribe({next:function(a){a=a instanceof r?c.materializeInnerObservable(a,c.frame):a;g.expected.push({frame:c.frame,notification:J("N",a,void 0)})},error:function(a){g.expected.push({frame:c.frame,notification:J("E",void 0,a)})},complete:function(){g.expected.push({frame:c.frame,notification:xa})}})},l)}}};a.prototype.expectSubscriptions=function(b){var c={actual:b,ready:!1};this.flushTests.push(c);
  var e=this.runMode;return{toBe:function(b){b="string"===typeof b?[b]:b;c.ready=!0;c.expected=b.map(function(b){return a.parseMarblesAsSubscriptions(b,e)}).filter(function(a){return Infinity!==a.subscribedFrame})}}};a.prototype.flush=function(){for(var a=this,d=this.hotObservables;0<d.length;)d.shift().setup();b.prototype.flush.call(this);this.flushTests=this.flushTests.filter(function(b){return b.ready?(a.assertDeepEqual(b.actual,b.expected),!1):!0})};a.parseMarblesAsSubscriptions=function(a,b){var c=
  this;void 0===b&&(b=!1);if("string"!==typeof a)return new Aa(Infinity);var d=x([],w(a));a=d.length;for(var g=-1,l=Infinity,k=Infinity,m=0,p=function(a){var e=m,f=function(a){e+=a*c.frameTimeFactor},h=d[a];switch(h){case " ":b||f(1);break;case "-":f(1);break;case "(":g=m;f(1);break;case ")":g=-1;f(1);break;case "^":if(Infinity!==l)throw Error("found a second subscription point '^' in a subscription marble diagram. There can only be one.");l=-1<g?g:m;f(1);break;case "!":if(Infinity!==k)throw Error("found a second unsubscription point '!' in a subscription marble diagram. There can only be one.");
  k=-1<g?g:m;break;default:if(b&&h.match(/^[0-9]$/)&&(0===a||" "===d[a-1])){var p=d.slice(a).join("").match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);if(p){a+=p[0].length-1;var h=parseFloat(p[1]),q=void 0;switch(p[2]){case "ms":q=h;break;case "s":q=1E3*h;break;case "m":q=6E4*h}f(q/n.frameTimeFactor);break}}throw Error("there can only be '^' and '!' markers in a subscription marble diagram. Found instead '"+h+"'.");}m=e;r=a},n=this,r,q=0;q<a;q++)p(q),q=r;return 0>k?new Aa(l):new Aa(l,k)};a.parseMarbles=function(a,
  b,e,f,g){var c=this;void 0===f&&(f=!1);void 0===g&&(g=!1);if(-1!==a.indexOf("!"))throw Error('conventional marble diagrams cannot have the unsubscription marker "!"');var d=x([],w(a)),h=d.length,p=[];a=g?a.replace(/^[ ]+/,"").indexOf("^"):a.indexOf("^");var m=-1===a?0:a*-this.frameTimeFactor,n="object"!==typeof b?function(a){return a}:function(a){return f&&b[a]instanceof Hb?b[a].messages:b[a]},q=-1;a=function(a){var b=m,f=function(a){b+=a*c.frameTimeFactor},h=void 0,k=d[a];switch(k){case " ":g||f(1);
  break;case "-":f(1);break;case "(":q=m;f(1);break;case ")":q=-1;f(1);break;case "|":h=xa;f(1);break;case "^":f(1);break;case "#":h=J("E",void 0,e||"error");f(1);break;default:if(g&&k.match(/^[0-9]$/)&&(0===a||" "===d[a-1])){var l=d.slice(a).join("").match(/^([0-9]+(?:\.[0-9]+)?)(ms|s|m) /);if(l){a+=l[0].length-1;var k=parseFloat(l[1]),v=void 0;switch(l[2]){case "ms":v=k;break;case "s":v=1E3*k;break;case "m":v=6E4*k}f(v/r.frameTimeFactor);break}}h=J("N",n(k),void 0);f(1)}h&&p.push({frame:-1<q?q:m,
  notification:h});m=b;t=a};for(var r=this,t,y=0;y<h;y++)a(y),y=t;return p};a.prototype.createAnimator=function(){var b=this;if(!this.runMode)throw Error("animate() must only be used in run mode");var d=0,e;return{animate:function(c){var d,f;if(e)throw Error("animate() must not be called more than once within run()");if(/[|#]/.test(c))throw Error("animate() must not complete or error");e=new Map;c=a.parseMarbles(c,void 0,void 0,void 0,!0);try{for(var g=F(c),m=g.next();!m.done;m=g.next())b.schedule(function(){var a,
  c,d=b.now(),f=Array.from(e.values());e.clear();try{for(var g=(a=void 0,F(f)),h=g.next();!h.done;h=g.next()){var k=h.value;k(d)}}catch(X){a={error:X}}finally{try{h&&!h.done&&(c=g.return)&&c.call(g)}finally{if(a)throw a.error;}}},m.value.frame)}catch(p){d={error:p}}finally{try{m&&!m.done&&(f=g.return)&&f.call(g)}finally{if(d)throw d.error;}}},delegate:{requestAnimationFrame:function(a){if(!e)throw Error("animate() was not called within run()");var b=++d;e.set(b,a);return b},cancelAnimationFrame:function(a){if(!e)throw Error("animate() was not called within run()");
  e.delete(a)}}}};a.prototype.createDelegates=function(){var a=this,b=0,e=new Map,f=function(){var b=a.now(),c=Array.from(e.values()).filter(function(a){return a.due<=b}),d=c.filter(function(a){return"immediate"===a.type});if(0<d.length)d=d[0],c=d.handle,d=d.handler,e.delete(c),d();else if(d=c.filter(function(a){return"interval"===a.type}),0<d.length){var c=d[0],g=c.duration,d=c.handler;c.due=b+g;c.subscription=a.schedule(f,g);d()}else if(c=c.filter(function(a){return"timeout"===a.type}),0<c.length)d=
  c[0],c=d.handle,d=d.handler,e.delete(c),d();else throw Error("Expected a due immediate or interval");};return{immediate:{setImmediate:function(c){var d=++b;e.set(d,{due:a.now(),duration:0,handle:d,handler:c,subscription:a.schedule(f,0),type:"immediate"});return d},clearImmediate:function(a){var b=e.get(a);b&&(b.subscription.unsubscribe(),e.delete(a))}},interval:{setInterval:function(c,d){void 0===d&&(d=0);var g=++b;e.set(g,{due:a.now()+d,duration:d,handle:g,handler:c,subscription:a.schedule(f,d),
  type:"interval"});return g},clearInterval:function(a){var b=e.get(a);b&&(b.subscription.unsubscribe(),e.delete(a))}},timeout:{setTimeout:function(c,d){void 0===d&&(d=0);var g=++b;e.set(g,{due:a.now()+d,duration:d,handle:g,handler:c,subscription:a.schedule(f,d),type:"timeout"});return g},clearTimeout:function(a){var b=e.get(a);b&&(b.subscription.unsubscribe(),e.delete(a))}}}};a.prototype.run=function(b){var c=a.frameTimeFactor,e=this.maxFrames;a.frameTimeFactor=1;this.maxFrames=Infinity;this.runMode=
  !0;var f=this.createAnimator(),g=this.createDelegates();N.delegate=f.delegate;ka.delegate=this;ma.delegate=g.immediate;la.delegate=g.interval;da.delegate=g.timeout;Da.delegate=this;f={cold:this.createColdObservable.bind(this),hot:this.createHotObservable.bind(this),flush:this.flush.bind(this),time:this.createTime.bind(this),expectObservable:this.expectObservable.bind(this),expectSubscriptions:this.expectSubscriptions.bind(this),animate:f.animate};try{var l=b(f);this.flush();return l}finally{a.frameTimeFactor=
  c,this.maxFrames=e,this.runMode=!1,N.delegate=void 0,ka.delegate=void 0,ma.delegate=void 0,la.delegate=void 0,da.delegate=void 0,Da.delegate=void 0}};a.frameTimeFactor=10;return a}(Ud),cf=Object.freeze({TestScheduler:bf}),yb=function(){return function(b,a,c,d){void 0===d&&(d="download_load");this.originalEvent=b;this.xhr=a;this.request=c;this.type=d;c=a.status;d=a.responseType;this.status=null!==c&&void 0!==c?c:0;this.responseType=null!==d&&void 0!==d?d:"";this.responseHeaders=(c=a.getAllResponseHeaders())?
  c.split("\n").reduce(function(a,b){var c=b.indexOf(": ");a[b.slice(0,c)]=b.slice(c+2);return a},{}):{};this.response=Ld(a);a=b.total;this.loaded=b.loaded;this.total=a}}(),wa=R(function(b){return function(a,b,d){this.message=a;this.name="AjaxError";this.xhr=b;this.request=d;this.status=b.status;this.responseType=b.responseType;var c;try{c=Ld(b)}catch(f){c=b.responseText}this.response=c}}),Md=function(){function b(a,b){wa.call(this,"ajax timeout",a,b);this.name="AjaxTimeoutError";return this}b.prototype=
  Object.create(wa.prototype);return b}(),Me=Q(function(b){return b.response}),ba=function(){var b=function(a){return Ne("string"===typeof a?{url:a}:a)};b.get=Ge;b.post=He;b.delete=Ie;b.put=Je;b.patch=Ke;b.getJSON=Le;return b}(),Pe="upload",Od="download",zb="loadstart",Ab="progress",Nd="load",Qe=Object.prototype.toString,df=Object.freeze({ajax:ba,AjaxError:wa,AjaxTimeoutError:Md,AjaxResponse:yb}),ef={url:"",deserializer:function(b){return JSON.parse(b.data)},serializer:function(b){return JSON.stringify(b)}},
  Yd=function(b){function a(a,d){var c=b.call(this)||this;c._socket=null;if(a instanceof r)c.destination=d,c.source=a;else{d=c._config=T({},ef);c._output=new A;if("string"===typeof a)d.url=a;else for(var f in a)a.hasOwnProperty(f)&&(d[f]=a[f]);if(!d.WebSocketCtor&&WebSocket)d.WebSocketCtor=WebSocket;else if(!d.WebSocketCtor)throw Error("no WebSocket constructor can be found");c.destination=new ha}return c}y(a,b);a.prototype.lift=function(b){var c=new a(this._config,this.destination);c.operator=b;c.source=
  this;return c};a.prototype._resetState=function(){this._socket=null;this.source||(this.destination=new ha);this._output=new A};a.prototype.multiplex=function(a,b,e){var c=this;return new r(function(d){try{c.next(a())}catch(k){d.error(k)}var f=c.subscribe({next:function(a){try{e(a)&&d.next(a)}catch(z){d.error(z)}},error:function(a){return d.error(a)},complete:function(){return d.complete()}});return function(){try{c.next(b())}catch(k){d.error(k)}f.unsubscribe()}})};a.prototype._connectSocket=function(){var a=
  this,b=this._config,e=b.WebSocketCtor,f=b.protocol,g=b.url,b=b.binaryType,l=this._output,k=null;try{this._socket=k=f?new e(g,f):new e(g),b&&(this._socket.binaryType=b)}catch(p){l.error(p);return}var m=new D(function(){a._socket=null;k&&1===k.readyState&&k.close()});k.onopen=function(b){if(a._socket){var c=a._config.openObserver;c&&c.next(b);b=a.destination;a.destination=na.create(function(b){if(1===k.readyState)try{var c=a._config.serializer;k.send(c(b))}catch(u){a.destination.error(u)}},function(b){var c=
  a._config.closingObserver;c&&c.next(void 0);b&&b.code?k.close(b.code,b.reason):l.error(new TypeError("WebSocketSubject.error must be called with an object with an error code, and an optional reason: { code: number, reason: string }"));a._resetState()},function(){var b=a._config.closingObserver;b&&b.next(void 0);k.close();a._resetState()});b&&b instanceof ha&&m.add(b.subscribe(a.destination))}else k.close(),a._resetState()};k.onerror=function(b){a._resetState();l.error(b)};k.onclose=function(b){k===
  a._socket&&a._resetState();var c=a._config.closeObserver;c&&c.next(b);b.wasClean?l.complete():l.error(b)};k.onmessage=function(b){try{var c=a._config.deserializer;l.next(c(b))}catch(B){l.error(B)}}};a.prototype._subscribe=function(a){var b=this,c=this.source;if(c)return c.subscribe(a);this._socket||this._connectSocket();this._output.subscribe(a);a.add(function(){var a=b._socket;0===b._output.observers.length&&(!a||1!==a.readyState&&0!==a.readyState||a.close(),b._resetState())});return a};a.prototype.unsubscribe=
  function(){var a=this._socket;!a||1!==a.readyState&&0!==a.readyState||a.close();this._resetState();b.prototype.unsubscribe.call(this)};return a}(Db),ff=Object.freeze({webSocket:function(b){return new Yd(b)},WebSocketSubject:Yd}),gf=Object.freeze({fromFetch:function(b,a){void 0===a&&(a={});var c=a.selector,d=Zd(a,["selector"]);return new r(function(a){var e=new AbortController,g=e.signal,l=!0,k=d.signal;if(k)if(k.aborted)e.abort();else{var n=function(){g.aborted||e.abort()};k.addEventListener("abort",
  n);a.add(function(){return k.removeEventListener("abort",n)})}var p=T(T({},d),{signal:g}),r=function(b){l=!1;a.error(b)};fetch(b,p).then(function(b){c?q(c(b)).subscribe(m(a,void 0,function(){l=!1;a.complete()},r)):(l=!1,a.next(b),a.complete())}).catch(r);return function(){l&&e.abort()}})}});g.operators=af;g.testing=cf;g.ajax=df;g.webSocket=ff;g.fetch=gf;g.Observable=r;g.ConnectableObservable=Ra;g.observable=pa;g.animationFrames=function(b){return b?Mb(b):Te};g.Subject=A;g.BehaviorSubject=Zc;g.ReplaySubject=
  ha;g.AsyncSubject=fb;g.asap=Rd;g.asapScheduler=Rd;g.async=ib;g.asyncScheduler=I;g.queue=Sd;g.queueScheduler=Sd;g.animationFrame=Td;g.animationFrameScheduler=Td;g.VirtualTimeScheduler=Ud;g.VirtualAction=Gb;g.Scheduler=Fb;g.Subscription=D;g.Subscriber=na;g.Notification=Pa;g.pipe=Xa;g.noop=C;g.identity=E;g.isObservable=function(b){return!!b&&(b instanceof r||t(b.lift)&&t(b.subscribe))};g.lastValueFrom=function(b,a){var c="object"===typeof a;return new Promise(function(d,e){var f=!1,g;b.subscribe({next:function(a){g=
  a;f=!0},error:e,complete:function(){f?d(g):c?d(a.defaultValue):e(new aa)}})})};g.firstValueFrom=function(b,a){var c="object"===typeof a;return new Promise(function(d,e){var f=new ia({next:function(a){d(a);f.unsubscribe()},error:e,complete:function(){c?d(a.defaultValue):e(new aa)}});b.subscribe(f)})};g.ArgumentOutOfRangeError=rb;g.EmptyError=aa;g.NotFoundError=ld;g.ObjectUnsubscribedError=Qd;g.SequenceError=kd;g.TimeoutError=Xb;g.UnsubscriptionError=Sa;g.bindCallback=function(b,a,c){return Ga(!1,b,
  a,c)};g.bindNodeCallback=function(b,a,c){return Ga(!0,b,a,c)};g.combineLatest=$b;g.concat=ta;g.connectable=function(b,a){void 0===a&&(a=$e);var c=null,d=a.connector;a=a.resetOnDisconnect;var e=void 0===a?!0:a,f=d();a=new r(function(a){return f.subscribe(a)});a.connect=function(){if(!c||c.closed)c=Ia(function(){return b}).subscribe(f),e&&c.add(function(){return f=d()});return c};return a};g.defer=Ia;g.empty=function(b){return b?de(b):L};g.forkJoin=function(){for(var b=[],a=0;a<arguments.length;a++)b[a]=
  arguments[a];var a=oa(b),b=Yb(b),c=b.args,d=b.keys,b=new r(function(a){var b=c.length;if(b)for(var e=Array(b),g=b,k=b,n=function(b){var f=!1;q(c[b]).subscribe(m(a,function(a){f||(f=!0,k--);e[b]=a},function(){return g--},void 0,function(){g&&f||(k||a.next(d?Zb(d,e):e),a.complete())}))},p=0;p<b;p++)n(p);else a.complete()});return a?b.pipe(W(a)):b};g.from=P;g.fromEvent=hb;g.fromEventPattern=dc;g.generate=function(b,a,c,d,e){function f(){var b;return Ua(this,function(d){switch(d.label){case 0:b=k,d.label=
  1;case 1:return a&&!a(b)?[3,4]:[4,l(b)];case 2:d.sent(),d.label=3;case 3:return b=c(b),[3,1];case 4:return[2]}})}var g,l,k;1===arguments.length?(k=b.initialState,a=b.condition,c=b.iterate,g=b.resultSelector,l=void 0===g?E:g,e=b.scheduler):(k=b,!d||Ea(d)?(l=E,e=d):l=d);return Ia(e?function(){return Tb(f(),e)}:f)};g.iif=function(b,a,c){return Ia(function(){return b()?a:c})};g.interval=ec;g.merge=function(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];var a=O(b),c="number"===typeof b[b.length-
  1]?b.pop():Infinity;return b.length?1===b.length?q(b[0]):sa(c)(P(b,a)):L};g.never=function(){return Vd};g.of=cb;g.onErrorResumeNext=fc;g.pairs=function(b,a){return P(Object.entries(b),a)};g.partition=function(b,a,c){return[K(a,c)(q(b)),K(gc(a,c))(q(b))]};g.race=function(){for(var b=[],a=0;a<arguments.length;a++)b[a]=arguments[a];b=Z(b);return 1===b.length?q(b[0]):new r(hc(b))};g.range=function(b,a,c){null==a&&(a=b,b=0);if(0>=a)return L;var d=a+b;return new r(c?function(a){var e=b;return c.schedule(function(){e<
  d?(a.next(e++),this.schedule()):a.complete()})}:function(a){for(var c=b;c<d&&!a.closed;)a.next(c++);a.complete()})};g.throwError=Wb;g.timer=Y;g.using=function(b,a){return new r(function(c){var d=b(),e=a(d);(e?q(e):L).subscribe(c);return function(){d&&d.unsubscribe()}})};g.zip=jb;g.scheduled=Vb;g.EMPTY=L;g.NEVER=Vd;g.config=S;g.audit=kb;g.auditTime=ic;g.buffer=jc;g.bufferCount=kc;g.bufferTime=lc;g.bufferToggle=mc;g.bufferWhen=nc;g.catchError=lb;g.combineAll=Ja;g.combineLatestAll=Ja;g.combineLatestWith=
  qc;g.concatAll=Ha;g.concatMap=Ka;g.concatMapTo=rc;g.concatWith=tc;g.connect=La;g.count=uc;g.debounce=vc;g.debounceTime=wc;g.defaultIfEmpty=ua;g.delay=xc;g.delayWhen=Ma;g.dematerialize=yc;g.distinct=zc;g.distinctUntilChanged=qb;g.distinctUntilKeyChanged=Ac;g.elementAt=Bc;g.endWith=Cc;g.every=Dc;g.exhaust=Oa;g.exhaustAll=Oa;g.exhaustMap=Na;g.expand=Ec;g.filter=K;g.finalize=Fc;g.find=Gc;g.findIndex=Ic;g.first=Jc;g.groupBy=Kc;g.ignoreElements=ob;g.isEmpty=Lc;g.last=Mc;g.map=Q;g.mapTo=pb;g.materialize=
  Nc;g.max=Oc;g.mergeAll=sa;g.flatMap=H;g.mergeMap=H;g.mergeMapTo=Pc;g.mergeScan=Qc;g.mergeWith=Sc;g.min=Tc;g.multicast=Qa;g.observeOn=qa;g.onErrorResumeNextWith=Uc;g.pairwise=Vc;g.pluck=Wc;g.publish=Xc;g.publishBehavior=Yc;g.publishLast=$c;g.publishReplay=ad;g.raceWith=tb;g.reduce=fa;g.repeat=bd;g.repeatWhen=cd;g.retry=dd;g.retryWhen=ed;g.refCount=Za;g.sample=ub;g.sampleTime=fd;g.scan=gd;g.sequenceEqual=hd;g.share=vb;g.shareReplay=id;g.single=jd;g.skip=md;g.skipLast=nd;g.skipUntil=od;g.skipWhile=pd;
  g.startWith=qd;g.subscribeOn=ra;g.switchAll=rd;g.switchMap=ja;g.switchMapTo=sd;g.switchScan=td;g.take=ga;g.takeLast=sb;g.takeUntil=ud;g.takeWhile=vd;g.tap=wd;g.throttle=xb;g.throttleTime=xd;g.throwIfEmpty=va;g.timeInterval=yd;g.timeout=eb;g.timeoutWith=zd;g.timestamp=Ad;g.toArray=mb;g.window=Bd;g.windowCount=Cd;g.windowTime=Dd;g.windowToggle=Ed;g.windowWhen=Fd;g.withLatestFrom=Gd;g.zipAll=Hd;g.zipWith=Jd;Object.defineProperty(g,"__esModule",{value:!0})});
  //# sourceMappingURL=bpRC.umd.min.js.map
  
  !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).bpTime=e()}(this,(function(){"use strict";var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",c="month",f="quarter",h="year",d="date",l="Invalid Date",$=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(t){var e=["th","st","nd","rd"],n=t%100;return"["+t+(e[(n-20)%10]||e[n]||e[0])+"]"}},m=function(t,e,n){var r=String(t);return!r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return(e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return-t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return+(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return{M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},g="en",D={};D[g]=M;var p="$isbpTimeObject",S=function(t){return t instanceof _||!(!t||!t[p])},w=function t(e,n,r){var i;if(!e)return g;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0])}else{var a=e.name;D[a]=e,i=a}return!r&&i&&(g=i),i||!r&&g},O=function(t,e){if(S(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=w(t.locale,null,!0),this.parse(t),this.$x=this.$x||t.x||{},this[p]=!0}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.init()},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds()},m.$utils=function(){return b},m.isValid=function(){return!(this.$d.toString()===l)},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return O(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<O(t)},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return b.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v="set"+(this.$u?"UTC":"");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+"Hours",0);case u:return $(v+"Minutes",1);case s:return $(v+"Seconds",2);case i:return $(v+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,!1)},m.$set=function(t,e){var n,o=b.p(t),f="set"+(this.$u?"UTC":""),l=(n={},n[a]=f+"Date",n[d]=f+"Date",n[c]=f+"Month",n[h]=f+"FullYear",n[u]=f+"Hours",n[s]=f+"Minutes",n[i]=f+"Seconds",n[r]=f+"Milliseconds",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[b.p(t)]()},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l)};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},d=function(t){return b.s(s%12||12,t,"0")},$=f||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r};return r.replace(y,(function(t,r){return r||function(t){switch(t){case"YY":return String(e.$y).slice(-2);case"YYYY":return b.s(e.$y,4,"0");case"M":return a+1;case"MM":return b.s(a+1,2,"0");case"MMM":return h(n.monthsShort,a,c,3);case"MMMM":return h(c,a);case"D":return e.$D;case"DD":return b.s(e.$D,2,"0");case"d":return String(e.$W);case"dd":return h(n.weekdaysMin,e.$W,o,2);case"ddd":return h(n.weekdaysShort,e.$W,o,3);case"dddd":return o[e.$W];case"H":return String(s);case"HH":return b.s(s,2,"0");case"h":return d(1);case"hh":return d(2);case"a":return $(s,u,!0);case"A":return $(s,u,!1);case"m":return String(u);case"mm":return b.s(u,2,"0");case"s":return String(e.$s);case"ss":return b.s(e.$s,2,"0");case"SSS":return b.s(e.$ms,3,"0");case"Z":return i}return null}(t)||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function(){return b.m(y,m)};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g}return l?$:b.a($)},m.daysInMonth=function(){return this.endOf(c).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,!0);return r&&(n.$L=r),n},m.clone=function(){return b.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),k=_.prototype;return O.prototype=k,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",c],["$y",h],["$D",d]].forEach((function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1])}})),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=!0),O},O.locale=w,O.isbpTime=S,O.unix=function(t){return O(1e3*t)},O.en=D[g],O.Ls=D,O.p={},O}));

  /**
 * bpFuzzy.js v7.0.0 - Lightweight fuzzy-search (http://bpFuzzyjs.io)
 *
 * Copyright (c) 2023 Kiro Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.bpFuzzy = factory());
})(this, (function () { 'use strict';

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";

    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  function isArray(value) {
    return !Array.isArray ? getTag(value) === '[object Array]' : Array.isArray(value);
  }

  // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/baseToString.js
  var INFINITY = 1 / 0;
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY ? '-0' : result;
  }
  function toString(value) {
    return value == null ? '' : baseToString(value);
  }
  function isString(value) {
    return typeof value === 'string';
  }
  function isNumber(value) {
    return typeof value === 'number';
  }

  // Adapted from: https://github.com/lodash/lodash/blob/master/isBoolean.js
  function isBoolean(value) {
    return value === true || value === false || isObjectLike(value) && getTag(value) == '[object Boolean]';
  }
  function isObject(value) {
    return _typeof(value) === 'object';
  }

  // Checks if `value` is object-like.
  function isObjectLike(value) {
    return isObject(value) && value !== null;
  }
  function isDefined(value) {
    return value !== undefined && value !== null;
  }
  function isBlank(value) {
    return !value.trim().length;
  }

  // Gets the `toStringTag` of `value`.
  // Adapted from: https://github.com/lodash/lodash/blob/master/.internal/getTag.js
  function getTag(value) {
    return value == null ? value === undefined ? '[object Undefined]' : '[object Null]' : Object.prototype.toString.call(value);
  }

  var EXTENDED_SEARCH_UNAVAILABLE = 'Extended search is not available';
  var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
  var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = function LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key) {
    return "Invalid value for key ".concat(key);
  };
  var PATTERN_LENGTH_TOO_LARGE = function PATTERN_LENGTH_TOO_LARGE(max) {
    return "Pattern length exceeds max of ".concat(max, ".");
  };
  var MISSING_KEY_PROPERTY = function MISSING_KEY_PROPERTY(name) {
    return "Missing ".concat(name, " property in key");
  };
  var INVALID_KEY_WEIGHT_VALUE = function INVALID_KEY_WEIGHT_VALUE(key) {
    return "Property 'weight' in key '".concat(key, "' must be a positive integer");
  };

  var hasOwn = Object.prototype.hasOwnProperty;
  var KeyStore = /*#__PURE__*/function () {
    function KeyStore(keys) {
      var _this = this;
      _classCallCheck(this, KeyStore);
      this._keys = [];
      this._keyMap = {};
      var totalWeight = 0;
      keys.forEach(function (key) {
        var obj = createKey(key);
        _this._keys.push(obj);
        _this._keyMap[obj.id] = obj;
        totalWeight += obj.weight;
      });

      // Normalize weights so that their sum is equal to 1
      this._keys.forEach(function (key) {
        key.weight /= totalWeight;
      });
    }
    _createClass(KeyStore, [{
      key: "get",
      value: function get(keyId) {
        return this._keyMap[keyId];
      }
    }, {
      key: "keys",
      value: function keys() {
        return this._keys;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return JSON.stringify(this._keys);
      }
    }]);
    return KeyStore;
  }();
  function createKey(key) {
    var path = null;
    var id = null;
    var src = null;
    var weight = 1;
    var getFn = null;
    if (isString(key) || isArray(key)) {
      src = key;
      path = createKeyPath(key);
      id = createKeyId(key);
    } else {
      if (!hasOwn.call(key, 'name')) {
        throw new Error(MISSING_KEY_PROPERTY('name'));
      }
      var name = key.name;
      src = name;
      if (hasOwn.call(key, 'weight')) {
        weight = key.weight;
        if (weight <= 0) {
          throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
        }
      }
      path = createKeyPath(name);
      id = createKeyId(name);
      getFn = key.getFn;
    }
    return {
      path: path,
      id: id,
      weight: weight,
      src: src,
      getFn: getFn
    };
  }
  function createKeyPath(key) {
    return isArray(key) ? key : key.split('.');
  }
  function createKeyId(key) {
    return isArray(key) ? key.join('.') : key;
  }

  function get(obj, path) {
    var list = [];
    var arr = false;
    var deepGet = function deepGet(obj, path, index) {
      if (!isDefined(obj)) {
        return;
      }
      if (!path[index]) {
        // If there's no path left, we've arrived at the object we care about.
        list.push(obj);
      } else {
        var key = path[index];
        var value = obj[key];
        if (!isDefined(value)) {
          return;
        }

        // If we're at the last value in the path, and if it's a string/number/bool,
        // add it to the list
        if (index === path.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
          list.push(toString(value));
        } else if (isArray(value)) {
          arr = true;
          // Search each item in the array.
          for (var i = 0, len = value.length; i < len; i += 1) {
            deepGet(value[i], path, index + 1);
          }
        } else if (path.length) {
          // An object. Recurse further.
          deepGet(value, path, index + 1);
        }
      }
    };

    // Backwards compatibility (since path used to be a string)
    deepGet(obj, isString(path) ? path.split('.') : path, 0);
    return arr ? list : list[0];
  }

  var MatchOptions = {
    // Whether the matches should be included in the result set. When `true`, each record in the result
    // set will include the indices of the matched characters.
    // These can consequently be used for highlighting purposes.
    includeMatches: false,
    // When `true`, the matching function will continue to the end of a search pattern even if
    // a perfect match has already been located in the string.
    findAllMatches: false,
    // Minimum number of characters that must be matched before a result is considered a match
    minMatchCharLength: 1
  };
  var BasicOptions = {
    // When `true`, the algorithm continues searching to the end of the input even if a perfect
    // match is found before the end of the same input.
    isCaseSensitive: false,
    // When true, the matching function will continue to the end of a search pattern even if
    includeScore: false,
    // List of properties that will be searched. This also supports nested properties.
    keys: [],
    // Whether to sort the result list, by score
    shouldSort: true,
    // Default sort function: sort by ascending score, ascending index
    sortFn: function sortFn(a, b) {
      return a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1;
    }
  };
  var FuzzyOptions = {
    // Approximately where in the text is the pattern expected to be found?
    location: 0,
    // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
    // (of both letters and location), a threshold of '1.0' would match anything.
    threshold: 0.6,
    // Determines how close the match must be to the fuzzy location (specified above).
    // An exact letter match which is 'distance' characters away from the fuzzy location
    // would score as a complete mismatch. A distance of '0' requires the match be at
    // the exact location specified, a threshold of '1000' would require a perfect match
    // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
    distance: 100
  };
  var AdvancedOptions = {
    // When `true`, it enables the use of unix-like search commands
    useExtendedSearch: false,
    // The get function to use when fetching an object's properties.
    // The default will search nested paths *ie foo.bar.baz*
    getFn: get,
    // When `true`, search will ignore `location` and `distance`, so it won't matter
    // where in the string the pattern appears.
    // More info: https://bpFuzzyjs.io/concepts/scoring-theory.html#fuzziness-score
    ignoreLocation: false,
    // When `true`, the calculation for the relevance score (used for sorting) will
    // ignore the field-length norm.
    // More info: https://bpFuzzyjs.io/concepts/scoring-theory.html#field-length-norm
    ignoreFieldNorm: false,
    // The weight to determine how much field length norm effects scoring.
    fieldNormWeight: 1
  };
  var Config = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, BasicOptions), MatchOptions), FuzzyOptions), AdvancedOptions);

  var SPACE = /[^ ]+/g;

  // Field-length norm: the shorter the field, the higher the weight.
  // Set to 3 decimals to reduce index size.
  function norm() {
    var weight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var mantissa = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
    var cache = new Map();
    var m = Math.pow(10, mantissa);
    return {
      get: function get(value) {
        var numTokens = value.match(SPACE).length;
        if (cache.has(numTokens)) {
          return cache.get(numTokens);
        }

        // Default function is 1/sqrt(x), weight makes that variable
        var norm = 1 / Math.pow(numTokens, 0.5 * weight);

        // In place of `toFixed(mantissa)`, for faster computation
        var n = parseFloat(Math.round(norm * m) / m);
        cache.set(numTokens, n);
        return n;
      },
      clear: function clear() {
        cache.clear();
      }
    };
  }

  var bpFuzzyIndex = /*#__PURE__*/function () {
    function bpFuzzyIndex() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$getFn = _ref.getFn,
        getFn = _ref$getFn === void 0 ? Config.getFn : _ref$getFn,
        _ref$fieldNormWeight = _ref.fieldNormWeight,
        fieldNormWeight = _ref$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref$fieldNormWeight;
      _classCallCheck(this, bpFuzzyIndex);
      this.norm = norm(fieldNormWeight, 3);
      this.getFn = getFn;
      this.isCreated = false;
      this.setIndexRecords();
    }
    _createClass(bpFuzzyIndex, [{
      key: "setSources",
      value: function setSources() {
        var docs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        this.docs = docs;
      }
    }, {
      key: "setIndexRecords",
      value: function setIndexRecords() {
        var records = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        this.records = records;
      }
    }, {
      key: "setKeys",
      value: function setKeys() {
        var _this = this;
        var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        this.keys = keys;
        this._keysMap = {};
        keys.forEach(function (key, idx) {
          _this._keysMap[key.id] = idx;
        });
      }
    }, {
      key: "create",
      value: function create() {
        var _this2 = this;
        if (this.isCreated || !this.docs.length) {
          return;
        }
        this.isCreated = true;

        // List is Array<String>
        if (isString(this.docs[0])) {
          this.docs.forEach(function (doc, docIndex) {
            _this2._addString(doc, docIndex);
          });
        } else {
          // List is Array<Object>
          this.docs.forEach(function (doc, docIndex) {
            _this2._addObject(doc, docIndex);
          });
        }
        this.norm.clear();
      }
      // Adds a doc to the end of the index
    }, {
      key: "add",
      value: function add(doc) {
        var idx = this.size();
        if (isString(doc)) {
          this._addString(doc, idx);
        } else {
          this._addObject(doc, idx);
        }
      }
      // Removes the doc at the specified index of the index
    }, {
      key: "removeAt",
      value: function removeAt(idx) {
        this.records.splice(idx, 1);

        // Change ref index of every subsquent doc
        for (var i = idx, len = this.size(); i < len; i += 1) {
          this.records[i].i -= 1;
        }
      }
    }, {
      key: "getValueForItemAtKeyId",
      value: function getValueForItemAtKeyId(item, keyId) {
        return item[this._keysMap[keyId]];
      }
    }, {
      key: "size",
      value: function size() {
        return this.records.length;
      }
    }, {
      key: "_addString",
      value: function _addString(doc, docIndex) {
        if (!isDefined(doc) || isBlank(doc)) {
          return;
        }
        var record = {
          v: doc,
          i: docIndex,
          n: this.norm.get(doc)
        };
        this.records.push(record);
      }
    }, {
      key: "_addObject",
      value: function _addObject(doc, docIndex) {
        var _this3 = this;
        var record = {
          i: docIndex,
          $: {}
        };

        // Iterate over every key (i.e, path), and fetch the value at that key
        this.keys.forEach(function (key, keyIndex) {
          var value = key.getFn ? key.getFn(doc) : _this3.getFn(doc, key.path);
          if (!isDefined(value)) {
            return;
          }
          if (isArray(value)) {
            var subRecords = [];
            var stack = [{
              nestedArrIndex: -1,
              value: value
            }];
            while (stack.length) {
              var _stack$pop = stack.pop(),
                nestedArrIndex = _stack$pop.nestedArrIndex,
                _value = _stack$pop.value;
              if (!isDefined(_value)) {
                continue;
              }
              if (isString(_value) && !isBlank(_value)) {
                var subRecord = {
                  v: _value,
                  i: nestedArrIndex,
                  n: _this3.norm.get(_value)
                };
                subRecords.push(subRecord);
              } else if (isArray(_value)) {
                _value.forEach(function (item, k) {
                  stack.push({
                    nestedArrIndex: k,
                    value: item
                  });
                });
              } else ;
            }
            record.$[keyIndex] = subRecords;
          } else if (isString(value) && !isBlank(value)) {
            var _subRecord = {
              v: value,
              n: _this3.norm.get(value)
            };
            record.$[keyIndex] = _subRecord;
          }
        });
        this.records.push(record);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return {
          keys: this.keys,
          records: this.records
        };
      }
    }]);
    return bpFuzzyIndex;
  }();
  function createIndex(keys, docs) {
    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref2$getFn = _ref2.getFn,
      getFn = _ref2$getFn === void 0 ? Config.getFn : _ref2$getFn,
      _ref2$fieldNormWeight = _ref2.fieldNormWeight,
      fieldNormWeight = _ref2$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref2$fieldNormWeight;
    var myIndex = new bpFuzzyIndex({
      getFn: getFn,
      fieldNormWeight: fieldNormWeight
    });
    myIndex.setKeys(keys.map(createKey));
    myIndex.setSources(docs);
    myIndex.create();
    return myIndex;
  }
  function parseIndex(data) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref3$getFn = _ref3.getFn,
      getFn = _ref3$getFn === void 0 ? Config.getFn : _ref3$getFn,
      _ref3$fieldNormWeight = _ref3.fieldNormWeight,
      fieldNormWeight = _ref3$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref3$fieldNormWeight;
    var keys = data.keys,
      records = data.records;
    var myIndex = new bpFuzzyIndex({
      getFn: getFn,
      fieldNormWeight: fieldNormWeight
    });
    myIndex.setKeys(keys);
    myIndex.setIndexRecords(records);
    return myIndex;
  }

  function computeScore$1(pattern) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$errors = _ref.errors,
      errors = _ref$errors === void 0 ? 0 : _ref$errors,
      _ref$currentLocation = _ref.currentLocation,
      currentLocation = _ref$currentLocation === void 0 ? 0 : _ref$currentLocation,
      _ref$expectedLocation = _ref.expectedLocation,
      expectedLocation = _ref$expectedLocation === void 0 ? 0 : _ref$expectedLocation,
      _ref$distance = _ref.distance,
      distance = _ref$distance === void 0 ? Config.distance : _ref$distance,
      _ref$ignoreLocation = _ref.ignoreLocation,
      ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
    var accuracy = errors / pattern.length;
    if (ignoreLocation) {
      return accuracy;
    }
    var proximity = Math.abs(expectedLocation - currentLocation);
    if (!distance) {
      // Dodge divide by zero error.
      return proximity ? 1.0 : accuracy;
    }
    return accuracy + proximity / distance;
  }

  function convertMaskToIndices() {
    var matchmask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var minMatchCharLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Config.minMatchCharLength;
    var indices = [];
    var start = -1;
    var end = -1;
    var i = 0;
    for (var len = matchmask.length; i < len; i += 1) {
      var match = matchmask[i];
      if (match && start === -1) {
        start = i;
      } else if (!match && start !== -1) {
        end = i - 1;
        if (end - start + 1 >= minMatchCharLength) {
          indices.push([start, end]);
        }
        start = -1;
      }
    }

    // (i-1 - start) + 1 => i - start
    if (matchmask[i - 1] && i - start >= minMatchCharLength) {
      indices.push([start, i - 1]);
    }
    return indices;
  }

  // Machine word size
  var MAX_BITS = 32;

  function search(text, pattern, patternAlphabet) {
    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
      _ref$location = _ref.location,
      location = _ref$location === void 0 ? Config.location : _ref$location,
      _ref$distance = _ref.distance,
      distance = _ref$distance === void 0 ? Config.distance : _ref$distance,
      _ref$threshold = _ref.threshold,
      threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,
      _ref$findAllMatches = _ref.findAllMatches,
      findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,
      _ref$minMatchCharLeng = _ref.minMatchCharLength,
      minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,
      _ref$includeMatches = _ref.includeMatches,
      includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
      _ref$ignoreLocation = _ref.ignoreLocation,
      ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
    if (pattern.length > MAX_BITS) {
      throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
    }
    var patternLen = pattern.length;
    // Set starting location at beginning text and initialize the alphabet.
    var textLen = text.length;
    // Handle the case when location > text.length
    var expectedLocation = Math.max(0, Math.min(location, textLen));
    // Highest score beyond which we give up.
    var currentThreshold = threshold;
    // Is there a nearby exact match? (speedup)
    var bestLocation = expectedLocation;

    // Performance: only computer matches when the minMatchCharLength > 1
    // OR if `includeMatches` is true.
    var computeMatches = minMatchCharLength > 1 || includeMatches;
    // A mask of the matches, used for building the indices
    var matchMask = computeMatches ? Array(textLen) : [];
    var index;

    // Get all exact matches, here for speed up
    while ((index = text.indexOf(pattern, bestLocation)) > -1) {
      var score = computeScore$1(pattern, {
        currentLocation: index,
        expectedLocation: expectedLocation,
        distance: distance,
        ignoreLocation: ignoreLocation
      });
      currentThreshold = Math.min(score, currentThreshold);
      bestLocation = index + patternLen;
      if (computeMatches) {
        var i = 0;
        while (i < patternLen) {
          matchMask[index + i] = 1;
          i += 1;
        }
      }
    }

    // Reset the best location
    bestLocation = -1;
    var lastBitArr = [];
    var finalScore = 1;
    var binMax = patternLen + textLen;
    var mask = 1 << patternLen - 1;
    for (var _i = 0; _i < patternLen; _i += 1) {
      // Scan for the best match; each iteration allows for one more error.
      // Run a binary search to determine how far from the match location we can stray
      // at this error level.
      var binMin = 0;
      var binMid = binMax;
      while (binMin < binMid) {
        var _score = computeScore$1(pattern, {
          errors: _i,
          currentLocation: expectedLocation + binMid,
          expectedLocation: expectedLocation,
          distance: distance,
          ignoreLocation: ignoreLocation
        });
        if (_score <= currentThreshold) {
          binMin = binMid;
        } else {
          binMax = binMid;
        }
        binMid = Math.floor((binMax - binMin) / 2 + binMin);
      }

      // Use the result from this iteration as the maximum for the next.
      binMax = binMid;
      var start = Math.max(1, expectedLocation - binMid + 1);
      var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;

      // Initialize the bit array
      var bitArr = Array(finish + 2);
      bitArr[finish + 1] = (1 << _i) - 1;
      for (var j = finish; j >= start; j -= 1) {
        var currentLocation = j - 1;
        var charMatch = patternAlphabet[text.charAt(currentLocation)];
        if (computeMatches) {
          // Speed up: quick bool to int conversion (i.e, `charMatch ? 1 : 0`)
          matchMask[currentLocation] = +!!charMatch;
        }

        // First pass: exact match
        bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;

        // Subsequent passes: fuzzy match
        if (_i) {
          bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
        }
        if (bitArr[j] & mask) {
          finalScore = computeScore$1(pattern, {
            errors: _i,
            currentLocation: currentLocation,
            expectedLocation: expectedLocation,
            distance: distance,
            ignoreLocation: ignoreLocation
          });

          // This match will almost certainly be better than any existing match.
          // But check anyway.
          if (finalScore <= currentThreshold) {
            // Indeed it is
            currentThreshold = finalScore;
            bestLocation = currentLocation;

            // Already passed `loc`, downhill from here on in.
            if (bestLocation <= expectedLocation) {
              break;
            }

            // When passing `bestLocation`, don't exceed our current distance from `expectedLocation`.
            start = Math.max(1, 2 * expectedLocation - bestLocation);
          }
        }
      }

      // No hope for a (better) match at greater error levels.
      var _score2 = computeScore$1(pattern, {
        errors: _i + 1,
        currentLocation: expectedLocation,
        expectedLocation: expectedLocation,
        distance: distance,
        ignoreLocation: ignoreLocation
      });
      if (_score2 > currentThreshold) {
        break;
      }
      lastBitArr = bitArr;
    }
    var result = {
      isMatch: bestLocation >= 0,
      // Count exact matches (those with a score of 0) to be "almost" exact
      score: Math.max(0.001, finalScore)
    };
    if (computeMatches) {
      var indices = convertMaskToIndices(matchMask, minMatchCharLength);
      if (!indices.length) {
        result.isMatch = false;
      } else if (includeMatches) {
        result.indices = indices;
      }
    }
    return result;
  }

  function createPatternAlphabet(pattern) {
    var mask = {};
    for (var i = 0, len = pattern.length; i < len; i += 1) {
      var _char = pattern.charAt(i);
      mask[_char] = (mask[_char] || 0) | 1 << len - i - 1;
    }
    return mask;
  }

  var BitapSearch = /*#__PURE__*/function () {
    function BitapSearch(pattern) {
      var _this = this;
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$location = _ref.location,
        location = _ref$location === void 0 ? Config.location : _ref$location,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,
        _ref$distance = _ref.distance,
        distance = _ref$distance === void 0 ? Config.distance : _ref$distance,
        _ref$includeMatches = _ref.includeMatches,
        includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
        _ref$findAllMatches = _ref.findAllMatches,
        findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,
        _ref$minMatchCharLeng = _ref.minMatchCharLength,
        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,
        _ref$isCaseSensitive = _ref.isCaseSensitive,
        isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,
        _ref$ignoreLocation = _ref.ignoreLocation,
        ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
      _classCallCheck(this, BitapSearch);
      this.options = {
        location: location,
        threshold: threshold,
        distance: distance,
        includeMatches: includeMatches,
        findAllMatches: findAllMatches,
        minMatchCharLength: minMatchCharLength,
        isCaseSensitive: isCaseSensitive,
        ignoreLocation: ignoreLocation
      };
      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
      this.chunks = [];
      if (!this.pattern.length) {
        return;
      }
      var addChunk = function addChunk(pattern, startIndex) {
        _this.chunks.push({
          pattern: pattern,
          alphabet: createPatternAlphabet(pattern),
          startIndex: startIndex
        });
      };
      var len = this.pattern.length;
      if (len > MAX_BITS) {
        var i = 0;
        var remainder = len % MAX_BITS;
        var end = len - remainder;
        while (i < end) {
          addChunk(this.pattern.substr(i, MAX_BITS), i);
          i += MAX_BITS;
        }
        if (remainder) {
          var startIndex = len - MAX_BITS;
          addChunk(this.pattern.substr(startIndex), startIndex);
        }
      } else {
        addChunk(this.pattern, 0);
      }
    }
    _createClass(BitapSearch, [{
      key: "searchIn",
      value: function searchIn(text) {
        var _this$options = this.options,
          isCaseSensitive = _this$options.isCaseSensitive,
          includeMatches = _this$options.includeMatches;
        if (!isCaseSensitive) {
          text = text.toLowerCase();
        }

        // Exact match
        if (this.pattern === text) {
          var _result = {
            isMatch: true,
            score: 0
          };
          if (includeMatches) {
            _result.indices = [[0, text.length - 1]];
          }
          return _result;
        }

        // Otherwise, use Bitap algorithm
        var _this$options2 = this.options,
          location = _this$options2.location,
          distance = _this$options2.distance,
          threshold = _this$options2.threshold,
          findAllMatches = _this$options2.findAllMatches,
          minMatchCharLength = _this$options2.minMatchCharLength,
          ignoreLocation = _this$options2.ignoreLocation;
        var allIndices = [];
        var totalScore = 0;
        var hasMatches = false;
        this.chunks.forEach(function (_ref2) {
          var pattern = _ref2.pattern,
            alphabet = _ref2.alphabet,
            startIndex = _ref2.startIndex;
          var _search = search(text, pattern, alphabet, {
              location: location + startIndex,
              distance: distance,
              threshold: threshold,
              findAllMatches: findAllMatches,
              minMatchCharLength: minMatchCharLength,
              includeMatches: includeMatches,
              ignoreLocation: ignoreLocation
            }),
            isMatch = _search.isMatch,
            score = _search.score,
            indices = _search.indices;
          if (isMatch) {
            hasMatches = true;
          }
          totalScore += score;
          if (isMatch && indices) {
            allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));
          }
        });
        var result = {
          isMatch: hasMatches,
          score: hasMatches ? totalScore / this.chunks.length : 1
        };
        if (hasMatches && includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }]);
    return BitapSearch;
  }();

  var BaseMatch = /*#__PURE__*/function () {
    function BaseMatch(pattern) {
      _classCallCheck(this, BaseMatch);
      this.pattern = pattern;
    }
    _createClass(BaseMatch, [{
      key: "search",
      value: function search( /*text*/) {}
    }], [{
      key: "isMultiMatch",
      value: function isMultiMatch(pattern) {
        return getMatch(pattern, this.multiRegex);
      }
    }, {
      key: "isSingleMatch",
      value: function isSingleMatch(pattern) {
        return getMatch(pattern, this.singleRegex);
      }
    }]);
    return BaseMatch;
  }();
  function getMatch(pattern, exp) {
    var matches = pattern.match(exp);
    return matches ? matches[1] : null;
  }

  var ExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(ExactMatch, _BaseMatch);
    var _super = _createSuper(ExactMatch);
    function ExactMatch(pattern) {
      _classCallCheck(this, ExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(ExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = text === this.pattern;
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, this.pattern.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^="(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^=(.*)$/;
      }
    }]);
    return ExactMatch;
  }(BaseMatch);

  var InverseExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(InverseExactMatch, _BaseMatch);
    var _super = _createSuper(InverseExactMatch);
    function InverseExactMatch(pattern) {
      _classCallCheck(this, InverseExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(InverseExactMatch, [{
      key: "search",
      value: function search(text) {
        var index = text.indexOf(this.pattern);
        var isMatch = index === -1;
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'inverse-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^!"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^!(.*)$/;
      }
    }]);
    return InverseExactMatch;
  }(BaseMatch);

  var PrefixExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(PrefixExactMatch, _BaseMatch);
    var _super = _createSuper(PrefixExactMatch);
    function PrefixExactMatch(pattern) {
      _classCallCheck(this, PrefixExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(PrefixExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = text.startsWith(this.pattern);
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, this.pattern.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'prefix-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^\^"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^\^(.*)$/;
      }
    }]);
    return PrefixExactMatch;
  }(BaseMatch);

  var InversePrefixExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(InversePrefixExactMatch, _BaseMatch);
    var _super = _createSuper(InversePrefixExactMatch);
    function InversePrefixExactMatch(pattern) {
      _classCallCheck(this, InversePrefixExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(InversePrefixExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = !text.startsWith(this.pattern);
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'inverse-prefix-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^!\^"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^!\^(.*)$/;
      }
    }]);
    return InversePrefixExactMatch;
  }(BaseMatch);

  var SuffixExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(SuffixExactMatch, _BaseMatch);
    var _super = _createSuper(SuffixExactMatch);
    function SuffixExactMatch(pattern) {
      _classCallCheck(this, SuffixExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(SuffixExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = text.endsWith(this.pattern);
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [text.length - this.pattern.length, text.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'suffix-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^"(.*)"\$$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^(.*)\$$/;
      }
    }]);
    return SuffixExactMatch;
  }(BaseMatch);

  var InverseSuffixExactMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(InverseSuffixExactMatch, _BaseMatch);
    var _super = _createSuper(InverseSuffixExactMatch);
    function InverseSuffixExactMatch(pattern) {
      _classCallCheck(this, InverseSuffixExactMatch);
      return _super.call(this, pattern);
    }
    _createClass(InverseSuffixExactMatch, [{
      key: "search",
      value: function search(text) {
        var isMatch = !text.endsWith(this.pattern);
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: [0, text.length - 1]
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'inverse-suffix-exact';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^!"(.*)"\$$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^!(.*)\$$/;
      }
    }]);
    return InverseSuffixExactMatch;
  }(BaseMatch);

  var FuzzyMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(FuzzyMatch, _BaseMatch);
    var _super = _createSuper(FuzzyMatch);
    function FuzzyMatch(pattern) {
      var _this;
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$location = _ref.location,
        location = _ref$location === void 0 ? Config.location : _ref$location,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,
        _ref$distance = _ref.distance,
        distance = _ref$distance === void 0 ? Config.distance : _ref$distance,
        _ref$includeMatches = _ref.includeMatches,
        includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
        _ref$findAllMatches = _ref.findAllMatches,
        findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,
        _ref$minMatchCharLeng = _ref.minMatchCharLength,
        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,
        _ref$isCaseSensitive = _ref.isCaseSensitive,
        isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,
        _ref$ignoreLocation = _ref.ignoreLocation,
        ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
      _classCallCheck(this, FuzzyMatch);
      _this = _super.call(this, pattern);
      _this._bitapSearch = new BitapSearch(pattern, {
        location: location,
        threshold: threshold,
        distance: distance,
        includeMatches: includeMatches,
        findAllMatches: findAllMatches,
        minMatchCharLength: minMatchCharLength,
        isCaseSensitive: isCaseSensitive,
        ignoreLocation: ignoreLocation
      });
      return _this;
    }
    _createClass(FuzzyMatch, [{
      key: "search",
      value: function search(text) {
        return this._bitapSearch.searchIn(text);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'fuzzy';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^(.*)$/;
      }
    }]);
    return FuzzyMatch;
  }(BaseMatch);

  var IncludeMatch = /*#__PURE__*/function (_BaseMatch) {
    _inherits(IncludeMatch, _BaseMatch);
    var _super = _createSuper(IncludeMatch);
    function IncludeMatch(pattern) {
      _classCallCheck(this, IncludeMatch);
      return _super.call(this, pattern);
    }
    _createClass(IncludeMatch, [{
      key: "search",
      value: function search(text) {
        var location = 0;
        var index;
        var indices = [];
        var patternLen = this.pattern.length;

        // Get all exact matches
        while ((index = text.indexOf(this.pattern, location)) > -1) {
          location = index + patternLen;
          indices.push([index, location - 1]);
        }
        var isMatch = !!indices.length;
        return {
          isMatch: isMatch,
          score: isMatch ? 0 : 1,
          indices: indices
        };
      }
    }], [{
      key: "type",
      get: function get() {
        return 'include';
      }
    }, {
      key: "multiRegex",
      get: function get() {
        return /^'"(.*)"$/;
      }
    }, {
      key: "singleRegex",
      get: function get() {
        return /^'(.*)$/;
      }
    }]);
    return IncludeMatch;
  }(BaseMatch);

  // Order is important. DO NOT CHANGE.
  var searchers = [ExactMatch, IncludeMatch, PrefixExactMatch, InversePrefixExactMatch, InverseSuffixExactMatch, SuffixExactMatch, InverseExactMatch, FuzzyMatch];
  var searchersLen = searchers.length;

  // Regex to split by spaces, but keep anything in quotes together
  var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
  var OR_TOKEN = '|';

  // Return a 2D array representation of the query, for simpler parsing.
  // Example:
  // "^core go$ | rb$ | py$ xy$" => [["^core", "go$"], ["rb$"], ["py$", "xy$"]]
  function parseQuery(pattern) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return pattern.split(OR_TOKEN).map(function (item) {
      var query = item.trim().split(SPACE_RE).filter(function (item) {
        return item && !!item.trim();
      });
      var results = [];
      for (var i = 0, len = query.length; i < len; i += 1) {
        var queryItem = query[i];

        // 1. Handle multiple query match (i.e, once that are quoted, like `"hello world"`)
        var found = false;
        var idx = -1;
        while (!found && ++idx < searchersLen) {
          var searcher = searchers[idx];
          var token = searcher.isMultiMatch(queryItem);
          if (token) {
            results.push(new searcher(token, options));
            found = true;
          }
        }
        if (found) {
          continue;
        }

        // 2. Handle single query matches (i.e, once that are *not* quoted)
        idx = -1;
        while (++idx < searchersLen) {
          var _searcher = searchers[idx];
          var _token = _searcher.isSingleMatch(queryItem);
          if (_token) {
            results.push(new _searcher(_token, options));
            break;
          }
        }
      }
      return results;
    });
  }

  // These extended matchers can return an array of matches, as opposed
  // to a singl match
  var MultiMatchSet = new Set([FuzzyMatch.type, IncludeMatch.type]);

  /**
   * Command-like searching
   * ======================
   *
   * Given multiple search terms delimited by spaces.e.g. `^jscript .python$ ruby !java`,
   * search in a given text.
   *
   * Search syntax:
   *
   * | Token       | Match type                 | Description                            |
   * | ----------- | -------------------------- | -------------------------------------- |
   * | `jscript`   | fuzzy-match                | Items that fuzzy match `jscript`       |
   * | `=scheme`   | exact-match                | Items that are `scheme`                |
   * | `'python`   | include-match              | Items that include `python`            |
   * | `!ruby`     | inverse-exact-match        | Items that do not include `ruby`       |
   * | `^java`     | prefix-exact-match         | Items that start with `java`           |
   * | `!^earlang` | inverse-prefix-exact-match | Items that do not start with `earlang` |
   * | `.js$`      | suffix-exact-match         | Items that end with `.js`              |
   * | `!.go$`     | inverse-suffix-exact-match | Items that do not end with `.go`       |
   *
   * A single pipe character acts as an OR operator. For example, the following
   * query matches entries that start with `core` and end with either`go`, `rb`,
   * or`py`.
   *
   * ```
   * ^core go$ | rb$ | py$
   * ```
   */
  var ExtendedSearch = /*#__PURE__*/function () {
    function ExtendedSearch(pattern) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$isCaseSensitive = _ref.isCaseSensitive,
        isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive,
        _ref$includeMatches = _ref.includeMatches,
        includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
        _ref$minMatchCharLeng = _ref.minMatchCharLength,
        minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng,
        _ref$ignoreLocation = _ref.ignoreLocation,
        ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation,
        _ref$findAllMatches = _ref.findAllMatches,
        findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches,
        _ref$location = _ref.location,
        location = _ref$location === void 0 ? Config.location : _ref$location,
        _ref$threshold = _ref.threshold,
        threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold,
        _ref$distance = _ref.distance,
        distance = _ref$distance === void 0 ? Config.distance : _ref$distance;
      _classCallCheck(this, ExtendedSearch);
      this.query = null;
      this.options = {
        isCaseSensitive: isCaseSensitive,
        includeMatches: includeMatches,
        minMatchCharLength: minMatchCharLength,
        findAllMatches: findAllMatches,
        ignoreLocation: ignoreLocation,
        location: location,
        threshold: threshold,
        distance: distance
      };
      this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
      this.query = parseQuery(this.pattern, this.options);
    }
    _createClass(ExtendedSearch, [{
      key: "searchIn",
      value: function searchIn(text) {
        var query = this.query;
        if (!query) {
          return {
            isMatch: false,
            score: 1
          };
        }
        var _this$options = this.options,
          includeMatches = _this$options.includeMatches,
          isCaseSensitive = _this$options.isCaseSensitive;
        text = isCaseSensitive ? text : text.toLowerCase();
        var numMatches = 0;
        var allIndices = [];
        var totalScore = 0;

        // ORs
        for (var i = 0, qLen = query.length; i < qLen; i += 1) {
          var searchers = query[i];

          // Reset indices
          allIndices.length = 0;
          numMatches = 0;

          // ANDs
          for (var j = 0, pLen = searchers.length; j < pLen; j += 1) {
            var searcher = searchers[j];
            var _searcher$search = searcher.search(text),
              isMatch = _searcher$search.isMatch,
              indices = _searcher$search.indices,
              score = _searcher$search.score;
            if (isMatch) {
              numMatches += 1;
              totalScore += score;
              if (includeMatches) {
                var type = searcher.constructor.type;
                if (MultiMatchSet.has(type)) {
                  allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));
                } else {
                  allIndices.push(indices);
                }
              }
            } else {
              totalScore = 0;
              numMatches = 0;
              allIndices.length = 0;
              break;
            }
          }

          // OR condition, so if TRUE, return
          if (numMatches) {
            var result = {
              isMatch: true,
              score: totalScore / numMatches
            };
            if (includeMatches) {
              result.indices = allIndices;
            }
            return result;
          }
        }

        // Nothing was matched
        return {
          isMatch: false,
          score: 1
        };
      }
    }], [{
      key: "condition",
      value: function condition(_, options) {
        return options.useExtendedSearch;
      }
    }]);
    return ExtendedSearch;
  }();

  var registeredSearchers = [];
  function register() {
    registeredSearchers.push.apply(registeredSearchers, arguments);
  }
  function createSearcher(pattern, options) {
    for (var i = 0, len = registeredSearchers.length; i < len; i += 1) {
      var searcherClass = registeredSearchers[i];
      if (searcherClass.condition(pattern, options)) {
        return new searcherClass(pattern, options);
      }
    }
    return new BitapSearch(pattern, options);
  }

  var LogicalOperator = {
    AND: '$and',
    OR: '$or'
  };
  var KeyType = {
    PATH: '$path',
    PATTERN: '$val'
  };
  var isExpression = function isExpression(query) {
    return !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
  };
  var isPath = function isPath(query) {
    return !!query[KeyType.PATH];
  };
  var isLeaf = function isLeaf(query) {
    return !isArray(query) && isObject(query) && !isExpression(query);
  };
  var convertToExplicit = function convertToExplicit(query) {
    return _defineProperty({}, LogicalOperator.AND, Object.keys(query).map(function (key) {
      return _defineProperty({}, key, query[key]);
    }));
  };

  // When `auto` is `true`, the parse function will infer and initialize and add
  // the appropriate `Searcher` instance
  function parse(query, options) {
    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref3$auto = _ref3.auto,
      auto = _ref3$auto === void 0 ? true : _ref3$auto;
    var next = function next(query) {
      var keys = Object.keys(query);
      var isQueryPath = isPath(query);
      if (!isQueryPath && keys.length > 1 && !isExpression(query)) {
        return next(convertToExplicit(query));
      }
      if (isLeaf(query)) {
        var key = isQueryPath ? query[KeyType.PATH] : keys[0];
        var pattern = isQueryPath ? query[KeyType.PATTERN] : query[key];
        if (!isString(pattern)) {
          throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
        }
        var obj = {
          keyId: createKeyId(key),
          pattern: pattern
        };
        if (auto) {
          obj.searcher = createSearcher(pattern, options);
        }
        return obj;
      }
      var node = {
        children: [],
        operator: keys[0]
      };
      keys.forEach(function (key) {
        var value = query[key];
        if (isArray(value)) {
          value.forEach(function (item) {
            node.children.push(next(item));
          });
        }
      });
      return node;
    };
    if (!isExpression(query)) {
      query = convertToExplicit(query);
    }
    return next(query);
  }

  // Practical scoring function
  function computeScore(results, _ref) {
    var _ref$ignoreFieldNorm = _ref.ignoreFieldNorm,
      ignoreFieldNorm = _ref$ignoreFieldNorm === void 0 ? Config.ignoreFieldNorm : _ref$ignoreFieldNorm;
    results.forEach(function (result) {
      var totalScore = 1;
      result.matches.forEach(function (_ref2) {
        var key = _ref2.key,
          norm = _ref2.norm,
          score = _ref2.score;
        var weight = key ? key.weight : null;
        totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm));
      });
      result.score = totalScore;
    });
  }

  function transformMatches(result, data) {
    var matches = result.matches;
    data.matches = [];
    if (!isDefined(matches)) {
      return;
    }
    matches.forEach(function (match) {
      if (!isDefined(match.indices) || !match.indices.length) {
        return;
      }
      var indices = match.indices,
        value = match.value;
      var obj = {
        indices: indices,
        value: value
      };
      if (match.key) {
        obj.key = match.key.src;
      }
      if (match.idx > -1) {
        obj.refIndex = match.idx;
      }
      data.matches.push(obj);
    });
  }

  function transformScore(result, data) {
    data.score = result.score;
  }

  function format(results, docs) {
    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
      _ref$includeMatches = _ref.includeMatches,
      includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches,
      _ref$includeScore = _ref.includeScore,
      includeScore = _ref$includeScore === void 0 ? Config.includeScore : _ref$includeScore;
    var transformers = [];
    if (includeMatches) transformers.push(transformMatches);
    if (includeScore) transformers.push(transformScore);
    return results.map(function (result) {
      var idx = result.idx;
      var data = {
        item: docs[idx],
        refIndex: idx
      };
      if (transformers.length) {
        transformers.forEach(function (transformer) {
          transformer(result, data);
        });
      }
      return data;
    });
  }

  var bpFuzzy$1 = /*#__PURE__*/function () {
    function bpFuzzy(docs) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var index = arguments.length > 2 ? arguments[2] : undefined;
      _classCallCheck(this, bpFuzzy);
      this.options = _objectSpread2(_objectSpread2({}, Config), options);
      if (this.options.useExtendedSearch && !true) {
        throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
      }
      this._keyStore = new KeyStore(this.options.keys);
      this.setCollection(docs, index);
    }
    _createClass(bpFuzzy, [{
      key: "setCollection",
      value: function setCollection(docs, index) {
        this._docs = docs;
        if (index && !(index instanceof bpFuzzyIndex)) {
          throw new Error(INCORRECT_INDEX_TYPE);
        }
        this._myIndex = index || createIndex(this.options.keys, this._docs, {
          getFn: this.options.getFn,
          fieldNormWeight: this.options.fieldNormWeight
        });
      }
    }, {
      key: "add",
      value: function add(doc) {
        if (!isDefined(doc)) {
          return;
        }
        this._docs.push(doc);
        this._myIndex.add(doc);
      }
    }, {
      key: "remove",
      value: function remove() {
        var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function /* doc, idx */ () {
          return false;
        };
        var results = [];
        for (var i = 0, len = this._docs.length; i < len; i += 1) {
          var doc = this._docs[i];
          if (predicate(doc, i)) {
            this.removeAt(i);
            i -= 1;
            len -= 1;
            results.push(doc);
          }
        }
        return results;
      }
    }, {
      key: "removeAt",
      value: function removeAt(idx) {
        this._docs.splice(idx, 1);
        this._myIndex.removeAt(idx);
      }
    }, {
      key: "getIndex",
      value: function getIndex() {
        return this._myIndex;
      }
    }, {
      key: "search",
      value: function search(query) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref$limit = _ref.limit,
          limit = _ref$limit === void 0 ? -1 : _ref$limit;
        var _this$options = this.options,
          includeMatches = _this$options.includeMatches,
          includeScore = _this$options.includeScore,
          shouldSort = _this$options.shouldSort,
          sortFn = _this$options.sortFn,
          ignoreFieldNorm = _this$options.ignoreFieldNorm;
        var results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
        computeScore(results, {
          ignoreFieldNorm: ignoreFieldNorm
        });
        if (shouldSort) {
          results.sort(sortFn);
        }
        if (isNumber(limit) && limit > -1) {
          results = results.slice(0, limit);
        }
        return format(results, this._docs, {
          includeMatches: includeMatches,
          includeScore: includeScore
        });
      }
    }, {
      key: "_searchStringList",
      value: function _searchStringList(query) {
        var searcher = createSearcher(query, this.options);
        var records = this._myIndex.records;
        var results = [];

        // Iterate over every string in the index
        records.forEach(function (_ref2) {
          var text = _ref2.v,
            idx = _ref2.i,
            norm = _ref2.n;
          if (!isDefined(text)) {
            return;
          }
          var _searcher$searchIn = searcher.searchIn(text),
            isMatch = _searcher$searchIn.isMatch,
            score = _searcher$searchIn.score,
            indices = _searcher$searchIn.indices;
          if (isMatch) {
            results.push({
              item: text,
              idx: idx,
              matches: [{
                score: score,
                value: text,
                norm: norm,
                indices: indices
              }]
            });
          }
        });
        return results;
      }
    }, {
      key: "_searchLogical",
      value: function _searchLogical(query) {
        var _this = this;
        var expression = parse(query, this.options);
        var evaluate = function evaluate(node, item, idx) {
          if (!node.children) {
            var keyId = node.keyId,
              searcher = node.searcher;
            var matches = _this._findMatches({
              key: _this._keyStore.get(keyId),
              value: _this._myIndex.getValueForItemAtKeyId(item, keyId),
              searcher: searcher
            });
            if (matches && matches.length) {
              return [{
                idx: idx,
                item: item,
                matches: matches
              }];
            }
            return [];
          }
          var res = [];
          for (var i = 0, len = node.children.length; i < len; i += 1) {
            var child = node.children[i];
            var result = evaluate(child, item, idx);
            if (result.length) {
              res.push.apply(res, _toConsumableArray(result));
            } else if (node.operator === LogicalOperator.AND) {
              return [];
            }
          }
          return res;
        };
        var records = this._myIndex.records;
        var resultMap = {};
        var results = [];
        records.forEach(function (_ref3) {
          var item = _ref3.$,
            idx = _ref3.i;
          if (isDefined(item)) {
            var expResults = evaluate(expression, item, idx);
            if (expResults.length) {
              // Dedupe when adding
              if (!resultMap[idx]) {
                resultMap[idx] = {
                  idx: idx,
                  item: item,
                  matches: []
                };
                results.push(resultMap[idx]);
              }
              expResults.forEach(function (_ref4) {
                var _resultMap$idx$matche;
                var matches = _ref4.matches;
                (_resultMap$idx$matche = resultMap[idx].matches).push.apply(_resultMap$idx$matche, _toConsumableArray(matches));
              });
            }
          }
        });
        return results;
      }
    }, {
      key: "_searchObjectList",
      value: function _searchObjectList(query) {
        var _this2 = this;
        var searcher = createSearcher(query, this.options);
        var _this$_myIndex = this._myIndex,
          keys = _this$_myIndex.keys,
          records = _this$_myIndex.records;
        var results = [];

        // List is Array<Object>
        records.forEach(function (_ref5) {
          var item = _ref5.$,
            idx = _ref5.i;
          if (!isDefined(item)) {
            return;
          }
          var matches = [];

          // Iterate over every key (i.e, path), and fetch the value at that key
          keys.forEach(function (key, keyIndex) {
            matches.push.apply(matches, _toConsumableArray(_this2._findMatches({
              key: key,
              value: item[keyIndex],
              searcher: searcher
            })));
          });
          if (matches.length) {
            results.push({
              idx: idx,
              item: item,
              matches: matches
            });
          }
        });
        return results;
      }
    }, {
      key: "_findMatches",
      value: function _findMatches(_ref6) {
        var key = _ref6.key,
          value = _ref6.value,
          searcher = _ref6.searcher;
        if (!isDefined(value)) {
          return [];
        }
        var matches = [];
        if (isArray(value)) {
          value.forEach(function (_ref7) {
            var text = _ref7.v,
              idx = _ref7.i,
              norm = _ref7.n;
            if (!isDefined(text)) {
              return;
            }
            var _searcher$searchIn2 = searcher.searchIn(text),
              isMatch = _searcher$searchIn2.isMatch,
              score = _searcher$searchIn2.score,
              indices = _searcher$searchIn2.indices;
            if (isMatch) {
              matches.push({
                score: score,
                key: key,
                value: text,
                idx: idx,
                norm: norm,
                indices: indices
              });
            }
          });
        } else {
          var text = value.v,
            norm = value.n;
          var _searcher$searchIn3 = searcher.searchIn(text),
            isMatch = _searcher$searchIn3.isMatch,
            score = _searcher$searchIn3.score,
            indices = _searcher$searchIn3.indices;
          if (isMatch) {
            matches.push({
              score: score,
              key: key,
              value: text,
              norm: norm,
              indices: indices
            });
          }
        }
        return matches;
      }
    }]);
    return bpFuzzy;
  }();

  bpFuzzy$1.version = '7.0.0';
  bpFuzzy$1.createIndex = createIndex;
  bpFuzzy$1.parseIndex = parseIndex;
  bpFuzzy$1.config = Config;
  {
    bpFuzzy$1.parseQuery = parse;
  }
  {
    register(ExtendedSearch);
  }
  var bpFuzzy = bpFuzzy$1;

  return bpFuzzy;

}));

/**
 * bpSearch - http://bpSearchjs.com - A bit like Solr, but much smaller and not as bright - 2.3.9
 * Copyright (C) 2020 Oliver Nightingale
 * @license MIT
 */

;(function(){

  /**
   * A convenience function for configuring and constructing
   * a new bpSearch Index.
   *
   * A bpSearch.Builder instance is created and the pipeline setup
   * with a trimmer, stop word filter and stemmer.
   *
   * This builder object is yielded to the configuration function
   * that is passed as a parameter, allowing the list of fields
   * and other builder parameters to be customised.
   *
   * All documents _must_ be added within the passed config function.
   *
   * @example
   * var idx = bpSearch(function () {
   *   this.field('title')
   *   this.field('body')
   *   this.ref('id')
   *
   *   documents.forEach(function (doc) {
   *     this.add(doc)
   *   }, this)
   * })
   *
   * @see {@link bpSearch.Builder}
   * @see {@link bpSearch.Pipeline}
   * @see {@link bpSearch.trimmer}
   * @see {@link bpSearch.stopWordFilter}
   * @see {@link bpSearch.stemmer}
   * @namespace {function} bpSearch
   */
  var bpSearch = function (config) {
    var builder = new bpSearch.Builder
  
    builder.pipeline.add(
      bpSearch.trimmer,
      bpSearch.stopWordFilter,
      bpSearch.stemmer
    )
  
    builder.searchPipeline.add(
      bpSearch.stemmer
    )
  
    config.call(builder, builder)
    return builder.build()
  }
  
  bpSearch.version = "2.3.9"
  /*!
   * bpSearch.utils
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * A namespace containing utils for the rest of the bpSearch library
   * @namespace bpSearch.utils
   */
  bpSearch.utils = {}
  
  /**
   * Print a warning message to the console.
   *
   * @param {String} message The message to be printed.
   * @memberOf bpSearch.utils
   * @function
   */
  bpSearch.utils.warn = (function (global) {
    /* eslint-disable no-console */
    return function (message) {
      if (global.console && console.warn) {
        console.warn(message)
      }
    }
    /* eslint-enable no-console */
  })(this)
  
  /**
   * Convert an object to a string.
   *
   * In the case of `null` and `undefined` the function returns
   * the empty string, in all other cases the result of calling
   * `toString` on the passed object is returned.
   *
   * @param {Any} obj The object to convert to a string.
   * @return {String} string representation of the passed object.
   * @memberOf bpSearch.utils
   */
  bpSearch.utils.asString = function (obj) {
    if (obj === void 0 || obj === null) {
      return ""
    } else {
      return obj.toString()
    }
  }
  
  /**
   * Clones an object.
   *
   * Will create a copy of an existing object such that any mutations
   * on the copy cannot affect the original.
   *
   * Only shallow objects are supported, passing a nested object to this
   * function will cause a TypeError.
   *
   * Objects with primitives, and arrays of primitives are supported.
   *
   * @param {Object} obj The object to clone.
   * @return {Object} a clone of the passed object.
   * @throws {TypeError} when a nested object is passed.
   * @memberOf Utils
   */
  bpSearch.utils.clone = function (obj) {
    if (obj === null || obj === undefined) {
      return obj
    }
  
    var clone = Object.create(null),
        keys = Object.keys(obj)
  
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i],
          val = obj[key]
  
      if (Array.isArray(val)) {
        clone[key] = val.slice()
        continue
      }
  
      if (typeof val === 'string' ||
          typeof val === 'number' ||
          typeof val === 'boolean') {
        clone[key] = val
        continue
      }
  
      throw new TypeError("clone is not deep and does not support nested objects")
    }
  
    return clone
  }
  bpSearch.FieldRef = function (docRef, fieldName, stringValue) {
    this.docRef = docRef
    this.fieldName = fieldName
    this._stringValue = stringValue
  }
  
  bpSearch.FieldRef.joiner = "/"
  
  bpSearch.FieldRef.fromString = function (s) {
    var n = s.indexOf(bpSearch.FieldRef.joiner)
  
    if (n === -1) {
      throw "malformed field ref string"
    }
  
    var fieldRef = s.slice(0, n),
        docRef = s.slice(n + 1)
  
    return new bpSearch.FieldRef (docRef, fieldRef, s)
  }
  
  bpSearch.FieldRef.prototype.toString = function () {
    if (this._stringValue == undefined) {
      this._stringValue = this.fieldName + bpSearch.FieldRef.joiner + this.docRef
    }
  
    return this._stringValue
  }
  /*!
   * bpSearch.Set
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * A bpSearch set.
   *
   * @constructor
   */
  bpSearch.Set = function (elements) {
    this.elements = Object.create(null)
  
    if (elements) {
      this.length = elements.length
  
      for (var i = 0; i < this.length; i++) {
        this.elements[elements[i]] = true
      }
    } else {
      this.length = 0
    }
  }
  
  /**
   * A complete set that contains all elements.
   *
   * @static
   * @readonly
   * @type {bpSearch.Set}
   */
  bpSearch.Set.complete = {
    intersect: function (other) {
      return other
    },
  
    union: function () {
      return this
    },
  
    contains: function () {
      return true
    }
  }
  
  /**
   * An empty set that contains no elements.
   *
   * @static
   * @readonly
   * @type {bpSearch.Set}
   */
  bpSearch.Set.empty = {
    intersect: function () {
      return this
    },
  
    union: function (other) {
      return other
    },
  
    contains: function () {
      return false
    }
  }
  
  /**
   * Returns true if this set contains the specified object.
   *
   * @param {object} object - Object whose presence in this set is to be tested.
   * @returns {boolean} - True if this set contains the specified object.
   */
  bpSearch.Set.prototype.contains = function (object) {
    return !!this.elements[object]
  }
  
  /**
   * Returns a new set containing only the elements that are present in both
   * this set and the specified set.
   *
   * @param {bpSearch.Set} other - set to intersect with this set.
   * @returns {bpSearch.Set} a new set that is the intersection of this and the specified set.
   */
  
  bpSearch.Set.prototype.intersect = function (other) {
    var a, b, elements, intersection = []
  
    if (other === bpSearch.Set.complete) {
      return this
    }
  
    if (other === bpSearch.Set.empty) {
      return other
    }
  
    if (this.length < other.length) {
      a = this
      b = other
    } else {
      a = other
      b = this
    }
  
    elements = Object.keys(a.elements)
  
    for (var i = 0; i < elements.length; i++) {
      var element = elements[i]
      if (element in b.elements) {
        intersection.push(element)
      }
    }
  
    return new bpSearch.Set (intersection)
  }
  
  /**
   * Returns a new set combining the elements of this and the specified set.
   *
   * @param {bpSearch.Set} other - set to union with this set.
   * @return {bpSearch.Set} a new set that is the union of this and the specified set.
   */
  
  bpSearch.Set.prototype.union = function (other) {
    if (other === bpSearch.Set.complete) {
      return bpSearch.Set.complete
    }
  
    if (other === bpSearch.Set.empty) {
      return this
    }
  
    return new bpSearch.Set(Object.keys(this.elements).concat(Object.keys(other.elements)))
  }
  /**
   * A function to calculate the inverse document frequency for
   * a posting. This is shared between the builder and the index
   *
   * @private
   * @param {object} posting - The posting for a given term
   * @param {number} documentCount - The total number of documents.
   */
  bpSearch.idf = function (posting, documentCount) {
    var documentsWithTerm = 0
  
    for (var fieldName in posting) {
      if (fieldName == '_index') continue // Ignore the term index, its not a field
      documentsWithTerm += Object.keys(posting[fieldName]).length
    }
  
    var x = (documentCount - documentsWithTerm + 0.5) / (documentsWithTerm + 0.5)
  
    return Math.log(1 + Math.abs(x))
  }
  
  /**
   * A token wraps a string representation of a token
   * as it is passed through the text processing pipeline.
   *
   * @constructor
   * @param {string} [str=''] - The string token being wrapped.
   * @param {object} [metadata={}] - Metadata associated with this token.
   */
  bpSearch.Token = function (str, metadata) {
    this.str = str || ""
    this.metadata = metadata || {}
  }
  
  /**
   * Returns the token string that is being wrapped by this object.
   *
   * @returns {string}
   */
  bpSearch.Token.prototype.toString = function () {
    return this.str
  }
  
  /**
   * A token update function is used when updating or optionally
   * when cloning a token.
   *
   * @callback bpSearch.Token~updateFunction
   * @param {string} str - The string representation of the token.
   * @param {Object} metadata - All metadata associated with this token.
   */
  
  /**
   * Applies the given function to the wrapped string token.
   *
   * @example
   * token.update(function (str, metadata) {
   *   return str.toUpperCase()
   * })
   *
   * @param {bpSearch.Token~updateFunction} fn - A function to apply to the token string.
   * @returns {bpSearch.Token}
   */
  bpSearch.Token.prototype.update = function (fn) {
    this.str = fn(this.str, this.metadata)
    return this
  }
  
  /**
   * Creates a clone of this token. Optionally a function can be
   * applied to the cloned token.
   *
   * @param {bpSearch.Token~updateFunction} [fn] - An optional function to apply to the cloned token.
   * @returns {bpSearch.Token}
   */
  bpSearch.Token.prototype.clone = function (fn) {
    fn = fn || function (s) { return s }
    return new bpSearch.Token (fn(this.str, this.metadata), this.metadata)
  }
  /*!
   * bpSearch.tokenizer
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * A function for splitting a string into tokens ready to be inserted into
   * the search index. Uses `bpSearch.tokenizer.separator` to split strings, change
   * the value of this property to change how strings are split into tokens.
   *
   * This tokenizer will convert its parameter to a string by calling `toString` and
   * then will split this string on the character in `bpSearch.tokenizer.separator`.
   * Arrays will have their elements converted to strings and wrapped in a bpSearch.Token.
   *
   * Optional metadata can be passed to the tokenizer, this metadata will be cloned and
   * added as metadata to every token that is created from the object to be tokenized.
   *
   * @static
   * @param {?(string|object|object[])} obj - The object to convert into tokens
   * @param {?object} metadata - Optional metadata to associate with every token
   * @returns {bpSearch.Token[]}
   * @see {@link bpSearch.Pipeline}
   */
  bpSearch.tokenizer = function (obj, metadata) {
    if (obj == null || obj == undefined) {
      return []
    }
  
    if (Array.isArray(obj)) {
      return obj.map(function (t) {
        return new bpSearch.Token(
          bpSearch.utils.asString(t).toLowerCase(),
          bpSearch.utils.clone(metadata)
        )
      })
    }
  
    var str = obj.toString().toLowerCase(),
        len = str.length,
        tokens = []
  
    for (var sliceEnd = 0, sliceStart = 0; sliceEnd <= len; sliceEnd++) {
      var char = str.charAt(sliceEnd),
          sliceLength = sliceEnd - sliceStart
  
      if ((char.match(bpSearch.tokenizer.separator) || sliceEnd == len)) {
  
        if (sliceLength > 0) {
          var tokenMetadata = bpSearch.utils.clone(metadata) || {}
          tokenMetadata["position"] = [sliceStart, sliceLength]
          tokenMetadata["index"] = tokens.length
  
          tokens.push(
            new bpSearch.Token (
              str.slice(sliceStart, sliceEnd),
              tokenMetadata
            )
          )
        }
  
        sliceStart = sliceEnd + 1
      }
  
    }
  
    return tokens
  }
  
  /**
   * The separator used to split a string into tokens. Override this property to change the behaviour of
   * `bpSearch.tokenizer` behaviour when tokenizing strings. By default this splits on whitespace and hyphens.
   *
   * @static
   * @see bpSearch.tokenizer
   */
  bpSearch.tokenizer.separator = /[\s\-]+/
  /*!
   * bpSearch.Pipeline
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * bpSearch.Pipelines maintain an ordered list of functions to be applied to all
   * tokens in documents entering the search index and queries being ran against
   * the index.
   *
   * An instance of bpSearch.Index created with the bpSearch shortcut will contain a
   * pipeline with a stop word filter and an English language stemmer. Extra
   * functions can be added before or after either of these functions or these
   * default functions can be removed.
   *
   * When run the pipeline will call each function in turn, passing a token, the
   * index of that token in the original list of all tokens and finally a list of
   * all the original tokens.
   *
   * The output of functions in the pipeline will be passed to the next function
   * in the pipeline. To exclude a token from entering the index the function
   * should return undefined, the rest of the pipeline will not be called with
   * this token.
   *
   * For serialisation of pipelines to work, all functions used in an instance of
   * a pipeline should be registered with bpSearch.Pipeline. Registered functions can
   * then be loaded. If trying to load a serialised pipeline that uses functions
   * that are not registered an error will be thrown.
   *
   * If not planning on serialising the pipeline then registering pipeline functions
   * is not necessary.
   *
   * @constructor
   */
  bpSearch.Pipeline = function () {
    this._stack = []
  }
  
  bpSearch.Pipeline.registeredFunctions = Object.create(null)
  
  /**
   * A pipeline function maps bpSearch.Token to bpSearch.Token. A bpSearch.Token contains the token
   * string as well as all known metadata. A pipeline function can mutate the token string
   * or mutate (or add) metadata for a given token.
   *
   * A pipeline function can indicate that the passed token should be discarded by returning
   * null, undefined or an empty string. This token will not be passed to any downstream pipeline
   * functions and will not be added to the index.
   *
   * Multiple tokens can be returned by returning an array of tokens. Each token will be passed
   * to any downstream pipeline functions and all will returned tokens will be added to the index.
   *
   * Any number of pipeline functions may be chained together using a bpSearch.Pipeline.
   *
   * @interface bpSearch.PipelineFunction
   * @param {bpSearch.Token} token - A token from the document being processed.
   * @param {number} i - The index of this token in the complete list of tokens for this document/field.
   * @param {bpSearch.Token[]} tokens - All tokens for this document/field.
   * @returns {(?bpSearch.Token|bpSearch.Token[])}
   */
  
  /**
   * Register a function with the pipeline.
   *
   * Functions that are used in the pipeline should be registered if the pipeline
   * needs to be serialised, or a serialised pipeline needs to be loaded.
   *
   * Registering a function does not add it to a pipeline, functions must still be
   * added to instances of the pipeline for them to be used when running a pipeline.
   *
   * @param {bpSearch.PipelineFunction} fn - The function to check for.
   * @param {String} label - The label to register this function with
   */
  bpSearch.Pipeline.registerFunction = function (fn, label) {
    if (label in this.registeredFunctions) {
      bpSearch.utils.warn('Overwriting existing registered function: ' + label)
    }
  
    fn.label = label
    bpSearch.Pipeline.registeredFunctions[fn.label] = fn
  }
  
  /**
   * Warns if the function is not registered as a Pipeline function.
   *
   * @param {bpSearch.PipelineFunction} fn - The function to check for.
   * @private
   */
  bpSearch.Pipeline.warnIfFunctionNotRegistered = function (fn) {
    var isRegistered = fn.label && (fn.label in this.registeredFunctions)
  
    if (!isRegistered) {
      bpSearch.utils.warn('Function is not registered with pipeline. This may cause problems when serialising the index.\n', fn)
    }
  }
  
  /**
   * Loads a previously serialised pipeline.
   *
   * All functions to be loaded must already be registered with bpSearch.Pipeline.
   * If any function from the serialised data has not been registered then an
   * error will be thrown.
   *
   * @param {Object} serialised - The serialised pipeline to load.
   * @returns {bpSearch.Pipeline}
   */
  bpSearch.Pipeline.load = function (serialised) {
    var pipeline = new bpSearch.Pipeline
  
    serialised.forEach(function (fnName) {
      var fn = bpSearch.Pipeline.registeredFunctions[fnName]
  
      if (fn) {
        pipeline.add(fn)
      } else {
        throw new Error('Cannot load unregistered function: ' + fnName)
      }
    })
  
    return pipeline
  }
  
  /**
   * Adds new functions to the end of the pipeline.
   *
   * Logs a warning if the function has not been registered.
   *
   * @param {bpSearch.PipelineFunction[]} functions - Any number of functions to add to the pipeline.
   */
  bpSearch.Pipeline.prototype.add = function () {
    var fns = Array.prototype.slice.call(arguments)
  
    fns.forEach(function (fn) {
      bpSearch.Pipeline.warnIfFunctionNotRegistered(fn)
      this._stack.push(fn)
    }, this)
  }
  
  /**
   * Adds a single function after a function that already exists in the
   * pipeline.
   *
   * Logs a warning if the function has not been registered.
   *
   * @param {bpSearch.PipelineFunction} existingFn - A function that already exists in the pipeline.
   * @param {bpSearch.PipelineFunction} newFn - The new function to add to the pipeline.
   */
  bpSearch.Pipeline.prototype.after = function (existingFn, newFn) {
    bpSearch.Pipeline.warnIfFunctionNotRegistered(newFn)
  
    var pos = this._stack.indexOf(existingFn)
    if (pos == -1) {
      throw new Error('Cannot find existingFn')
    }
  
    pos = pos + 1
    this._stack.splice(pos, 0, newFn)
  }
  
  /**
   * Adds a single function before a function that already exists in the
   * pipeline.
   *
   * Logs a warning if the function has not been registered.
   *
   * @param {bpSearch.PipelineFunction} existingFn - A function that already exists in the pipeline.
   * @param {bpSearch.PipelineFunction} newFn - The new function to add to the pipeline.
   */
  bpSearch.Pipeline.prototype.before = function (existingFn, newFn) {
    bpSearch.Pipeline.warnIfFunctionNotRegistered(newFn)
  
    var pos = this._stack.indexOf(existingFn)
    if (pos == -1) {
      throw new Error('Cannot find existingFn')
    }
  
    this._stack.splice(pos, 0, newFn)
  }
  
  /**
   * Removes a function from the pipeline.
   *
   * @param {bpSearch.PipelineFunction} fn The function to remove from the pipeline.
   */
  bpSearch.Pipeline.prototype.remove = function (fn) {
    var pos = this._stack.indexOf(fn)
    if (pos == -1) {
      return
    }
  
    this._stack.splice(pos, 1)
  }
  
  /**
   * Runs the current list of functions that make up the pipeline against the
   * passed tokens.
   *
   * @param {Array} tokens The tokens to run through the pipeline.
   * @returns {Array}
   */
  bpSearch.Pipeline.prototype.run = function (tokens) {
    var stackLength = this._stack.length
  
    for (var i = 0; i < stackLength; i++) {
      var fn = this._stack[i]
      var memo = []
  
      for (var j = 0; j < tokens.length; j++) {
        var result = fn(tokens[j], j, tokens)
  
        if (result === null || result === void 0 || result === '') continue
  
        if (Array.isArray(result)) {
          for (var k = 0; k < result.length; k++) {
            memo.push(result[k])
          }
        } else {
          memo.push(result)
        }
      }
  
      tokens = memo
    }
  
    return tokens
  }
  
  /**
   * Convenience method for passing a string through a pipeline and getting
   * strings out. This method takes care of wrapping the passed string in a
   * token and mapping the resulting tokens back to strings.
   *
   * @param {string} str - The string to pass through the pipeline.
   * @param {?object} metadata - Optional metadata to associate with the token
   * passed to the pipeline.
   * @returns {string[]}
   */
  bpSearch.Pipeline.prototype.runString = function (str, metadata) {
    var token = new bpSearch.Token (str, metadata)
  
    return this.run([token]).map(function (t) {
      return t.toString()
    })
  }
  
  /**
   * Resets the pipeline by removing any existing processors.
   *
   */
  bpSearch.Pipeline.prototype.reset = function () {
    this._stack = []
  }
  
  /**
   * Returns a representation of the pipeline ready for serialisation.
   *
   * Logs a warning if the function has not been registered.
   *
   * @returns {Array}
   */
  bpSearch.Pipeline.prototype.toJSON = function () {
    return this._stack.map(function (fn) {
      bpSearch.Pipeline.warnIfFunctionNotRegistered(fn)
  
      return fn.label
    })
  }
  /*!
   * bpSearch.Vector
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * A vector is used to construct the vector space of documents and queries. These
   * vectors support operations to determine the similarity between two documents or
   * a document and a query.
   *
   * Normally no parameters are required for initializing a vector, but in the case of
   * loading a previously dumped vector the raw elements can be provided to the constructor.
   *
   * For performance reasons vectors are implemented with a flat array, where an elements
   * index is immediately followed by its value. E.g. [index, value, index, value]. This
   * allows the underlying array to be as sparse as possible and still offer decent
   * performance when being used for vector calculations.
   *
   * @constructor
   * @param {Number[]} [elements] - The flat list of element index and element value pairs.
   */
  bpSearch.Vector = function (elements) {
    this._magnitude = 0
    this.elements = elements || []
  }
  
  
  /**
   * Calculates the position within the vector to insert a given index.
   *
   * This is used internally by insert and upsert. If there are duplicate indexes then
   * the position is returned as if the value for that index were to be updated, but it
   * is the callers responsibility to check whether there is a duplicate at that index
   *
   * @param {Number} insertIdx - The index at which the element should be inserted.
   * @returns {Number}
   */
  bpSearch.Vector.prototype.positionForIndex = function (index) {
    // For an empty vector the tuple can be inserted at the beginning
    if (this.elements.length == 0) {
      return 0
    }
  
    var start = 0,
        end = this.elements.length / 2,
        sliceLength = end - start,
        pivotPoint = Math.floor(sliceLength / 2),
        pivotIndex = this.elements[pivotPoint * 2]
  
    while (sliceLength > 1) {
      if (pivotIndex < index) {
        start = pivotPoint
      }
  
      if (pivotIndex > index) {
        end = pivotPoint
      }
  
      if (pivotIndex == index) {
        break
      }
  
      sliceLength = end - start
      pivotPoint = start + Math.floor(sliceLength / 2)
      pivotIndex = this.elements[pivotPoint * 2]
    }
  
    if (pivotIndex == index) {
      return pivotPoint * 2
    }
  
    if (pivotIndex > index) {
      return pivotPoint * 2
    }
  
    if (pivotIndex < index) {
      return (pivotPoint + 1) * 2
    }
  }
  
  /**
   * Inserts an element at an index within the vector.
   *
   * Does not allow duplicates, will throw an error if there is already an entry
   * for this index.
   *
   * @param {Number} insertIdx - The index at which the element should be inserted.
   * @param {Number} val - The value to be inserted into the vector.
   */
  bpSearch.Vector.prototype.insert = function (insertIdx, val) {
    this.upsert(insertIdx, val, function () {
      throw "duplicate index"
    })
  }
  
  /**
   * Inserts or updates an existing index within the vector.
   *
   * @param {Number} insertIdx - The index at which the element should be inserted.
   * @param {Number} val - The value to be inserted into the vector.
   * @param {function} fn - A function that is called for updates, the existing value and the
   * requested value are passed as arguments
   */
  bpSearch.Vector.prototype.upsert = function (insertIdx, val, fn) {
    this._magnitude = 0
    var position = this.positionForIndex(insertIdx)
  
    if (this.elements[position] == insertIdx) {
      this.elements[position + 1] = fn(this.elements[position + 1], val)
    } else {
      this.elements.splice(position, 0, insertIdx, val)
    }
  }
  
  /**
   * Calculates the magnitude of this vector.
   *
   * @returns {Number}
   */
  bpSearch.Vector.prototype.magnitude = function () {
    if (this._magnitude) return this._magnitude
  
    var sumOfSquares = 0,
        elementsLength = this.elements.length
  
    for (var i = 1; i < elementsLength; i += 2) {
      var val = this.elements[i]
      sumOfSquares += val * val
    }
  
    return this._magnitude = Math.sqrt(sumOfSquares)
  }
  
  /**
   * Calculates the dot product of this vector and another vector.
   *
   * @param {bpSearch.Vector} otherVector - The vector to compute the dot product with.
   * @returns {Number}
   */
  bpSearch.Vector.prototype.dot = function (otherVector) {
    var dotProduct = 0,
        a = this.elements, b = otherVector.elements,
        aLen = a.length, bLen = b.length,
        aVal = 0, bVal = 0,
        i = 0, j = 0
  
    while (i < aLen && j < bLen) {
      aVal = a[i], bVal = b[j]
      if (aVal < bVal) {
        i += 2
      } else if (aVal > bVal) {
        j += 2
      } else if (aVal == bVal) {
        dotProduct += a[i + 1] * b[j + 1]
        i += 2
        j += 2
      }
    }
  
    return dotProduct
  }
  
  /**
   * Calculates the similarity between this vector and another vector.
   *
   * @param {bpSearch.Vector} otherVector - The other vector to calculate the
   * similarity with.
   * @returns {Number}
   */
  bpSearch.Vector.prototype.similarity = function (otherVector) {
    return this.dot(otherVector) / this.magnitude() || 0
  }
  
  /**
   * Converts the vector to an array of the elements within the vector.
   *
   * @returns {Number[]}
   */
  bpSearch.Vector.prototype.toArray = function () {
    var output = new Array (this.elements.length / 2)
  
    for (var i = 1, j = 0; i < this.elements.length; i += 2, j++) {
      output[j] = this.elements[i]
    }
  
    return output
  }
  
  /**
   * A JSON serializable representation of the vector.
   *
   * @returns {Number[]}
   */
  bpSearch.Vector.prototype.toJSON = function () {
    return this.elements
  }
  /* eslint-disable */
  /*!
   * bpSearch.stemmer
   * Copyright (C) 2020 Oliver Nightingale
   * Includes code from - http://tartarus.org/~martin/PorterStemmer/js.txt
   */
  
  /**
   * bpSearch.stemmer is an english language stemmer, this is a JavaScript
   * implementation of the PorterStemmer taken from http://tartarus.org/~martin
   *
   * @static
   * @implements {bpSearch.PipelineFunction}
   * @param {bpSearch.Token} token - The string to stem
   * @returns {bpSearch.Token}
   * @see {@link bpSearch.Pipeline}
   * @function
   */
  bpSearch.stemmer = (function(){
    var step2list = {
        "ational" : "ate",
        "tional" : "tion",
        "enci" : "ence",
        "anci" : "ance",
        "izer" : "ize",
        "bli" : "ble",
        "alli" : "al",
        "entli" : "ent",
        "eli" : "e",
        "ousli" : "ous",
        "ization" : "ize",
        "ation" : "ate",
        "ator" : "ate",
        "alism" : "al",
        "iveness" : "ive",
        "fulness" : "ful",
        "ousness" : "ous",
        "aliti" : "al",
        "iviti" : "ive",
        "biliti" : "ble",
        "logi" : "log"
      },
  
      step3list = {
        "icate" : "ic",
        "ative" : "",
        "alize" : "al",
        "iciti" : "ic",
        "ical" : "ic",
        "ful" : "",
        "ness" : ""
      },
  
      c = "[^aeiou]",          // consonant
      v = "[aeiouy]",          // vowel
      C = c + "[^aeiouy]*",    // consonant sequence
      V = v + "[aeiou]*",      // vowel sequence
  
      mgr0 = "^(" + C + ")?" + V + C,               // [C]VC... is m>0
      meq1 = "^(" + C + ")?" + V + C + "(" + V + ")?$",  // [C]VC[V] is m=1
      mgr1 = "^(" + C + ")?" + V + C + V + C,       // [C]VCVC... is m>1
      s_v = "^(" + C + ")?" + v;                   // vowel in stem
  
    var re_mgr0 = new RegExp(mgr0);
    var re_mgr1 = new RegExp(mgr1);
    var re_meq1 = new RegExp(meq1);
    var re_s_v = new RegExp(s_v);
  
    var re_1a = /^(.+?)(ss|i)es$/;
    var re2_1a = /^(.+?)([^s])s$/;
    var re_1b = /^(.+?)eed$/;
    var re2_1b = /^(.+?)(ed|ing)$/;
    var re_1b_2 = /.$/;
    var re2_1b_2 = /(at|bl|iz)$/;
    var re3_1b_2 = new RegExp("([^aeiouylsz])\\1$");
    var re4_1b_2 = new RegExp("^" + C + v + "[^aeiouwxy]$");
  
    var re_1c = /^(.+?[^aeiou])y$/;
    var re_2 = /^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/;
  
    var re_3 = /^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/;
  
    var re_4 = /^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/;
    var re2_4 = /^(.+?)(s|t)(ion)$/;
  
    var re_5 = /^(.+?)e$/;
    var re_5_1 = /ll$/;
    var re3_5 = new RegExp("^" + C + v + "[^aeiouwxy]$");
  
    var porterStemmer = function porterStemmer(w) {
      var stem,
        suffix,
        firstch,
        re,
        re2,
        re3,
        re4;
  
      if (w.length < 3) { return w; }
  
      firstch = w.substr(0,1);
      if (firstch == "y") {
        w = firstch.toUpperCase() + w.substr(1);
      }
  
      // Step 1a
      re = re_1a
      re2 = re2_1a;
  
      if (re.test(w)) { w = w.replace(re,"$1$2"); }
      else if (re2.test(w)) { w = w.replace(re2,"$1$2"); }
  
      // Step 1b
      re = re_1b;
      re2 = re2_1b;
      if (re.test(w)) {
        var fp = re.exec(w);
        re = re_mgr0;
        if (re.test(fp[1])) {
          re = re_1b_2;
          w = w.replace(re,"");
        }
      } else if (re2.test(w)) {
        var fp = re2.exec(w);
        stem = fp[1];
        re2 = re_s_v;
        if (re2.test(stem)) {
          w = stem;
          re2 = re2_1b_2;
          re3 = re3_1b_2;
          re4 = re4_1b_2;
          if (re2.test(w)) { w = w + "e"; }
          else if (re3.test(w)) { re = re_1b_2; w = w.replace(re,""); }
          else if (re4.test(w)) { w = w + "e"; }
        }
      }
  
      // Step 1c - replace suffix y or Y by i if preceded by a non-vowel which is not the first letter of the word (so cry -> cri, by -> by, say -> say)
      re = re_1c;
      if (re.test(w)) {
        var fp = re.exec(w);
        stem = fp[1];
        w = stem + "i";
      }
  
      // Step 2
      re = re_2;
      if (re.test(w)) {
        var fp = re.exec(w);
        stem = fp[1];
        suffix = fp[2];
        re = re_mgr0;
        if (re.test(stem)) {
          w = stem + step2list[suffix];
        }
      }
  
      // Step 3
      re = re_3;
      if (re.test(w)) {
        var fp = re.exec(w);
        stem = fp[1];
        suffix = fp[2];
        re = re_mgr0;
        if (re.test(stem)) {
          w = stem + step3list[suffix];
        }
      }
  
      // Step 4
      re = re_4;
      re2 = re2_4;
      if (re.test(w)) {
        var fp = re.exec(w);
        stem = fp[1];
        re = re_mgr1;
        if (re.test(stem)) {
          w = stem;
        }
      } else if (re2.test(w)) {
        var fp = re2.exec(w);
        stem = fp[1] + fp[2];
        re2 = re_mgr1;
        if (re2.test(stem)) {
          w = stem;
        }
      }
  
      // Step 5
      re = re_5;
      if (re.test(w)) {
        var fp = re.exec(w);
        stem = fp[1];
        re = re_mgr1;
        re2 = re_meq1;
        re3 = re3_5;
        if (re.test(stem) || (re2.test(stem) && !(re3.test(stem)))) {
          w = stem;
        }
      }
  
      re = re_5_1;
      re2 = re_mgr1;
      if (re.test(w) && re2.test(w)) {
        re = re_1b_2;
        w = w.replace(re,"");
      }
  
      // and turn initial Y back to y
  
      if (firstch == "y") {
        w = firstch.toLowerCase() + w.substr(1);
      }
  
      return w;
    };
  
    return function (token) {
      return token.update(porterStemmer);
    }
  })();
  
  bpSearch.Pipeline.registerFunction(bpSearch.stemmer, 'stemmer')
  /*!
   * bpSearch.stopWordFilter
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * bpSearch.generateStopWordFilter builds a stopWordFilter function from the provided
   * list of stop words.
   *
   * The built in bpSearch.stopWordFilter is built using this generator and can be used
   * to generate custom stopWordFilters for applications or non English languages.
   *
   * @function
   * @param {Array} token The token to pass through the filter
   * @returns {bpSearch.PipelineFunction}
   * @see bpSearch.Pipeline
   * @see bpSearch.stopWordFilter
   */
  bpSearch.generateStopWordFilter = function (stopWords) {
    var words = stopWords.reduce(function (memo, stopWord) {
      memo[stopWord] = stopWord
      return memo
    }, {})
  
    return function (token) {
      if (token && words[token.toString()] !== token.toString()) return token
    }
  }
  
  /**
   * bpSearch.stopWordFilter is an English language stop word list filter, any words
   * contained in the list will not be passed through the filter.
   *
   * This is intended to be used in the Pipeline. If the token does not pass the
   * filter then undefined will be returned.
   *
   * @function
   * @implements {bpSearch.PipelineFunction}
   * @params {bpSearch.Token} token - A token to check for being a stop word.
   * @returns {bpSearch.Token}
   * @see {@link bpSearch.Pipeline}
   */
  bpSearch.stopWordFilter = bpSearch.generateStopWordFilter([
    'a',
    'able',
    'about',
    'across',
    'after',
    'all',
    'almost',
    'also',
    'am',
    'among',
    'an',
    'and',
    'any',
    'are',
    'as',
    'at',
    'be',
    'because',
    'been',
    'but',
    'by',
    'can',
    'cannot',
    'could',
    'dear',
    'did',
    'do',
    'does',
    'either',
    'else',
    'ever',
    'every',
    'for',
    'from',
    'get',
    'got',
    'had',
    'has',
    'have',
    'he',
    'her',
    'hers',
    'him',
    'his',
    'how',
    'however',
    'i',
    'if',
    'in',
    'into',
    'is',
    'it',
    'its',
    'just',
    'least',
    'let',
    'like',
    'likely',
    'may',
    'me',
    'might',
    'most',
    'must',
    'my',
    'neither',
    'no',
    'nor',
    'not',
    'of',
    'off',
    'often',
    'on',
    'only',
    'or',
    'other',
    'our',
    'own',
    'rather',
    'said',
    'say',
    'says',
    'she',
    'should',
    'since',
    'so',
    'some',
    'than',
    'that',
    'the',
    'their',
    'them',
    'then',
    'there',
    'these',
    'they',
    'this',
    'tis',
    'to',
    'too',
    'twas',
    'us',
    'wants',
    'was',
    'we',
    'were',
    'what',
    'when',
    'where',
    'which',
    'while',
    'who',
    'whom',
    'why',
    'will',
    'with',
    'would',
    'yet',
    'you',
    'your'
  ])
  
  bpSearch.Pipeline.registerFunction(bpSearch.stopWordFilter, 'stopWordFilter')
  /*!
   * bpSearch.trimmer
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * bpSearch.trimmer is a pipeline function for trimming non word
   * characters from the beginning and end of tokens before they
   * enter the index.
   *
   * This implementation may not work correctly for non latin
   * characters and should either be removed or adapted for use
   * with languages with non-latin characters.
   *
   * @static
   * @implements {bpSearch.PipelineFunction}
   * @param {bpSearch.Token} token The token to pass through the filter
   * @returns {bpSearch.Token}
   * @see bpSearch.Pipeline
   */
  bpSearch.trimmer = function (token) {
    return token.update(function (s) {
      return s.replace(/^\W+/, '').replace(/\W+$/, '')
    })
  }
  
  bpSearch.Pipeline.registerFunction(bpSearch.trimmer, 'trimmer')
  /*!
   * bpSearch.TokenSet
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * A token set is used to store the unique list of all tokens
   * within an index. Token sets are also used to represent an
   * incoming query to the index, this query token set and index
   * token set are then intersected to find which tokens to look
   * up in the inverted index.
   *
   * A token set can hold multiple tokens, as in the case of the
   * index token set, or it can hold a single token as in the
   * case of a simple query token set.
   *
   * Additionally token sets are used to perform wildcard matching.
   * Leading, contained and trailing wildcards are supported, and
   * from this edit distance matching can also be provided.
   *
   * Token sets are implemented as a minimal finite state automata,
   * where both common prefixes and suffixes are shared between tokens.
   * This helps to reduce the space used for storing the token set.
   *
   * @constructor
   */
  bpSearch.TokenSet = function () {
    this.final = false
    this.edges = {}
    this.id = bpSearch.TokenSet._nextId
    bpSearch.TokenSet._nextId += 1
  }
  
  /**
   * Keeps track of the next, auto increment, identifier to assign
   * to a new tokenSet.
   *
   * TokenSets require a unique identifier to be correctly minimised.
   *
   * @private
   */
  bpSearch.TokenSet._nextId = 1
  
  /**
   * Creates a TokenSet instance from the given sorted array of words.
   *
   * @param {String[]} arr - A sorted array of strings to create the set from.
   * @returns {bpSearch.TokenSet}
   * @throws Will throw an error if the input array is not sorted.
   */
  bpSearch.TokenSet.fromArray = function (arr) {
    var builder = new bpSearch.TokenSet.Builder
  
    for (var i = 0, len = arr.length; i < len; i++) {
      builder.insert(arr[i])
    }
  
    builder.finish()
    return builder.root
  }
  
  /**
   * Creates a token set from a query clause.
   *
   * @private
   * @param {Object} clause - A single clause from bpSearch.Query.
   * @param {string} clause.term - The query clause term.
   * @param {number} [clause.editDistance] - The optional edit distance for the term.
   * @returns {bpSearch.TokenSet}
   */
  bpSearch.TokenSet.fromClause = function (clause) {
    if ('editDistance' in clause) {
      return bpSearch.TokenSet.fromFuzzyString(clause.term, clause.editDistance)
    } else {
      return bpSearch.TokenSet.fromString(clause.term)
    }
  }
  
  /**
   * Creates a token set representing a single string with a specified
   * edit distance.
   *
   * Insertions, deletions, substitutions and transpositions are each
   * treated as an edit distance of 1.
   *
   * Increasing the allowed edit distance will have a dramatic impact
   * on the performance of both creating and intersecting these TokenSets.
   * It is advised to keep the edit distance less than 3.
   *
   * @param {string} str - The string to create the token set from.
   * @param {number} editDistance - The allowed edit distance to match.
   * @returns {bpSearch.Vector}
   */
  bpSearch.TokenSet.fromFuzzyString = function (str, editDistance) {
    var root = new bpSearch.TokenSet
  
    var stack = [{
      node: root,
      editsRemaining: editDistance,
      str: str
    }]
  
    while (stack.length) {
      var frame = stack.pop()
  
      // no edit
      if (frame.str.length > 0) {
        var char = frame.str.charAt(0),
            noEditNode
  
        if (char in frame.node.edges) {
          noEditNode = frame.node.edges[char]
        } else {
          noEditNode = new bpSearch.TokenSet
          frame.node.edges[char] = noEditNode
        }
  
        if (frame.str.length == 1) {
          noEditNode.final = true
        }
  
        stack.push({
          node: noEditNode,
          editsRemaining: frame.editsRemaining,
          str: frame.str.slice(1)
        })
      }
  
      if (frame.editsRemaining == 0) {
        continue
      }
  
      // insertion
      if ("*" in frame.node.edges) {
        var insertionNode = frame.node.edges["*"]
      } else {
        var insertionNode = new bpSearch.TokenSet
        frame.node.edges["*"] = insertionNode
      }
  
      if (frame.str.length == 0) {
        insertionNode.final = true
      }
  
      stack.push({
        node: insertionNode,
        editsRemaining: frame.editsRemaining - 1,
        str: frame.str
      })
  
      // deletion
      // can only do a deletion if we have enough edits remaining
      // and if there are characters left to delete in the string
      if (frame.str.length > 1) {
        stack.push({
          node: frame.node,
          editsRemaining: frame.editsRemaining - 1,
          str: frame.str.slice(1)
        })
      }
  
      // deletion
      // just removing the last character from the str
      if (frame.str.length == 1) {
        frame.node.final = true
      }
  
      // substitution
      // can only do a substitution if we have enough edits remaining
      // and if there are characters left to substitute
      if (frame.str.length >= 1) {
        if ("*" in frame.node.edges) {
          var substitutionNode = frame.node.edges["*"]
        } else {
          var substitutionNode = new bpSearch.TokenSet
          frame.node.edges["*"] = substitutionNode
        }
  
        if (frame.str.length == 1) {
          substitutionNode.final = true
        }
  
        stack.push({
          node: substitutionNode,
          editsRemaining: frame.editsRemaining - 1,
          str: frame.str.slice(1)
        })
      }
  
      // transposition
      // can only do a transposition if there are edits remaining
      // and there are enough characters to transpose
      if (frame.str.length > 1) {
        var charA = frame.str.charAt(0),
            charB = frame.str.charAt(1),
            transposeNode
  
        if (charB in frame.node.edges) {
          transposeNode = frame.node.edges[charB]
        } else {
          transposeNode = new bpSearch.TokenSet
          frame.node.edges[charB] = transposeNode
        }
  
        if (frame.str.length == 1) {
          transposeNode.final = true
        }
  
        stack.push({
          node: transposeNode,
          editsRemaining: frame.editsRemaining - 1,
          str: charA + frame.str.slice(2)
        })
      }
    }
  
    return root
  }
  
  /**
   * Creates a TokenSet from a string.
   *
   * The string may contain one or more wildcard characters (*)
   * that will allow wildcard matching when intersecting with
   * another TokenSet.
   *
   * @param {string} str - The string to create a TokenSet from.
   * @returns {bpSearch.TokenSet}
   */
  bpSearch.TokenSet.fromString = function (str) {
    var node = new bpSearch.TokenSet,
        root = node
  
    /*
     * Iterates through all characters within the passed string
     * appending a node for each character.
     *
     * When a wildcard character is found then a self
     * referencing edge is introduced to continually match
     * any number of any characters.
     */
    for (var i = 0, len = str.length; i < len; i++) {
      var char = str[i],
          final = (i == len - 1)
  
      if (char == "*") {
        node.edges[char] = node
        node.final = final
  
      } else {
        var next = new bpSearch.TokenSet
        next.final = final
  
        node.edges[char] = next
        node = next
      }
    }
  
    return root
  }
  
  /**
   * Converts this TokenSet into an array of strings
   * contained within the TokenSet.
   *
   * This is not intended to be used on a TokenSet that
   * contains wildcards, in these cases the results are
   * undefined and are likely to cause an infinite loop.
   *
   * @returns {string[]}
   */
  bpSearch.TokenSet.prototype.toArray = function () {
    var words = []
  
    var stack = [{
      prefix: "",
      node: this
    }]
  
    while (stack.length) {
      var frame = stack.pop(),
          edges = Object.keys(frame.node.edges),
          len = edges.length
  
      if (frame.node.final) {
        /* In Safari, at this point the prefix is sometimes corrupted, see:
         * https://github.com/olivernn/bpSearch.js/issues/279 Calling any
         * String.prototype method forces Safari to "cast" this string to what
         * it's supposed to be, fixing the bug. */
        frame.prefix.charAt(0)
        words.push(frame.prefix)
      }
  
      for (var i = 0; i < len; i++) {
        var edge = edges[i]
  
        stack.push({
          prefix: frame.prefix.concat(edge),
          node: frame.node.edges[edge]
        })
      }
    }
  
    return words
  }
  
  /**
   * Generates a string representation of a TokenSet.
   *
   * This is intended to allow TokenSets to be used as keys
   * in objects, largely to aid the construction and minimisation
   * of a TokenSet. As such it is not designed to be a human
   * friendly representation of the TokenSet.
   *
   * @returns {string}
   */
  bpSearch.TokenSet.prototype.toString = function () {
    // NOTE: Using Object.keys here as this.edges is very likely
    // to enter 'hash-mode' with many keys being added
    //
    // avoiding a for-in loop here as it leads to the function
    // being de-optimised (at least in V8). From some simple
    // benchmarks the performance is comparable, but allowing
    // V8 to optimize may mean easy performance wins in the future.
  
    if (this._str) {
      return this._str
    }
  
    var str = this.final ? '1' : '0',
        labels = Object.keys(this.edges).sort(),
        len = labels.length
  
    for (var i = 0; i < len; i++) {
      var label = labels[i],
          node = this.edges[label]
  
      str = str + label + node.id
    }
  
    return str
  }
  
  /**
   * Returns a new TokenSet that is the intersection of
   * this TokenSet and the passed TokenSet.
   *
   * This intersection will take into account any wildcards
   * contained within the TokenSet.
   *
   * @param {bpSearch.TokenSet} b - An other TokenSet to intersect with.
   * @returns {bpSearch.TokenSet}
   */
  bpSearch.TokenSet.prototype.intersect = function (b) {
    var output = new bpSearch.TokenSet,
        frame = undefined
  
    var stack = [{
      qNode: b,
      output: output,
      node: this
    }]
  
    while (stack.length) {
      frame = stack.pop()
  
      // NOTE: As with the #toString method, we are using
      // Object.keys and a for loop instead of a for-in loop
      // as both of these objects enter 'hash' mode, causing
      // the function to be de-optimised in V8
      var qEdges = Object.keys(frame.qNode.edges),
          qLen = qEdges.length,
          nEdges = Object.keys(frame.node.edges),
          nLen = nEdges.length
  
      for (var q = 0; q < qLen; q++) {
        var qEdge = qEdges[q]
  
        for (var n = 0; n < nLen; n++) {
          var nEdge = nEdges[n]
  
          if (nEdge == qEdge || qEdge == '*') {
            var node = frame.node.edges[nEdge],
                qNode = frame.qNode.edges[qEdge],
                final = node.final && qNode.final,
                next = undefined
  
            if (nEdge in frame.output.edges) {
              // an edge already exists for this character
              // no need to create a new node, just set the finality
              // bit unless this node is already final
              next = frame.output.edges[nEdge]
              next.final = next.final || final
  
            } else {
              // no edge exists yet, must create one
              // set the finality bit and insert it
              // into the output
              next = new bpSearch.TokenSet
              next.final = final
              frame.output.edges[nEdge] = next
            }
  
            stack.push({
              qNode: qNode,
              output: next,
              node: node
            })
          }
        }
      }
    }
  
    return output
  }
  bpSearch.TokenSet.Builder = function () {
    this.previousWord = ""
    this.root = new bpSearch.TokenSet
    this.uncheckedNodes = []
    this.minimizedNodes = {}
  }
  
  bpSearch.TokenSet.Builder.prototype.insert = function (word) {
    var node,
        commonPrefix = 0
  
    if (word < this.previousWord) {
      throw new Error ("Out of order word insertion")
    }
  
    for (var i = 0; i < word.length && i < this.previousWord.length; i++) {
      if (word[i] != this.previousWord[i]) break
      commonPrefix++
    }
  
    this.minimize(commonPrefix)
  
    if (this.uncheckedNodes.length == 0) {
      node = this.root
    } else {
      node = this.uncheckedNodes[this.uncheckedNodes.length - 1].child
    }
  
    for (var i = commonPrefix; i < word.length; i++) {
      var nextNode = new bpSearch.TokenSet,
          char = word[i]
  
      node.edges[char] = nextNode
  
      this.uncheckedNodes.push({
        parent: node,
        char: char,
        child: nextNode
      })
  
      node = nextNode
    }
  
    node.final = true
    this.previousWord = word
  }
  
  bpSearch.TokenSet.Builder.prototype.finish = function () {
    this.minimize(0)
  }
  
  bpSearch.TokenSet.Builder.prototype.minimize = function (downTo) {
    for (var i = this.uncheckedNodes.length - 1; i >= downTo; i--) {
      var node = this.uncheckedNodes[i],
          childKey = node.child.toString()
  
      if (childKey in this.minimizedNodes) {
        node.parent.edges[node.char] = this.minimizedNodes[childKey]
      } else {
        // Cache the key for this node since
        // we know it can't change anymore
        node.child._str = childKey
  
        this.minimizedNodes[childKey] = node.child
      }
  
      this.uncheckedNodes.pop()
    }
  }
  /*!
   * bpSearch.Index
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * An index contains the built index of all documents and provides a query interface
   * to the index.
   *
   * Usually instances of bpSearch.Index will not be created using this constructor, instead
   * bpSearch.Builder should be used to construct new indexes, or bpSearch.Index.load should be
   * used to load previously built and serialized indexes.
   *
   * @constructor
   * @param {Object} attrs - The attributes of the built search index.
   * @param {Object} attrs.invertedIndex - An index of term/field to document reference.
   * @param {Object<string, bpSearch.Vector>} attrs.fieldVectors - Field vectors
   * @param {bpSearch.TokenSet} attrs.tokenSet - An set of all corpus tokens.
   * @param {string[]} attrs.fields - The names of indexed document fields.
   * @param {bpSearch.Pipeline} attrs.pipeline - The pipeline to use for search terms.
   */
  bpSearch.Index = function (attrs) {
    this.invertedIndex = attrs.invertedIndex
    this.fieldVectors = attrs.fieldVectors
    this.tokenSet = attrs.tokenSet
    this.fields = attrs.fields
    this.pipeline = attrs.pipeline
  }
  
  /**
   * A result contains details of a document matching a search query.
   * @typedef {Object} bpSearch.Index~Result
   * @property {string} ref - The reference of the document this result represents.
   * @property {number} score - A number between 0 and 1 representing how similar this document is to the query.
   * @property {bpSearch.MatchData} matchData - Contains metadata about this match including which term(s) caused the match.
   */
  
  /**
   * Although bpSearch provides the ability to create queries using bpSearch.Query, it also provides a simple
   * query language which itself is parsed into an instance of bpSearch.Query.
   *
   * For programmatically building queries it is advised to directly use bpSearch.Query, the query language
   * is best used for human entered text rather than program generated text.
   *
   * At its simplest queries can just be a single term, e.g. `hello`, multiple terms are also supported
   * and will be combined with OR, e.g `hello world` will match documents that contain either 'hello'
   * or 'world', though those that contain both will rank higher in the results.
   *
   * Wildcards can be included in terms to match one or more unspecified characters, these wildcards can
   * be inserted anywhere within the term, and more than one wildcard can exist in a single term. Adding
   * wildcards will increase the number of documents that will be found but can also have a negative
   * impact on query performance, especially with wildcards at the beginning of a term.
   *
   * Terms can be restricted to specific fields, e.g. `title:hello`, only documents with the term
   * hello in the title field will match this query. Using a field not present in the index will lead
   * to an error being thrown.
   *
   * Modifiers can also be added to terms, bpSearch supports edit distance and boost modifiers on terms. A term
   * boost will make documents matching that term score higher, e.g. `foo^5`. Edit distance is also supported
   * to provide fuzzy matching, e.g. 'hello~2' will match documents with hello with an edit distance of 2.
   * Avoid large values for edit distance to improve query performance.
   *
   * Each term also supports a presence modifier. By default a term's presence in document is optional, however
   * this can be changed to either required or prohibited. For a term's presence to be required in a document the
   * term should be prefixed with a '+', e.g. `+foo bar` is a search for documents that must contain 'foo' and
   * optionally contain 'bar'. Conversely a leading '-' sets the terms presence to prohibited, i.e. it must not
   * appear in a document, e.g. `-foo bar` is a search for documents that do not contain 'foo' but may contain 'bar'.
   *
   * To escape special characters the backslash character '\' can be used, this allows searches to include
   * characters that would normally be considered modifiers, e.g. `foo\~2` will search for a term "foo~2" instead
   * of attempting to apply a boost of 2 to the search term "foo".
   *
   * @typedef {string} bpSearch.Index~QueryString
   * @example <caption>Simple single term query</caption>
   * hello
   * @example <caption>Multiple term query</caption>
   * hello world
   * @example <caption>term scoped to a field</caption>
   * title:hello
   * @example <caption>term with a boost of 10</caption>
   * hello^10
   * @example <caption>term with an edit distance of 2</caption>
   * hello~2
   * @example <caption>terms with presence modifiers</caption>
   * -foo +bar baz
   */
  
  /**
   * Performs a search against the index using bpSearch query syntax.
   *
   * Results will be returned sorted by their score, the most relevant results
   * will be returned first.  For details on how the score is calculated, please see
   * the {@link https://bpSearchjs.com/guides/searching.html#scoring|guide}.
   *
   * For more programmatic querying use bpSearch.Index#query.
   *
   * @param {bpSearch.Index~QueryString} queryString - A string containing a bpSearch query.
   * @throws {bpSearch.QueryParseError} If the passed query string cannot be parsed.
   * @returns {bpSearch.Index~Result[]}
   */
  bpSearch.Index.prototype.search = function (queryString) {
    return this.query(function (query) {
      var parser = new bpSearch.QueryParser(queryString, query)
      parser.parse()
    })
  }
  
  /**
   * A query builder callback provides a query object to be used to express
   * the query to perform on the index.
   *
   * @callback bpSearch.Index~queryBuilder
   * @param {bpSearch.Query} query - The query object to build up.
   * @this bpSearch.Query
   */
  
  /**
   * Performs a query against the index using the yielded bpSearch.Query object.
   *
   * If performing programmatic queries against the index, this method is preferred
   * over bpSearch.Index#search so as to avoid the additional query parsing overhead.
   *
   * A query object is yielded to the supplied function which should be used to
   * express the query to be run against the index.
   *
   * Note that although this function takes a callback parameter it is _not_ an
   * asynchronous operation, the callback is just yielded a query object to be
   * customized.
   *
   * @param {bpSearch.Index~queryBuilder} fn - A function that is used to build the query.
   * @returns {bpSearch.Index~Result[]}
   */
  bpSearch.Index.prototype.query = function (fn) {
    // for each query clause
    // * process terms
    // * expand terms from token set
    // * find matching documents and metadata
    // * get document vectors
    // * score documents
  
    var query = new bpSearch.Query(this.fields),
        matchingFields = Object.create(null),
        queryVectors = Object.create(null),
        termFieldCache = Object.create(null),
        requiredMatches = Object.create(null),
        prohibitedMatches = Object.create(null)
  
    /*
     * To support field level boosts a query vector is created per
     * field. An empty vector is eagerly created to support negated
     * queries.
     */
    for (var i = 0; i < this.fields.length; i++) {
      queryVectors[this.fields[i]] = new bpSearch.Vector
    }
  
    fn.call(query, query)
  
    for (var i = 0; i < query.clauses.length; i++) {
      /*
       * Unless the pipeline has been disabled for this term, which is
       * the case for terms with wildcards, we need to pass the clause
       * term through the search pipeline. A pipeline returns an array
       * of processed terms. Pipeline functions may expand the passed
       * term, which means we may end up performing multiple index lookups
       * for a single query term.
       */
      var clause = query.clauses[i],
          terms = null,
          clauseMatches = bpSearch.Set.empty
  
      if (clause.usePipeline) {
        terms = this.pipeline.runString(clause.term, {
          fields: clause.fields
        })
      } else {
        terms = [clause.term]
      }
  
      for (var m = 0; m < terms.length; m++) {
        var term = terms[m]
  
        /*
         * Each term returned from the pipeline needs to use the same query
         * clause object, e.g. the same boost and or edit distance. The
         * simplest way to do this is to re-use the clause object but mutate
         * its term property.
         */
        clause.term = term
  
        /*
         * From the term in the clause we create a token set which will then
         * be used to intersect the indexes token set to get a list of terms
         * to lookup in the inverted index
         */
        var termTokenSet = bpSearch.TokenSet.fromClause(clause),
            expandedTerms = this.tokenSet.intersect(termTokenSet).toArray()
  
        /*
         * If a term marked as required does not exist in the tokenSet it is
         * impossible for the search to return any matches. We set all the field
         * scoped required matches set to empty and stop examining any further
         * clauses.
         */
        if (expandedTerms.length === 0 && clause.presence === bpSearch.Query.presence.REQUIRED) {
          for (var k = 0; k < clause.fields.length; k++) {
            var field = clause.fields[k]
            requiredMatches[field] = bpSearch.Set.empty
          }
  
          break
        }
  
        for (var j = 0; j < expandedTerms.length; j++) {
          /*
           * For each term get the posting and termIndex, this is required for
           * building the query vector.
           */
          var expandedTerm = expandedTerms[j],
              posting = this.invertedIndex[expandedTerm],
              termIndex = posting._index
  
          for (var k = 0; k < clause.fields.length; k++) {
            /*
             * For each field that this query term is scoped by (by default
             * all fields are in scope) we need to get all the document refs
             * that have this term in that field.
             *
             * The posting is the entry in the invertedIndex for the matching
             * term from above.
             */
            var field = clause.fields[k],
                fieldPosting = posting[field],
                matchingDocumentRefs = Object.keys(fieldPosting),
                termField = expandedTerm + "/" + field,
                matchingDocumentsSet = new bpSearch.Set(matchingDocumentRefs)
  
            /*
             * if the presence of this term is required ensure that the matching
             * documents are added to the set of required matches for this clause.
             *
             */
            if (clause.presence == bpSearch.Query.presence.REQUIRED) {
              clauseMatches = clauseMatches.union(matchingDocumentsSet)
  
              if (requiredMatches[field] === undefined) {
                requiredMatches[field] = bpSearch.Set.complete
              }
            }
  
            /*
             * if the presence of this term is prohibited ensure that the matching
             * documents are added to the set of prohibited matches for this field,
             * creating that set if it does not yet exist.
             */
            if (clause.presence == bpSearch.Query.presence.PROHIBITED) {
              if (prohibitedMatches[field] === undefined) {
                prohibitedMatches[field] = bpSearch.Set.empty
              }
  
              prohibitedMatches[field] = prohibitedMatches[field].union(matchingDocumentsSet)
  
              /*
               * Prohibited matches should not be part of the query vector used for
               * similarity scoring and no metadata should be extracted so we continue
               * to the next field
               */
              continue
            }
  
            /*
             * The query field vector is populated using the termIndex found for
             * the term and a unit value with the appropriate boost applied.
             * Using upsert because there could already be an entry in the vector
             * for the term we are working with. In that case we just add the scores
             * together.
             */
            queryVectors[field].upsert(termIndex, clause.boost, function (a, b) { return a + b })
  
            /**
             * If we've already seen this term, field combo then we've already collected
             * the matching documents and metadata, no need to go through all that again
             */
            if (termFieldCache[termField]) {
              continue
            }
  
            for (var l = 0; l < matchingDocumentRefs.length; l++) {
              /*
               * All metadata for this term/field/document triple
               * are then extracted and collected into an instance
               * of bpSearch.MatchData ready to be returned in the query
               * results
               */
              var matchingDocumentRef = matchingDocumentRefs[l],
                  matchingFieldRef = new bpSearch.FieldRef (matchingDocumentRef, field),
                  metadata = fieldPosting[matchingDocumentRef],
                  fieldMatch
  
              if ((fieldMatch = matchingFields[matchingFieldRef]) === undefined) {
                matchingFields[matchingFieldRef] = new bpSearch.MatchData (expandedTerm, field, metadata)
              } else {
                fieldMatch.add(expandedTerm, field, metadata)
              }
  
            }
  
            termFieldCache[termField] = true
          }
        }
      }
  
      /**
       * If the presence was required we need to update the requiredMatches field sets.
       * We do this after all fields for the term have collected their matches because
       * the clause terms presence is required in _any_ of the fields not _all_ of the
       * fields.
       */
      if (clause.presence === bpSearch.Query.presence.REQUIRED) {
        for (var k = 0; k < clause.fields.length; k++) {
          var field = clause.fields[k]
          requiredMatches[field] = requiredMatches[field].intersect(clauseMatches)
        }
      }
    }
  
    /**
     * Need to combine the field scoped required and prohibited
     * matching documents into a global set of required and prohibited
     * matches
     */
    var allRequiredMatches = bpSearch.Set.complete,
        allProhibitedMatches = bpSearch.Set.empty
  
    for (var i = 0; i < this.fields.length; i++) {
      var field = this.fields[i]
  
      if (requiredMatches[field]) {
        allRequiredMatches = allRequiredMatches.intersect(requiredMatches[field])
      }
  
      if (prohibitedMatches[field]) {
        allProhibitedMatches = allProhibitedMatches.union(prohibitedMatches[field])
      }
    }
  
    var matchingFieldRefs = Object.keys(matchingFields),
        results = [],
        matches = Object.create(null)
  
    /*
     * If the query is negated (contains only prohibited terms)
     * we need to get _all_ fieldRefs currently existing in the
     * index. This is only done when we know that the query is
     * entirely prohibited terms to avoid any cost of getting all
     * fieldRefs unnecessarily.
     *
     * Additionally, blank MatchData must be created to correctly
     * populate the results.
     */
    if (query.isNegated()) {
      matchingFieldRefs = Object.keys(this.fieldVectors)
  
      for (var i = 0; i < matchingFieldRefs.length; i++) {
        var matchingFieldRef = matchingFieldRefs[i]
        var fieldRef = bpSearch.FieldRef.fromString(matchingFieldRef)
        matchingFields[matchingFieldRef] = new bpSearch.MatchData
      }
    }
  
    for (var i = 0; i < matchingFieldRefs.length; i++) {
      /*
       * Currently we have document fields that match the query, but we
       * need to return documents. The matchData and scores are combined
       * from multiple fields belonging to the same document.
       *
       * Scores are calculated by field, using the query vectors created
       * above, and combined into a final document score using addition.
       */
      var fieldRef = bpSearch.FieldRef.fromString(matchingFieldRefs[i]),
          docRef = fieldRef.docRef
  
      if (!allRequiredMatches.contains(docRef)) {
        continue
      }
  
      if (allProhibitedMatches.contains(docRef)) {
        continue
      }
  
      var fieldVector = this.fieldVectors[fieldRef],
          score = queryVectors[fieldRef.fieldName].similarity(fieldVector),
          docMatch
  
      if ((docMatch = matches[docRef]) !== undefined) {
        docMatch.score += score
        docMatch.matchData.combine(matchingFields[fieldRef])
      } else {
        var match = {
          ref: docRef,
          score: score,
          matchData: matchingFields[fieldRef]
        }
        matches[docRef] = match
        results.push(match)
      }
    }
  
    /*
     * Sort the results objects by score, highest first.
     */
    return results.sort(function (a, b) {
      return b.score - a.score
    })
  }
  
  /**
   * Prepares the index for JSON serialization.
   *
   * The schema for this JSON blob will be described in a
   * separate JSON schema file.
   *
   * @returns {Object}
   */
  bpSearch.Index.prototype.toJSON = function () {
    var invertedIndex = Object.keys(this.invertedIndex)
      .sort()
      .map(function (term) {
        return [term, this.invertedIndex[term]]
      }, this)
  
    var fieldVectors = Object.keys(this.fieldVectors)
      .map(function (ref) {
        return [ref, this.fieldVectors[ref].toJSON()]
      }, this)
  
    return {
      version: bpSearch.version,
      fields: this.fields,
      fieldVectors: fieldVectors,
      invertedIndex: invertedIndex,
      pipeline: this.pipeline.toJSON()
    }
  }
  
  /**
   * Loads a previously serialized bpSearch.Index
   *
   * @param {Object} serializedIndex - A previously serialized bpSearch.Index
   * @returns {bpSearch.Index}
   */
  bpSearch.Index.load = function (serializedIndex) {
    var attrs = {},
        fieldVectors = {},
        serializedVectors = serializedIndex.fieldVectors,
        invertedIndex = Object.create(null),
        serializedInvertedIndex = serializedIndex.invertedIndex,
        tokenSetBuilder = new bpSearch.TokenSet.Builder,
        pipeline = bpSearch.Pipeline.load(serializedIndex.pipeline)
  
    if (serializedIndex.version != bpSearch.version) {
      bpSearch.utils.warn("Version mismatch when loading serialised index. Current version of bpSearch '" + bpSearch.version + "' does not match serialized index '" + serializedIndex.version + "'")
    }
  
    for (var i = 0; i < serializedVectors.length; i++) {
      var tuple = serializedVectors[i],
          ref = tuple[0],
          elements = tuple[1]
  
      fieldVectors[ref] = new bpSearch.Vector(elements)
    }
  
    for (var i = 0; i < serializedInvertedIndex.length; i++) {
      var tuple = serializedInvertedIndex[i],
          term = tuple[0],
          posting = tuple[1]
  
      tokenSetBuilder.insert(term)
      invertedIndex[term] = posting
    }
  
    tokenSetBuilder.finish()
  
    attrs.fields = serializedIndex.fields
  
    attrs.fieldVectors = fieldVectors
    attrs.invertedIndex = invertedIndex
    attrs.tokenSet = tokenSetBuilder.root
    attrs.pipeline = pipeline
  
    return new bpSearch.Index(attrs)
  }
  /*!
   * bpSearch.Builder
   * Copyright (C) 2020 Oliver Nightingale
   */
  
  /**
   * bpSearch.Builder performs indexing on a set of documents and
   * returns instances of bpSearch.Index ready for querying.
   *
   * All configuration of the index is done via the builder, the
   * fields to index, the document reference, the text processing
   * pipeline and document scoring parameters are all set on the
   * builder before indexing.
   *
   * @constructor
   * @property {string} _ref - Internal reference to the document reference field.
   * @property {string[]} _fields - Internal reference to the document fields to index.
   * @property {object} invertedIndex - The inverted index maps terms to document fields.
   * @property {object} documentTermFrequencies - Keeps track of document term frequencies.
   * @property {object} documentLengths - Keeps track of the length of documents added to the index.
   * @property {bpSearch.tokenizer} tokenizer - Function for splitting strings into tokens for indexing.
   * @property {bpSearch.Pipeline} pipeline - The pipeline performs text processing on tokens before indexing.
   * @property {bpSearch.Pipeline} searchPipeline - A pipeline for processing search terms before querying the index.
   * @property {number} documentCount - Keeps track of the total number of documents indexed.
   * @property {number} _b - A parameter to control field length normalization, setting this to 0 disabled normalization, 1 fully normalizes field lengths, the default value is 0.75.
   * @property {number} _k1 - A parameter to control how quickly an increase in term frequency results in term frequency saturation, the default value is 1.2.
   * @property {number} termIndex - A counter incremented for each unique term, used to identify a terms position in the vector space.
   * @property {array} metadataWhitelist - A list of metadata keys that have been whitelisted for entry in the index.
   */
  bpSearch.Builder = function () {
    this._ref = "id"
    this._fields = Object.create(null)
    this._documents = Object.create(null)
    this.invertedIndex = Object.create(null)
    this.fieldTermFrequencies = {}
    this.fieldLengths = {}
    this.tokenizer = bpSearch.tokenizer
    this.pipeline = new bpSearch.Pipeline
    this.searchPipeline = new bpSearch.Pipeline
    this.documentCount = 0
    this._b = 0.75
    this._k1 = 1.2
    this.termIndex = 0
    this.metadataWhitelist = []
  }
  
  /**
   * Sets the document field used as the document reference. Every document must have this field.
   * The type of this field in the document should be a string, if it is not a string it will be
   * coerced into a string by calling toString.
   *
   * The default ref is 'id'.
   *
   * The ref should _not_ be changed during indexing, it should be set before any documents are
   * added to the index. Changing it during indexing can lead to inconsistent results.
   *
   * @param {string} ref - The name of the reference field in the document.
   */
  bpSearch.Builder.prototype.ref = function (ref) {
    this._ref = ref
  }
  
  /**
   * A function that is used to extract a field from a document.
   *
   * bpSearch expects a field to be at the top level of a document, if however the field
   * is deeply nested within a document an extractor function can be used to extract
   * the right field for indexing.
   *
   * @callback fieldExtractor
   * @param {object} doc - The document being added to the index.
   * @returns {?(string|object|object[])} obj - The object that will be indexed for this field.
   * @example <caption>Extracting a nested field</caption>
   * function (doc) { return doc.nested.field }
   */
  
  /**
   * Adds a field to the list of document fields that will be indexed. Every document being
   * indexed should have this field. Null values for this field in indexed documents will
   * not cause errors but will limit the chance of that document being retrieved by searches.
   *
   * All fields should be added before adding documents to the index. Adding fields after
   * a document has been indexed will have no effect on already indexed documents.
   *
   * Fields can be boosted at build time. This allows terms within that field to have more
   * importance when ranking search results. Use a field boost to specify that matches within
   * one field are more important than other fields.
   *
   * @param {string} fieldName - The name of a field to index in all documents.
   * @param {object} attributes - Optional attributes associated with this field.
   * @param {number} [attributes.boost=1] - Boost applied to all terms within this field.
   * @param {fieldExtractor} [attributes.extractor] - Function to extract a field from a document.
   * @throws {RangeError} fieldName cannot contain unsupported characters '/'
   */
  bpSearch.Builder.prototype.field = function (fieldName, attributes) {
    if (/\//.test(fieldName)) {
      throw new RangeError ("Field '" + fieldName + "' contains illegal character '/'")
    }
  
    this._fields[fieldName] = attributes || {}
  }
  
  /**
   * A parameter to tune the amount of field length normalisation that is applied when
   * calculating relevance scores. A value of 0 will completely disable any normalisation
   * and a value of 1 will fully normalise field lengths. The default is 0.75. Values of b
   * will be clamped to the range 0 - 1.
   *
   * @param {number} number - The value to set for this tuning parameter.
   */
  bpSearch.Builder.prototype.b = function (number) {
    if (number < 0) {
      this._b = 0
    } else if (number > 1) {
      this._b = 1
    } else {
      this._b = number
    }
  }
  
  /**
   * A parameter that controls the speed at which a rise in term frequency results in term
   * frequency saturation. The default value is 1.2. Setting this to a higher value will give
   * slower saturation levels, a lower value will result in quicker saturation.
   *
   * @param {number} number - The value to set for this tuning parameter.
   */
  bpSearch.Builder.prototype.k1 = function (number) {
    this._k1 = number
  }
  
  /**
   * Adds a document to the index.
   *
   * Before adding fields to the index the index should have been fully setup, with the document
   * ref and all fields to index already having been specified.
   *
   * The document must have a field name as specified by the ref (by default this is 'id') and
   * it should have all fields defined for indexing, though null or undefined values will not
   * cause errors.
   *
   * Entire documents can be boosted at build time. Applying a boost to a document indicates that
   * this document should rank higher in search results than other documents.
   *
   * @param {object} doc - The document to add to the index.
   * @param {object} attributes - Optional attributes associated with this document.
   * @param {number} [attributes.boost=1] - Boost applied to all terms within this document.
   */
  bpSearch.Builder.prototype.add = function (doc, attributes) {
    var docRef = doc[this._ref],
        fields = Object.keys(this._fields)
  
    this._documents[docRef] = attributes || {}
    this.documentCount += 1
  
    for (var i = 0; i < fields.length; i++) {
      var fieldName = fields[i],
          extractor = this._fields[fieldName].extractor,
          field = extractor ? extractor(doc) : doc[fieldName],
          tokens = this.tokenizer(field, {
            fields: [fieldName]
          }),
          terms = this.pipeline.run(tokens),
          fieldRef = new bpSearch.FieldRef (docRef, fieldName),
          fieldTerms = Object.create(null)
  
      this.fieldTermFrequencies[fieldRef] = fieldTerms
      this.fieldLengths[fieldRef] = 0
  
      // store the length of this field for this document
      this.fieldLengths[fieldRef] += terms.length
  
      // calculate term frequencies for this field
      for (var j = 0; j < terms.length; j++) {
        var term = terms[j]
  
        if (fieldTerms[term] == undefined) {
          fieldTerms[term] = 0
        }
  
        fieldTerms[term] += 1
  
        // add to inverted index
        // create an initial posting if one doesn't exist
        if (this.invertedIndex[term] == undefined) {
          var posting = Object.create(null)
          posting["_index"] = this.termIndex
          this.termIndex += 1
  
          for (var k = 0; k < fields.length; k++) {
            posting[fields[k]] = Object.create(null)
          }
  
          this.invertedIndex[term] = posting
        }
  
        // add an entry for this term/fieldName/docRef to the invertedIndex
        if (this.invertedIndex[term][fieldName][docRef] == undefined) {
          this.invertedIndex[term][fieldName][docRef] = Object.create(null)
        }
  
        // store all whitelisted metadata about this token in the
        // inverted index
        for (var l = 0; l < this.metadataWhitelist.length; l++) {
          var metadataKey = this.metadataWhitelist[l],
              metadata = term.metadata[metadataKey]
  
          if (this.invertedIndex[term][fieldName][docRef][metadataKey] == undefined) {
            this.invertedIndex[term][fieldName][docRef][metadataKey] = []
          }
  
          this.invertedIndex[term][fieldName][docRef][metadataKey].push(metadata)
        }
      }
  
    }
  }
  
  /**
   * Calculates the average document length for this index
   *
   * @private
   */
  bpSearch.Builder.prototype.calculateAverageFieldLengths = function () {
  
    var fieldRefs = Object.keys(this.fieldLengths),
        numberOfFields = fieldRefs.length,
        accumulator = {},
        documentsWithField = {}
  
    for (var i = 0; i < numberOfFields; i++) {
      var fieldRef = bpSearch.FieldRef.fromString(fieldRefs[i]),
          field = fieldRef.fieldName
  
      documentsWithField[field] || (documentsWithField[field] = 0)
      documentsWithField[field] += 1
  
      accumulator[field] || (accumulator[field] = 0)
      accumulator[field] += this.fieldLengths[fieldRef]
    }
  
    var fields = Object.keys(this._fields)
  
    for (var i = 0; i < fields.length; i++) {
      var fieldName = fields[i]
      accumulator[fieldName] = accumulator[fieldName] / documentsWithField[fieldName]
    }
  
    this.averageFieldLength = accumulator
  }
  
  /**
   * Builds a vector space model of every document using bpSearch.Vector
   *
   * @private
   */
  bpSearch.Builder.prototype.createFieldVectors = function () {
    var fieldVectors = {},
        fieldRefs = Object.keys(this.fieldTermFrequencies),
        fieldRefsLength = fieldRefs.length,
        termIdfCache = Object.create(null)
  
    for (var i = 0; i < fieldRefsLength; i++) {
      var fieldRef = bpSearch.FieldRef.fromString(fieldRefs[i]),
          fieldName = fieldRef.fieldName,
          fieldLength = this.fieldLengths[fieldRef],
          fieldVector = new bpSearch.Vector,
          termFrequencies = this.fieldTermFrequencies[fieldRef],
          terms = Object.keys(termFrequencies),
          termsLength = terms.length
  
  
      var fieldBoost = this._fields[fieldName].boost || 1,
          docBoost = this._documents[fieldRef.docRef].boost || 1
  
      for (var j = 0; j < termsLength; j++) {
        var term = terms[j],
            tf = termFrequencies[term],
            termIndex = this.invertedIndex[term]._index,
            idf, score, scoreWithPrecision
  
        if (termIdfCache[term] === undefined) {
          idf = bpSearch.idf(this.invertedIndex[term], this.documentCount)
          termIdfCache[term] = idf
        } else {
          idf = termIdfCache[term]
        }
  
        score = idf * ((this._k1 + 1) * tf) / (this._k1 * (1 - this._b + this._b * (fieldLength / this.averageFieldLength[fieldName])) + tf)
        score *= fieldBoost
        score *= docBoost
        scoreWithPrecision = Math.round(score * 1000) / 1000
        // Converts 1.23456789 to 1.234.
        // Reducing the precision so that the vectors take up less
        // space when serialised. Doing it now so that they behave
        // the same before and after serialisation. Also, this is
        // the fastest approach to reducing a number's precision in
        // JavaScript.
  
        fieldVector.insert(termIndex, scoreWithPrecision)
      }
  
      fieldVectors[fieldRef] = fieldVector
    }
  
    this.fieldVectors = fieldVectors
  }
  
  /**
   * Creates a token set of all tokens in the index using bpSearch.TokenSet
   *
   * @private
   */
  bpSearch.Builder.prototype.createTokenSet = function () {
    this.tokenSet = bpSearch.TokenSet.fromArray(
      Object.keys(this.invertedIndex).sort()
    )
  }
  
  /**
   * Builds the index, creating an instance of bpSearch.Index.
   *
   * This completes the indexing process and should only be called
   * once all documents have been added to the index.
   *
   * @returns {bpSearch.Index}
   */
  bpSearch.Builder.prototype.build = function () {
    this.calculateAverageFieldLengths()
    this.createFieldVectors()
    this.createTokenSet()
  
    return new bpSearch.Index({
      invertedIndex: this.invertedIndex,
      fieldVectors: this.fieldVectors,
      tokenSet: this.tokenSet,
      fields: Object.keys(this._fields),
      pipeline: this.searchPipeline
    })
  }
  
  /**
   * Applies a plugin to the index builder.
   *
   * A plugin is a function that is called with the index builder as its context.
   * Plugins can be used to customise or extend the behaviour of the index
   * in some way. A plugin is just a function, that encapsulated the custom
   * behaviour that should be applied when building the index.
   *
   * The plugin function will be called with the index builder as its argument, additional
   * arguments can also be passed when calling use. The function will be called
   * with the index builder as its context.
   *
   * @param {Function} plugin The plugin to apply.
   */
  bpSearch.Builder.prototype.use = function (fn) {
    var args = Array.prototype.slice.call(arguments, 1)
    args.unshift(this)
    fn.apply(this, args)
  }
  /**
   * Contains and collects metadata about a matching document.
   * A single instance of bpSearch.MatchData is returned as part of every
   * bpSearch.Index~Result.
   *
   * @constructor
   * @param {string} term - The term this match data is associated with
   * @param {string} field - The field in which the term was found
   * @param {object} metadata - The metadata recorded about this term in this field
   * @property {object} metadata - A cloned collection of metadata associated with this document.
   * @see {@link bpSearch.Index~Result}
   */
  bpSearch.MatchData = function (term, field, metadata) {
    var clonedMetadata = Object.create(null),
        metadataKeys = Object.keys(metadata || {})
  
    // Cloning the metadata to prevent the original
    // being mutated during match data combination.
    // Metadata is kept in an array within the inverted
    // index so cloning the data can be done with
    // Array#slice
    for (var i = 0; i < metadataKeys.length; i++) {
      var key = metadataKeys[i]
      clonedMetadata[key] = metadata[key].slice()
    }
  
    this.metadata = Object.create(null)
  
    if (term !== undefined) {
      this.metadata[term] = Object.create(null)
      this.metadata[term][field] = clonedMetadata
    }
  }
  
  /**
   * An instance of bpSearch.MatchData will be created for every term that matches a
   * document. However only one instance is required in a bpSearch.Index~Result. This
   * method combines metadata from another instance of bpSearch.MatchData with this
   * objects metadata.
   *
   * @param {bpSearch.MatchData} otherMatchData - Another instance of match data to merge with this one.
   * @see {@link bpSearch.Index~Result}
   */
  bpSearch.MatchData.prototype.combine = function (otherMatchData) {
    var terms = Object.keys(otherMatchData.metadata)
  
    for (var i = 0; i < terms.length; i++) {
      var term = terms[i],
          fields = Object.keys(otherMatchData.metadata[term])
  
      if (this.metadata[term] == undefined) {
        this.metadata[term] = Object.create(null)
      }
  
      for (var j = 0; j < fields.length; j++) {
        var field = fields[j],
            keys = Object.keys(otherMatchData.metadata[term][field])
  
        if (this.metadata[term][field] == undefined) {
          this.metadata[term][field] = Object.create(null)
        }
  
        for (var k = 0; k < keys.length; k++) {
          var key = keys[k]
  
          if (this.metadata[term][field][key] == undefined) {
            this.metadata[term][field][key] = otherMatchData.metadata[term][field][key]
          } else {
            this.metadata[term][field][key] = this.metadata[term][field][key].concat(otherMatchData.metadata[term][field][key])
          }
  
        }
      }
    }
  }
  
  /**
   * Add metadata for a term/field pair to this instance of match data.
   *
   * @param {string} term - The term this match data is associated with
   * @param {string} field - The field in which the term was found
   * @param {object} metadata - The metadata recorded about this term in this field
   */
  bpSearch.MatchData.prototype.add = function (term, field, metadata) {
    if (!(term in this.metadata)) {
      this.metadata[term] = Object.create(null)
      this.metadata[term][field] = metadata
      return
    }
  
    if (!(field in this.metadata[term])) {
      this.metadata[term][field] = metadata
      return
    }
  
    var metadataKeys = Object.keys(metadata)
  
    for (var i = 0; i < metadataKeys.length; i++) {
      var key = metadataKeys[i]
  
      if (key in this.metadata[term][field]) {
        this.metadata[term][field][key] = this.metadata[term][field][key].concat(metadata[key])
      } else {
        this.metadata[term][field][key] = metadata[key]
      }
    }
  }
  /**
   * A bpSearch.Query provides a programmatic way of defining queries to be performed
   * against a {@link bpSearch.Index}.
   *
   * Prefer constructing a bpSearch.Query using the {@link bpSearch.Index#query} method
   * so the query object is pre-initialized with the right index fields.
   *
   * @constructor
   * @property {bpSearch.Query~Clause[]} clauses - An array of query clauses.
   * @property {string[]} allFields - An array of all available fields in a bpSearch.Index.
   */
  bpSearch.Query = function (allFields) {
    this.clauses = []
    this.allFields = allFields
  }
  
  /**
   * Constants for indicating what kind of automatic wildcard insertion will be used when constructing a query clause.
   *
   * This allows wildcards to be added to the beginning and end of a term without having to manually do any string
   * concatenation.
   *
   * The wildcard constants can be bitwise combined to select both leading and trailing wildcards.
   *
   * @constant
   * @default
   * @property {number} wildcard.NONE - The term will have no wildcards inserted, this is the default behaviour
   * @property {number} wildcard.LEADING - Prepend the term with a wildcard, unless a leading wildcard already exists
   * @property {number} wildcard.TRAILING - Append a wildcard to the term, unless a trailing wildcard already exists
   * @see bpSearch.Query~Clause
   * @see bpSearch.Query#clause
   * @see bpSearch.Query#term
   * @example <caption>query term with trailing wildcard</caption>
   * query.term('foo', { wildcard: bpSearch.Query.wildcard.TRAILING })
   * @example <caption>query term with leading and trailing wildcard</caption>
   * query.term('foo', {
   *   wildcard: bpSearch.Query.wildcard.LEADING | bpSearch.Query.wildcard.TRAILING
   * })
   */
  
  bpSearch.Query.wildcard = new String ("*")
  bpSearch.Query.wildcard.NONE = 0
  bpSearch.Query.wildcard.LEADING = 1
  bpSearch.Query.wildcard.TRAILING = 2
  
  /**
   * Constants for indicating what kind of presence a term must have in matching documents.
   *
   * @constant
   * @enum {number}
   * @see bpSearch.Query~Clause
   * @see bpSearch.Query#clause
   * @see bpSearch.Query#term
   * @example <caption>query term with required presence</caption>
   * query.term('foo', { presence: bpSearch.Query.presence.REQUIRED })
   */
  bpSearch.Query.presence = {
    /**
     * Term's presence in a document is optional, this is the default value.
     */
    OPTIONAL: 1,
  
    /**
     * Term's presence in a document is required, documents that do not contain
     * this term will not be returned.
     */
    REQUIRED: 2,
  
    /**
     * Term's presence in a document is prohibited, documents that do contain
     * this term will not be returned.
     */
    PROHIBITED: 3
  }
  
  /**
   * A single clause in a {@link bpSearch.Query} contains a term and details on how to
   * match that term against a {@link bpSearch.Index}.
   *
   * @typedef {Object} bpSearch.Query~Clause
   * @property {string[]} fields - The fields in an index this clause should be matched against.
   * @property {number} [boost=1] - Any boost that should be applied when matching this clause.
   * @property {number} [editDistance] - Whether the term should have fuzzy matching applied, and how fuzzy the match should be.
   * @property {boolean} [usePipeline] - Whether the term should be passed through the search pipeline.
   * @property {number} [wildcard=bpSearch.Query.wildcard.NONE] - Whether the term should have wildcards appended or prepended.
   * @property {number} [presence=bpSearch.Query.presence.OPTIONAL] - The terms presence in any matching documents.
   */
  
  /**
   * Adds a {@link bpSearch.Query~Clause} to this query.
   *
   * Unless the clause contains the fields to be matched all fields will be matched. In addition
   * a default boost of 1 is applied to the clause.
   *
   * @param {bpSearch.Query~Clause} clause - The clause to add to this query.
   * @see bpSearch.Query~Clause
   * @returns {bpSearch.Query}
   */
  bpSearch.Query.prototype.clause = function (clause) {
    if (!('fields' in clause)) {
      clause.fields = this.allFields
    }
  
    if (!('boost' in clause)) {
      clause.boost = 1
    }
  
    if (!('usePipeline' in clause)) {
      clause.usePipeline = true
    }
  
    if (!('wildcard' in clause)) {
      clause.wildcard = bpSearch.Query.wildcard.NONE
    }
  
    if ((clause.wildcard & bpSearch.Query.wildcard.LEADING) && (clause.term.charAt(0) != bpSearch.Query.wildcard)) {
      clause.term = "*" + clause.term
    }
  
    if ((clause.wildcard & bpSearch.Query.wildcard.TRAILING) && (clause.term.slice(-1) != bpSearch.Query.wildcard)) {
      clause.term = "" + clause.term + "*"
    }
  
    if (!('presence' in clause)) {
      clause.presence = bpSearch.Query.presence.OPTIONAL
    }
  
    this.clauses.push(clause)
  
    return this
  }
  
  /**
   * A negated query is one in which every clause has a presence of
   * prohibited. These queries require some special processing to return
   * the expected results.
   *
   * @returns boolean
   */
  bpSearch.Query.prototype.isNegated = function () {
    for (var i = 0; i < this.clauses.length; i++) {
      if (this.clauses[i].presence != bpSearch.Query.presence.PROHIBITED) {
        return false
      }
    }
  
    return true
  }
  
  /**
   * Adds a term to the current query, under the covers this will create a {@link bpSearch.Query~Clause}
   * to the list of clauses that make up this query.
   *
   * The term is used as is, i.e. no tokenization will be performed by this method. Instead conversion
   * to a token or token-like string should be done before calling this method.
   *
   * The term will be converted to a string by calling `toString`. Multiple terms can be passed as an
   * array, each term in the array will share the same options.
   *
   * @param {object|object[]} term - The term(s) to add to the query.
   * @param {object} [options] - Any additional properties to add to the query clause.
   * @returns {bpSearch.Query}
   * @see bpSearch.Query#clause
   * @see bpSearch.Query~Clause
   * @example <caption>adding a single term to a query</caption>
   * query.term("foo")
   * @example <caption>adding a single term to a query and specifying search fields, term boost and automatic trailing wildcard</caption>
   * query.term("foo", {
   *   fields: ["title"],
   *   boost: 10,
   *   wildcard: bpSearch.Query.wildcard.TRAILING
   * })
   * @example <caption>using bpSearch.tokenizer to convert a string to tokens before using them as terms</caption>
   * query.term(bpSearch.tokenizer("foo bar"))
   */
  bpSearch.Query.prototype.term = function (term, options) {
    if (Array.isArray(term)) {
      term.forEach(function (t) { this.term(t, bpSearch.utils.clone(options)) }, this)
      return this
    }
  
    var clause = options || {}
    clause.term = term.toString()
  
    this.clause(clause)
  
    return this
  }
  bpSearch.QueryParseError = function (message, start, end) {
    this.name = "QueryParseError"
    this.message = message
    this.start = start
    this.end = end
  }
  
  bpSearch.QueryParseError.prototype = new Error
  bpSearch.QueryLexer = function (str) {
    this.lexemes = []
    this.str = str
    this.length = str.length
    this.pos = 0
    this.start = 0
    this.escapeCharPositions = []
  }
  
  bpSearch.QueryLexer.prototype.run = function () {
    var state = bpSearch.QueryLexer.lexText
  
    while (state) {
      state = state(this)
    }
  }
  
  bpSearch.QueryLexer.prototype.sliceString = function () {
    var subSlices = [],
        sliceStart = this.start,
        sliceEnd = this.pos
  
    for (var i = 0; i < this.escapeCharPositions.length; i++) {
      sliceEnd = this.escapeCharPositions[i]
      subSlices.push(this.str.slice(sliceStart, sliceEnd))
      sliceStart = sliceEnd + 1
    }
  
    subSlices.push(this.str.slice(sliceStart, this.pos))
    this.escapeCharPositions.length = 0
  
    return subSlices.join('')
  }
  
  bpSearch.QueryLexer.prototype.emit = function (type) {
    this.lexemes.push({
      type: type,
      str: this.sliceString(),
      start: this.start,
      end: this.pos
    })
  
    this.start = this.pos
  }
  
  bpSearch.QueryLexer.prototype.escapeCharacter = function () {
    this.escapeCharPositions.push(this.pos - 1)
    this.pos += 1
  }
  
  bpSearch.QueryLexer.prototype.next = function () {
    if (this.pos >= this.length) {
      return bpSearch.QueryLexer.EOS
    }
  
    var char = this.str.charAt(this.pos)
    this.pos += 1
    return char
  }
  
  bpSearch.QueryLexer.prototype.width = function () {
    return this.pos - this.start
  }
  
  bpSearch.QueryLexer.prototype.ignore = function () {
    if (this.start == this.pos) {
      this.pos += 1
    }
  
    this.start = this.pos
  }
  
  bpSearch.QueryLexer.prototype.backup = function () {
    this.pos -= 1
  }
  
  bpSearch.QueryLexer.prototype.acceptDigitRun = function () {
    var char, charCode
  
    do {
      char = this.next()
      charCode = char.charCodeAt(0)
    } while (charCode > 47 && charCode < 58)
  
    if (char != bpSearch.QueryLexer.EOS) {
      this.backup()
    }
  }
  
  bpSearch.QueryLexer.prototype.more = function () {
    return this.pos < this.length
  }
  
  bpSearch.QueryLexer.EOS = 'EOS'
  bpSearch.QueryLexer.FIELD = 'FIELD'
  bpSearch.QueryLexer.TERM = 'TERM'
  bpSearch.QueryLexer.EDIT_DISTANCE = 'EDIT_DISTANCE'
  bpSearch.QueryLexer.BOOST = 'BOOST'
  bpSearch.QueryLexer.PRESENCE = 'PRESENCE'
  
  bpSearch.QueryLexer.lexField = function (lexer) {
    lexer.backup()
    lexer.emit(bpSearch.QueryLexer.FIELD)
    lexer.ignore()
    return bpSearch.QueryLexer.lexText
  }
  
  bpSearch.QueryLexer.lexTerm = function (lexer) {
    if (lexer.width() > 1) {
      lexer.backup()
      lexer.emit(bpSearch.QueryLexer.TERM)
    }
  
    lexer.ignore()
  
    if (lexer.more()) {
      return bpSearch.QueryLexer.lexText
    }
  }
  
  bpSearch.QueryLexer.lexEditDistance = function (lexer) {
    lexer.ignore()
    lexer.acceptDigitRun()
    lexer.emit(bpSearch.QueryLexer.EDIT_DISTANCE)
    return bpSearch.QueryLexer.lexText
  }
  
  bpSearch.QueryLexer.lexBoost = function (lexer) {
    lexer.ignore()
    lexer.acceptDigitRun()
    lexer.emit(bpSearch.QueryLexer.BOOST)
    return bpSearch.QueryLexer.lexText
  }
  
  bpSearch.QueryLexer.lexEOS = function (lexer) {
    if (lexer.width() > 0) {
      lexer.emit(bpSearch.QueryLexer.TERM)
    }
  }
  
  // This matches the separator used when tokenising fields
  // within a document. These should match otherwise it is
  // not possible to search for some tokens within a document.
  //
  // It is possible for the user to change the separator on the
  // tokenizer so it _might_ clash with any other of the special
  // characters already used within the search string, e.g. :.
  //
  // This means that it is possible to change the separator in
  // such a way that makes some words unsearchable using a search
  // string.
  bpSearch.QueryLexer.termSeparator = bpSearch.tokenizer.separator
  
  bpSearch.QueryLexer.lexText = function (lexer) {
    while (true) {
      var char = lexer.next()
  
      if (char == bpSearch.QueryLexer.EOS) {
        return bpSearch.QueryLexer.lexEOS
      }
  
      // Escape character is '\'
      if (char.charCodeAt(0) == 92) {
        lexer.escapeCharacter()
        continue
      }
  
      if (char == ":") {
        return bpSearch.QueryLexer.lexField
      }
  
      if (char == "~") {
        lexer.backup()
        if (lexer.width() > 0) {
          lexer.emit(bpSearch.QueryLexer.TERM)
        }
        return bpSearch.QueryLexer.lexEditDistance
      }
  
      if (char == "^") {
        lexer.backup()
        if (lexer.width() > 0) {
          lexer.emit(bpSearch.QueryLexer.TERM)
        }
        return bpSearch.QueryLexer.lexBoost
      }
  
      // "+" indicates term presence is required
      // checking for length to ensure that only
      // leading "+" are considered
      if (char == "+" && lexer.width() === 1) {
        lexer.emit(bpSearch.QueryLexer.PRESENCE)
        return bpSearch.QueryLexer.lexText
      }
  
      // "-" indicates term presence is prohibited
      // checking for length to ensure that only
      // leading "-" are considered
      if (char == "-" && lexer.width() === 1) {
        lexer.emit(bpSearch.QueryLexer.PRESENCE)
        return bpSearch.QueryLexer.lexText
      }
  
      if (char.match(bpSearch.QueryLexer.termSeparator)) {
        return bpSearch.QueryLexer.lexTerm
      }
    }
  }
  
  bpSearch.QueryParser = function (str, query) {
    this.lexer = new bpSearch.QueryLexer (str)
    this.query = query
    this.currentClause = {}
    this.lexemeIdx = 0
  }
  
  bpSearch.QueryParser.prototype.parse = function () {
    this.lexer.run()
    this.lexemes = this.lexer.lexemes
  
    var state = bpSearch.QueryParser.parseClause
  
    while (state) {
      state = state(this)
    }
  
    return this.query
  }
  
  bpSearch.QueryParser.prototype.peekLexeme = function () {
    return this.lexemes[this.lexemeIdx]
  }
  
  bpSearch.QueryParser.prototype.consumeLexeme = function () {
    var lexeme = this.peekLexeme()
    this.lexemeIdx += 1
    return lexeme
  }
  
  bpSearch.QueryParser.prototype.nextClause = function () {
    var completedClause = this.currentClause
    this.query.clause(completedClause)
    this.currentClause = {}
  }
  
  bpSearch.QueryParser.parseClause = function (parser) {
    var lexeme = parser.peekLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    switch (lexeme.type) {
      case bpSearch.QueryLexer.PRESENCE:
        return bpSearch.QueryParser.parsePresence
      case bpSearch.QueryLexer.FIELD:
        return bpSearch.QueryParser.parseField
      case bpSearch.QueryLexer.TERM:
        return bpSearch.QueryParser.parseTerm
      default:
        var errorMessage = "expected either a field or a term, found " + lexeme.type
  
        if (lexeme.str.length >= 1) {
          errorMessage += " with value '" + lexeme.str + "'"
        }
  
        throw new bpSearch.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  }
  
  bpSearch.QueryParser.parsePresence = function (parser) {
    var lexeme = parser.consumeLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    switch (lexeme.str) {
      case "-":
        parser.currentClause.presence = bpSearch.Query.presence.PROHIBITED
        break
      case "+":
        parser.currentClause.presence = bpSearch.Query.presence.REQUIRED
        break
      default:
        var errorMessage = "unrecognised presence operator'" + lexeme.str + "'"
        throw new bpSearch.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  
    var nextLexeme = parser.peekLexeme()
  
    if (nextLexeme == undefined) {
      var errorMessage = "expecting term or field, found nothing"
      throw new bpSearch.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  
    switch (nextLexeme.type) {
      case bpSearch.QueryLexer.FIELD:
        return bpSearch.QueryParser.parseField
      case bpSearch.QueryLexer.TERM:
        return bpSearch.QueryParser.parseTerm
      default:
        var errorMessage = "expecting term or field, found '" + nextLexeme.type + "'"
        throw new bpSearch.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
    }
  }
  
  bpSearch.QueryParser.parseField = function (parser) {
    var lexeme = parser.consumeLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    if (parser.query.allFields.indexOf(lexeme.str) == -1) {
      var possibleFields = parser.query.allFields.map(function (f) { return "'" + f + "'" }).join(', '),
          errorMessage = "unrecognised field '" + lexeme.str + "', possible fields: " + possibleFields
  
      throw new bpSearch.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  
    parser.currentClause.fields = [lexeme.str]
  
    var nextLexeme = parser.peekLexeme()
  
    if (nextLexeme == undefined) {
      var errorMessage = "expecting term, found nothing"
      throw new bpSearch.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  
    switch (nextLexeme.type) {
      case bpSearch.QueryLexer.TERM:
        return bpSearch.QueryParser.parseTerm
      default:
        var errorMessage = "expecting term, found '" + nextLexeme.type + "'"
        throw new bpSearch.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
    }
  }
  
  bpSearch.QueryParser.parseTerm = function (parser) {
    var lexeme = parser.consumeLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    parser.currentClause.term = lexeme.str.toLowerCase()
  
    if (lexeme.str.indexOf("*") != -1) {
      parser.currentClause.usePipeline = false
    }
  
    var nextLexeme = parser.peekLexeme()
  
    if (nextLexeme == undefined) {
      parser.nextClause()
      return
    }
  
    switch (nextLexeme.type) {
      case bpSearch.QueryLexer.TERM:
        parser.nextClause()
        return bpSearch.QueryParser.parseTerm
      case bpSearch.QueryLexer.FIELD:
        parser.nextClause()
        return bpSearch.QueryParser.parseField
      case bpSearch.QueryLexer.EDIT_DISTANCE:
        return bpSearch.QueryParser.parseEditDistance
      case bpSearch.QueryLexer.BOOST:
        return bpSearch.QueryParser.parseBoost
      case bpSearch.QueryLexer.PRESENCE:
        parser.nextClause()
        return bpSearch.QueryParser.parsePresence
      default:
        var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'"
        throw new bpSearch.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
    }
  }
  
  bpSearch.QueryParser.parseEditDistance = function (parser) {
    var lexeme = parser.consumeLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    var editDistance = parseInt(lexeme.str, 10)
  
    if (isNaN(editDistance)) {
      var errorMessage = "edit distance must be numeric"
      throw new bpSearch.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  
    parser.currentClause.editDistance = editDistance
  
    var nextLexeme = parser.peekLexeme()
  
    if (nextLexeme == undefined) {
      parser.nextClause()
      return
    }
  
    switch (nextLexeme.type) {
      case bpSearch.QueryLexer.TERM:
        parser.nextClause()
        return bpSearch.QueryParser.parseTerm
      case bpSearch.QueryLexer.FIELD:
        parser.nextClause()
        return bpSearch.QueryParser.parseField
      case bpSearch.QueryLexer.EDIT_DISTANCE:
        return bpSearch.QueryParser.parseEditDistance
      case bpSearch.QueryLexer.BOOST:
        return bpSearch.QueryParser.parseBoost
      case bpSearch.QueryLexer.PRESENCE:
        parser.nextClause()
        return bpSearch.QueryParser.parsePresence
      default:
        var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'"
        throw new bpSearch.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
    }
  }
  
  bpSearch.QueryParser.parseBoost = function (parser) {
    var lexeme = parser.consumeLexeme()
  
    if (lexeme == undefined) {
      return
    }
  
    var boost = parseInt(lexeme.str, 10)
  
    if (isNaN(boost)) {
      var errorMessage = "boost must be numeric"
      throw new bpSearch.QueryParseError (errorMessage, lexeme.start, lexeme.end)
    }
  
    parser.currentClause.boost = boost
  
    var nextLexeme = parser.peekLexeme()
  
    if (nextLexeme == undefined) {
      parser.nextClause()
      return
    }
  
    switch (nextLexeme.type) {
      case bpSearch.QueryLexer.TERM:
        parser.nextClause()
        return bpSearch.QueryParser.parseTerm
      case bpSearch.QueryLexer.FIELD:
        parser.nextClause()
        return bpSearch.QueryParser.parseField
      case bpSearch.QueryLexer.EDIT_DISTANCE:
        return bpSearch.QueryParser.parseEditDistance
      case bpSearch.QueryLexer.BOOST:
        return bpSearch.QueryParser.parseBoost
      case bpSearch.QueryLexer.PRESENCE:
        parser.nextClause()
        return bpSearch.QueryParser.parsePresence
      default:
        var errorMessage = "Unexpected lexeme type '" + nextLexeme.type + "'"
        throw new bpSearch.QueryParseError (errorMessage, nextLexeme.start, nextLexeme.end)
    }
  }
  
    /**
     * export the module via AMD, CommonJS or as a browser global
     * Export code from https://github.com/umdjs/umd/blob/master/returnExports.js
     */
    ;(function (root, factory) {
      if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(factory)
      } else if (typeof exports === 'object') {
        /**
         * Node. Does not work with strict CommonJS, but
         * only CommonJS-like enviroments that support module.exports,
         * like Node.
         */
        module.exports = factory()
      } else {
        // Browser globals (root is window)
        root.bpSearch = factory()
      }
    }(this, function () {
      /**
       * Just return a value to define the module export.
       * This example returns an object, but the module
       * can return a function as the exported value.
       */
      return bpSearch
    }))
  })();
  
  /* bpKeys v1.6.5 craig.is/killing/mice */
(function(q,u,c){function v(a,b,g){a.addEventListener?a.addEventListener(b,g,!1):a.attachEvent("on"+b,g)}function z(a){if("keypress"==a.type){var b=String.fromCharCode(a.which);a.shiftKey||(b=b.toLowerCase());return b}return n[a.which]?n[a.which]:r[a.which]?r[a.which]:String.fromCharCode(a.which).toLowerCase()}function F(a){var b=[];a.shiftKey&&b.push("shift");a.altKey&&b.push("alt");a.ctrlKey&&b.push("ctrl");a.metaKey&&b.push("meta");return b}function w(a){return"shift"==a||"ctrl"==a||"alt"==a||
"meta"==a}function A(a,b){var g,d=[];var e=a;"+"===e?e=["+"]:(e=e.replace(/\+{2}/g,"+plus"),e=e.split("+"));for(g=0;g<e.length;++g){var m=e[g];B[m]&&(m=B[m]);b&&"keypress"!=b&&C[m]&&(m=C[m],d.push("shift"));w(m)&&d.push(m)}e=m;g=b;if(!g){if(!p){p={};for(var c in n)95<c&&112>c||n.hasOwnProperty(c)&&(p[n[c]]=c)}g=p[e]?"keydown":"keypress"}"keypress"==g&&d.length&&(g="keydown");return{key:m,modifiers:d,action:g}}function D(a,b){return null===a||a===u?!1:a===b?!0:D(a.parentNode,b)}function d(a){function b(a){a=
a||{};var b=!1,l;for(l in p)a[l]?b=!0:p[l]=0;b||(x=!1)}function g(a,b,t,f,g,d){var l,E=[],h=t.type;if(!k._callbacks[a])return[];"keyup"==h&&w(a)&&(b=[a]);for(l=0;l<k._callbacks[a].length;++l){var c=k._callbacks[a][l];if((f||!c.seq||p[c.seq]==c.level)&&h==c.action){var e;(e="keypress"==h&&!t.metaKey&&!t.ctrlKey)||(e=c.modifiers,e=b.sort().join(",")===e.sort().join(","));e&&(e=f&&c.seq==f&&c.level==d,(!f&&c.combo==g||e)&&k._callbacks[a].splice(l,1),E.push(c))}}return E}function c(a,b,c,f){k.stopCallback(b,
b.target||b.srcElement,c,f)||!1!==a(b,c)||(b.preventDefault?b.preventDefault():b.returnValue=!1,b.stopPropagation?b.stopPropagation():b.cancelBubble=!0)}function e(a){"number"!==typeof a.which&&(a.which=a.keyCode);var b=z(a);b&&("keyup"==a.type&&y===b?y=!1:k.handleKey(b,F(a),a))}function m(a,g,t,f){function h(c){return function(){x=c;++p[a];clearTimeout(q);q=setTimeout(b,1E3)}}function l(g){c(t,g,a);"keyup"!==f&&(y=z(g));setTimeout(b,10)}for(var d=p[a]=0;d<g.length;++d){var e=d+1===g.length?l:h(f||
A(g[d+1]).action);n(g[d],e,f,a,d)}}function n(a,b,c,f,d){k._directMap[a+":"+c]=b;a=a.replace(/\s+/g," ");var e=a.split(" ");1<e.length?m(a,e,b,c):(c=A(a,c),k._callbacks[c.key]=k._callbacks[c.key]||[],g(c.key,c.modifiers,{type:c.action},f,a,d),k._callbacks[c.key][f?"unshift":"push"]({callback:b,modifiers:c.modifiers,action:c.action,seq:f,level:d,combo:a}))}var k=this;a=a||u;if(!(k instanceof d))return new d(a);k.target=a;k._callbacks={};k._directMap={};var p={},q,y=!1,r=!1,x=!1;k._handleKey=function(a,
d,e){var f=g(a,d,e),h;d={};var k=0,l=!1;for(h=0;h<f.length;++h)f[h].seq&&(k=Math.max(k,f[h].level));for(h=0;h<f.length;++h)f[h].seq?f[h].level==k&&(l=!0,d[f[h].seq]=1,c(f[h].callback,e,f[h].combo,f[h].seq)):l||c(f[h].callback,e,f[h].combo);f="keypress"==e.type&&r;e.type!=x||w(a)||f||b(d);r=l&&"keydown"==e.type};k._bindMultiple=function(a,b,c){for(var d=0;d<a.length;++d)n(a[d],b,c)};v(a,"keypress",e);v(a,"keydown",e);v(a,"keyup",e)}if(q){var n={8:"backspace",9:"tab",13:"enter",16:"shift",17:"ctrl",
18:"alt",20:"capslock",27:"esc",32:"space",33:"pageup",34:"pagedown",35:"end",36:"home",37:"left",38:"up",39:"right",40:"down",45:"ins",46:"del",91:"meta",93:"meta",224:"meta"},r={106:"*",107:"+",109:"-",110:".",111:"/",186:";",187:"=",188:",",189:"-",190:".",191:"/",192:"`",219:"[",220:"\\",221:"]",222:"'"},C={"~":"`","!":"1","@":"2","#":"3",$:"4","%":"5","^":"6","&":"7","*":"8","(":"9",")":"0",_:"-","+":"=",":":";",'"':"'","<":",",">":".","?":"/","|":"\\"},B={option:"alt",command:"meta","return":"enter",
escape:"esc",plus:"+",mod:/Mac|iPod|iPhone|iPad/.test(navigator.platform)?"meta":"ctrl"},p;for(c=1;20>c;++c)n[111+c]="f"+c;for(c=0;9>=c;++c)n[c+96]=c.toString();d.prototype.bind=function(a,b,c){a=a instanceof Array?a:[a];this._bindMultiple.call(this,a,b,c);return this};d.prototype.unbind=function(a,b){return this.bind.call(this,a,function(){},b)};d.prototype.trigger=function(a,b){if(this._directMap[a+":"+b])this._directMap[a+":"+b]({},a);return this};d.prototype.reset=function(){this._callbacks={};
this._directMap={};return this};d.prototype.stopCallback=function(a,b){if(-1<(" "+b.className+" ").indexOf(" bpKeys ")||D(b,this.target))return!1;if("composedPath"in a&&"function"===typeof a.composedPath){var c=a.composedPath()[0];c!==a.target&&(b=c)}return"INPUT"==b.tagName||"SELECT"==b.tagName||"TEXTAREA"==b.tagName||b.isContentEditable};d.prototype.handleKey=function(){return this._handleKey.apply(this,arguments)};d.addKeycodes=function(a){for(var b in a)a.hasOwnProperty(b)&&(n[b]=a[b]);p=null};
d.init=function(){var a=d(u),b;for(b in a)"_"!==b.charAt(0)&&(d[b]=function(b){return function(){return a[b].apply(a,arguments)}}(b))};d.init();q.bpKeys=d;"undefined"!==typeof module&&module.exports&&(module.exports=d);"function"===typeof define&&define.amd&&define(function(){return d})}})("undefined"!==typeof window?window:null,"undefined"!==typeof window?document:null);

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global.page = factory());
}(this, (function () { 'use strict';

var isarray = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

/**
 * Expose `pathToRegexp`.
 */
var pathToRegexp_1 = pathToRegexp;
var parse_1 = parse;
var compile_1 = compile;
var tokensToFunction_1 = tokensToFunction;
var tokensToRegExp_1 = tokensToRegExp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?", undefined]
  // "/route(\\d+)"  => [undefined, undefined, undefined, "\d+", undefined, undefined]
  // "/*"            => ["/", undefined, undefined, undefined, undefined, "*"]
  '([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^()])+)\\))?|\\(((?:\\\\.|[^()])+)\\))([+*?])?|(\\*))'
].join('|'), 'g');

/**
 * Parse a string for the raw tokens.
 *
 * @param  {String} str
 * @return {Array}
 */
function parse (str) {
  var tokens = [];
  var key = 0;
  var index = 0;
  var path = '';
  var res;

  while ((res = PATH_REGEXP.exec(str)) != null) {
    var m = res[0];
    var escaped = res[1];
    var offset = res.index;
    path += str.slice(index, offset);
    index = offset + m.length;

    // Ignore already escaped sequences.
    if (escaped) {
      path += escaped[1];
      continue
    }

    // Push the current path onto the tokens.
    if (path) {
      tokens.push(path);
      path = '';
    }

    var prefix = res[2];
    var name = res[3];
    var capture = res[4];
    var group = res[5];
    var suffix = res[6];
    var asterisk = res[7];

    var repeat = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';
    var delimiter = prefix || '/';
    var pattern = capture || group || (asterisk ? '.*' : '[^' + delimiter + ']+?');

    tokens.push({
      name: name || key++,
      prefix: prefix || '',
      delimiter: delimiter,
      optional: optional,
      repeat: repeat,
      pattern: escapeGroup(pattern)
    });
  }

  // Match any characters still remaining.
  if (index < str.length) {
    path += str.substr(index);
  }

  // If the path exists, push it onto the end.
  if (path) {
    tokens.push(path);
  }

  return tokens
}

/**
 * Compile a string to a template function for the path.
 *
 * @param  {String}   str
 * @return {Function}
 */
function compile (str) {
  return tokensToFunction(parse(str))
}

/**
 * Expose a method for transforming tokens into the path function.
 */
function tokensToFunction (tokens) {
  // Compile all the tokens into regexps.
  var matches = new Array(tokens.length);

  // Compile all the patterns before compilation.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] === 'object') {
      matches[i] = new RegExp('^' + tokens[i].pattern + '$');
    }
  }

  return function (obj) {
    var path = '';
    var data = obj || {};

    for (var i = 0; i < tokens.length; i++) {
      var token = tokens[i];

      if (typeof token === 'string') {
        path += token;

        continue
      }

      var value = data[token.name];
      var segment;

      if (value == null) {
        if (token.optional) {
          continue
        } else {
          throw new TypeError('Expected "' + token.name + '" to be defined')
        }
      }

      if (isarray(value)) {
        if (!token.repeat) {
          throw new TypeError('Expected "' + token.name + '" to not repeat, but received "' + value + '"')
        }

        if (value.length === 0) {
          if (token.optional) {
            continue
          } else {
            throw new TypeError('Expected "' + token.name + '" to not be empty')
          }
        }

        for (var j = 0; j < value.length; j++) {
          segment = encodeURIComponent(value[j]);

          if (!matches[i].test(segment)) {
            throw new TypeError('Expected all "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
          }

          path += (j === 0 ? token.prefix : token.delimiter) + segment;
        }

        continue
      }

      segment = encodeURIComponent(value);

      if (!matches[i].test(segment)) {
        throw new TypeError('Expected "' + token.name + '" to match "' + token.pattern + '", but received "' + segment + '"')
      }

      path += token.prefix + segment;
    }

    return path
  }
}

/**
 * Escape a regular expression string.
 *
 * @param  {String} str
 * @return {String}
 */
function escapeString (str) {
  return str.replace(/([.+*?=^!:${}()[\]|\/])/g, '\\$1')
}

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1')
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {String}
 */
function flags (options) {
  return options.sensitive ? '' : 'i'
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {RegExp} path
 * @param  {Array}  keys
 * @return {RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name: i,
        prefix: null,
        delimiter: null,
        optional: false,
        repeat: false,
        pattern: null
      });
    }
  }

  return attachKeys(path, keys)
}

/**
 * Transform an array into a regexp.
 *
 * @param  {Array}  path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));

  return attachKeys(regexp, keys)
}

/**
 * Create a path regexp from string input.
 *
 * @param  {String} path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function stringToRegexp (path, keys, options) {
  var tokens = parse(path);
  var re = tokensToRegExp(tokens, options);

  // Attach keys back to the regexp.
  for (var i = 0; i < tokens.length; i++) {
    if (typeof tokens[i] !== 'string') {
      keys.push(tokens[i]);
    }
  }

  return attachKeys(re, keys)
}

/**
 * Expose a function for taking tokens and returning a RegExp.
 *
 * @param  {Array}  tokens
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function tokensToRegExp (tokens, options) {
  options = options || {};

  var strict = options.strict;
  var end = options.end !== false;
  var route = '';
  var lastToken = tokens[tokens.length - 1];
  var endsWithSlash = typeof lastToken === 'string' && /\/$/.test(lastToken);

  // Iterate over the tokens and create our regexp string.
  for (var i = 0; i < tokens.length; i++) {
    var token = tokens[i];

    if (typeof token === 'string') {
      route += escapeString(token);
    } else {
      var prefix = escapeString(token.prefix);
      var capture = token.pattern;

      if (token.repeat) {
        capture += '(?:' + prefix + capture + ')*';
      }

      if (token.optional) {
        if (prefix) {
          capture = '(?:' + prefix + '(' + capture + '))?';
        } else {
          capture = '(' + capture + ')?';
        }
      } else {
        capture = prefix + '(' + capture + ')';
      }

      route += capture;
    }
  }

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return new RegExp('^' + route, flags(options))
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 [keys]
 * @param  {Object}                [options]
 * @return {RegExp}
 */
function pathToRegexp (path, keys, options) {
  keys = keys || [];

  if (!isarray(keys)) {
    options = keys;
    keys = [];
  } else if (!options) {
    options = {};
  }

  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys, options)
  }

  if (isarray(path)) {
    return arrayToRegexp(path, keys, options)
  }

  return stringToRegexp(path, keys, options)
}

pathToRegexp_1.parse = parse_1;
pathToRegexp_1.compile = compile_1;
pathToRegexp_1.tokensToFunction = tokensToFunction_1;
pathToRegexp_1.tokensToRegExp = tokensToRegExp_1;

/**
   * Module dependencies.
   */

  

  /**
   * Short-cuts for global-object checks
   */

  var hasDocument = ('undefined' !== typeof document);
  var hasWindow = ('undefined' !== typeof window);
  var hasHistory = ('undefined' !== typeof history);
  var hasProcess = typeof process !== 'undefined';

  /**
   * Detect click event
   */
  var clickEvent = hasDocument && document.ontouchstart ? 'touchstart' : 'click';

  /**
   * To work properly with the URL
   * history.location generated polyfill in https://github.com/devote/HTML5-History-API
   */

  var isLocation = hasWindow && !!(window.history.location || window.location);

  /**
   * The page instance
   * @api private
   */
  function Page() {
    // public things
    this.callbacks = [];
    this.exits = [];
    this.current = '';
    this.len = 0;

    // private things
    this._decodeURLComponents = true;
    this._base = '';
    this._strict = false;
    this._running = false;
    this._hashbang = false;

    // bound functions
    this.clickHandler = this.clickHandler.bind(this);
    this._onpopstate = this._onpopstate.bind(this);
  }

  /**
   * Configure the instance of page. This can be called multiple times.
   *
   * @param {Object} options
   * @api public
   */

  Page.prototype.configure = function(options) {
    var opts = options || {};

    this._window = opts.window || (hasWindow && window);
    this._decodeURLComponents = opts.decodeURLComponents !== false;
    this._popstate = opts.popstate !== false && hasWindow;
    this._click = opts.click !== false && hasDocument;
    this._hashbang = !!opts.hashbang;

    var _window = this._window;
    if(this._popstate) {
      _window.addEventListener('popstate', this._onpopstate, false);
    } else if(hasWindow) {
      _window.removeEventListener('popstate', this._onpopstate, false);
    }

    if (this._click) {
      _window.document.addEventListener(clickEvent, this.clickHandler, false);
    } else if(hasDocument) {
      _window.document.removeEventListener(clickEvent, this.clickHandler, false);
    }

    if(this._hashbang && hasWindow && !hasHistory) {
      _window.addEventListener('hashchange', this._onpopstate, false);
    } else if(hasWindow) {
      _window.removeEventListener('hashchange', this._onpopstate, false);
    }
  };

  /**
   * Get or set basepath to `path`.
   *
   * @param {string} path
   * @api public
   */

  Page.prototype.base = function(path) {
    if (0 === arguments.length) return this._base;
    this._base = path;
  };

  /**
   * Gets the `base`, which depends on whether we are using History or
   * hashbang routing.

   * @api private
   */
  Page.prototype._getBase = function() {
    var base = this._base;
    if(!!base) return base;
    var loc = hasWindow && this._window && this._window.location;

    if(hasWindow && this._hashbang && loc && loc.protocol === 'file:') {
      base = loc.pathname;
    }

    return base;
  };

  /**
   * Get or set strict path matching to `enable`
   *
   * @param {boolean} enable
   * @api public
   */

  Page.prototype.strict = function(enable) {
    if (0 === arguments.length) return this._strict;
    this._strict = enable;
  };


  /**
   * Bind with the given `options`.
   *
   * Options:
   *
   *    - `click` bind to click events [true]
   *    - `popstate` bind to popstate [true]
   *    - `dispatch` perform initial dispatch [true]
   *
   * @param {Object} options
   * @api public
   */

  Page.prototype.start = function(options) {
    var opts = options || {};
    this.configure(opts);

    if (false === opts.dispatch) return;
    this._running = true;

    var url;
    if(isLocation) {
      var window = this._window;
      var loc = window.location;

      if(this._hashbang && ~loc.hash.indexOf('#!')) {
        url = loc.hash.substr(2) + loc.search;
      } else if (this._hashbang) {
        url = loc.search + loc.hash;
      } else {
        url = loc.pathname + loc.search + loc.hash;
      }
    }

    this.replace(url, null, true, opts.dispatch);
  };

  /**
   * Unbind click and popstate event handlers.
   *
   * @api public
   */

  Page.prototype.stop = function() {
    if (!this._running) return;
    this.current = '';
    this.len = 0;
    this._running = false;

    var window = this._window;
    this._click && window.document.removeEventListener(clickEvent, this.clickHandler, false);
    hasWindow && window.removeEventListener('popstate', this._onpopstate, false);
    hasWindow && window.removeEventListener('hashchange', this._onpopstate, false);
  };

  /**
   * Show `path` with optional `state` object.
   *
   * @param {string} path
   * @param {Object=} state
   * @param {boolean=} dispatch
   * @param {boolean=} push
   * @return {!Context}
   * @api public
   */

  Page.prototype.show = function(path, state, dispatch, push) {
    var ctx = new Context(path, state, this),
      prev = this.prevContext;
    this.prevContext = ctx;
    this.current = ctx.path;
    if (false !== dispatch) this.dispatch(ctx, prev);
    if (false !== ctx.handled && false !== push) ctx.pushState();
    return ctx;
  };

  /**
   * Goes back in the history
   * Back should always let the current route push state and then go back.
   *
   * @param {string} path - fallback path to go back if no more history exists, if undefined defaults to page.base
   * @param {Object=} state
   * @api public
   */

  Page.prototype.back = function(path, state) {
    var page = this;
    if (this.len > 0) {
      var window = this._window;
      // this may need more testing to see if all browsers
      // wait for the next tick to go back in history
      hasHistory && window.history.back();
      this.len--;
    } else if (path) {
      setTimeout(function() {
        page.show(path, state);
      });
    } else {
      setTimeout(function() {
        page.show(page._getBase(), state);
      });
    }
  };

  /**
   * Register route to redirect from one path to other
   * or just redirect to another route
   *
   * @param {string} from - if param 'to' is undefined redirects to 'from'
   * @param {string=} to
   * @api public
   */
  Page.prototype.redirect = function(from, to) {
    var inst = this;

    // Define route from a path to another
    if ('string' === typeof from && 'string' === typeof to) {
      page.call(this, from, function(e) {
        setTimeout(function() {
          inst.replace(/** @type {!string} */ (to));
        }, 0);
      });
    }

    // Wait for the push state and replace it with another
    if ('string' === typeof from && 'undefined' === typeof to) {
      setTimeout(function() {
        inst.replace(from);
      }, 0);
    }
  };

  /**
   * Replace `path` with optional `state` object.
   *
   * @param {string} path
   * @param {Object=} state
   * @param {boolean=} init
   * @param {boolean=} dispatch
   * @return {!Context}
   * @api public
   */


  Page.prototype.replace = function(path, state, init, dispatch) {
    var ctx = new Context(path, state, this),
      prev = this.prevContext;
    this.prevContext = ctx;
    this.current = ctx.path;
    ctx.init = init;
    ctx.save(); // save before dispatching, which may redirect
    if (false !== dispatch) this.dispatch(ctx, prev);
    return ctx;
  };

  /**
   * Dispatch the given `ctx`.
   *
   * @param {Context} ctx
   * @api private
   */

  Page.prototype.dispatch = function(ctx, prev) {
    var i = 0, j = 0, page = this;

    function nextExit() {
      var fn = page.exits[j++];
      if (!fn) return nextEnter();
      fn(prev, nextExit);
    }

    function nextEnter() {
      var fn = page.callbacks[i++];

      if (ctx.path !== page.current) {
        ctx.handled = false;
        return;
      }
      if (!fn) return unhandled.call(page, ctx);
      fn(ctx, nextEnter);
    }

    if (prev) {
      nextExit();
    } else {
      nextEnter();
    }
  };

  /**
   * Register an exit route on `path` with
   * callback `fn()`, which will be called
   * on the previous context when a new
   * page is visited.
   */
  Page.prototype.exit = function(path, fn) {
    if (typeof path === 'function') {
      return this.exit('*', path);
    }

    var route = new Route(path, null, this);
    for (var i = 1; i < arguments.length; ++i) {
      this.exits.push(route.middleware(arguments[i]));
    }
  };

  /**
   * Handle "click" events.
   */

  /* jshint +W054 */
  Page.prototype.clickHandler = function(e) {
    if (1 !== this._which(e)) return;

    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
    if (e.defaultPrevented) return;

    // ensure link
    // use shadow dom when available if not, fall back to composedPath()
    // for browsers that only have shady
    var el = e.target;
    var eventPath = e.path || (e.composedPath ? e.composedPath() : null);

    if(eventPath) {
      for (var i = 0; i < eventPath.length; i++) {
        if (!eventPath[i].nodeName) continue;
        if (eventPath[i].nodeName.toUpperCase() !== 'A') continue;
        if (!eventPath[i].href) continue;

        el = eventPath[i];
        break;
      }
    }

    // continue ensure link
    // el.nodeName for svg links are 'a' instead of 'A'
    while (el && 'A' !== el.nodeName.toUpperCase()) el = el.parentNode;
    if (!el || 'A' !== el.nodeName.toUpperCase()) return;

    // check if link is inside an svg
    // in this case, both href and target are always inside an object
    var svg = (typeof el.href === 'object') && el.href.constructor.name === 'SVGAnimatedString';

    // Ignore if tag has
    // 1. "download" attribute
    // 2. rel="external" attribute
    if (el.hasAttribute('download') || el.getAttribute('rel') === 'external') return;

    // ensure non-hash for the same path
    var link = el.getAttribute('href');
    if(!this._hashbang && this._samePath(el) && (el.hash || '#' === link)) return;

    // Check for mailto: in the href
    if (link && link.indexOf('mailto:') > -1) return;

    // check target
    // svg target is an object and its desired value is in .baseVal property
    if (svg ? el.target.baseVal : el.target) return;

    // x-origin
    // note: svg links that are not relative don't call click events (and skip page.js)
    // consequently, all svg links tested inside page.js are relative and in the same origin
    if (!svg && !this.sameOrigin(el.href)) return;

    // rebuild path
    // There aren't .pathname and .search properties in svg links, so we use href
    // Also, svg href is an object and its desired value is in .baseVal property
    var path = svg ? el.href.baseVal : (el.pathname + el.search + (el.hash || ''));

    path = path[0] !== '/' ? '/' + path : path;

    // strip leading "/[drive letter]:" on NW.js on Windows
    if (hasProcess && path.match(/^\/[a-zA-Z]:\//)) {
      path = path.replace(/^\/[a-zA-Z]:\//, '/');
    }

    // same page
    var orig = path;
    var pageBase = this._getBase();

    if (path.indexOf(pageBase) === 0) {
      path = path.substr(pageBase.length);
    }

    if (this._hashbang) path = path.replace('#!', '');

    if (pageBase && orig === path && (!isLocation || this._window.location.protocol !== 'file:')) {
      return;
    }

    e.preventDefault();
    this.show(orig);
  };

  /**
   * Handle "populate" events.
   * @api private
   */

  Page.prototype._onpopstate = (function () {
    var loaded = false;
    if ( ! hasWindow ) {
      return function () {};
    }
    if (hasDocument && document.readyState === 'complete') {
      loaded = true;
    } else {
      window.addEventListener('load', function() {
        setTimeout(function() {
          loaded = true;
        }, 0);
      });
    }
    return function onpopstate(e) {
      if (!loaded) return;
      var page = this;
      if (e.state) {
        var path = e.state.path;
        page.replace(path, e.state);
      } else if (isLocation) {
        var loc = page._window.location;
        page.show(loc.pathname + loc.search + loc.hash, undefined, undefined, false);
      }
    };
  })();

  /**
   * Event button.
   */
  Page.prototype._which = function(e) {
    e = e || (hasWindow && this._window.event);
    return null == e.which ? e.button : e.which;
  };

  /**
   * Convert to a URL object
   * @api private
   */
  Page.prototype._toURL = function(href) {
    var window = this._window;
    if(typeof URL === 'function' && isLocation) {
      return new URL(href, window.location.toString());
    } else if (hasDocument) {
      var anc = window.document.createElement('a');
      anc.href = href;
      return anc;
    }
  };

  /**
   * Check if `href` is the same origin.
   * @param {string} href
   * @api public
   */
  Page.prototype.sameOrigin = function(href) {
    if(!href || !isLocation) return false;

    var url = this._toURL(href);
    var window = this._window;

    var loc = window.location;

    /*
       When the port is the default http port 80 for http, or 443 for
       https, internet explorer 11 returns an empty string for loc.port,
       so we need to compare loc.port with an empty string if url.port
       is the default port 80 or 443.
       Also the comparition with `port` is changed from `===` to `==` because
       `port` can be a string sometimes. This only applies to ie11.
    */
    return loc.protocol === url.protocol &&
      loc.hostname === url.hostname &&
      (loc.port === url.port || loc.port === '' && (url.port == 80 || url.port == 443)); // jshint ignore:line
  };

  /**
   * @api private
   */
  Page.prototype._samePath = function(url) {
    if(!isLocation) return false;
    var window = this._window;
    var loc = window.location;
    return url.pathname === loc.pathname &&
      url.search === loc.search;
  };

  /**
   * Remove URL encoding from the given `str`.
   * Accommodates whitespace in both x-www-form-urlencoded
   * and regular percent-encoded form.
   *
   * @param {string} val - URL component to decode
   * @api private
   */
  Page.prototype._decodeURLEncodedURIComponent = function(val) {
    if (typeof val !== 'string') { return val; }
    return this._decodeURLComponents ? decodeURIComponent(val.replace(/\+/g, ' ')) : val;
  };

  /**
   * Create a new `page` instance and function
   */
  function createPage() {
    var pageInstance = new Page();

    function pageFn(/* args */) {
      return page.apply(pageInstance, arguments);
    }

    // Copy all of the things over. In 2.0 maybe we use setPrototypeOf
    pageFn.callbacks = pageInstance.callbacks;
    pageFn.exits = pageInstance.exits;
    pageFn.base = pageInstance.base.bind(pageInstance);
    pageFn.strict = pageInstance.strict.bind(pageInstance);
    pageFn.start = pageInstance.start.bind(pageInstance);
    pageFn.stop = pageInstance.stop.bind(pageInstance);
    pageFn.show = pageInstance.show.bind(pageInstance);
    pageFn.back = pageInstance.back.bind(pageInstance);
    pageFn.redirect = pageInstance.redirect.bind(pageInstance);
    pageFn.replace = pageInstance.replace.bind(pageInstance);
    pageFn.dispatch = pageInstance.dispatch.bind(pageInstance);
    pageFn.exit = pageInstance.exit.bind(pageInstance);
    pageFn.configure = pageInstance.configure.bind(pageInstance);
    pageFn.sameOrigin = pageInstance.sameOrigin.bind(pageInstance);
    pageFn.clickHandler = pageInstance.clickHandler.bind(pageInstance);

    pageFn.create = createPage;

    Object.defineProperty(pageFn, 'len', {
      get: function(){
        return pageInstance.len;
      },
      set: function(val) {
        pageInstance.len = val;
      }
    });

    Object.defineProperty(pageFn, 'current', {
      get: function(){
        return pageInstance.current;
      },
      set: function(val) {
        pageInstance.current = val;
      }
    });

    // In 2.0 these can be named exports
    pageFn.Context = Context;
    pageFn.Route = Route;

    return pageFn;
  }

  /**
   * Register `path` with callback `fn()`,
   * or route `path`, or redirection,
   * or `page.start()`.
   *
   *   page(fn);
   *   page('*', fn);
   *   page('/user/:id', load, user);
   *   page('/user/' + user.id, { some: 'thing' });
   *   page('/user/' + user.id);
   *   page('/from', '/to')
   *   page();
   *
   * @param {string|!Function|!Object} path
   * @param {Function=} fn
   * @api public
   */

  function page(path, fn) {
    // <callback>
    if ('function' === typeof path) {
      return page.call(this, '*', path);
    }

    // route <path> to <callback ...>
    if ('function' === typeof fn) {
      var route = new Route(/** @type {string} */ (path), null, this);
      for (var i = 1; i < arguments.length; ++i) {
        this.callbacks.push(route.middleware(arguments[i]));
      }
      // show <path> with [state]
    } else if ('string' === typeof path) {
      this['string' === typeof fn ? 'redirect' : 'show'](path, fn);
      // start [options]
    } else {
      this.start(path);
    }
  }

  /**
   * Unhandled `ctx`. When it's not the initial
   * popstate then redirect. If you wish to handle
   * 404s on your own use `page('*', callback)`.
   *
   * @param {Context} ctx
   * @api private
   */
  function unhandled(ctx) {
    if (ctx.handled) return;
    var current;
    var page = this;
    var window = page._window;

    if (page._hashbang) {
      current = isLocation && this._getBase() + window.location.hash.replace('#!', '');
    } else {
      current = isLocation && window.location.pathname + window.location.search;
    }

    if (current === ctx.canonicalPath) return;
    page.stop();
    ctx.handled = false;
    isLocation && (window.location.href = ctx.canonicalPath);
  }

  /**
   * Escapes RegExp characters in the given string.
   *
   * @param {string} s
   * @api private
   */
  function escapeRegExp(s) {
    return s.replace(/([.+*?=^!:${}()[\]|/\\])/g, '\\$1');
  }

  /**
   * Initialize a new "request" `Context`
   * with the given `path` and optional initial `state`.
   *
   * @constructor
   * @param {string} path
   * @param {Object=} state
   * @api public
   */

  function Context(path, state, pageInstance) {
    var _page = this.page = pageInstance || page;
    var window = _page._window;
    var hashbang = _page._hashbang;

    var pageBase = _page._getBase();
    if ('/' === path[0] && 0 !== path.indexOf(pageBase)) path = pageBase + (hashbang ? '#!' : '') + path;
    var i = path.indexOf('?');

    this.canonicalPath = path;
    var re = new RegExp('^' + escapeRegExp(pageBase));
    this.path = path.replace(re, '') || '/';
    if (hashbang) this.path = this.path.replace('#!', '') || '/';

    this.title = (hasDocument && window.document.title);
    this.state = state || {};
    this.state.path = path;
    this.querystring = ~i ? _page._decodeURLEncodedURIComponent(path.slice(i + 1)) : '';
    this.pathname = _page._decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);
    this.params = {};

    // fragment
    this.hash = '';
    if (!hashbang) {
      if (!~this.path.indexOf('#')) return;
      var parts = this.path.split('#');
      this.path = this.pathname = parts[0];
      this.hash = _page._decodeURLEncodedURIComponent(parts[1]) || '';
      this.querystring = this.querystring.split('#')[0];
    }
  }

  /**
   * Push state.
   *
   * @api private
   */

  Context.prototype.pushState = function() {
    var page = this.page;
    var window = page._window;
    var hashbang = page._hashbang;

    page.len++;
    if (hasHistory) {
        window.history.pushState(this.state, this.title,
          hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
    }
  };

  /**
   * Save the context state.
   *
   * @api public
   */

  Context.prototype.save = function() {
    var page = this.page;
    if (hasHistory) {
        page._window.history.replaceState(this.state, this.title,
          page._hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
    }
  };

  /**
   * Initialize `Route` with the given HTTP `path`,
   * and an array of `callbacks` and `options`.
   *
   * Options:
   *
   *   - `sensitive`    enable case-sensitive routes
   *   - `strict`       enable strict matching for trailing slashes
   *
   * @constructor
   * @param {string} path
   * @param {Object=} options
   * @api private
   */

  function Route(path, options, page) {
    var _page = this.page = page || globalPage;
    var opts = options || {};
    opts.strict = opts.strict || _page._strict;
    this.path = (path === '*') ? '(.*)' : path;
    this.method = 'GET';
    this.regexp = pathToRegexp_1(this.path, this.keys = [], opts);
  }

  /**
   * Return route middleware with
   * the given callback `fn()`.
   *
   * @param {Function} fn
   * @return {Function}
   * @api public
   */

  Route.prototype.middleware = function(fn) {
    var self = this;
    return function(ctx, next) {
      if (self.match(ctx.path, ctx.params)) {
        ctx.routePath = self.path;
        return fn(ctx, next);
      }
      next();
    };
  };

  /**
   * Check if this route matches `path`, if so
   * populate `params`.
   *
   * @param {string} path
   * @param {Object} params
   * @return {boolean}
   * @api private
   */

  Route.prototype.match = function(path, params) {
    var keys = this.keys,
      qsIndex = path.indexOf('?'),
      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,
      m = this.regexp.exec(decodeURIComponent(pathname));

    if (!m) return false;

    delete params[0];

    for (var i = 1, len = m.length; i < len; ++i) {
      var key = keys[i - 1];
      var val = this.page._decodeURLEncodedURIComponent(m[i]);
      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {
        params[key.name] = val;
      }
    }

    return true;
  };


  /**
   * Module exports.
   */

  var globalPage = createPage();
  var page_js = globalPage;
  var default_1 = globalPage;

page_js.default = default_1;

return page_js;

})));

(function (window) {
  'use strict';

  var VoiceRecognition = window.webkitSpeechRecognition;

  /**
   * bpSpeech Constructor.
   * @constructor
   * @params {String} lang - A given language.
   * @returns {bpSpeech} Returns a new instance of bpSpeech.
   */
  function bpSpeech(lang) {
      this._lang = lang;
      this.initialize();
  }

  /**
   * Initializes a new instance of bpSpeech.
   * @function
   * @returns {bpSpeech} Returns a new instance of bpSpeech.
   */
  bpSpeech.prototype.initialize = function () {

      this._collection = {};
      this._createRecognition();
      this._bindKeyEvents();

      return this;
  };

  /**
   * Creates a new instance of VoiceRecognition.
   * @function
   * @private
   * @returns {bpSpeech}
   */
  bpSpeech.prototype._createRecognition = function () {

      this._recognition = new VoiceRecognition();

      this._recognition.continuous = true;
      this._recognition.interimResults = false;
      this._recognition.lang = this._lang || 'en-US';
      this._recognition.maxAlternatives = 1;

      this._recognition.onresult = undefined;

      this._recognition.start();

      return this;
  };

  /**
   * Binds key events.
   * @function
   * @private
   * @returns {bpSpeech}
   */
  bpSpeech.prototype._bindKeyEvents = function () {
      var that = this,
          keypress = false;

      document.addEventListener('keydown', function (eve) {
          if (!keypress && eve.keyCode === 86) {
              that.start();
              keypress = true;
          }
      });

      document.addEventListener('keyup', function (eve) {
          if (keypress && eve.keyCode === 86) {
              keypress = false;
          }
      });

      return this;
  };

  /**
   * Transcripts commands.
   * @function
   * @private
   * @returns {bpSpeech}
   */
  bpSpeech.prototype._result = function (eve) {
      this.stop();

      var that = this,
          i = eve.resultIndex,
          len = eve.results.length,
          j = 0,
          listeners,
          lenListeners,
          command;

      for (i; i < len; i += 1) {

          if (eve.results[i].isFinal) {
              command = eve.results[i][0].transcript.replace(/^\s+|\s+$/g, '').toLowerCase();

              if (that._collection[command]) {
                  listeners = that._collection[command].listeners;
                  lenListeners = listeners.length;

                  for (j; j < lenListeners; j += 1) {
                      listeners[j].call();
                  }
              }

          }
      }
  };

  /**
   * Sets a new command with a listener to the collection.
   * @memberof! bpSpeech.prototype
   * @function
   * @param {String} [command] - A given command.
   * @param {Funtion} listener - A given listener.
   * @returns {bpSpeech}
   */
  bpSpeech.prototype.setCommand = function (command, listener) {
      if (this._collection[command] === undefined) {
          this._collection[command] = {
              'listeners': []
          };
      }

      this._collection[command].listeners.push(listener);

      return this;
  };

  /**
   * Rmoves a given command or its listener from the collection.
   * @memberof! bpSpeech.prototype
   * @function
   * @param {String} [command] - A given command.
   * @param {Funtion} listener - A given listener.
   * @returns {bpSpeech}
   */
  bpSpeech.prototype.removeCommand = function (command, listener) {
      var listeners = this._collection[command].listeners,
          i = 0,
          len = listeners.length;

      if (len !== undefined) {
          for (i; i < len; i += 1) {
              if (listeners[i] === listener) {
                  listeners.splice(i, 1);
                  break;
              }
          }
      }

      if (listeners.length === 0 || listener === undefined) {
          delete this._collection[command];
      }

      return this;
  };

  /**
   * Starts the recognition.
   * @memberof! bpSpeech.prototype
   * @function
   * @returns {bpSpeech}
   */
  bpSpeech.prototype.start = function () {
      var that = this;
      this._recognition.onresult = function (eve) {
          that._result.call(that, eve);
      };

      return this;
  };

  /**
   * Stops the recognition.
   * @memberof! bpSpeech.prototype
   * @function
   * @returns {bpSpeech}
   */
  bpSpeech.prototype.stop = function () {
      this._recognition.onresult = undefined;

      return this;
  };

  /**
   * Expose bpSpeech
   */
  // AMD suppport
  if (typeof window.define === 'function' && window.define.amd !== undefined) {
      window.define('bpSpeech', [], function () {
          return bpSpeech;
      });

  // CommonJS suppport
  } else if (typeof module !== 'undefined' && module.exports !== undefined) {
      module.exports = bpSpeech;

  // Default
  } else {
      window.bpSpeech = bpSpeech;
  }

}(this));

/**
 * bpVision - A modern approach for Computer Vision on the web.
 * @author Eduardo Lundgren <edu@rdo.io>
 * @version v1.1.3
 * @link http://bpVisionjs.com
 * @license BSD
 */
!function(t,r){t.bpVision=t.bpVision||{},bpVision.inherits=function(t,r){function n(){}n.prototype=r.prototype,t.superClass_=r.prototype,t.prototype=new n,t.prototype.constructor=t,t.base=function(t,n){var e=Array.prototype.slice.call(arguments,2);return r.prototype[n].apply(t,e)}},bpVision.initUserMedia_=function(r,n){t.navigator.mediaDevices.getUserMedia({video:!0,audio:!(!n||!n.audio)}).then(function(t){r.srcObject=t})["catch"](function(t){throw Error("Cannot capture user camera.")})},bpVision.isNode=function(t){return t.nodeType||this.isWindow(t)},bpVision.isWindow=function(t){return!!(t&&t.alert&&t.document)},bpVision.one=function(t,r){return this.isNode(t)?t:(r||document).querySelector(t)},bpVision.track=function(t,r,n){if(t=bpVision.one(t),!t)throw new Error("Element not found, try a different element or selector.");if(!r)throw new Error("Tracker not specified, try `bpVision.track(element, new bpVision.FaceTracker())`.");switch(t.nodeName.toLowerCase()){case"canvas":return this.trackCanvas_(t,r,n);case"img":return this.trackImg_(t,r,n);case"video":return n&&n.camera&&this.initUserMedia_(t,n),this.trackVideo_(t,r,n);default:throw new Error("Element not supported, try in a canvas, img, or video.")}},bpVision.trackCanvas_=function(t,r){var n=this,e=new bpVision.TrackerTask(r);return e.on("run",function(){n.trackCanvasInternal_(t,r)}),e.run()},bpVision.trackCanvasInternal_=function(t,r){var n=t.width,e=t.height,a=t.getContext("2d"),i=a.getImageData(0,0,n,e);r.track(i.data,n,e)},bpVision.trackImg_=function(t,r){var n=t.width,e=t.height,a=document.createElement("canvas");a.width=n,a.height=e;var i=new bpVision.TrackerTask(r);return i.on("run",function(){bpVision.Canvas.loadImage(a,t.src,0,0,n,e,function(){bpVision.trackCanvasInternal_(a,r)})}),i.run()},bpVision.trackVideo_=function(r,n){var e,a,i=document.createElement("canvas"),o=i.getContext("2d"),c=function(){e=r.offsetWidth,a=r.offsetHeight,i.width=e,i.height=a};c(),r.addEventListener("resize",c);var s,g=function(){s=t.requestAnimationFrame(function(){if(r.readyState===r.HAVE_ENOUGH_DATA){try{o.drawImage(r,0,0,e,a)}catch(t){}bpVision.trackCanvasInternal_(i,n)}g()})},h=new bpVision.TrackerTask(n);return h.on("stop",function(){t.cancelAnimationFrame(s)}),h.on("run",function(){g()}),h.run()},t.URL||(t.URL=t.URL||t.webkitURL||t.msURL||t.oURL),navigator.getUserMedia||(navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia)}(window),function(){bpVision.EventEmitter=function(){},bpVision.EventEmitter.prototype.events_=null,bpVision.EventEmitter.prototype.addListener=function(t,r){if("function"!=typeof r)throw new TypeError("Listener must be a function");return this.events_||(this.events_={}),this.emit("newListener",t,r),this.events_[t]||(this.events_[t]=[]),this.events_[t].push(r),this},bpVision.EventEmitter.prototype.listeners=function(t){return this.events_&&this.events_[t]},bpVision.EventEmitter.prototype.emit=function(t){var r=this.listeners(t);if(r){for(var n=Array.prototype.slice.call(arguments,1),e=0;e<r.length;e++)r[e]&&r[e].apply(this,n);return!0}return!1},bpVision.EventEmitter.prototype.on=bpVision.EventEmitter.prototype.addListener,bpVision.EventEmitter.prototype.once=function(t,r){var n=this;n.on(t,function e(){n.removeListener(t,e),r.apply(this,arguments)})},bpVision.EventEmitter.prototype.removeAllListeners=function(t){return this.events_?(t?delete this.events_[t]:delete this.events_,this):this},bpVision.EventEmitter.prototype.removeListener=function(t,r){if("function"!=typeof r)throw new TypeError("Listener must be a function");if(!this.events_)return this;var n=this.listeners(t);if(Array.isArray(n)){var e=n.indexOf(r);if(e<0)return this;n.splice(e,1)}return this},bpVision.EventEmitter.prototype.setMaxListeners=function(){throw new Error("Not implemented")}}(),function(){bpVision.Canvas={},bpVision.Canvas.loadImage=function(t,r,n,e,a,i,o){var c=this,s=new window.Image;s.crossOrigin="*",s.onload=function(){var r=t.getContext("2d");t.width=a,t.height=i,r.drawImage(s,n,e,a,i),o&&o.call(c),s=null},s.src=r}}(),function(){bpVision.DisjointSet=function(t){if(void 0===t)throw new Error("DisjointSet length not specified.");this.length=t,this.parent=new Uint32Array(t);for(var r=0;r<t;r++)this.parent[r]=r},bpVision.DisjointSet.prototype.length=null,bpVision.DisjointSet.prototype.parent=null,bpVision.DisjointSet.prototype.find=function(t){return this.parent[t]===t?t:this.parent[t]=this.find(this.parent[t])},bpVision.DisjointSet.prototype.union=function(t,r){var n=this.find(t),e=this.find(r);this.parent[n]=e}}(),function(){bpVision.Image={},bpVision.Image.blur=function(t,r,n,e){if(e=Math.abs(e),e<=1)throw new Error("Diameter should be greater than 1.");for(var a=e/2,i=Math.ceil(e)+(1-Math.ceil(e)%2),o=new Float32Array(i),c=(a+.5)/3,s=c*c,g=1/Math.sqrt(2*Math.PI*s),h=-1/(2*c*c),k=0,f=Math.floor(i/2),u=0;u<i;u++){var l=u-f,m=g*Math.exp(l*l*h);o[u]=m,k+=m}for(var d=0;d<o.length;d++)o[d]/=k;return this.separableConvolve(t,r,n,o,o,!1)},bpVision.Image.computeIntegralImage=function(t,r,n,e,a,i,o){if(arguments.length<4)throw new Error("You should specify at least one output array in the order: sum, square, tilted, sobel.");var c;o&&(c=bpVision.Image.sobel(t,r,n));for(var s=0;s<n;s++)for(var g=0;g<r;g++){var h=s*r*4+4*g,k=~~(.299*t[h]+.587*t[h+1]+.114*t[h+2]);if(e&&this.computePixelValueSAT_(e,r,s,g,k),a&&this.computePixelValueSAT_(a,r,s,g,k*k),i){var f=h-4*r,u=~~(.299*t[f]+.587*t[f+1]+.114*t[f+2]);this.computePixelValueRSAT_(i,r,s,g,k,u||0)}o&&this.computePixelValueSAT_(o,r,s,g,c[h])}},bpVision.Image.computePixelValueRSAT_=function(t,r,n,e,a,i){var o=n*r+e;t[o]=(t[o-r-1]||0)+(t[o-r+1]||0)-(t[o-r-r]||0)+a+i},bpVision.Image.computePixelValueSAT_=function(t,r,n,e,a){var i=n*r+e;t[i]=(t[i-r]||0)+(t[i-1]||0)+a-(t[i-r-1]||0)},bpVision.Image.grayscale=function(t,r,n,e){for(var a=new Uint8ClampedArray(e?t.length:t.length>>2),i=0,o=0,c=0;c<n;c++)for(var s=0;s<r;s++){var g=.299*t[o]+.587*t[o+1]+.114*t[o+2];a[i++]=g,e&&(a[i++]=g,a[i++]=g,a[i++]=t[o+3]),o+=4}return a},bpVision.Image.horizontalConvolve=function(t,r,n,e,a){for(var i=e.length,o=Math.floor(i/2),c=new Float32Array(r*n*4),s=a?1:0,g=0;g<n;g++)for(var h=0;h<r;h++){for(var k=g,f=h,u=4*(g*r+h),l=0,m=0,d=0,v=0,p=0;p<i;p++){var y=k,w=Math.min(r-1,Math.max(0,f+p-o)),T=4*(y*r+w),x=e[p];l+=t[T]*x,m+=t[T+1]*x,d+=t[T+2]*x,v+=t[T+3]*x}c[u]=l,c[u+1]=m,c[u+2]=d,c[u+3]=v+s*(255-v)}return c},bpVision.Image.verticalConvolve=function(t,r,n,e,a){for(var i=e.length,o=Math.floor(i/2),c=new Float32Array(r*n*4),s=a?1:0,g=0;g<n;g++)for(var h=0;h<r;h++){for(var k=g,f=h,u=4*(g*r+h),l=0,m=0,d=0,v=0,p=0;p<i;p++){var y=Math.min(n-1,Math.max(0,k+p-o)),w=f,T=4*(y*r+w),x=e[p];l+=t[T]*x,m+=t[T+1]*x,d+=t[T+2]*x,v+=t[T+3]*x}c[u]=l,c[u+1]=m,c[u+2]=d,c[u+3]=v+s*(255-v)}return c},bpVision.Image.separableConvolve=function(t,r,n,e,a,i){var o=this.verticalConvolve(t,r,n,a,i);return this.horizontalConvolve(o,r,n,e,i)},bpVision.Image.sobel=function(t,r,n){t=this.grayscale(t,r,n,!0);for(var e=new Float32Array(r*n*4),a=new Float32Array([-1,0,1]),i=new Float32Array([1,2,1]),o=this.separableConvolve(t,r,n,a,i),c=this.separableConvolve(t,r,n,i,a),s=0;s<e.length;s+=4){var g=o[s],h=c[s],k=Math.sqrt(h*h+g*g);e[s]=k,e[s+1]=k,e[s+2]=k,e[s+3]=255}return e},bpVision.Image.equalizeHist=function(t,r,n){for(var e=new Uint8ClampedArray(t.length),a=new Array(256),i=0;i<256;i++)a[i]=0;for(var i=0;i<t.length;i++)e[i]=t[i],a[t[i]]++;for(var o=a[0],i=0;i<256;i++)a[i]+=o,o=a[i];for(var c=255/t.length,i=0;i<t.length;i++)e[i]=a[t[i]]*c+.5|0;return e}}(),function(){bpVision.ViolaJones={},bpVision.ViolaJones.REGIONS_OVERLAP=.5,bpVision.ViolaJones.classifiers={},bpVision.ViolaJones.detect=function(t,r,n,e,a,i,o,c){var s,g=0,h=[],k=new Int32Array(r*n),f=new Int32Array(r*n),u=new Int32Array(r*n);o>0&&(s=new Int32Array(r*n)),bpVision.Image.computeIntegralImage(t,r,n,k,f,u,s);for(var l=c[0],m=c[1],d=e*a,v=d*l|0,p=d*m|0;v<r&&p<n;){for(var y=d*i+.5|0,w=0;w<n-p;w+=y)for(var T=0;T<r-v;T+=y)o>0&&this.isTriviallyExcluded(o,s,w,T,r,v,p)||this.evalStages_(c,k,f,u,w,T,r,v,p,d)&&(h[g++]={width:v,height:p,x:T,y:w});d*=a,v=d*l|0,p=d*m|0}return this.mergeRectangles_(h)},bpVision.ViolaJones.isTriviallyExcluded=function(t,r,n,e,a,i,o){var c=n*a+e,s=c+i,g=c+o*a,h=g+i,k=(r[c]-r[s]-r[g]+r[h])/(i*o*255);return k<t},bpVision.ViolaJones.evalStages_=function(t,r,n,e,a,i,o,c,s,g){var h=1/(c*s),k=a*o+i,f=k+c,u=k+s*o,l=u+c,m=(r[k]-r[f]-r[u]+r[l])*h,d=(n[k]-n[f]-n[u]+n[l])*h-m*m,v=1;d>0&&(v=Math.sqrt(d));for(var p=t.length,y=2;y<p;){for(var w=0,T=t[y++],x=t[y++];x--;){for(var M=0,_=t[y++],C=t[y++],E=0;E<C;E++){var F,B,L,S,A=i+t[y++]*g+.5|0,I=a+t[y++]*g+.5|0,R=t[y++]*g+.5|0,b=t[y++]*g+.5|0,D=t[y++];_?(F=A-b+R+(I+R+b-1)*o,B=A+(I-1)*o,L=A-b+(I+b-1)*o,S=A+R+(I+R-1)*o,M+=(e[F]+e[B]-e[L]-e[S])*D):(F=I*o+A,B=F+R,L=F+b*o,S=L+R,M+=(r[F]-r[B]-r[L]+r[S])*D)}var O=t[y++],N=t[y++],j=t[y++];w+=M*h<O*v?N:j}if(w<T)return!1}return!0},bpVision.ViolaJones.mergeRectangles_=function(t){for(var r=new bpVision.DisjointSet(t.length),n=0;n<t.length;n++)for(var e=t[n],a=0;a<t.length;a++){var i=t[a];if(bpVision.Math.intersectRect(e.x,e.y,e.x+e.width,e.y+e.height,i.x,i.y,i.x+i.width,i.y+i.height)){var o=Math.max(e.x,i.x),c=Math.max(e.y,i.y),s=Math.min(e.x+e.width,i.x+i.width),g=Math.min(e.y+e.height,i.y+i.height),h=(o-s)*(c-g),k=e.width*e.height,f=i.width*i.height;h/(k*(k/f))>=this.REGIONS_OVERLAP&&h/(f*(k/f))>=this.REGIONS_OVERLAP&&r.union(n,a)}}for(var u={},l=0;l<r.length;l++){var m=r.find(l);u[m]?(u[m].total++,u[m].width+=t[l].width,u[m].height+=t[l].height,u[m].x+=t[l].x,u[m].y+=t[l].y):u[m]={total:1,width:t[l].width,height:t[l].height,x:t[l].x,y:t[l].y}}var d=[];return Object.keys(u).forEach(function(t){var r=u[t];d.push({total:r.total,width:r.width/r.total+.5|0,height:r.height/r.total+.5|0,x:r.x/r.total+.5|0,y:r.y/r.total+.5|0})}),d}}(),function(){bpVision.Brief={},bpVision.Brief.N=512,bpVision.Brief.randomImageOffsets_={},bpVision.Brief.randomWindowOffsets_=null,bpVision.Brief.getDescriptors=function(t,r,n){for(var e=new Int32Array((n.length>>1)*(this.N>>5)),a=0,i=this.getRandomOffsets_(r),o=0,c=0;c<n.length;c+=2)for(var s=r*n[c+1]+n[c],g=0,h=0,k=this.N;h<k;h++)t[i[g++]+s]<t[i[g++]+s]&&(a|=1<<(31&h)),h+1&31||(e[o++]=a,a=0);return e},bpVision.Brief.match=function(t,r,n,e){for(var a=t.length>>1,i=n.length>>1,o=new Array(a),c=0;c<a;c++){for(var s=1/0,g=0,h=0;h<i;h++){for(var k=0,f=0,u=this.N>>5;f<u;f++)k+=bpVision.Math.hammingWeight(r[c*u+f]^e[h*u+f]);k<s&&(s=k,g=h)}o[c]={index1:c,index2:g,keypoint1:[t[2*c],t[2*c+1]],keypoint2:[n[2*g],n[2*g+1]],confidence:1-s/this.N}}return o},bpVision.Brief.reciprocalMatch=function(t,r,n,e){var a=[];if(0===t.length||0===n.length)return a;for(var i=bpVision.Brief.match(t,r,n,e),o=bpVision.Brief.match(n,e,t,r),c=0;c<i.length;c++)o[i[c].index2].index2===c&&a.push(i[c]);return a},bpVision.Brief.getRandomOffsets_=function(t){if(!this.randomWindowOffsets_){for(var r=0,n=new Int32Array(4*this.N),e=0;e<this.N;e++)n[r++]=Math.round(bpVision.Math.uniformRandom(-15,16)),n[r++]=Math.round(bpVision.Math.uniformRandom(-15,16)),n[r++]=Math.round(bpVision.Math.uniformRandom(-15,16)),n[r++]=Math.round(bpVision.Math.uniformRandom(-15,16));this.randomWindowOffsets_=n}if(!this.randomImageOffsets_[t]){for(var a=0,i=new Int32Array(2*this.N),o=0;o<this.N;o++)i[a++]=this.randomWindowOffsets_[4*o]*t+this.randomWindowOffsets_[4*o+1],i[a++]=this.randomWindowOffsets_[4*o+2]*t+this.randomWindowOffsets_[4*o+3];this.randomImageOffsets_[t]=i}return this.randomImageOffsets_[t]}}(),function(){bpVision.Fast={},bpVision.Fast.THRESHOLD=40,bpVision.Fast.circles_={},bpVision.Fast.findCorners=function(t,r,n,e){var a=this.getCircleOffsets_(r),i=new Int32Array(16),o=[];void 0===e&&(e=this.THRESHOLD);for(var c=3;c<n-3;c++)for(var s=3;s<r-3;s++){for(var g=c*r+s,h=t[g],k=0;k<16;k++)i[k]=t[g+a[k]];this.isCorner(h,i,e)&&(o.push(s,c),s+=3)}return o},bpVision.Fast.isBrighter=function(t,r,n){return t-r>n},bpVision.Fast.isCorner=function(t,r,n){if(this.isTriviallyExcluded(r,t,n))return!1;for(var e=0;e<16;e++){for(var a=!0,i=!0,o=0;o<9;o++){var c=r[e+o&15];if(!this.isBrighter(t,c,n)&&(i=!1,a===!1))break;if(!this.isDarker(t,c,n)&&(a=!1,i===!1))break}if(i||a)return!0}return!1},bpVision.Fast.isDarker=function(t,r,n){return r-t>n},bpVision.Fast.isTriviallyExcluded=function(t,r,n){var e=0,a=t[8],i=t[12],o=t[4],c=t[0];return this.isBrighter(c,r,n)&&e++,this.isBrighter(o,r,n)&&e++,this.isBrighter(a,r,n)&&e++,this.isBrighter(i,r,n)&&e++,e<3&&(e=0,this.isDarker(c,r,n)&&e++,this.isDarker(o,r,n)&&e++,this.isDarker(a,r,n)&&e++,this.isDarker(i,r,n)&&e++,e<3)},bpVision.Fast.getCircleOffsets_=function(t){if(this.circles_[t])return this.circles_[t];var r=new Int32Array(16);return r[0]=-t-t-t,r[1]=r[0]+1,r[2]=r[1]+t+1,r[3]=r[2]+t+1,r[4]=r[3]+t,r[5]=r[4]+t,r[6]=r[5]+t-1,r[7]=r[6]+t-1,r[8]=r[7]-1,r[9]=r[8]-1,r[10]=r[9]-t-1,r[11]=r[10]-t-1,r[12]=r[11]-t,r[13]=r[12]-t,r[14]=r[13]-t+1,r[15]=r[14]-t+1,this.circles_[t]=r,r}}(),function(){bpVision.Math={},bpVision.Math.distance=function(t,r,n,e){var a=n-t,i=e-r;return Math.sqrt(a*a+i*i)},bpVision.Math.hammingWeight=function(t){return t-=t>>1&1431655765,t=(858993459&t)+(t>>2&858993459),16843009*(t+(t>>4)&252645135)>>24},bpVision.Math.uniformRandom=function(t,r){return t+Math.random()*(r-t)},bpVision.Math.intersectRect=function(t,r,n,e,a,i,o,c){return!(a>n||o<t||i>e||c<r)}}(),function(){bpVision.Matrix={},bpVision.Matrix.forEach=function(t,r,n,e,a){a=a||1;for(var i=0;i<n;i+=a)for(var o=0;o<r;o+=a){var c=i*r*4+4*o;e.call(this,t[c],t[c+1],t[c+2],t[c+3],c,i,o)}},bpVision.Matrix.sub=function(t,r){for(var n=bpVision.Matrix.clone(t),e=0;e<n.length;e++)for(var a=0;a<n[e].length;a++)n[e][a]-=r[e][a];return n},bpVision.Matrix.add=function(t,r){for(var n=bpVision.Matrix.clone(t),e=0;e<n.length;e++)for(var a=0;a<n[e].length;a++)n[e][a]+=r[e][a];return n},bpVision.Matrix.clone=function(t,r,n){r=r||t[0].length,n=n||t.length;for(var e=new Array(n),a=n;a--;){e[a]=new Array(r);for(var i=r;i--;)e[a][i]=t[a][i]}return e},bpVision.Matrix.mulScalar=function(t,r){for(var n=bpVision.Matrix.clone(r),e=0;e<r.length;e++)for(var a=0;a<r[e].length;a++)n[e][a]*=t;return n},bpVision.Matrix.transpose=function(t){for(var r=new Array(t[0].length),n=0;n<t[0].length;n++){r[n]=new Array(t.length);for(var e=0;e<t.length;e++)r[n][e]=t[e][n]}return r},bpVision.Matrix.mul=function(t,r){for(var n=new Array(t.length),e=0;e<t.length;e++){n[e]=new Array(r[0].length);for(var a=0;a<r[0].length;a++){n[e][a]=0;for(var i=0;i<t[0].length;i++)n[e][a]+=t[e][i]*r[i][a]}}return n},bpVision.Matrix.norm=function(t){for(var r=0,n=0;n<t.length;n++)for(var e=0;e<t[n].length;e++)r+=t[n][e]*t[n][e];return Math.sqrt(r)},bpVision.Matrix.calcCovarMatrix=function(t){for(var r=new Array(t.length),n=0;n<t.length;n++){r[n]=[0];for(var e=0;e<t[n].length;e++)r[n][0]+=t[n][e]/t[n].length}for(var a=bpVision.Matrix.clone(r),n=0;n<a.length;n++)for(var e=0;e<t[0].length-1;e++)a[n].push(a[n][0]);var i=bpVision.Matrix.sub(t,a),o=bpVision.Matrix.transpose(i),c=bpVision.Matrix.mul(o,i);return[c,r]}}(),function(){bpVision.EPnP={},bpVision.EPnP.solve=function(t,r,n){}}(),function(){bpVision.Tracker=function(){bpVision.Tracker.base(this,"constructor")},bpVision.inherits(bpVision.Tracker,bpVision.EventEmitter),bpVision.Tracker.prototype.track=function(){}}(),function(){bpVision.TrackerTask=function(t){if(bpVision.TrackerTask.base(this,"constructor"),!t)throw new Error("Tracker instance not specified.");this.setTracker(t)},bpVision.inherits(bpVision.TrackerTask,bpVision.EventEmitter),bpVision.TrackerTask.prototype.tracker_=null,bpVision.TrackerTask.prototype.running_=!1,bpVision.TrackerTask.prototype.getTracker=function(){return this.tracker_},bpVision.TrackerTask.prototype.inRunning=function(){return this.running_},bpVision.TrackerTask.prototype.setRunning=function(t){this.running_=t},bpVision.TrackerTask.prototype.setTracker=function(t){this.tracker_=t},bpVision.TrackerTask.prototype.run=function(){var t=this;if(!this.inRunning())return this.setRunning(!0),this.reemitTrackEvent_=function(r){t.emit("track",r)},this.tracker_.on("track",this.reemitTrackEvent_),this.emit("run"),this},bpVision.TrackerTask.prototype.stop=function(){if(this.inRunning())return this.setRunning(!1),this.emit("stop"),this.tracker_.removeListener("track",this.reemitTrackEvent_),this}}(),function(){bpVision.ColorTracker=function(t){bpVision.ColorTracker.base(this,"constructor"),"string"==typeof t&&(t=[t]),t&&(t.forEach(function(t){if(!bpVision.ColorTracker.getColor(t))throw new Error('Color not valid, try `new bpVision.ColorTracker("magenta")`.')}),this.setColors(t))},bpVision.inherits(bpVision.ColorTracker,bpVision.Tracker),bpVision.ColorTracker.knownColors_={},bpVision.ColorTracker.neighbours_={},bpVision.ColorTracker.registerColor=function(t,r){bpVision.ColorTracker.knownColors_[t]=r},bpVision.ColorTracker.getColor=function(t){return bpVision.ColorTracker.knownColors_[t]},bpVision.ColorTracker.prototype.colors=["magenta"],bpVision.ColorTracker.prototype.minDimension=20,bpVision.ColorTracker.prototype.maxDimension=1/0,bpVision.ColorTracker.prototype.minGroupSize=30,bpVision.ColorTracker.prototype.calculateDimensions_=function(t,r){for(var n=-1,e=-1,a=1/0,i=1/0,o=0;o<r;o+=2){var c=t[o],s=t[o+1];c<a&&(a=c),c>n&&(n=c),s<i&&(i=s),s>e&&(e=s)}return{width:n-a,height:e-i,x:a,y:i}},bpVision.ColorTracker.prototype.getColors=function(){return this.colors},bpVision.ColorTracker.prototype.getMinDimension=function(){return this.minDimension},bpVision.ColorTracker.prototype.getMaxDimension=function(){return this.maxDimension},bpVision.ColorTracker.prototype.getMinGroupSize=function(){return this.minGroupSize},bpVision.ColorTracker.prototype.getNeighboursForWidth_=function(t){if(bpVision.ColorTracker.neighbours_[t])return bpVision.ColorTracker.neighbours_[t];var r=new Int32Array(8);return r[0]=4*-t,r[1]=4*-t+4,r[2]=4,r[3]=4*t+4,r[4]=4*t,r[5]=4*t-4,r[6]=-4,r[7]=4*-t-4,bpVision.ColorTracker.neighbours_[t]=r,r},bpVision.ColorTracker.prototype.mergeRectangles_=function(t){for(var r,n=[],e=this.getMinDimension(),a=this.getMaxDimension(),i=0;i<t.length;i++){var o=t[i];r=!0;for(var c=i+1;c<t.length;c++){var s=t[c];if(bpVision.Math.intersectRect(o.x,o.y,o.x+o.width,o.y+o.height,s.x,s.y,s.x+s.width,s.y+s.height)){r=!1;var g=Math.min(o.x,s.x),h=Math.min(o.y,s.y),k=Math.max(o.x+o.width,s.x+s.width),f=Math.max(o.y+o.height,s.y+s.height);s.height=f-h,s.width=k-g,s.x=g,s.y=h;break}}r&&o.width>=e&&o.height>=e&&o.width<=a&&o.height<=a&&n.push(o)}return n},bpVision.ColorTracker.prototype.setColors=function(t){this.colors=t},bpVision.ColorTracker.prototype.setMinDimension=function(t){this.minDimension=t},bpVision.ColorTracker.prototype.setMaxDimension=function(t){this.maxDimension=t},bpVision.ColorTracker.prototype.setMinGroupSize=function(t){this.minGroupSize=t},bpVision.ColorTracker.prototype.track=function(t,r,n){var e=this,a=this.getColors();if(!a)throw new Error('Colors not specified, try `new bpVision.ColorTracker("magenta")`.');var i=[];a.forEach(function(a){i=i.concat(e.trackColor_(t,r,n,a))}),this.emit("track",{data:i})},bpVision.ColorTracker.prototype.trackColor_=function(n,e,a,i){var o,c,s,g,h,k=bpVision.ColorTracker.knownColors_[i],f=new Int32Array(n.length>>2),u=new Int8Array(n.length),l=this.getMinGroupSize(),m=this.getNeighboursForWidth_(e),d=new Int32Array(n.length),v=[],p=-4;if(!k)return v;for(var y=0;y<a;y++)for(var w=0;w<e;w++)if(p+=4,!u[p]){for(o=0,h=-1,d[++h]=p,d[++h]=y,d[++h]=w,u[p]=1;h>=0;)if(s=d[h--],c=d[h--],g=d[h--],k(n[g],n[g+1],n[g+2],n[g+3],g,c,s)){f[o++]=s,f[o++]=c;for(var T=0;T<m.length;T++){var x=g+m[T],M=c+t[T],_=s+r[T];!u[x]&&M>=0&&M<a&&_>=0&&_<e&&(d[++h]=x,d[++h]=M,d[++h]=_,u[x]=1)}}if(o>=l){var C=this.calculateDimensions_(f,o);C&&(C.color=i,v.push(C))}}return this.mergeRectangles_(v)},bpVision.ColorTracker.registerColor("cyan",function(t,r,n){var e=50,a=70,i=t-0,o=r-255,c=n-255;return r-t>=e&&n-t>=a||i*i+o*o+c*c<6400}),bpVision.ColorTracker.registerColor("magenta",function(t,r,n){var e=50,a=t-255,i=r-0,o=n-255;return t-r>=e&&n-r>=e||a*a+i*i+o*o<19600}),bpVision.ColorTracker.registerColor("yellow",function(t,r,n){var e=50,a=t-255,i=r-255,o=n-0;return t-n>=e&&r-n>=e||a*a+i*i+o*o<1e4});var t=new Int32Array([-1,-1,0,1,1,1,0,-1]),r=new Int32Array([0,1,1,1,0,-1,-1,-1])}(),function(){bpVision.ObjectTracker=function(t){bpVision.ObjectTracker.base(this,"constructor"),t&&(Array.isArray(t)||(t=[t]),Array.isArray(t)&&t.forEach(function(r,n){if("string"==typeof r&&(t[n]=bpVision.ViolaJones.classifiers[r]),!t[n])throw new Error('Object classifier not valid, try `new bpVision.ObjectTracker("face")`.')})),this.setClassifiers(t)},bpVision.inherits(bpVision.ObjectTracker,bpVision.Tracker),bpVision.ObjectTracker.prototype.edgesDensity=.2,bpVision.ObjectTracker.prototype.initialScale=1,bpVision.ObjectTracker.prototype.scaleFactor=1.25,bpVision.ObjectTracker.prototype.stepSize=1.5,bpVision.ObjectTracker.prototype.getClassifiers=function(){return this.classifiers},bpVision.ObjectTracker.prototype.getEdgesDensity=function(){return this.edgesDensity},bpVision.ObjectTracker.prototype.getInitialScale=function(){return this.initialScale},bpVision.ObjectTracker.prototype.getScaleFactor=function(){return this.scaleFactor},bpVision.ObjectTracker.prototype.getStepSize=function(){return this.stepSize},bpVision.ObjectTracker.prototype.track=function(t,r,n){var e=this,a=this.getClassifiers();if(!a)throw new Error('Object classifier not specified, try `new bpVision.ObjectTracker("face")`.');var i=[];a.forEach(function(a){i=i.concat(bpVision.ViolaJones.detect(t,r,n,e.getInitialScale(),e.getScaleFactor(),e.getStepSize(),e.getEdgesDensity(),a))}),this.emit("track",{data:i})},bpVision.ObjectTracker.prototype.setClassifiers=function(t){this.classifiers=t},bpVision.ObjectTracker.prototype.setEdgesDensity=function(t){this.edgesDensity=t},bpVision.ObjectTracker.prototype.setInitialScale=function(t){this.initialScale=t},bpVision.ObjectTracker.prototype.setScaleFactor=function(t){this.scaleFactor=t},bpVision.ObjectTracker.prototype.setStepSize=function(t){this.stepSize=t}}(),function(){bpVision.LandmarksTracker=function(){bpVision.LandmarksTracker.base(this,"constructor")},bpVision.inherits(bpVision.LandmarksTracker,bpVision.ObjectTracker),bpVision.LandmarksTracker.prototype.track=function(t,r,n){var e=bpVision.ViolaJones.classifiers.face,a=bpVision.ViolaJones.detect(t,r,n,this.getInitialScale(),this.getScaleFactor(),this.getStepSize(),this.getEdgesDensity(),e),i=bpVision.LBF.align(t,r,n,a);this.emit("track",{data:{faces:a,landmarks:i}})}}(),function(){bpVision.LBF={},bpVision.LBF.Regressor=function(t){this.maxNumStages=t,this.rfs=new Array(t),this.models=new Array(t);for(var r=0;r<t;r++)this.rfs[r]=new bpVision.LBF.RandomForest(r),this.models[r]=bpVision.LBF.RegressorData[r].models;this.meanShape=bpVision.LBF.LandmarksData},bpVision.LBF.Regressor.prototype.predict=function(t,r,n,e){var a=[],i=[],o=[],c=bpVision.Matrix.clone(this.meanShape);a.push({data:t,width:r,height:n}),o.push(e),i.push(bpVision.LBF.projectShapeToBoundingBox_(c,e));for(var s=0;s<this.maxNumStages;s++){var g=bpVision.LBF.Regressor.deriveBinaryFeat(this.rfs[s],a,i,o,c);this.applyGlobalPrediction(g,this.models[s],i,o)}return i[0]},bpVision.LBF.Regressor.prototype.applyGlobalPrediction=function(t,r,n,e){for(var a=2*n[0].length,i=new Array(a/2),o=0;o<a/2;o++)i[o]=[0,0];for(var o=0;o<n.length;o++){for(var c=0;c<a;c++){for(var s=0,g=0,h=0;(h=t[o][g].index)!=-1;g++)h<=r[c].nr_feature&&(s+=r[c].data[h-1]*t[o][g].value);c<a/2?i[c][0]=s:i[c-a/2][1]=s}var k=bpVision.LBF.similarityTransform_(bpVision.LBF.unprojectShapeToBoundingBox_(n[o],e[o]),this.meanShape),f=(bpVision.Matrix.transpose(k[0]),bpVision.LBF.unprojectShapeToBoundingBox_(n[o],e[o]));f=bpVision.Matrix.add(f,i),n[o]=bpVision.LBF.projectShapeToBoundingBox_(f,e[o])}},bpVision.LBF.Regressor.deriveBinaryFeat=function(t,r,n,e,a){for(var i=new Array(r.length),o=0;o<r.length;o++){var c=t.maxNumTrees*t.landmarkNum+1;i[o]=new Array(c);for(var s=0;s<c;s++)i[o][s]={}}for(var g=1<<t.maxDepth-1,o=0;o<r.length;o++){for(var h=bpVision.LBF.unprojectShapeToBoundingBox_(n[o],e[o]),k=bpVision.LBF.similarityTransform_(h,a),s=0;s<t.landmarkNum;s++)for(var f=0;f<t.maxNumTrees;f++){var u=bpVision.LBF.Regressor.getCodeFromTree(t.rfs[s][f],r[o],n[o],e[o],k[0],k[1]),l=s*t.maxNumTrees+f;i[o][l].index=g*l+u,i[o][l].value=1}i[o][t.landmarkNum*t.maxNumTrees].index=-1,i[o][t.landmarkNum*t.maxNumTrees].value=-1}return i},bpVision.LBF.Regressor.getCodeFromTree=function(t,r,n,e,a,i){for(var o=0,c=0;;){var s=Math.cos(t.nodes[o].feats[0])*t.nodes[o].feats[2]*t.maxRadioRadius*e.width,g=Math.sin(t.nodes[o].feats[0])*t.nodes[o].feats[2]*t.maxRadioRadius*e.height,h=Math.cos(t.nodes[o].feats[1])*t.nodes[o].feats[3]*t.maxRadioRadius*e.width,k=Math.sin(t.nodes[o].feats[1])*t.nodes[o].feats[3]*t.maxRadioRadius*e.height,f=a[0][0]*s+a[0][1]*g,u=a[1][0]*s+a[1][1]*g,l=Math.floor(f+n[t.landmarkID][0]),m=Math.floor(u+n[t.landmarkID][1]);l=Math.max(0,Math.min(l,r.height-1)),m=Math.max(0,Math.min(m,r.width-1));var d=a[0][0]*h+a[0][1]*k,v=a[1][0]*h+a[1][1]*k,p=Math.floor(d+n[t.landmarkID][0]),y=Math.floor(v+n[t.landmarkID][1]);p=Math.max(0,Math.min(p,r.height-1)),y=Math.max(0,Math.min(y,r.width-1));var w=Math.floor(r.data[m*r.width+l])-Math.floor(r.data[y*r.width+p]);if(o=w<t.nodes[o].thresh?t.nodes[o].cnodes[0]:t.nodes[o].cnodes[1],1==t.nodes[o].is_leafnode){c=1;for(var T=0;T<t.leafnodes.length;T++){if(t.leafnodes[T]==o)return c;c++}return c}}return c}}(),function(){bpVision.LBF.maxNumStages=4,bpVision.LBF.regressor_=null,bpVision.LBF.align=function(t,r,n,e){null==bpVision.LBF.regressor_&&(bpVision.LBF.regressor_=new bpVision.LBF.Regressor(bpVision.LBF.maxNumStages)),t=bpVision.Image.grayscale(t,r,n,!1),t=bpVision.Image.equalizeHist(t,r,n);var a=new Array(e.length);for(var i in e){e[i].height=e[i].width;var o={};o.startX=e[i].x,o.startY=e[i].y,o.width=e[i].width,o.height=e[i].height,a[i]=bpVision.LBF.regressor_.predict(t,r,n,o)}return a},bpVision.LBF.unprojectShapeToBoundingBox_=function(t,r){for(var n=new Array(t.length),e=0;e<t.length;e++)n[e]=[(t[e][0]-r.startX)/r.width,(t[e][1]-r.startY)/r.height];return n},bpVision.LBF.projectShapeToBoundingBox_=function(t,r){for(var n=new Array(t.length),e=0;e<t.length;e++)n[e]=[t[e][0]*r.width+r.startX,t[e][1]*r.height+r.startY];return n},bpVision.LBF.similarityTransform_=function(t,r){for(var n=[0,0],e=[0,0],a=0;a<t.length;a++)n[0]+=t[a][0],n[1]+=t[a][1],e[0]+=r[a][0],e[1]+=r[a][1];n[0]/=t.length,n[1]/=t.length,e[0]/=r.length,e[1]/=r.length;for(var i=bpVision.Matrix.clone(t),o=bpVision.Matrix.clone(r),a=0;a<t.length;a++)i[a][0]-=n[0],i[a][1]-=n[1],o[a][0]-=e[0],o[a][1]-=e[1];var c,s,g,h,k=bpVision.Matrix.calcCovarMatrix(i);c=k[0],g=k[1],k=bpVision.Matrix.calcCovarMatrix(o),s=k[0],h=k[1];var f=Math.sqrt(bpVision.Matrix.norm(c)),u=Math.sqrt(bpVision.Matrix.norm(s)),l=f/u;i=bpVision.Matrix.mulScalar(1/f,i),o=bpVision.Matrix.mulScalar(1/u,o);for(var m=0,d=0,a=0;a<t.length;a++)m=m+i[a][1]*o[a][0]-i[a][0]*o[a][1],d=d+i[a][0]*o[a][0]+i[a][1]*o[a][1];var v=Math.sqrt(m*m+d*d),p=m/v,y=d/v,w=[[y,-p],[p,y]];return[w,l]},bpVision.LBF.RandomForest=function(t){this.maxNumTrees=bpVision.LBF.RegressorData[t].max_numtrees,this.landmarkNum=bpVision.LBF.RegressorData[t].num_landmark,this.maxDepth=bpVision.LBF.RegressorData[t].max_depth,this.stages=bpVision.LBF.RegressorData[t].stages,this.rfs=new Array(this.landmarkNum);for(var r=0;r<this.landmarkNum;r++){this.rfs[r]=new Array(this.maxNumTrees);for(var n=0;n<this.maxNumTrees;n++)this.rfs[r][n]=new bpVision.LBF.Tree(t,r,n)}},bpVision.LBF.Tree=function(t,r,n){var e=bpVision.LBF.RegressorData[t].landmarks[r][n];this.maxDepth=e.max_depth,this.maxNumNodes=e.max_numnodes,this.nodes=e.nodes,this.landmarkID=e.landmark_id,this.numLeafnodes=e.num_leafnodes,this.numNodes=e.num_nodes,this.maxNumFeats=e.max_numfeats,this.maxRadioRadius=e.max_radio_radius,this.leafnodes=e.id_leafnodes}}();

/*!
 * pace.js v1.2.4
 * https://github.com/CodeByZach/pace/
 * Licensed MIT  HubSpot, Inc.
 */
!function(){function o(t,e){return function(){return t.apply(e,arguments)}}var u,c,i,s,n,y,t,l,v,r,a,p,e,h,w,b,f,g,d,m,k,S,q,L,x,P,T,R,j,O,E,M,A,C,N,_,F,U,W,X,D,H,I,z,G,B,J=[].slice,K={}.hasOwnProperty,Q=function(t,e){for(var n in e)K.call(e,n)&&(t[n]=e[n]);function r(){this.constructor=t}return r.prototype=e.prototype,t.prototype=new r,t.__super__=e.prototype,t},V=[].indexOf||function(t){for(var e=0,n=this.length;e<n;e++)if(e in this&&this[e]===t)return e;return-1};function Y(){}for(g={className:"",catchupTime:100,initialRate:.03,minTime:250,ghostTime:100,maxProgressPerFrame:20,easeFactor:1.25,startOnPageLoad:!0,restartOnPushState:!0,restartOnRequestAfter:500,target:"body",elements:{checkInterval:100,selectors:["body"]},eventLag:{minSamples:10,sampleCount:3,lagThreshold:3},ajax:{trackMethods:["GET"],trackWebSockets:!0,ignoreURLs:[]}},P=function(){var t;return null!=(t="undefined"!=typeof performance&&null!==performance&&"function"==typeof performance.now?performance.now():void 0)?t:+new Date},R=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||window.msRequestAnimationFrame,f=window.cancelAnimationFrame||window.mozCancelAnimationFrame,p=function(t,e,n){if("function"==typeof t.addEventListener)return t.addEventListener(e,n,!1);var r;"function"!=typeof t["on"+e]||"object"!=typeof t["on"+e].eventListeners?(r=new s,"function"==typeof t["on"+e]&&r.on(e,t["on"+e]),t["on"+e]=function(t){return r.trigger(e,t)},t["on"+e].eventListeners=r):r=t["on"+e].eventListeners,r.on(e,n)},null==R&&(R=function(t){return setTimeout(t,50)},f=function(t){return clearTimeout(t)}),O=function(e){var n=P(),r=function(){var t=P()-n;return 33<=t?(n=P(),e(t,function(){return R(r)})):setTimeout(r,33-t)};return r()},j=function(){var t=arguments[0],e=arguments[1],n=3<=arguments.length?J.call(arguments,2):[];return"function"==typeof t[e]?t[e].apply(t,n):t[e]},d=function(){for(var t,e,n,r=arguments[0],s=2<=arguments.length?J.call(arguments,1):[],o=0,i=s.length;o<i;o++)if(e=s[o])for(t in e)K.call(e,t)&&(n=e[t],null!=r[t]&&"object"==typeof r[t]&&null!=n&&"object"==typeof n?d(r[t],n):r[t]=n);return r},h=function(t){for(var e,n,r=e=0,s=0,o=t.length;s<o;s++)n=t[s],r+=Math.abs(n),e++;return r/e},k=function(t,e){var n,r;if(null==t&&(t="options"),null==e&&(e=!0),r=document.querySelector("[data-pace-"+t+"]")){if(n=r.getAttribute("data-pace-"+t),!e)return n;try{return JSON.parse(n)}catch(t){return"undefined"!=typeof console&&null!==console?console.error("Error parsing inline pace options",t):void 0}}},Y.prototype.on=function(t,e,n,r){var s;return null==r&&(r=!1),null==this.bindings&&(this.bindings={}),null==(s=this.bindings)[t]&&(s[t]=[]),this.bindings[t].push({handler:e,ctx:n,once:r})},Y.prototype.once=function(t,e,n){return this.on(t,e,n,!0)},Y.prototype.off=function(t,e){var n,r,s;if(null!=(null!=(r=this.bindings)?r[t]:void 0)){if(null==e)return delete this.bindings[t];for(n=0,s=[];n<this.bindings[t].length;)this.bindings[t][n].handler===e?s.push(this.bindings[t].splice(n,1)):s.push(n++);return s}},Y.prototype.trigger=function(){var t,e,n,r,s,o,i=arguments[0],a=2<=arguments.length?J.call(arguments,1):[];if(null!=(r=this.bindings)&&r[i]){for(n=0,o=[];n<this.bindings[i].length;)e=(s=this.bindings[i][n]).handler,t=s.ctx,s=s.once,e.apply(null!=t?t:this,a),s?o.push(this.bindings[i].splice(n,1)):o.push(n++);return o}},B=Y,y=window.Pace||{},window.Pace=y,d(y,B.prototype),T=y.options=d({},g,window.paceOptions,k()),X=0,H=(z=["ajax","document","eventLag","elements"]).length;X<H;X++)!0===T[C=z[X]]&&(T[C]=g[C]);function Z(){return Z.__super__.constructor.apply(this,arguments)}function $(){this.progress=0}function tt(){this.bindings={}}function et(){var e,o=this;et.__super__.constructor.apply(this,arguments),e=function(r){var s=r.open;return r.open=function(t,e,n){return A(t)&&o.trigger("request",{type:t,url:e,request:r}),s.apply(r,arguments)}},window.XMLHttpRequest=function(t){t=new W(t);return e(t),t};try{m(window.XMLHttpRequest,W)}catch(t){}if(null!=U){window.XDomainRequest=function(){var t=new U;return e(t),t};try{m(window.XDomainRequest,U)}catch(t){}}if(null!=F&&T.ajax.trackWebSockets){window.WebSocket=function(t,e){var n=null!=e?new F(t,e):new F(t);return A("socket")&&o.trigger("request",{type:"socket",url:t,protocols:e,request:n}),n};try{m(window.WebSocket,F)}catch(t){}}}function nt(){this.complete=o(this.complete,this);var t=this;this.elements=[],S().on("request",function(){return t.watch.apply(t,arguments)})}function rt(t){var e,n,r,s;for(null==t&&(t={}),this.complete=o(this.complete,this),this.elements=[],null==t.selectors&&(t.selectors=[]),n=0,r=(s=t.selectors).length;n<r;n++)e=s[n],this.elements.push(new i(e,this.complete))}function st(t,e){this.selector=t,this.completeCallback=e,this.progress=0,this.check()}function ot(){var t,e,n=this;this.progress=null!=(e=this.states[document.readyState])?e:100,t=document.onreadystatechange,document.onreadystatechange=function(){return null!=n.states[document.readyState]&&(n.progress=n.states[document.readyState]),"function"==typeof t?t.apply(null,arguments):void 0}}function it(t){this.source=t,this.last=this.sinceLastUpdate=0,this.rate=T.initialRate,this.catchup=0,this.progress=this.lastProgress=0,null!=this.source&&(this.progress=j(this.source,"progress"))}B=Error,Q(Z,B),n=Z,$.prototype.getElement=function(){var t;if(null==this.el){if(!(t=document.querySelector(T.target)))throw new n;this.el=document.createElement("div"),this.el.className="pace pace-active",document.body.className=document.body.className.replace(/(pace-done )|/,"pace-running ");var e=""!==T.className?" "+T.className:"";this.el.innerHTML='<div class="pace-progress'+e+'">\n  <div class="pace-progress-inner"></div>\n</div>\n<div class="pace-activity"></div>',null!=t.firstChild?t.insertBefore(this.el,t.firstChild):t.appendChild(this.el)}return this.el},$.prototype.finish=function(){var t=this.getElement();return t.className=t.className.replace("pace-active","pace-inactive"),document.body.className=document.body.className.replace("pace-running ","pace-done ")},$.prototype.update=function(t){return this.progress=t,y.trigger("progress",t),this.render()},$.prototype.destroy=function(){try{this.getElement().parentNode.removeChild(this.getElement())}catch(t){n=t}return this.el=void 0},$.prototype.render=function(){var t,e,n,r,s,o,i;if(null==document.querySelector(T.target))return!1;for(t=this.getElement(),r="translate3d("+this.progress+"%, 0, 0)",s=0,o=(i=["webkitTransform","msTransform","transform"]).length;s<o;s++)e=i[s],t.children[0].style[e]=r;return(!this.lastRenderedProgress||this.lastRenderedProgress|0!==this.progress|0)&&(t.children[0].setAttribute("data-progress-text",(0|this.progress)+"%"),100<=this.progress?n="99":(n=this.progress<10?"0":"",n+=0|this.progress),t.children[0].setAttribute("data-progress",""+n)),y.trigger("change",this.progress),this.lastRenderedProgress=this.progress},$.prototype.done=function(){return 100<=this.progress},c=$,tt.prototype.trigger=function(t,e){var n,r,s,o,i;if(null!=this.bindings[t]){for(i=[],r=0,s=(o=this.bindings[t]).length;r<s;r++)n=o[r],i.push(n.call(this,e));return i}},tt.prototype.on=function(t,e){var n;return null==(n=this.bindings)[t]&&(n[t]=[]),this.bindings[t].push(e)},s=tt,W=window.XMLHttpRequest,U=window.XDomainRequest,F=window.WebSocket,m=function(t,e){var n,r=[];for(n in e.prototype)try{null==t[n]&&"function"!=typeof e[n]?"function"==typeof Object.defineProperty?r.push(Object.defineProperty(t,n,{get:function(t){return function(){return e.prototype[t]}}(n),configurable:!0,enumerable:!0})):r.push(t[n]=e.prototype[n]):r.push(void 0)}catch(t){0}return r},L=[],y.ignore=function(){var t=arguments[0],e=2<=arguments.length?J.call(arguments,1):[];return L.unshift("ignore"),e=t.apply(null,e),L.shift(),e},y.track=function(){var t=arguments[0],e=2<=arguments.length?J.call(arguments,1):[];return L.unshift("track"),e=t.apply(null,e),L.shift(),e},A=function(t){if(null==t&&(t="GET"),"track"===L[0])return"force";if(!L.length&&T.ajax){if("socket"===t&&T.ajax.trackWebSockets)return!0;if(t=t.toUpperCase(),0<=V.call(T.ajax.trackMethods,t))return!0}return!1},Q(et,s),t=et,D=null,M=function(t){for(var e,n=T.ajax.ignoreURLs,r=0,s=n.length;r<s;r++)if("string"==typeof(e=n[r])){if(-1!==t.indexOf(e))return!0}else if(e.test(t))return!0;return!1},(S=function(){return D=null==D?new t:D})().on("request",function(t){var o,i=t.type,a=t.request,e=t.url;if(!M(e))return y.running||!1===T.restartOnRequestAfter&&"force"!==A(i)?void 0:(o=arguments,"boolean"==typeof(e=T.restartOnRequestAfter||0)&&(e=0),setTimeout(function(){var t,e,n,r,s="socket"===i?a.readyState<1:0<(s=a.readyState)&&s<4;if(s){for(y.restart(),r=[],t=0,e=(n=y.sources).length;t<e;t++){if((C=n[t])instanceof u){C.watch.apply(C,o);break}r.push(void 0)}return r}},e))}),nt.prototype.watch=function(t){var e=t.type,n=t.request,t=t.url;if(!M(t))return n=new("socket"===e?r:a)(n,this.complete),this.elements.push(n)},nt.prototype.complete=function(e){return this.elements=this.elements.filter(function(t){return t!==e})},u=nt,a=function(e,n){var t,r,s,o,i=this;if(this.progress=0,null!=window.ProgressEvent)for(p(e,"progress",function(t){return t.lengthComputable?i.progress=100*t.loaded/t.total:i.progress=i.progress+(100-i.progress)/2}),t=0,r=(o=["load","abort","timeout","error"]).length;t<r;t++)p(e,o[t],function(){return n(i),i.progress=100});else s=e.onreadystatechange,e.onreadystatechange=function(){var t;return 0===(t=e.readyState)||4===t?(n(i),i.progress=100):3===e.readyState&&(i.progress=50),"function"==typeof s?s.apply(null,arguments):void 0}},r=function(t,e){for(var n,r=this,s=this.progress=0,o=(n=["error","open"]).length;s<o;s++)p(t,n[s],function(){return e(r),r.progress=100})},rt.prototype.complete=function(e){return this.elements=this.elements.filter(function(t){return t!==e})},k=rt,st.prototype.check=function(){var t=this;return document.querySelector(this.selector)?this.done():setTimeout(function(){return t.check()},T.elements.checkInterval)},st.prototype.done=function(){return this.completeCallback(this),this.completeCallback=null,this.progress=100},i=st,ot.prototype.states={loading:0,interactive:50,complete:100},B=ot,Q=function(){var e,n,r,s,o,i=this;this.progress=0,o=[],s=0,r=P(),n=setInterval(function(){var t=P()-r-50;return r=P(),o.push(t),o.length>T.eventLag.sampleCount&&o.shift(),e=h(o),++s>=T.eventLag.minSamples&&e<T.eventLag.lagThreshold?(i.progress=100,clearInterval(n)):i.progress=3/(e+3)*100},50)},it.prototype.tick=function(t,e){return 100<=(e=null==e?j(this.source,"progress"):e)&&(this.done=!0),e===this.last?this.sinceLastUpdate+=t:(this.sinceLastUpdate&&(this.rate=(e-this.last)/this.sinceLastUpdate),this.catchup=(e-this.progress)/T.catchupTime,this.sinceLastUpdate=0,this.last=e),e>this.progress&&(this.progress+=this.catchup*t),e=1-Math.pow(this.progress/100,T.easeFactor),this.progress+=e*this.rate*t,this.progress=Math.min(this.lastProgress+T.maxProgressPerFrame,this.progress),this.progress=Math.max(0,this.progress),this.progress=Math.min(100,this.progress),this.lastProgress=this.progress,this.progress},v=it,b=e=_=w=E=N=null,y.running=!1,q=function(){if(T.restartOnPushState)return y.restart()},null!=window.history.pushState&&(I=window.history.pushState,window.history.pushState=function(){return q(),I.apply(window.history,arguments)}),null!=window.history.replaceState&&(G=window.history.replaceState,window.history.replaceState=function(){return q(),G.apply(window.history,arguments)}),l={ajax:u,elements:k,document:B,eventLag:Q},(x=function(){var t,e,n,r,s,o,i,a;for(y.sources=N=[],e=0,r=(o=["ajax","elements","document","eventLag"]).length;e<r;e++)!1!==T[t=o[e]]&&N.push(new l[t](T[t]));for(n=0,s=(a=null!=(i=T.extraSources)?i:[]).length;n<s;n++)C=a[n],N.push(new C(T));return y.bar=w=new c,E=[],_=new v})(),y.stop=function(){return y.trigger("stop"),y.running=!1,w.destroy(),b=!0,null!=e&&("function"==typeof f&&f(e),e=null),x()},y.restart=function(){return y.trigger("restart"),y.stop(),y.start()},y.go=function(){var m;return y.running=!0,w.render(),m=P(),b=!1,e=O(function(t,e){w.progress;for(var n,r,s,o,i,a,u,c,l,p,h=a=0,f=!0,g=u=0,d=N.length;u<d;g=++u)for(C=N[g],i=null!=E[g]?E[g]:E[g]=[],s=c=0,l=(r=null!=(p=C.elements)?p:[C]).length;c<l;s=++c)o=r[s],f&=(o=null!=i[s]?i[s]:i[s]=new v(o)).done,o.done||(h++,a+=o.tick(t));return n=a/h,w.update(_.tick(t,n)),w.done()||f||b?(w.update(100),y.trigger("done"),setTimeout(function(){return w.finish(),y.running=!1,y.trigger("hide")},Math.max(T.ghostTime,Math.max(T.minTime-(P()-m),0)))):e()})},y.start=function(t){d(T,t),y.running=!0;try{w.render()}catch(t){n=t}return document.querySelector(".pace")?(y.trigger("start"),y.go()):setTimeout(y.start,50)},"function"==typeof define&&define.amd?define(function(){return y}):"object"==typeof exports?module.exports=y:T.startOnPageLoad&&y.start()}.call(this);

paceOptions = {
  // Disable the 'elements' source
  elements: false,

  // Only show the progress on regular and ajax-y page navigation,
  // not every request
  restartOnRequestAfter: false
}



//==== Source/SpaceTode.js ====//
;
try {
	HABITAT
}
catch {
	throw new Error(`\n\n[SpaceTode] Habitat.js is required by SpaceTode.\n\nIts source is at http://habitat.todepond.cool.\nFor more info, go to https://github.com/l2wilson94/Habitat.\n`)
}

if (HABITAT.EAT_LEGACY !== true) throw new Error(`\n\n[SpaceTode] EatLegacy.js is required by SpaceTode.\n\nIts source is at http://habitat.todepond.cool/Build/EatLegacy.js.\n`)


//==== Source/EventWindow.js ====//
;//=============//
// EventWindow //
//=============//
const EVENTWINDOW = {}

{

	// Event Window Job Description
	//=============================
	// "I am responsible for my SITES."

	//========//
	// Public //
	//========//
	EVENTWINDOW.getSiteNumber = (x, y, z) => {
		const key = getSiteKey(x, y, z)
		return SITE_NUMBERS[key]
	}
	
	EVENTWINDOW.updateWorld = (world) => {
		const area = world.area
		const grid = world.grid
		for (const y of area.yStart.to(area.yEnd)) {
			for (const x of area.xStart.to(area.xEnd)) {
				for (const z of area.zStart.to(area.zEnd)) {
				
					const space = grid[y][x][z]
					const sites = makeSites(world, x, y, z)
					for (let siteNumber = 0; siteNumber < sites.length; siteNumber++) {
						const site = sites[siteNumber]
						space.sites.push(site)
					}
					
					//const siteRefs = getSiteRefs(sites)
					//space.siteRefs = siteRefs
				}
			}
		}
	}
	
	//===========//
	// Constants //
	//===========//	
	SITE_POSITIONS = [
		// >x ^y
		// looking from the front
		[-2,2,0],  [-1,2,0],  [0,2,0],  [1,2,0],  [2,2,0],
		[-2,1,0],  [-1,1,0],  [0,1,0],  [1,1,0], [2,1,0],
		[-2,0,0],  [-1,0,0],  [0,0,0],  [1,0,0], [2,0, 0],
		[-2,-1,0], [-1,-1,0], [0,-1,0], [1,-1,0],[2,-1,0],
		[-2,-2,0], [-1,-2,0], [0,-2,0], [1,-2,0], [2,-2,0],
		
		// >x ^z
		// looking from the top
		[-2,0,2],  [-1,0,2],  [0,0,2],  [1,0,2],  [2,0,2],
		[-2,0,1],  [-1,0,1],  [0,0,1],  [1,0,1],  [2,0,1],
		/*[-2,0,0], [-1,0,0], [0,0,0], [1,0,0], [2,0,0],*/
		[-2,0,-1], [-1,0,-1], [0,0,-1], [1,0,-1], [2,0,-1],
		[-2,0,-2], [-1,0,-2], [0,0,-2], [1,0,-2], [2,0,-2],
		
		//>z ^y
		// looking from the side
		[0,2,-2], [0,2,-1], /*[0,2,0],*/ [0,2,1], [0,2,2],
		[0,1,-2], [0,1,-1], /*[0,1,0],*/ [0,1,1], [0,1,2],
		/*[0,0,-2], [0,0,-1], [0,0,0], [0,0,1], [0,0,2],*/
		[0,-1,-2], [0,-1,-1], /*[0,-1,0],*/ [0,-1,1], [0,-1,2],
		[0,-2,-2], [0,-2,-1], /*[0,-1,0],*/ [0,-2,1], [0,-2,2],
		
	]
	
	const SITE_NUMBERS = []
	
	//=======//
	// Setup //
	//=======//
	const getSiteKey = (x, y, z) => {
		return `${x}${y}${z}`
	}
	
	for (const i in SITE_POSITIONS) {
		const position = SITE_POSITIONS[i]
		const key = getSiteKey(...position)
		SITE_NUMBERS[key] = parseInt(i)
	}
	
	//===========//
	// Functions //
	//===========//	
	const getSiteRefs = (sites) => {
		const length = sites.length
		const array = new Uint32Array(length)
		for (let i = 0; i < length; i++) {
			array[i] = sites[i].id
		}
		return array
	}
	
	const makeSites = (world, x, y, z) => {
	
		// Written by hand because it made lookup faster compared to dynamically filling the array
		const sites = [
			SITE.make(WORLD.selectSpace(world, x + -2, y + 2, z + 0), x + -2, y + 2, z + 0),
			SITE.make(WORLD.selectSpace(world, x + -1, y + 2, z + 0), x + -1, y + 2, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 0, y + 2, z + 0), x + 0, y + 2, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 1, y + 2, z + 0), x + 1, y + 2, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 2, y + 2, z + 0), x + 2, y + 2, z + 0),
			
			SITE.make(WORLD.selectSpace(world, x + -2, y + 1, z + 0), x + -2, y + 1, z + 0),
			SITE.make(WORLD.selectSpace(world, x + -1, y + 1, z + 0), x + -1, y + 1, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 0, y + 1, z + 0), x + 0, y + 1, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 1, y + 1, z + 0), x + 1, y + 1, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 2, y + 1, z + 0), x + 2, y + 1, z + 0),
			
			SITE.make(WORLD.selectSpace(world, x + -2, y + 0, z + 0), x + -2, y + 0, z + 0),
			SITE.make(WORLD.selectSpace(world, x + -1, y + 0, z + 0), x + -1, y + 0, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 0, y + 0, z + 0), x + 0, y + 0, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 1, y + 0, z + 0), x + 1, y + 0, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 2, y + 0, z + 0), x + 2, y + 0, z + 0),
			
			SITE.make(WORLD.selectSpace(world, x + -2, y + -1, z + 0), x + -2, y + -1, z + 0),
			SITE.make(WORLD.selectSpace(world, x + -1, y + -1, z + 0), x + -1, y + -1, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 0, y + -1, z + 0), x + 0, y + -1, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 1, y + -1, z + 0), x + 1, y + -1, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 2, y + -1, z + 0), x + 2, y + -1, z + 0),
			
			SITE.make(WORLD.selectSpace(world, x + -2, y + -2, z + 0), x + -2, y + -2, z + 0),
			SITE.make(WORLD.selectSpace(world, x + -1, y + -2, z + 0), x + -1, y + -2, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 0, y + -2, z + 0), x + 0, y + -2, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 1, y + -2, z + 0), x + 1, y + -2, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 2, y + -2, z + 0), x + 2, y + -2, z + 0),
			
			SITE.make(WORLD.selectSpace(world, x + -2, y + 0, z + 2), x + -2, y + 0, z + 2),
			SITE.make(WORLD.selectSpace(world, x + -1, y + 0, z + 2), x + -1, y + 0, z + 2),
			SITE.make(WORLD.selectSpace(world, x + 0, y + 0, z + 2), x + 0, y + 0, z + 2),
			SITE.make(WORLD.selectSpace(world, x + 1, y + 0, z + 2), x + 1, y + 0, z + 2),
			SITE.make(WORLD.selectSpace(world, x + 2, y + 0, z + 2), x + 2, y + 0, z + 2),
			
			SITE.make(WORLD.selectSpace(world, x + -2, y + 0, z + 1), x + -2, y + 0, z + 1),
			SITE.make(WORLD.selectSpace(world, x + -1, y + 0, z + 1), x + -1, y + 0, z + 1),
			SITE.make(WORLD.selectSpace(world, x + 0, y + 0, z + 1), x + 0, y + 0, z + 1),
			SITE.make(WORLD.selectSpace(world, x + 1, y + 0, z + 1), x + 1, y + 0, z + 1),
			SITE.make(WORLD.selectSpace(world, x + 2, y + 0, z + 1), x + 2, y + 0, z + 1),
			/*
			SITE.make(WORLD.selectSpace(world, x + -2, y + 0, z + 0), x + -2, y + 0, z + 0),
			SITE.make(WORLD.selectSpace(world, x + -1, y + 0, z + 0), x + -1, y + 0, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 0, y + 0, z + 0), x + 0, y + 0, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 1, y + 0, z + 0), x + 1, y + 0, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 2, y + 0, z + 0), x + 2, y + 0, z + 0),
			*/
			SITE.make(WORLD.selectSpace(world, x + -2, y + 0, z + -1), x + -2, y + 0, z + -1),
			SITE.make(WORLD.selectSpace(world, x + -1, y + 0, z + -1), x + -1, y + 0, z + -1),
			SITE.make(WORLD.selectSpace(world, x + 0, y + 0, z + -1), x + 0, y + 0, z + -1),
			SITE.make(WORLD.selectSpace(world, x + 1, y + 0, z + -1), x + 1, y + 0, z + -1),
			SITE.make(WORLD.selectSpace(world, x + 2, y + 0, z + -1), x + 2, y + 0, z + -1),
			
			SITE.make(WORLD.selectSpace(world, x + -2, y + 0, z + -2), x + -2, y + 0, z + -2),
			SITE.make(WORLD.selectSpace(world, x + -1, y + 0, z + -2), x + -1, y + 0, z + -2),
			SITE.make(WORLD.selectSpace(world, x + 0, y + 0, z + -2), x + 0, y + 0, z + -2),
			SITE.make(WORLD.selectSpace(world, x + 1, y + 0, z + -2), x + 1, y + 0, z + -2),
			SITE.make(WORLD.selectSpace(world, x + 2, y + 0, z + -2), x + 2, y + 0, z + -2),
			
			SITE.make(WORLD.selectSpace(world, x + 0, y + 2, z + -2), x + 0, y + 2, z + -2),
			SITE.make(WORLD.selectSpace(world, x + 0, y + 2, z + -1), x + 0, y + 2, z + -1),
			/*WORLD.selectSpace(world, x + 0, y + 2, z + 0),*/
			SITE.make(WORLD.selectSpace(world, x + 0, y + 2, z + 1), x + 0, y + 2, z + 1),
			SITE.make(WORLD.selectSpace(world, x + 0, y + 2, z + 2), x + 0, y + 2, z + 2),
			
			SITE.make(WORLD.selectSpace(world, x + 0, y + 1, z + -2), x + 0, y + 1, z + -2),
			SITE.make(WORLD.selectSpace(world, x + 0, y + 1, z + -1), x + 0, y + 1, z + -1),
			/*WORLD.selectSpace(world, x + 0, y + 1, z + 0),*/
			SITE.make(WORLD.selectSpace(world, x + 0, y + 1, z + 1), x + 0, y + 1, z + 1),
			SITE.make(WORLD.selectSpace(world, x + 0, y + 1, z + 2), x + 0, y + 1, z + 2),
			/*
			SITE.make(WORLD.selectSpace(world, x + 0, y + 0, z + -2), x + 0, y + 0, z + -2),
			SITE.make(WORLD.selectSpace(world, x + 0, y + 0, z + -1), x + 0, y + 0, z + -1),
			SITE.make(WORLD.selectSpace(world, x + 0, y + 0, z + 0), x + 0, y + 0, z + 0),
			SITE.make(WORLD.selectSpace(world, x + 0, y + 0, z + 1), x + 0, y + 0, z + 1),
			SITE.make(WORLD.selectSpace(world, x + 0, y + 0, z + 2), x + 0, y + 0, z + 2),
			*/
			SITE.make(WORLD.selectSpace(world, x + 0, y + -1, z + -2), x + 0, y + -1, z + -2),
			SITE.make(WORLD.selectSpace(world, x + 0, y + -1, z + -1), x + 0, y + -1, z + -1),
			/*WORLD.selectSpace(world, x + 0, y + -1, z + 0),*/
			SITE.make(WORLD.selectSpace(world, x + 0, y + -1, z + 1), x + 0, y + -1, z + 1),
			SITE.make(WORLD.selectSpace(world, x + 0, y + -1, z + 2), x + 0, y + -1, z + 2),
			
			SITE.make(WORLD.selectSpace(world, x + 0, y + -2, z + -2), x + 0, y + -2, z + -2),
			SITE.make(WORLD.selectSpace(world, x + 0, y + -2, z + -1), x + 0, y + -2, z + -1),
			/*WORLD.selectSpace(world, x + 0, y + -2, z + 0),*/
			SITE.make(WORLD.selectSpace(world, x + 0, y + -2, z + 1), x + 0, y + -2, z + 1),
			SITE.make(WORLD.selectSpace(world, x + 0, y + -2, z + 2), x + 0, y + -2, z + 2),
		]
		return sites
	}
	
}

//==== Source/Symmetry.js ====//
;//==========//
// Symmetry //
//==========//
const SYMMETRY = {}

{
	
	const transformationCache = {}
	const getTransformation = (sig) => {
		if (transformationCache.has(sig)) return transformationCache[sig]
		const xAxis = getAxisAxis(sig, 0)
		const yAxis = getAxisAxis(sig, 1)
		const zAxis = getAxisAxis(sig, 2)
		const xSign = getAxisSign(sig, xAxis)
		const ySign = getAxisSign(sig, yAxis)
		const zSign = getAxisSign(sig, zAxis)
		const code = `(x, y, z) => [${xSign}${xAxis}, ${ySign}${yAxis}, ${zSign}${zAxis}]`
		return JS(code)
		
	}
	
	const getAxisSign = (sig, axis) => {
		const head = sig.split(axis)[0]
		if (head[head.length-1] === "-") return "-"
		return ""
	}
	
	const getAxisAxis = (sig, axisId) => {
		const uSig = sig.filter(c => c === "x" || c === "y" || c === "z")
		return uSig[axisId]
	}
	
	const T = getTransformation
	
	SYMMETRY.make = (name, transformations) => ({name, transformations})
	SYMMETRY.TYPE = {}
	SYMMETRY.TYPE.x = SYMMETRY.make("X", [
		T("xyz"),
		T("-xyz"),
	])
	
	SYMMETRY.TYPE.y = SYMMETRY.make("X", [
		T("xyz"),
		T("x-yz"),
	])
	
	SYMMETRY.TYPE.z = SYMMETRY.make("X", [
		T("xyz"),
		T("xy-z"),
	])
	
	SYMMETRY.TYPE.xy = SYMMETRY.make("XY", [
		T("xyz"),
		T("-xyz"),
		T("x-yz"),
		T("-x-yz"),
		T("yxz"),
		T("-yxz"),
		T("y-xz"),
		T("-y-xz"),
	])
	
	SYMMETRY.TYPE.xy.reflections = SYMMETRY.make("XY.REFLECTIONS", [
		T("xyz"),
		T("yxz"),
	])
	
	SYMMETRY.TYPE.xy.shifts = SYMMETRY.make("XY.SHIFTS", [...SYMMETRY.TYPE.xy.transformations])
	
	SYMMETRY.TYPE.xy.rotations = SYMMETRY.make("XY.ROTATIONS", [
		T("xyz"),
		T("-yxz"),
		T("-x-yz"),
		T("y-xz"),
	])
	
	SYMMETRY.TYPE.xy.directions = SYMMETRY.make("XY.DIRECTIONS", [
		T("xyz"),
		T("-x-yz"),
		T("yxz"),
		T("-y-xz"),
	])
	
	SYMMETRY.TYPE.xy.others = SYMMETRY.make("XY.OTHERS", [
		() => [-2,2,0],  () => [-1,2,0],  () => [0,2,0],  () => [1,2,0], () => [2,2,0],
		() => [-2,1,0],  () => [-1,1,0],  () => [0,1,0],  () => [1,1,0], () => [2,1,0],
		() => [-2,0,0],  () => [-1,0,0],/*() => [0,0,0],*/  () => [1,0,0], () => [2,0, 0],
		() => [-2,-1,0], () => [-1,-1,0], () => [0,-1,0], () => [1,-1,0],() => [2,-1,0],
		() => [-2,-2,0], () => [-1,-2,0], () => [0,-2,0], () => [1,-2,0], () => [2,-2,0],
	])
	
	SYMMETRY.TYPE.xz = SYMMETRY.make("XZ", [
		T("xyz"),
		T("-xyz"),
		T("xy-z"),
		T("-xy-z"),
		T("zyx"),
		T("-zyx"),
		T("zy-x"),
		T("-zy-x"),
	])
	
	SYMMETRY.TYPE.xz.swaps = SYMMETRY.make("XZ.SWAPS", [
		T("xyz"),
		T("zyx")
	])
	
	SYMMETRY.TYPE.xz.rotations = SYMMETRY.make("XZ.ROTATIONS", [
		T("xyz"),
		T("zy-x"),
		T("-xy-z"),
		T("-zyx"),
	])
	
	SYMMETRY.TYPE.xz.directions = SYMMETRY.make("XZ.ROTATIONS", [
		T("xyz"),
		T("-xy-z"),
		T("zyx"),
		T("-zy-x"),
	])
	
	SYMMETRY.TYPE.yz = SYMMETRY.make("YZ", [
		T("xyz"),
		T("x-yz"),
		T("xy-z"),
		T("x-y-z"),
		T("xzy"),
		T("x-zy"),
		T("xz-y"),
		T("x-z-y"),
	])
	
	SYMMETRY.TYPE.yz.rotations = SYMMETRY.make("YZ.ROTATIONS", [
		T("xyz"),
		T("x-y-z"),
		T("xzy"),
		T("x-z-y"),
	])
	
	SYMMETRY.TYPE.yz.directions = SYMMETRY.make("YZ.DIRECTIONS", [
		T("xyz"),
		T("x-y-z"),
		T("xzy"),
		T("x-z-y"),
	])
	
	SYMMETRY.TYPE.xyz = {}
	
	SYMMETRY.TYPE.xyz.directions = SYMMETRY.make("XYZ.DIRECTIONS", [
		T("xyz"),
		T("-x-yz"),
		
		T("zxy"),
		T("z-x-y"),
		
		T("yzx"),
		T("-yz-x"),
	])
	
	SYMMETRY.TYPE.xyz.shifts = SYMMETRY.make("XYZ.SHIFTS", [
		T("xyz"),
		T("x-yz"),
		T("-xyz"),
		T("-x-yz"),
		
		T("zxy"),
		T("z-xy"),
		T("zx-y"),
		T("z-x-y"),
		
		T("yzx"),
		T("yz-x"),
		T("-yzx"),
		T("-yz-x"),
	])
	
	SYMMETRY.TYPE.xyz.rotations = SYMMETRY.make("XYZ.ROTATIONS", [
		T("xyz"),	T("xzy"),
		T("x-yz"),	T("xz-y"),
		T("-xyz"),	T("-xzy"),
		T("-x-yz"),	T("-xz-y"),
		
		T("zyx"),	T("yxz"),
		T("z-yx"),	T("-yxz"),
		T("zy-x"),	T("y-xz"),
		T("z-y-x"),	T("-y-xz"),
		
		T("zxy"),	T("yzx"),
		T("zx-y"),	T("-yzx"),
		T("z-xy"),	T("yz-x"),
		T("z-x-y"),	T("-yz-x"),
	])
	
	SYMMETRY.TYPE.xyz.others = SYMMETRY.make("XYZ.OTHERS", SITE_POSITIONS.filter((p, i) => i !== 12).map(p => () => p))
}


//==== Source/Element.js ====//
;//=========//
// Element //
//=========//
const ELEMENT = {}

{
	// Element Job Description
	//========================
	// "I describe how I look and behave."

	//========//
	// Public //
	//========//
	ELEMENT.make = ({name, instructions = [], data = {}, args = {}, categories = [], elements = []}, {
		colour = "grey", emissive = colour, opacity = 1.0, visible = true, source = "",
		hidden = false, pour = true,
		...otherProperties
	} = {}) => {
	
		const behaveCode = JAVASCRIPT.makeBehaveCode(instructions, name)
		const behaveMaker = new Function(behaveCode)
		const behave = behaveMaker()
		//print(otherScopeProperties)
		const shaderColours = makeShaderColours(colour, emissive, opacity)
		colour = shaderColours.colour
		emissive = shaderColours.emissive
		const constructorCode = JAVASCRIPT.makeConstructorCode(name, data, args, visible, ...shaderColours)
		const element = JS(constructorCode)(...data, ...args)
		
		element.o={
			
			// Scope
			elements, data, args,
			
			// Appearance
			name, colour, emissive, opacity, categories, ...shaderColours, visible,
			
			// Dropper
			hidden, pour,
			
			// Debug
			source, constructorCode, behaveCode, instructions,
			
			// Behaviour
			behave, ...otherProperties
			
		}
		
		for (const child of element.elements) {
			element[child.name] = child
		}
		
		return element
	}
	
	//=========//
	// Private //
	//=========//
	const makeShaderColours = (colour, emissive, opacity) => {
		let colourColour = new THREE.Color(colour)
		let emissiveColour = new THREE.Color(emissive)

		if (!colourColour.hasOwnProperty("r")) {
			colourColour = new THREE.Color("red")
			colour = "red"
		}
		if (!emissiveColour.hasOwnProperty("r")) {
			emissiveColour = new THREE.Color("red")
			emissive = "red"
		}
		
		const shaderColour = {
			r: colourColour.r * 255,
			g: colourColour.g * 255,
			b: colourColour.b * 255,
		}
		
		const shaderOpacity = opacity * 255
		const shaderEmissive = {
			r: emissiveColour.r * 255,
			g: emissiveColour.g * 255,
			b: emissiveColour.b * 255,
		}
		
		return {shaderColour, shaderEmissive, shaderOpacity, colour, emissive}
		
	}
	
}


//==== Source/Instruction.js ====//
;//=============//
// Instruction //
//=============//
const POV = {}
POV.TYPE = {}
POV.make = (name, mod) => ({name, mod})
POV.TYPE.FRONT = POV.make("Front", (x, y, z) => [x, y, z])
POV.TYPE.BACK = POV.make("Back", (x, y, z) => [-x, y, -z])
POV.TYPE.RIGHT = POV.make("Right", (x, y, z) => [-z, y, -x])
POV.TYPE.LEFT = POV.make("Left", (x, y, z) => [z, y, x])
POV.TYPE.BOTTOM = POV.make("Bottom", (x, y, z) => [x, z, y])
POV.TYPE.TOP = POV.make("Top", (x, y, z) => [x, z, -y])


const INSTRUCTION = {}
INSTRUCTION.TYPE = {}
INSTRUCTION.make = (name, generate = () => { throw new Error(`[SpaceTode] The ${name} instruction is not supported yet`) }) => ({name, generate})

;{
	
	INSTRUCTION.TYPE.MIMIC = INSTRUCTION.make("Mimic", (template, targetGetter, instructions, spotMods = [], chunkMods = [], symmetry, symmetryId, forSymmId, char, diagramId, isAll) => {
		const target = targetGetter()
		
		const blockStart = {type: INSTRUCTION.TYPE.NAKED}
		const blockEnd = {type: INSTRUCTION.TYPE.BLOCK_END}
		const fullInstructions = [blockStart, ...target.instructions, blockEnd]
	
		for (let i = 0; i < fullInstructions.length; i++) {
			const instruction = fullInstructions[i]
			const type = instruction.type
			const value = instruction.value
			const tail = fullInstructions.slice(i+1)
			const newDiagramId = `${diagramId}D${i}`
			const jumps = type.generate(template, value, tail, spotMods, chunkMods, symmetry, symmetryId, forSymmId, char, newDiagramId, isAll)
			if (jumps !== undefined) i += jumps
		}
		//print(instructions)
	})

	INSTRUCTION.TYPE.BLOCK_END = INSTRUCTION.make("BlockEnd", () => {
		throw new Error(`[SpaceTode] The BlockEnd instruction should never be parsed on its own. Something has gone wrong with parsing.`)
	})
	
	INSTRUCTION.TYPE.BEHAVE = INSTRUCTION.make("Behave", (template, behave, instructions, spotMods = [], chunkMods = [], symmetry, symmetryId, forSymmId, char, diagramId, isAll) => {
		const id = template.head.behave.push(behave) - 1
		const chunk = makeEmptyChunk()
		chunk.debug = {source: `behave${id}`}
		
		processFunc ({
			name: "behave",
			func: behave,
			undefined,
			template,
			chunk,
			side: "input",
			symmetry,
			symmetryId,
			forSymmId,
			char: "behave",
			undefined,
			diagramId,
			isAll,
		})
		
		for (const mod of chunkMods) {
			mod(chunk)
		}
		
		template.main.push(chunk)
	})
	
	INSTRUCTION.TYPE.FOR = INSTRUCTION.make("ForBlock", (template, forSymmetry, instructions, spotMods = [], chunkMods = [], symmetry, symmetryId, forSymmId, char, diagramId, oldIsAll) => {
		if (forSymmId !== undefined) throw new Error(`[SpaceTode] You can't have a 'for' block inside another 'for' block because I haven't figured out how I want it to work yet.`)
		if (symmetry !== undefined) throw new Error(`[SpaceTode] You can't have an 'for' block inside an 'any' block because I haven't figured out how I want it to work yet.`)
		const isAll = forSymmetry.type === "all"
		const totalSymmetry = forSymmetry
		const totalSymmetryId = template.symmetry.push(totalSymmetry) - 1
		const newForSymmId = totalSymmetryId
		const forChunkMods = [...chunkMods, (chunk) => {
			chunk.forSymmId = newForSymmId
			chunk.forSymmTransCount = totalSymmetry.transformations.length
			chunk.forSymmIsAll = isAll
		}]
		for (let i = 0; i < instructions.length; i++) {
			const instruction = instructions[i]
			const type = instruction.type
			if (type === INSTRUCTION.TYPE.BLOCK_END) return i + 1
			const value = instruction.value
			const tail = instructions.slice(i+1)
			const newDiagramId = `${diagramId}D${i}`
			const jumps = type.generate(template, value, tail, spotMods, forChunkMods, totalSymmetry, totalSymmetryId, newForSymmId, char, newDiagramId, isAll)
			if (jumps !== undefined) i += jumps
		}
	})
	
	INSTRUCTION.TYPE.ANY = INSTRUCTION.make("AnyBlock", (template, selfSymmetry, instructions, spotMods = [], chunkMods = [], symmetry, symmetryId, forSymmId, char, diagramId, isAll) => {
		if (forSymmId !== undefined) throw new Error(`[SpaceTode] You can't have an 'any' block inside a 'for' block because I haven't figured out how I want it to work yet.`)
		if (symmetry !== undefined) throw new Error(`[SpaceTode] You can't have an 'any' block inside another 'any' block because I haven't figured out how I want it to work yet.`)
		const totalSymmetry = selfSymmetry
		const totalSymmetryId = template.symmetry.push(totalSymmetry) - 1
		for (let i = 0; i < instructions.length; i++) {
			const instruction = instructions[i]
			const type = instruction.type
			if (type === INSTRUCTION.TYPE.BLOCK_END) return i + 1
			const value = instruction.value
			const tail = instructions.slice(i+1)
			const newDiagramId = `${diagramId}D${i}`
			const jumps = type.generate(template, value, tail, spotMods, chunkMods, totalSymmetry, totalSymmetryId, forSymmId, char, newDiagramId, isAll)
			if (jumps !== undefined) i += jumps
		}
	})
	
	INSTRUCTION.TYPE.MAYBE = INSTRUCTION.make("MaybeBlock", (template, chance, instructions, spotMods = [], chunkMods = [], symmetry, symmetryId, forSymmId, char, diagramId, isAll) => {
		const maybeId = Symbol("MaybeId")
		const maybeMods = [...chunkMods, (chunk) => {
			chunk.maybeChance = chance
			if (chunk.maybes === undefined) chunk.maybes = []
			chunk.maybes = [...chunk.maybes, {id: maybeId, chance}]
		}]
		for (let i = 0; i < instructions.length; i++) {
			const instruction = instructions[i]
			const type = instruction.type
			if (type === INSTRUCTION.TYPE.BLOCK_END) return i + 1
			const value = instruction.value
			const tail = instructions.slice(i+1)
			const newDiagramId = `${diagramId}D${i}`
			const jumps = type.generate(template, value, tail, spotMods, maybeMods, symmetry, symmetryId, forSymmId, char, newDiagramId, isAll)
			if (jumps !== undefined) i += jumps
		}
	})
	
	INSTRUCTION.TYPE.ACTION = INSTRUCTION.make("ActionBlock", (template, v, instructions, spotMods = [], chunkMods = [], symmetry, symmetryId, forSymmId, char, diagramId, isAll) => {
		const actionId = Symbol("ActionId")
		const actionMods = [...chunkMods, (chunk) => {
			chunk.isInAction = true
			if (chunk.actionIds === undefined) chunk.actionIds = []
			chunk.actionIds = [...chunk.actionIds, actionId]
		}]
		for (let i = 0; i < instructions.length; i++) {
			const instruction = instructions[i]
			const type = instruction.type
			if (type === INSTRUCTION.TYPE.BLOCK_END) return i + 1
			const value = instruction.value
			const tail = instructions.slice(i+1)
			const newDiagramId = `${diagramId}D${i}`
			const jumps = type.generate(template, value, tail, spotMods, actionMods, symmetry, symmetryId, forSymmId, char, newDiagramId, isAll)
			if (jumps !== undefined) i += jumps
		}
	})
	
	INSTRUCTION.TYPE.POV = INSTRUCTION.make("PointOfView", (template, pov, instructions, spotMods = [], chunkMods = [], symmetry, symmetryId, forSymmId, char, diagramId, isAll) => {
		const povMods = [...spotMods, pov.mod]
		for (let i = 0; i < instructions.length; i++) {
			const instruction = instructions[i]
			const type = instruction.type
			if (type === INSTRUCTION.TYPE.BLOCK_END) return i + 1
			const value = instruction.value
			const tail = instructions.slice(i+1)
			const newDiagramId = `${diagramId}D${i}`
			const jumps = type.generate(template, value, tail, povMods, chunkMods, symmetry, symmetryId, forSymmId, char, newDiagramId, isAll)
			if (jumps !== undefined) i += jumps
		}
	})
	
	INSTRUCTION.TYPE.NAKED = INSTRUCTION.make("NakedBlock", (template, v, instructions, spotMods = [], chunkMods = [], symmetry, symmetryId, forSymmId, char, diagramId, isAll) => {
		for (let i = 0; i < instructions.length; i++) {
			const instruction = instructions[i]
			const type = instruction.type
			if (type === INSTRUCTION.TYPE.BLOCK_END) return i + 1
			const value = instruction.value
			const tail = instructions.slice(i+1)
			const newDiagramId = `${diagramId}D${i}`
			const jumps = type.generate(template, value, tail, spotMods, chunkMods, symmetry, symmetryId, forSymmId, char, newDiagramId, isAll)
			if (jumps !== undefined) i += jumps
		}
	})
	
	INSTRUCTION.TYPE.DIAGRAM = INSTRUCTION.make("Diagram", (template, diagram, instructions, spotMods = [], chunkMods = [], symmetry, symmetryId, forSymmId, char, diagramId, isAll) => {
		const moddedDiagram = modDiagram(diagram, spotMods)
		const chunk = makeEmptyChunk()
		chunk.debug = diagram.debug
		for (const spot of moddedDiagram) {
		
			const {inputChar, outputChar} = spot
			const {given, select, check} = spot.input
			const {change, keep} = spot.output
			
			processFunc ({
				name: "given",
				func: given,
				spot,
				template,
				chunk,
				side: "input",
				symmetry,
				symmetryId,
				forSymmId,
				char: inputChar,
				diagram,
				diagramId,
				isAll,
				spotMods,
			})
			
			processFunc ({
				name: "select",
				func: select,
				spot,
				template,
				chunk,
				side: "input",
				symmetry,
				symmetryId,
				forSymmId,
				char: inputChar,
				diagram,
				diagramId,
				isAll,
				spotMods,
			})
			
			processFunc ({
				name: "check",
				func: check,
				spot,
				template,
				chunk,
				side: "input",
				symmetry,
				symmetryId,
				forSymmId,
				char: inputChar,
				diagram,
				diagramId,
				isAll,
				spotMods,
			})
			
			processFunc ({
				name: "change",
				func: change,
				spot,
				template,
				chunk,
				side: "output",
				symmetry,
				symmetryId,
				forSymmId,
				char: outputChar,
				diagram,
				diagramId,
				isAll,
				spotMods,
			})
			
			processFunc ({
				name: "keep",
				func: keep,
				spot,
				template,
				chunk,
				side: "output",
				symmetry,
				symmetryId,
				forSymmId,
				char: outputChar,
				diagram,
				diagramId,
				isAll,
				spotMods,
			})
		}
		
		// Remove redundant needers from output - because they are already in input
		for (const neederName in chunk.output.needers) {
			const needer = chunk.output.needers[neederName]
			if (chunk.input.needers.has(neederName)) delete chunk.output.needers[neederName]
		}
		
		for (const mod of chunkMods) {
			mod(chunk)
		}
		
		template.main.push(chunk)
	})
	
	const modDiagram = (diagram, spotMods) => {
		const moddedDiagram = []
		for (const spot of diagram) {
			let {x, y, z} = spot
			for (const mod of spotMods) {
				[x, y, z] = mod(spot.x, spot.y, spot.z)
			}
			const moddedSpot = {...spot, x, y, z}
			moddedDiagram.push(moddedSpot)
		}
		return moddedDiagram
	}
	
	//======//
	// Func //
	//======//
	const processFunc = ({name, func, spot = {}, template, chunk, side, symmetry, symmetryId, forSymmId, char, diagram, diagramId, isAll, spotMods}) => {
		if (func === undefined) return
		
		const {x, y, z} = spot
		const {head, cache, chars} = template
		const id = head[name].pushUnique(func)
		if (chars[name][id] === undefined) chars[name][id] = []
		chars[name][id].pushUnique(char)
		const result = getResult(name)
		const paramNames = getParamNames(func)
		const params = paramNames.map(paramName => getParam(paramName))
		const argNames = params.map(param => getName(param, x, y, z, symmetryId, char, diagramId))
		
		const idResult = makeIdResult(result, id, paramNames)
		const needs = getNeeds(idResult)
		const idResultName = getName(idResult, x, y, z, symmetryId, char, diagramId)
		const needers = needs.map(need => makeNeeder({need, x, y, z, symmetry, symmetryId, forSymmId, id, argNames, idResultName, char, diagram, diagramId, isAll, spotMods}))
		for (const needer of needers) {
			if (needer.need.isCondition) chunk.conditions.pushUnique(needer.name)
			chunk[side].needers[needer.name] = needer
		}
		
		const neederGets = needers.filter(needer => needer.need.generateGet)
		const neederGetNames = neederGets.map(neederGet => neederGet.name)
		cache.pushUnique(...neederGetNames)
	}
	
	//=======//
	// Chunk //
	//=======//
	const makeEmptyChunk = () => ({
		type: INSTRUCTION.TYPE.DIAGRAM,
		input: {needers: {}},
		conditions: [],
		output: {needers: {}},
		debug: {},
	})
	
	//=======//
	// Needs //
	//=======//
	const getNeeds = (param) => {
		const needs = []
		const otherNeeds = param.needNames.map(needName => getParam(needName))
		for (const otherNeed of otherNeeds) needs.pushUnique(...getNeeds(otherNeed))
		if (param.type !== NEED_TYPE.ARG) needs.pushUnique(param)
		return needs
	}
	
	const makeNeeder = ({need, x, y, z, id, symmetry, symmetryId, argNames, idResultName, forSymmId, char, diagram, diagramId, isAll, spotMods}) => {
		const name = getName(need, x, y, z, symmetryId, char, diagramId)
		return {need, name, x, y, z, symmetry, symmetryId, id, argNames, idResultName, forSymmId, char, diagram, diagramId, isAll, spotMods}
	}
	
	//====================//
	// Params - Functions //
	//====================//
	const getParam = (name) => {
		const param = PARAM[name]
		if (param === undefined) throw new Error(`[SpaceTode] Unrecognised parameter: '${name}'`)
		return param
	}
	
	const getResult = (name) => {
		const result = RESULT[name]
		if (result === undefined) throw new Error(`[SpaceTode] No result found for param: '${name}'`)
		return result
	}
	
	const getName = (param, x, y, z, symmetryId, char, diagramId) => {
		const type = param.type
		let name = param.name
		if (type === NEED_TYPE.ARG) return name
		if (type === NEED_TYPE.GLOBAL) return name
		if (type === NEED_TYPE.SYMMETRY) return getSymmetryName(name, symmetryId)
		if (type === NEED_TYPE.LOCAL) {
			if (x === undefined) throw new Error(`\n\n[SpaceTode] Can't get local parameter '${name}' in a global setting.\n\nAre you trying to use '${name}' in a 'behave' function?\nYou can only use global parameters, such as 'origin', 'sites', 'self' and 'Self'.\n`)
			return getLocalName(name, x, y, z, symmetryId)
		}
		if (type === NEED_TYPE.SYMBOL) return getSymbolName(name, char, diagramId)
		throw new Error(`[SpaceTode] Unrecognised named param type: ${type}`)
	}
	
	const getParamNames = (func) => {
		if (func === undefined) return []
		const code = func.as(String)
		const paramNames = []
		let buffer = ""
		for (let i = 0; i < code.length; i++) {
			const char = code[i]
			if ((char == "(" || char == " " || char == "	") && buffer == "") continue
			if (char.match(/[a-zA-Z0-9$_]/)) buffer += char
			else if (char == " " || char == "," || char == "	" || char == ")") {
				if (buffer != "") {
					paramNames.push(buffer)
					buffer = ""
				}
			}
			else {
				throw new Error(`[SpaceTode] Unexpected character in named parameters: '${char}'\n\nPlease don't do anything fancy with your parameters in symbol functions :)\nGOOD: (element, space) => { ... }\nBAD: (element = Empty, {atom}) => { ... }\n\nPlease feel free to contact @todepond if you want to ask for help or complain about this :D\n`)
			}
			if (char == ")") break
		}
		return paramNames
	}
	
	const getSymbolName = (name, char, diagramId) => {
		const id = getCharId(char)
		return name + diagramId + "Char" + id
	}
	
	const uniqueCache = {}
	const getUniqueName = (name) => {
		if (uniqueCache.has(name)) {
			uniqueCache[name]++
			return name + uniqueCache[name]
		}
		uniqueCache[name] = 0
		return name + uniqueCache[name]
	}
	
	const getSymmetryName = (name, symmetryId) => {
		const symmetryTail = symmetryId !== undefined? "Symm" + symmetryId : ""
		return name + symmetryTail
	}
	
	const getLocalName = (name, x, y, z, symmetryId, isConst) => {
		const xyzTail = `${x}${y}${z}`
		const symmetryTail = symmetryId !== undefined? "Symm" + symmetryId : ""
		const constTail = isConst? `Const` : ``
		return name + xyzTail.replace(/-/g, "_") + symmetryTail + constTail
	}
	
	//======================//
	// Params - Definitions //
	//======================//
	const makeNeed = ({
		name,
		type,
		needNames = [],
		generateGet,
		generateExtra,
		generateConstant,
		preLoop = false,
		isCondition = false,
	}) => ({
		name,
		type,
		needNames,
		generateGet,
		generateExtra,
		generateConstant,
		preLoop,
		isCondition,
	})
	
	const NEED_TYPE = {
		ARG: Symbol("Arg"),
		GLOBAL: Symbol("Global"),
		SYMMETRY: Symbol("Symmetry"),
		LOCAL: Symbol("Local"),
		SYMBOL: Symbol("Symbol"), //TODO: bugged
	}
	
	const PARAM = {}
	PARAM.self = makeNeed({name: "self", type: NEED_TYPE.ARG})
	PARAM.Self = makeNeed({name: "Self", type: NEED_TYPE.ARG})
	PARAM.time = makeNeed({name: "time", type: NEED_TYPE.ARG})
	PARAM.origin = makeNeed({name: "origin", type: NEED_TYPE.ARG})
	
	// Legacy
	PARAM.selfElement = makeNeed({
		name: "selfElement",
		type: NEED_TYPE.GLOBAL,
		needNames: ["Self"],
		generateGet: () => `Self`,
	})
	
	PARAM.sites = makeNeed({
		name: "sites",
		type: NEED_TYPE.GLOBAL,
		preLoop: true,
		needNames: ["origin"],
		generateGet: () => `origin.sites`,
	})
	
	PARAM.transformationNumber = makeNeed({
		name: "transformationNumber",
		type: NEED_TYPE.SYMMETRY,
		needNames: ["transformationNumbers"],
		generateGet: (x, y, z, symmetry, symmetryId, id, argNames, idResultName, forSymmId, char, template, diagram, isAll) => {
			if (symmetry === undefined) return undefined
			if (forSymmId !== undefined) {
				if (isAll) return `transformationNumbersSymm${symmetryId}Const[i${symmetryId}]`
				return `transNumsShuffledSymm${symmetryId}[i${symmetryId}]`
			}
			return `Math.floor(Math.random() * ${symmetry.transformations.length})`
		}
	})
	
	PARAM.transformationNumbers = makeNeed({
		name: "transformationNumbers",
		type: NEED_TYPE.SYMMETRY,
		needNames: [],
		generateConstant: (x, y, z, symmetry, symmetryId, id, argNames, idResultName, forSymmId) => {
			if (forSymmId === undefined) return undefined
			return "[" + (0).to(symmetry.transformations.length-1).join(", ") + "]"
		}
	})
	
	PARAM.possibleSiteNumbers = makeNeed({
		name: "possibleSiteNumbers",
		type: NEED_TYPE.LOCAL,
		needNames: [],
		preLoop: true,
		generateConstant: (x, y, z, symmetry, symmetryId) => {
			if (x === 0 && y === 0 && z === 0) return undefined
			if (symmetry === undefined) return undefined
			const siteNumbers = symmetry.transformations.map(t => EVENTWINDOW.getSiteNumber(...t(x, y, z)))
			return `[${siteNumbers.join(", ")}]`
		},
	})
	
	PARAM.siteNumber = makeNeed({
		name: "siteNumber",
		type: NEED_TYPE.LOCAL,
		needNames: ["transformationNumber", "possibleSiteNumbers"],
		generateGet: (x, y, z, symmetry, symmetryId, id, argNames, idResultName, forSymmId) => {
			if (x === 0 && y === 0 && z === 0) return undefined
			if (symmetry === undefined) return undefined
			const possibleSiteNumbersName = getLocalName("possibleSiteNumbers", x, y, z, symmetryId, true)
			const transformationNumberName = getSymmetryName("transformationNumber", symmetryId)
			return `${possibleSiteNumbersName}[${transformationNumberName}]`
		},
	})
	
	PARAM.possibleXs = makeNeed({
		name: "possibleXs",
		type: NEED_TYPE.LOCAL,
		needNames: [],
		preLoop: true,
		generateConstant: (x, y, z, symmetry, symmetryId) => {
			if (x === 0 && y === 0 && z === 0) return undefined
			if (symmetry === undefined) return undefined
			const xs = symmetry.transformations.map(t => t(x, y, z)[0])
			return `[${xs.join(", ")}]`
		},
	})
	
	PARAM.x = makeNeed({
		name: "x",
		type: NEED_TYPE.LOCAL,
		needNames: ["transformationNumber", "possibleXs"],
		generateGet: (x, y, z, symmetry, symmetryId, id, argNames, idResultName, forSymmId) => {
			if (x === 0 && y === 0 && z === 0) return 0
			if (symmetry === undefined) return x
			const possibleXsName = getLocalName("possibleXs", x, y, z, symmetryId, true)
			const transformationNumberName = getSymmetryName("transformationNumber", symmetryId)
			return `${possibleXsName}[${transformationNumberName}]`
		}
	})
	
	PARAM.possibleYs = makeNeed({
		name: "possibleYs",
		type: NEED_TYPE.LOCAL,
		needNames: [],
		preLoop: true,
		generateConstant: (x, y, z, symmetry, symmetryId) => {
			if (x === 0 && y === 0 && z === 0) return undefined
			if (symmetry === undefined) return undefined
			const ys = symmetry.transformations.map(t => t(x, y, z)[1])
			return `[${ys.join(", ")}]`
		},
	})
	
	PARAM.y = makeNeed({
		name: "y",
		type: NEED_TYPE.LOCAL,
		needNames: ["transformationNumber", "possibleYs"],
		generateGet: (x, y, z, symmetry, symmetryId, id, argNames, idResultName, forSymmId) => {
			if (x === 0 && y === 0 && z === 0) return 0
			if (symmetry === undefined) return y
			const possibleYsName = getLocalName("possibleYs", x, y, z, symmetryId, true)
			const transformationNumberName = getSymmetryName("transformationNumber", symmetryId)
			return `${possibleYsName}[${transformationNumberName}]`
		}
	})
	
	PARAM.possibleZs = makeNeed({
		name: "possibleZs",
		type: NEED_TYPE.LOCAL,
		needNames: [],
		preLoop: true,
		generateConstant: (x, y, z, symmetry, symmetryId) => {
			if (x === 0 && y === 0 && z === 0) return undefined
			if (symmetry === undefined) return undefined
			const zs = symmetry.transformations.map(t => t(x, y, z)[2])
			return `[${zs.join(", ")}]`
		},
	})
	
	PARAM.z = makeNeed({
		name: "z",
		type: NEED_TYPE.LOCAL,
		needNames: ["transformationNumber", "possibleZs"],
		generateGet: (x, y, z, symmetry, symmetryId, id, argNames, idResultName, forSymmId) => {
			if (x === 0 && y === 0 && z === 0) return 0
			if (symmetry === undefined) return z
			const possibleZsName = getLocalName("possibleZs", x, y, z, symmetryId, true)
			const transformationNumberName = getSymmetryName("transformationNumber", symmetryId)
			return `${possibleZsName}[${transformationNumberName}]`
		}
	})
	
	PARAM.space = makeNeed({
		name: "space",
		type: NEED_TYPE.LOCAL,
		needNames: ["sites", "siteNumber"],
		generateGet: (x, y, z, symmetry, symmetryId) => {
			if (x === 0 && y === 0 && z === 0) return "origin"
			if (symmetry === undefined) {
				const siteNumber = EVENTWINDOW.getSiteNumber(x, y, z)
				return `sites[${siteNumber}]`
			}
			const siteNumberName = getLocalName("siteNumber", x, y, z, symmetryId)
			return `sites[${siteNumberName}]`
		},
	})
	
	PARAM.atom = makeNeed({
		name: "atom",
		type: NEED_TYPE.LOCAL,
		needNames: ["space"],
		generateGet: (x, y, z, symmetry, symmetryId) => {
			const spaceName = getLocalName("space", x, y, z, symmetryId)
			return `${spaceName}.atom`
		},
	})
	
	PARAM.element = makeNeed({
		name: "element",
		type: NEED_TYPE.LOCAL,
		needNames: ["space"],
		generateGet: (x, y, z, symmetry, symmetryId) => {
			const spaceName = getLocalName("space", x, y, z, symmetryId)
			return `${spaceName}.element`
		},
	})
	
	PARAM.selected = makeNeed({
		name: "selected",
		type: NEED_TYPE.SYMBOL,
		needNames: [],
		generateGet: (x, y, z, symmetry, symmetryId, id, args, idResultName, forSymmId, char, template, diagram, isAll, spotMods) => {
			const selectId = getSymbolId(char, "select", template)
			let selectResultPos = undefined
			const moddedDiagram = modDiagram(diagram, spotMods)
			for (const spot of moddedDiagram) {
				if (spot.inputChar === char) {
					// TODO: randomly select from multiple selects
					if (selectResultPos !== undefined) throw new Error(`[SpaceTode] You can only have one '${char}' symbol in the left-hand-side of a diagram because it has a 'select' keyword.`)
					selectResultPos = [spot.x, spot.y, spot.z]
				}
			}
			const selectResultName = getLocalName(`select${selectId}Result`, ...selectResultPos, symmetryId)
			return selectResultName
		},
	})
	
	//===============//
	// Result Params //
	//===============//
	const RESULT = {}
	RESULT.given = makeNeed({
		name: "given",
		type: NEED_TYPE.LOCAL,
		generateGet: (x, y, z, symmetry, symmetryId, id, args) => {
			const argsInner = args.join(", ")
			return `given${id}(${argsInner})`
		},
		isCondition: true,
	})
	
	RESULT.select = makeNeed({
		name: "select",
		type: NEED_TYPE.LOCAL,
		generateGet: (x, y, z, symmetry, symmetryId, id, args) => {
			const argsInner = args.join(", ")
			return `select${id}(${argsInner})`
		},
	})
	
	RESULT.keep = makeNeed({
		name: "keep",
		type: NEED_TYPE.LOCAL,
		needs: [],
		generateExtra: (x, y, z, symmetry, symmetryId, id, args) => {
			const argsInner = args.join(", ")
			return `keep${id}(${argsInner})`
		},
	})
	
	RESULT.check = makeNeed({
		name: "check",
		type: NEED_TYPE.SYMBOL,
		needNames: [],
		isCondition: true,
		generateGet: (x, y, z, symmetry, symmetryId, id, args) => {
			const argsInner = args.join(", ")
			return `check${id}(${argsInner})`
		},
	})
	
	RESULT.change = makeNeed({
		name: "change",
		type: NEED_TYPE.LOCAL,
		needNames: ["space"],
		generateGet: (x, y, z, symmetry, symmetryId, id, args) => {
			const argsInner = args.join(", ")
			return `change${id}(${argsInner})`
		},
		generateExtra: (x, y, z, symmetry, symmetryId, id, args, idResultName) => {
			const spaceName = getLocalName("space", x, y, z, symmetryId)
			return `SPACE.setAtom(${spaceName}, ${idResultName})`
		}
	})
	
	RESULT.behave = makeNeed({
		name: "behave",
		type: NEED_TYPE.GLOBAL,
		needs: [],
		isCondition: true,
		generateGet: (x, y, z, symmetry, symmetryId, id, args) => {
			const argsInner = args.join(", ")
			return `behave${id}(${argsInner})`
		},
	})
	
	//============//
	// ID Results //
	//============//
	let idResultsCache = {}
	INSTRUCTION.resetIdResultCache = () => idResultsCache = {} 
	const makeIdResult = (result, id, paramNames) => {
		const name = `${result.name}${id}Result`
		if (idResultsCache.has(name)) return idResultsCache[name]
		
		const needNames = [...result.needNames]
		needNames.pushUnique(...paramNames)
		
		const options = {...result, name, needNames}
		const idResult = makeNeed(options)
		idResultsCache[name] = idResult
		return idResult
	}
	
	//=============//
	// Behave Need //
	//=============//
	/*const makeBehaveNeed = (func, id) => {
		const params = getParamNames(func)
		return makeNeed({
			name: `behave${id}`,
			type: NEED_TYPE.GLOBAL,
			needNames: params,
			generateExtra: () => {
				return `behave${id}`
			}
		})
	}*/
	
	//=========//
	// Char ID //
	//=========//
	let charIdCache = []
	INSTRUCTION.resetCharIdCache = () => charIdCache = []
	const getCharId = (char) => {
		let id = charIdCache.indexOf(char)
		if (id !== -1) return id
		return charIdCache.push(char) - 1
	}
	
	//===========//
	// Symbol ID //
	//===========//
	const getSymbolId = (char, partName, template) => {
		const arr = template.chars[partName]
		for (const i in arr) {
			const e = arr[i]
			if (e.includes(char)) return i.as(Number)
		}
		return -1
	}
	
}




//==== Source/Javascript.js ====//
;//============//
// Javascript //
//============//
const JAVASCRIPT = {}

{
	// Javascript Job Description
	//===========================
	// "I generate Javascript for an element's 'behave' function."

	//========//
	// Public //
	//========//
	JAVASCRIPT.makeBehaveCode = (instructions, name) => {
		return makeBehaveCode(instructions, name)
	}
	
	show = (element) => {
		print(element.name)
		for (const instruction of element.instructions) print(instruction.type, instruction.value)
	}
	
	// messy as hell
	JAVASCRIPT.makeConstructorCode = (name, data, args, visible, shaderColour, shaderEmissive, shaderOpacity) => {
	
		let closureArgNames = ``
		let constructorArgNames = ``
		let propertyNames = ``
	
		for (const argName in data) {
			if (closureArgNames.length == 0) {
				closureArgNames += `${argName}Default`
				propertyNames += `,\n ${argName}: ${argName}Default`
			}
			else {
				closureArgNames += `, ${argName}Default`
				propertyNames += `, ${argName}: ${argName}Default`
			}
		}
		
		for (const argName in args) {
			if (closureArgNames.length == 0) {
				closureArgNames += `${argName}Default`
			}
			else {
				closureArgNames += `, ${argName}Default`
			}
			if (constructorArgNames.length == 0) {
				constructorArgNames += `${argName} = ${argName}Default`
				propertyNames += `, ${argName}: ${argName}`
			}
			else {
				constructorArgNames += `, ${argName} = ${argName}Default`
				propertyNames += `, ${argName}: ${argName}`
			}
		}
		
		const lines = []
		lines.push(`(${closureArgNames}) => {`)
		lines.push(`	`)
		lines.push(`	const element = function ${name}(${constructorArgNames}) {`)
		lines.push(`		const atom = {`)
		lines.push(`			element,`)
		lines.push(`			visible: ${visible},`)
		lines.push(`			colour: {r: ${shaderColour.r}, g: ${shaderColour.g}, b: ${shaderColour.b}},`)
		lines.push(`			emissive: {r: ${shaderEmissive.r}, g: ${shaderEmissive.g}, b: ${shaderEmissive.b}},`)
		lines.push(`			opacity: ${window.D2_MODE? 255 : shaderOpacity}`)
		lines.push(`			${propertyNames}`)
		lines.push(`		}`)
		lines.push(`		return atom`)
		lines.push(`	}`)
		lines.push(`	return element`)
		lines.push(`}`)
		const code = lines.join("\n")
		
		return code
		return (`(${closureArgNames}) => {\n` +
		`\n`+
		`const element = function ${name}(${constructorArgNames}) {\n`+
		`	const atom = {element, visible: element.visible, colour: element.shaderColour, emissive: element.shaderEmissive, opacity: element.shaderOpacity${propertyNames}}\n`+
		`	return atom\n`+
		`}\n`+
		`	return element\n`+
		`}`)
	}
	
	//==========//
	// Template //
	//==========//
	JAVASCRIPT.makeEmptyTemplate = () => ({
	
		// Head contains stores of global functions that we need
		head: {
			given: [],
			select: [],
			check: [],
			change: [],
			keep: [],
			behave: [],
		},
		
		// Stores the characters for symbol parts held in head
		chars: {
			given: [],
			select: [],
			check: [],
			change: [],
			keep: [],
			behave: [],
		},
		
		// Cache stores global variables that we might use more than once
		cache: [],
		
		// 
		symmetry: [],
		
		// Main is an array of stuff that happens in order
		// Strings just get naively added to the code
		// Chunk objects specify more fancy stuff
		main: [
			
		],
	})
	
	const buildTemplate = (template) => {
		
		const lines = []
		
		
		lines.push("//=========//")
		lines.push("// SYMBOLS //")
		lines.push("//=========//")
		for (const storeName in template.head) {
			const store = template.head[storeName]
			for (let i = 0; i < store.length; i++) {
				const script = store[i]
				if (script === undefined) continue
				if (script.split("\n").length > 1) lines.push(``)
				lines.push(`const ${storeName}${i} = ${script}`)
				if (script.split("\n").length > 1) lines.push(``)
			}
		}
		lines.push("")
		lines.push("//========//")
		lines.push("// BEHAVE //")
		lines.push("//========//")
		lines.push(`const behave = (origin, Self, time, self = origin.atom) => {`)
		const constants = []
		lines.push(...makeChunksLines(template.main, `	`, [], constants, false, template))
		lines.push(`}`)
		lines.push(``)
		lines.push(`return behave`)
		
		const constantLines = []
		constantLines.push(`//===========//`)
		constantLines.push(`// CONSTANTS //`)
		constantLines.push(`//===========//`)
		constantLines.push(...constants)
		constantLines.push(``)
		lines.unshift(...constantLines)
		
		const code = lines.join("\n")
		return code
	}
	
	const makeChunksLines = (chunks, margin, gots, constants, missGap = false, template) => {
		let alreadyGots = gots
		const lines = []
		const maybeBlocks = []
		const maybeGots = []
		const maybeSymms = []
		let prevForSymmId = []
		
		for (let i = 0; i < chunks.length; i++) {
			const chunk = chunks[i]
			if (missGap) missGap = false
			else lines.push(``)
			if (chunk.is(String)) {
				lines.push(`${margin}` + chunk)
				continue
			}
			
			// Update gots each time
			if (maybeBlocks.length > 0) alreadyGots = maybeGots.last
			else alreadyGots = gots
			
			//=======//
			// Maybe //
			//=======//
			let maybes = chunk.maybes
			if (maybes === undefined) maybes = []
			
			const oldId = maybeBlocks.last? maybeBlocks.last.id : undefined
			const newId = maybes.last? maybes.last.id : undefined
			
			const maybesLength = maybes.length
			const maybeBlocksLength = maybeBlocks.length
			
			// End Maybe
			if (maybesLength < maybeBlocksLength && oldId !== newId) {
				const afterMaybeGots = [...maybeGots.last]
				maybeBlocks.pop()
				maybeGots.pop()
				
				const tail = chunks.slice(i)
				for (const t in tail) {
					if (tail[t].forSymmId !== undefined) {
						if (tail[t].forSymmId === prevForSymmId.last) {
							tail[t] = {...tail[t], forSymmId: undefined}
						}
					}
				}
				
				const afterLines = makeChunksLines(tail, `${margin}`, afterMaybeGots, constants, true, template)
				lines.push(`${margin}// Continue rules after successful 'maybe'`)
				lines.push(...afterLines)
				lines.push(`${margin}return`)
				
				margin = margin.slice(0, -1)
				lines.push(`${margin}}`)
				lines.push(`${margin}`)
				lines.push(`${margin}// Continue rules after failing 'maybe'`)
				i--
				missGap = true
				continue
			}
			
			//=========//
			// End For //
			//=========//
			const nextForSymmId = chunk.forSymmId
			if (prevForSymmId.length !== 0 && nextForSymmId !== prevForSymmId.last) {
				prevForSymmId.pop()
				margin = margin.slice(0, -1)
				lines.push(`${margin}}`)
			}
			
			//================//
			// Pre-Loop Input //
			//================//
			//lines.push(...chunk.debug.source.split("\n").map(s => `${margin}// ${s}`))
			for (const needer of chunk.input.needers) {
				if (needer.need.preLoop) lines.push(...makeNeederLines(needer, `${margin}`, alreadyGots, true, constants, template))
			}
			
			//===========//
			// Start For //
			//===========//
			if (nextForSymmId !== undefined && prevForSymmId.last !== nextForSymmId) {
				const iName = `i${nextForSymmId}`
				if (!chunk.forSymmIsAll) lines.push(`${margin}const transNumsShuffledSymm${nextForSymmId} = transformationNumbersSymm${nextForSymmId}Const.shuffled`)
				lines.push(`${margin}for(let ${iName} = 0; ${iName} < ${chunk.forSymmTransCount}; ${iName}++) {`)
				lines.push(``)
				margin += `	`
				prevForSymmId.push(nextForSymmId)
			}
			
			// Start Maybe
			if (maybesLength > maybeBlocksLength) {
				const maybe = maybes.last
				maybeBlocks.push(maybe)
				maybeGots.push([...alreadyGots])
				lines.push(`${margin}// maybe(${maybes.last.chance})`)
				lines.push(`${margin}if (Math.random() < ${maybe.chance}) {`)
				lines.push(`${margin}`)
				margin += `	`
			}
			
			// Update gots after potentially changing block
			if (maybeBlocks.length > 0) alreadyGots = maybeGots.last
			else alreadyGots = gots
			
			//=======//
			// Input //
			//=======//
			lines.push(...chunk.debug.source.split("\n").map(s => `${margin}// ${s}`))
			for (const needer of chunk.input.needers) {
				if (!needer.need.preLoop) lines.push(...makeNeederLines(needer, `${margin}`, alreadyGots, true, constants, template))
			}
			
			//===========//
			// Condition //
			//===========//
			const conditionInnerCode = chunk.conditions.join(" && ")
			if (chunk.conditions.length === 0) lines.push(`${margin}{`)
			else lines.push(`${margin}if (${conditionInnerCode}) {`)
			
			//========//
			// Output //
			//========//
			const outputAlreadyGots = [...alreadyGots]
			for (const needer of chunk.output.needers) {
				lines.push(...makeNeederLines(needer, `${margin}	`, outputAlreadyGots, true, constants, template))
			}
			
			//=================//
			// Remaining Rules //
			//=================//
			if (chunk.isInAction) {
				const tail = chunks.slice(i+1).filter(c => {
					if (c.actionIds === undefined) return true
					if (c.actionIds.length === chunk.actionIds.length && c.actionIds.last !== chunk.actionIds.last) return true
					if ((c.actionIds.length > chunk.actionIds.length) && c.actionIds[chunk.actionIds.length-1] !== chunk.actionIds[chunk.actionIds.length-1]) return true
					if (c.actionIds.length < chunk.actionIds.length) return true
					return false
				})
				const afterLines = makeChunksLines(tail, `${margin}	`, outputAlreadyGots, constants, true, template)
				if (afterLines.length > 0) {
					lines.push(`${margin}	`)
					lines.push(`${margin}	// Continue rules after successful 'action'`)
				}
				lines.push(...afterLines)
			}
			
			//===================//
			// Remaining Actions //
			//===================//
			/*else {
				const tail = chunks.slice(i+1)
				const tailActions = tail.filter(chunk => chunk.isInAction)
				if (tailActions[0] !== undefined) {
					const afterLines = makeChunksLines(tailActions, `${margin}	`, outputAlreadyGots, constants, true, template)
					lines.push(`${margin}	`)
					lines.push(`${margin}	// Continue 'action's after matching a rule`)
					lines.push(...afterLines)
				}
			}*/
			
			lines.push(`${margin}	return`)
			lines.push(`${margin}}`)
		}
		
		//==========//
		// Tidy For //
		//==========//
		while (prevForSymmId.length !== 0) {
			prevForSymmId.pop()
			margin = margin.slice(0, -1)
			lines.push(`${margin}}`)
		}
			
		//============//
		// Tidy Maybe //
		//============//
		while (maybeBlocks.length > 0) {
			maybeBlocks.pop()
			margin = margin.slice(0, -1)
			lines.push(`${margin}}`)
		}
		
		return lines
	}
	
	const makeNeederLines = (needer, indent, alreadyGots, cache = true, constants, template) => {
		const lines = []
		const need = needer.need
		if (need.generateGet && !alreadyGots.includes(needer.name)) {
			// "I'll just add one more parameter to this function. This is the last one, I swear."
			// "I'll just add one more parameter to this function. This is the last one, I swear."
			// "I'll just add one more parameter to this function. This is the last one, I swear."
			// "I'll just add one more parameter to this function. This is the last one, I swear."
			// "I'll just add one more parameter to this function. This is the last one, I swear."
			// "I'll just add one more parameter to this function. This is the last one, I swear."
			// "I'll just add one more parameter to this function. This is the last one, I swear."
			// "I'll just add one more parameter to this function. This is the last one, I swear."
			// "I'll just add one more parameter to this function. This is the last one, I swear."
			// "I'll just add one more parameter to this function. This is the last one, I swear."
			// "I'll just add one more parameter to this function. This is the last one, I swear."
			const getCode = need.generateGet(needer.x, needer.y, needer.z, needer.symmetry, needer.symmetryId, needer.id, needer.argNames, needer.idResultName, needer.forSymmId, needer.char, template, needer.diagram, needer.isAll, needer.spotMods)
			if (getCode !== undefined) lines.push(`${indent}const ${needer.name} = ${getCode}`)
			if (cache) alreadyGots.push(needer.name)
		}
		if (need.generateConstant) {
			const constantCode = need.generateConstant(needer.x, needer.y, needer.z, needer.symmetry, needer.symmetryId, needer.id, needer.argNames, needer.idResultName, needer.forSymmId, needer.char, template, needer.diagram, needer.isAll, needer.spotMods)
			if (constantCode !== undefined) constants.pushUnique(`const ${needer.name}Const = ${constantCode}`)
		}
		if (need.generateExtra) {
			const extraCode = need.generateExtra(needer.x, needer.y, needer.z, needer.symmetry, needer.symmetryId, needer.id, needer.argNames, needer.idResultName, needer.forSymmId, needer.char, template, needer.diagram, needer.isAll, needer.spotMods)
			if (extraCode !== undefined) lines.push(`${indent}${extraCode}`)
		}
		return lines
	}
	
	//========//
	// Behave //
	//========//
	const makeBehaveCode = (instructions, name) => {
		INSTRUCTION.resetIdResultCache() //spent one whole hour hunting a bug because i forgot to reset the cache for each element. caches are evil
		INSTRUCTION.resetCharIdCache() //lol made another cache instead of doing it properly. im sure njothing will go wrong
		const template = JAVASCRIPT.makeEmptyTemplate()
		
		const blockStart = {type: INSTRUCTION.TYPE.NAKED}
		const blockEnd = {type: INSTRUCTION.TYPE.BLOCK_END}
		const fullInstructions = [blockStart, ...instructions, blockEnd]
	
		for (let i = 0; i < fullInstructions.length; i++) {
			const instruction = fullInstructions[i]
			const type = instruction.type
			const value = instruction.value
			const tail = fullInstructions.slice(i+1)
			const diagramId = `D${i}`
			const jumps = type.generate(template, value, tail, undefined, undefined, undefined, undefined, undefined, undefined, diagramId)
			if (jumps !== undefined) i += jumps
		}
		
		const code = buildTemplate(template)
		//if (name == "DReg") print(code)
		return code
	}
	
	const indentInnerCode = (code) => {
		const lines = code.split("\n")
		const indentedLines = lines.map((line, i) => (i == 0 || i >= lines.length-2)? line : `	${line}`)
		const indentedCode = indentedLines.join("\n")
		return indentedCode
	}
	
}




//==== Source/Parse.js ====//
;
{
	//=======//
	// Scope //
	//=======//
	const makeScope = (parent) => ({
		parent,
		elements: {},
		data: {},
		args: {},
		instructions: [],
		symbols: {_: undefined, o: undefined, d: undefined},
		properties: {},
		categories: [],
	})
	
	const absorbScope = (receiver, target, propsOnly = false, copySymbols = true) => {
		receiver.args.o= target.args
		receiver.data.o= target.data
		receiver.elements.o= target.elements
		receiver.global = target.global
		if (!propsOnly) receiver.instructions.push(...target.instructions)
		
		receiver.categories.push(...target.categories)
		receiver.properties.o= target.properties
		
		if (!copySymbols) return
		for (const symbolName in target.symbols) {
			if (target.symbols[symbolName] === undefined) continue
			if (receiver.symbols[symbolName] === undefined) {
				receiver.symbols[symbolName] = {}
			}
			receiver.symbols[symbolName].o= target.symbols[symbolName]
		}
	}
	
	const getSymbol = (name, scope, {parentOnly = false} = {}) => {
		if (!parentOnly && scope.symbols[name] != undefined) {
			return scope.symbols[name]
		}
		else if (scope.parent != undefined) {
			return getSymbol(name, scope.parent)
		}
	}
	
	const getElement = (name, scope) => {
		if (scope.elements[name] != undefined) {
			return scope.elements[name]
		}
		else if (scope.parent != undefined) {
			return getElement(name, scope.parent)
		}
	}
	
	//========//
	// Indent //
	//========//
	let indentBase = undefined
	let indentUnit = undefined
	let indentDepth = undefined
	
	const resetIndentInfo = () => {
		indentBase = undefined
		indentUnit = undefined
		indentDepth = 0
	}
	
	const getMargin = (depth) => {
		const margin = indentBase + [indentUnit].repeated(depth).join("")
		return margin
	}
	
	const getStringMarginLeft = (string) => {
		for (let i = 0; i < string.length; i++) {
			const char = string[i]
			if (char != " ") return i
		}
	}
	
	const getStringMarginRight = (string) => {
		return getStringMarginLeft(string.split("").reverse().join(""))
	}
	
	EAT.oneNonindent = (source, args) => EAT.nonindent(source, {...args, oneOnly: true})
	
	// Stay on the same indent level
	EAT.nonindent = (source, {oneOnly=false} = {}) => {
		
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success, snippet} = EAT.emptyLines(code)
		if (!success) return EAT.fail(code)
		
		const numberOfLines = snippet.split("\n").length - 1
		if (oneOnly == true && numberOfLines > 1) return EAT.fail(code)
		
		// NO BASE INDENT
		if (indentBase == undefined) {
			result = {code, snippet} = EAT.maybe(EAT.margin)(code)
			indentBase = snippet
			result.snippet = "\n"
			return result
		}
		
		// FULL CHECK
		else if (indentBase != undefined && indentUnit != undefined) {
			const expectedMargin = getMargin(indentDepth)
			result = {success, code, snippet} = EAT.string(expectedMargin)(code)
			if (success) {
				result.snippet = "\n"
				return result
			}
		}
		
		// PARTIAL CHECK
		else if (indentBase != undefined) {
			if (indentDepth == 0) {
				result = {success} = EAT.string(indentBase)(code)
				if (success) {
					result.snippet = "\n"
					return result
				}
			}
		}
		
		return EAT.fail(code)
		
	}
	
	// Go one indent level deeper
	EAT.indent = (source) => {
		
		indentDepth++
		
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success, snippet} = EAT.emptyLines(code)
		if (!success) {
			return EAT.fail(code)
		}
		
		// NO BASE INDENT
		if (indentBase == undefined) throw new Error(`[SpaceTode] The base indent level should have been discovered by now - something has gone wrong`)
		
		// GET INDENT UNIT
		else if (indentUnit == undefined) {
			result = {code, snippet} = EAT.maybe(EAT.margin)(code)
			if (snippet.slice(0, indentBase.length) != indentBase) return EAT.fail(code)
			const unit = snippet.slice(indentBase.length)
			if (unit.length == 0) return EAT.fail(code)
			indentUnit = unit
			if (indentBase.length > 0 && indentBase[0] != indentUnit[0]) return EAT.fail(code)
			return result
		}
		
		// CHECK INDENT
		const expectedMargin = getMargin(indentDepth)
		result = {code, snippet} = EAT.string(expectedMargin)(code)
		return result
		
	}
	
	// Go one indent level back
	EAT.unindent = (source) => {
	
		indentDepth--
		if (indentDepth < 0) throw new Error(`[SpaceTode] Can't reduce indent level below zero. This shouldn't happen.`)
		
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success, snippet} = EAT.emptyLines(code)
		if (!success) return EAT.fail(code)
		
		//result = {code, snippet} = EAT.maybe(EAT.margin)(code)
		
		if (indentBase == undefined) throw new Error(`[SpaceTode] The base indent level should have been discovered by now - something has gone wrong`)
		if (indentUnit == undefined) throw new Error(`[SpaceTode] The indent unit should have been discovered by now - something has gone wrong`)
		
		// CHECK INDENT
		const expectedMargin = getMargin(indentDepth)
		result = {code, snippet} = EAT.string(expectedMargin)(code)
		return result	
		
	}
	
	//=======//
	// Block //
	//=======//
	EAT.BLOCK_INLINE = Symbol("BlockInline")
	EAT.BLOCK_SINGLE = Symbol("BlockSingle")
	EAT.BLOCK_MULTI = Symbol("BlockMulti")
	
	EAT.block = (inner, noInline = false) => (source, ...args) => {
		
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code} = EAT.gap(code)
		result = {success} = EAT.string("{")(code)
		if (success) return EAT.blockBrace(inner)(code, ...args)
		else if (noInline) return EAT.fail(source)
		else return EAT.blockInline(inner)(code, ...args)
		
	}
	
	EAT.blockBrace = (inner) => (source, ...args) => {
		
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.string("{")(code)
		if (!success) return EAT.fail(code)
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.newline(code)
		if (!success) return EAT.blockSingle(inner)(source, ...args)
		else return EAT.blockMulti(inner)(source, ...args)
		
	}
	
	EAT.blockMulti = (inner) => (source, ...args) => {
	
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.string("{")(code)
		if (!success) return EAT.fail(code)
		
		result = {code, success} = inner(EAT.BLOCK_MULTI)(code, ...args)
		if (!success) return EAT.fail(code)
		const resultProperties = result
		
		result = {code, success} = EAT.string("}")(code)
		if (!success) return EAT.fail(code)
		
		return {...resultProperties, success: true, code: result.code}
	}
	
	EAT.blockSingle = (inner) => (source, ...args) => {
		
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.string("{")(code)
		if (!success) return EAT.fail(code)
		
		result = {code} = EAT.gap(code)
		result = {code, success} = inner(EAT.BLOCK_SINGLE)(code, ...args)
		if (!success) return EAT.fail(code)
		const resultProperties = result
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.string("}")(code)
		return {...resultProperties, ...result}
	}
	
	EAT.blockInline = (inner) => (source, ...args) => {
		
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code} = EAT.gap(code)
		result = {code, success} = inner(EAT.BLOCK_INLINE)(code, ...args)
		return result
		
	}
	
	//===========//
	// SpaceTode //
	//===========//
	SpaceTode = ([source]) => {
	
		resetIndentInfo()
	
		let result = undefined
		let success = undefined
		let code = source
		
		result = {code} = EAT.stripComments(code)
		
		// When SpaceTode is written at the top level, it is in its own scope.
		// It is then copied to the global scope.
		const scope = makeScope(SpaceTode.global)
		scope.global = true
		result = {success, code} = EAT.todeSplatMultiInner(code, scope)
		absorbScope(SpaceTode.global, scope)
		
		return scope
		
	}
	
	SpaceTode.global = makeScope()
	
	EAT.todeSplatBlock = (source, scope) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		const blockScope = makeScope(scope)
		result = {code, success} = EAT.block(EAT.todeSplat)(code, blockScope)
		if (!success) return EAT.fail(code)
		
		return {...result, blockScope}
		
	}
	
	EAT.todeSplat = (type) => (source, scope) => {
		
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		if (type == EAT.BLOCK_INLINE) {
			return EAT.maybe(EAT.todeSplatLine)(code, scope)
		}
		
		else if (type == EAT.BLOCK_SINGLE) {
			
			// bandage for inline javascript
			let lineResult = {snippet} = EAT.line(code)
			let edoc = snippet.split("").reverse().join("")
			lineResult = {code: edoc} = EAT.gap(edoc)
			lineResult = {code: edoc} = EAT.string("}")(edoc)
			code = edoc.split("").reverse().join("")
			const lineCode = code
			const nextCode = source.slice(lineCode.length)
			// bandage ends
			
			result = {code, success} = EAT.maybe(EAT.todeSplatLine)(code, scope)
			return {success, snippet: lineCode, code: nextCode}
		}
		
		else if (type == EAT.BLOCK_MULTI) {
		
			// EMPTY
			result = {success} = EAT.list (
				EAT.nonindent,
				EAT.string("}"),
			)(code)
			
			if (success) return EAT.nonindent(code)
			
			// NON-EMPTY
			return EAT.todeSplatMulti(code, scope)
		}
		
	}
	
	EAT.todeSplatMulti = (source, scope) => {
	
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.indent(code)
		if (!success) return EAT.fail(code)
		
		result = {code, success} = EAT.todeSplatMultiInner(code, scope)
		if (!success) return EAT.fail(code)
	
		result = {code, success} = EAT.unindent(code)
		if (!success) return EAT.fail(code)
		
		return result
		
	}
	
	EAT.todeSplatMultiInner = (source, scope) => {
	
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.todeSplatLine(code, scope)
		result = {code} = EAT.many (
			EAT.list (
				EAT.nonindent,
				EAT.todeSplatLine,
			)
		)(code, scope)
		
		return {success, code, snippet: result.snippet}
	}
	
	EAT.todeSplatLine = (source, scope, ignoreDiagram=false) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		// 'element' keyword
		result = {success} = EAT.string("element")(code)
		if (success) return EAT.element(code, scope)
		
		// 'prop'
		result = {success} = EAT.customProperty(code, scope)
		if (success) return result
		
		// 'data'
		result = {success} = EAT.data(code, scope)
		if (success) return result
		
		result = {success} = EAT.arg(code, scope)
		if (success) return result
		
		result = {success} = EAT.mimic(code, scope)
		if (success) return result
		
		// behave
		result = {success} = EAT.behave(code, scope)
		if (success) return result
		
		// 'colour', 'emissive', 'category', etc
		result = {success} = EAT.property(code, scope)
		if (success) return result
		
		// symbol part
		result = {success} = EAT.symbolPart(code, scope)
		if (success) return result
		
		// DIAGRAM SHENANIGENS BELOW
		if (ignoreDiagram) {
			const testResult = EAT.or(
				EAT.string("maybe"),
				EAT.string("action"),
				EAT.string("any"),
				EAT.string("for"),
				EAT.string("all"),
				EAT.string("pov"),
				EAT.string("rule"),
				EAT.string("{"),
			)(code)
			if (testResult.success) return testResult
			else return EAT.fail(code)
		}
		
		result = {success} = EAT.random(code, scope)
		if (success) return result
		
		result = {success} = EAT.action(code, scope)
		if (success) return result
		
		result = {success} = EAT.any(code, scope)
		if (success) return result
		
		result = {success} = EAT.for(code, scope)
		if (success) return result
		
		result = {success} = EAT.all(code, scope)
		if (success) return result
		
		result = {success} = EAT.pov(code, scope)
		if (success) return result
		
		// rule block
		const ruleBlockCode = code
		result = {success, code} = EAT.string("rule")(code)
		if (success) {
			result = {code} = EAT.gap(code)
			const blockScope = makeScope(scope)
			result = {code, success} = EAT.block(EAT.todeSplat)(code, blockScope)
			absorbScope(scope, blockScope)
			scope.instructions.push({type: INSTRUCTION.TYPE.NAKED})
			absorbScope(scope, blockScope, false, false)
			scope.instructions.push({type: INSTRUCTION.TYPE.BLOCK_END})
			return {...result, blockScope}
		}
		
		// naked block
		const blockScope = makeScope(scope)
		result = {code, success} = EAT.block(EAT.todeSplat, true)(code, blockScope)
		if (success) {
			scope.instructions.push({type: INSTRUCTION.TYPE.NAKED})
			absorbScope(scope, blockScope, false, false)
			scope.instructions.push({type: INSTRUCTION.TYPE.BLOCK_END})
			return {...result, blockScope}
		}
		
		// IF ALL ELSE FAILS
		// rule diagram!
		if (!ignoreDiagram) {
			result = {success} = EAT.diagram(code, scope)
			if (success) return result
		}
		
		return EAT.fail(code)
	}
	
	//=========//
	// Comment //
	//=========//
	// Has issues with Regex literals
	EAT.stripComments = (source) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		let codeStripped = ""
		
		let state = "normal"
		let stringEnder = undefined
		
		for (let i = 0; i < code.length; i++) {
			const char = code[i]
			if (state == "normal") {
				if (char == "/") {
					const nextChar = code[i+1]
					if (nextChar == "/") {
						state = "lineComment"
						i++
					}
					else if (nextChar == "*") {
						state = "blockComment"
						i++
					}
					else {
						codeStripped += char
					}
				}
				else if (char == '"') {
					codeStripped += char
					state = "string"
					stringEnder = '"'
				}
				else if (char == "'") {
					codeStripped += char
					state = "string"
					stringEnder = "'"
				}
				else if (char == "`") {
					throw new Error(`[SpaceTode] Template strings are not supported, sorry...`)
				}
				else {
					codeStripped += char
				}
			}
			else if (state == "blockComment") {
				if (char == "*") {
					const nextChar = code[i+1]
					if (nextChar == "/") {
						i++
						state = "normal"
					}
				}
			}
			else if (state == "lineComment") {
				if (char == "\n") {
					codeStripped += char
					state = "normal"
				}
			}
			else if (state == "string") {
				codeStripped += char
				if (char == "\\") {
					state = "stringEscape"
				}
				if (char == stringEnder) {
					state = "normal"
					stringEnder = undefined
				}
			}
			else if (state == "stringEscape") {
				codeStripped += char
				state = "string"
			}
			else {
				throw new Error (`[SpaceTode] Undeclared state while stripping comments: '${state}'`)
			}
		}
	
		return {result: success, code: codeStripped, snippet: source}
	}
	
	//=========//
	// Element //
	//=========//
	EAT.element = (source, parentScope) => {
		
		const scope = makeScope(parentScope)
		
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.string("element")(code)
		if (!success) throw new Error(`[SpaceTode] Expected 'element' keyword at start of element but got '${code[0]}'`)
		
		result = {code, success} = EAT.gap(code)
		if (!success) throw new Error(`[SpaceTode] Expected gap after 'element' keyword but got '${code[0]}'`)
		
		result = {code, success, snippet} = EAT.name(code)
		if (!success) throw new Error(`[SpaceTode] Expected element name but got '${code[0]}'`)
		scope.name = snippet
		
		//scope.instructions.push({type: INSTRUCTION.TYPE.BLOCK_START})
		const preBlockCode = code
		result = {code, success} = EAT.block(EAT.todeSplat)(code, scope)
		if (!success) throw new Error(`[SpaceTode] Expected element block but got something else:\n\n${code.split("\n").slice(0, 10).join("\n")}\n...\n`)
		
		//scope.instructions.push({type: INSTRUCTION.TYPE.BLOCK_END})
		
		snippet = source.slice(0, source.length - result.code.length)
		scope.properties.source = snippet
		
		const element = ELEMENT.make(scope, scope.properties)
		parentScope.elements[scope.name] = element
		
		if (parentScope.global == true) {
			if (window[scope.name] !== undefined) console.warn(`[SpaceTode] Overriding existing value with new element: '${scope.name}'`)
			window[scope.name] = element
		}
		
		return {success: true, snippet, code: result.code}
	}
	
	//========//
	// Symbol //
	//========//
	const SYMBOL_PART_NAMES = [
		"origin",
		"given",
		"change",
		"keep",
		"symbol",
		"select",
		"check",
	]
	
	EAT.symbolName = EAT.many(EAT.regex(/[^ 	\n]/))
	
	EAT.symbolPartReference = (source) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success, snippet} = EAT.name(code)
		if (!success) return EAT.fail(code)
		if (!SYMBOL_PART_NAMES.includes(snippet)) return EAT.fail(code)
		
		return result
	}
	
	EAT.symbolPart = (source, scope) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success, snippet} = EAT.symbolPartReference(code)
		const symbolPartName = snippet
		if (!success) return EAT.fail(code)
		
		result = {code} = EAT.gap(code)
		result = {code, success, snippet} = EAT.symbolName(code)
		const symbolName = snippet
		if (!success) return EAT.fail(code)
		
		const existingSymbol = getSymbol(symbolName, scope, {parentOnly: true})
		if (existingSymbol !== undefined) {
			throw new Error(`[SpaceTode] You can't define a symbol over multiple scopes: '${symbolName}'`)
		}
		
		const nojsResult = result
		
		result = {code} = EAT.gap(code)
		
		// TODO: before checking for javascript, check for:
		// (a) another symbol name to copy from
		//      note: what is copied should be different for symbol, input and output
		// (b) an element to base myself on - resultant code depends on what part it is
		
		// TODO: throw warning if you add javascript to a symbol part that doesn't use it
		// eg: origin, symbol
		result = {code, success, snippet, funcCode} = EAT.javascript(code, undefined, undefined, undefined, undefined, symbolPartName === "symbol")
		const javascript = funcCode
		
		if (scope.symbols[symbolName] == undefined) {
			scope.symbols[symbolName] = {}
			/*for (const symbolPartName of SYMBOL_PART_NAMES) {
				scope.symbols[symbolName][symbolPartName] = []
			}*/
		}
		const symbol = scope.symbols[symbolName]
		
		if (symbol.has(symbolPartName)) {
			throw new Error(`[SpaceTode] You can't define more than one '${symbolPartName}' on the '${symbolName}' symbol.`)
		}
		symbol[symbolPartName] = javascript		
		
		if (symbolPartName === "symbol") {
			symbol.given = `(element) => element === (${javascript})`
			symbol.change = `() => new (${javascript})()`
		}
		
		if (!success) return nojsResult
		else return result
	}
	
	EAT.behave = (source, scope) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.string("behave")(code)
		if (!success) return EAT.fail(code)
		
		result = {code} = EAT.gap(code)
		result = {code, success, snippet} = EAT.javascript(code, undefined, undefined, undefined, undefined, true)
		if (!success) return EAT.fail(code)
		scope.instructions.push({type: INSTRUCTION.TYPE.BEHAVE, value: result.funcCode})
		return result
	}
	
	//=============//
	// Declaration //
	//=============//
	const PROPERTY_NAMES = [
		"colour",
		"emissive",
		"opacity",
		"precise",
		"floor",
		"hidden",
		"category",
		"pour",
		"default",
		"visible",
	]
	
	EAT.propertyName = (source) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success, snippet} = EAT.name(code)
		if (!success) return EAT.fail(code)
		if (!PROPERTY_NAMES.includes(snippet)) return EAT.fail(code)
		
		return result
		
	}
	
	EAT.property = (source, scope) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success, snippet} = EAT.propertyName(code)
		const propertyName = snippet
		if (!success) return EAT.fail(code)
		const name = result.snippet
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.javascript(code)
		if (!success) return EAT.fail(code)
		
		if (propertyName == "category") {
			scope.categories.push(result.value)
		}
		else scope.properties[name] = result.value
		
		return result
	}
	
	EAT.data = (source, scope) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.string("data")(code)
		if (!success) return EAT.fail(code)
		
		result = {code, success} = EAT.gap(code)
		if (!success) return EAT.fail(code)
		
		result = {code, success, snippet} = EAT.name(code)
		if (!success) return EAT.fail(code)
		const name = result.snippet
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.javascript(code)
		//if (!success) return EAT.fail(code)
		
		scope.data[name] = result.value
		
		return {...result, success: true}
		
	}
	
	EAT.arg = (source, scope) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.string("arg")(code)
		if (!success) return EAT.fail(code)
		
		result = {code, success} = EAT.gap(code)
		if (!success) return EAT.fail(code)
		
		result = {code, success, snippet} = EAT.name(code)
		if (!success) return EAT.fail(code)
		const name = result.snippet
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.javascript(code)
		//if (!success) code 
		
		scope.args[name] = result.value
		
		return {...result, success: true}
		
	}
	
	EAT.customProperty = (source, scope) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.string("prop")(code)
		if (!success) return EAT.fail(code)
		
		result = {code, success} = EAT.gap(code)
		if (!success) return EAT.fail(code)
		
		result = {code, success, snippet} = EAT.name(code)
		if (!success) return EAT.fail(code)
		const name = result.snippet
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.javascript(code)
		if (!success) return EAT.fail(code)
		
		scope.properties[name] = result.value
		
		return result
		
	}
	
	//==========//
	// Function //
	//==========//
	EAT.mimic = (source, scope) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.string("mimic")(code)
		if (!success) return EAT.fail(code)
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.string("(")(code)
		if (!success) return EAT.fail(code)
		
		result = {code} = EAT.gap(code)
		result = {code, success, snippet} = EAT.javascriptArg(code, undefined, undefined, undefined, undefined, true)
		if (!success) return EAT.fail(code)
		
		scope.instructions.push({type: INSTRUCTION.TYPE.MIMIC, value: result.value})
		
		return result
		
	}
	
	EAT.random = (source, scope) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.string("maybe")(code)
		if (!success) return EAT.fail(code)
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.string("(")(code)
		if (!success) return EAT.fail(code)
		
		result = {code} = EAT.gap(code)
		result = {code, success, snippet} = EAT.javascriptArg(code)
		if (!success) return EAT.fail(code)
		
		const chance = result.value
		
		scope.instructions.push({type: INSTRUCTION.TYPE.MAYBE, value: result.value})
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.todeSplatBlock(code, scope)
		if (!success) return EAT.fail(code)
		
		absorbScope(scope, result.blockScope, false, false)
		//scope.instructions.push(...result.blockScope.instructions)
		scope.instructions.push({type: INSTRUCTION.TYPE.BLOCK_END})
		
		return result
		
	}
	
	EAT.pov = (source, scope) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.string("pov")(code)
		if (!success) return EAT.fail(code)
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.string("(")(code)
		if (!success) return EAT.fail(code)
		
		let jsHead = ``
		for (const povName in POV.TYPE) {
			jsHead += `const ${povName.as(LowerCase)} = POV.TYPE.${povName}\n`
		}
		
		result = {code} = EAT.gap(code)
		result = {code, success, snippet} = EAT.javascriptArg(code, jsHead)
		if (!success) return EAT.fail(code)
		
		const chance = result.value
		
		scope.instructions.push({type: INSTRUCTION.TYPE.POV, value: result.value})
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.todeSplatBlock(code, scope)
		if (!success) return EAT.fail(code)
		
		absorbScope(scope, result.blockScope, false, false)
		//scope.instructions.push(...result.blockScope.instructions)
		scope.instructions.push({type: INSTRUCTION.TYPE.BLOCK_END})
		
		return result
		
	}
	
	EAT.for = (source, scope) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.string("for")(code)
		if (!success) return EAT.fail(code)
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.string("(")(code)
		if (!success) return EAT.fail(code)
		
		let jsHead = ``
		for (const symmetryName in SYMMETRY.TYPE) {
			jsHead += `const ${symmetryName.as(LowerCase)} = SYMMETRY.TYPE.${symmetryName}\n`
		}
		
		result = {code} = EAT.gap(code)
		result = {code, success, snippet} = EAT.javascriptArg(code, jsHead)
		if (!success) return EAT.fail(code)
		
		const symm = result.value
		if (symm === undefined || symm.transformations === undefined) {
			throw new Error(`[SpaceTode] Unrecognised symmetry: '${snippet.slice(0, -1)}'`)
		}
		
		scope.instructions.push({type: INSTRUCTION.TYPE.FOR, value: result.value})
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.todeSplatBlock(code, scope)
		if (!success) return EAT.fail(code)
		
		absorbScope(scope, result.blockScope, false, false)
		/*scope.properties.o= result.blockScope.properties
		scope.instructions.push(...result.blockScope.instructions)*/
		scope.instructions.push({type: INSTRUCTION.TYPE.BLOCK_END})
		
		return result
		
	}
	
	EAT.all = (source, scope) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.string("all")(code)
		if (!success) return EAT.fail(code)
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.string("(")(code)
		if (!success) return EAT.fail(code)
		
		let jsHead = ``
		for (const symmetryName in SYMMETRY.TYPE) {
			jsHead += `const ${symmetryName.as(LowerCase)} = SYMMETRY.TYPE.${symmetryName}\n`
		}
		
		result = {code} = EAT.gap(code)
		result = {code, success, snippet} = EAT.javascriptArg(code, jsHead)
		if (!success) return EAT.fail(code)
		
		const symm = result.value
		if (symm === undefined || symm.transformations === undefined) {
			throw new Error(`[SpaceTode] Unrecognised symmetry: '${snippet.slice(0, -1)}'`)
		}
		
		scope.instructions.push({type: INSTRUCTION.TYPE.FOR, value: {...result.value, type: "all"}})
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.todeSplatBlock(code, scope)
		if (!success) return EAT.fail(code)
		
		absorbScope(scope, result.blockScope, false, false)
		/*scope.properties.o= result.blockScope.properties
		scope.instructions.push(...result.blockScope.instructions)*/
		scope.instructions.push({type: INSTRUCTION.TYPE.BLOCK_END})
		
		return result
		
	}
	
	EAT.any = (source, scope) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.string("any")(code)
		if (!success) return EAT.fail(code)
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.string("(")(code)
		if (!success) return EAT.fail(code)
		
		let jsHead = ``
		for (const symmetryName in SYMMETRY.TYPE) {
			jsHead += `const ${symmetryName.as(LowerCase)} = SYMMETRY.TYPE.${symmetryName}\n`
		}
		
		result = {code} = EAT.gap(code)
		result = {code, success, snippet} = EAT.javascriptArg(code, jsHead)
		if (!success) return EAT.fail(code)
		
		const symm = result.value
		if (symm === undefined || symm.transformations === undefined) {
			throw new Error(`[SpaceTode] Unrecognised symmetry: '${snippet.slice(0, -1)}'`)
		}
		
		scope.instructions.push({type: INSTRUCTION.TYPE.ANY, value: result.value})
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.todeSplatBlock(code, scope)
		if (!success) return EAT.fail(code)
		
		absorbScope(scope, result.blockScope, false, false)
		/*scope.properties.o= result.blockScope.properties
		scope.instructions.push(...result.blockScope.instructions)*/
		scope.instructions.push({type: INSTRUCTION.TYPE.BLOCK_END})
		
		return result
		
	}
	
	EAT.action = (source, scope) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.string("action")(code)
		if (!success) return EAT.fail(code)
		
		scope.instructions.push({type: INSTRUCTION.TYPE.ACTION})
		
		result = {code} = EAT.gap(code)
		result = {code, success} = EAT.todeSplatBlock(code, scope)
		if (!success) return EAT.fail(code)
		
		absorbScope(scope, result.blockScope, false, false)
		//scope.instructions.push(...result.blockScope.instructions)
		scope.instructions.push({type: INSTRUCTION.TYPE.BLOCK_END})
		
		return result
		
	}
	
	//=====//
	// Arg //
	//=====//
	EAT.javascriptArg = (source, head="", innerHead="", innerTail="", tail="", lazy=false) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		let innerCode = ""
		let state = "normal"
		let nestLevel = 1
		let stringEnder = undefined
		
		for (let i = 0; i < code.length; i++) {
			const char = code[i]
			
			if (state == "normal") {
				if (char == "(") {
					nestLevel++
				}
				else if (char == ")") {
					nestLevel--
					if (nestLevel <= 0) {
						state = "finished"
						break
					}
				}
				else if (char == '"') {
					state = "string"
					stringEnder = '"'
				}
				else if (char == "'") {
					state = "string"
					stringEnder = "'"
				}
				else if (char == "`") {
					throw new Error(`[SpaceTode] Template strings are not supported, sorry...`)
				}
				innerCode += char
			}
			
			else if (state == "string") {
				innerCode += char
				if (char == "\\") {
					state = "stringEscape"
				}
				if (char == stringEnder) {
					state = "normal"
					stringEnder = undefined
				}
			}
			
			else if (state == "stringEscape") {
				innerCode += char
				state = "string"
			}
		}
		
		if (state != "finished") return EAT.fail(code)
		
		result = {success} = EAT.javascript(innerCode, head, innerHead, innerTail, tail, lazy)
		if (!success) return EAT.fail(code)
		
		return {success, snippet: innerCode+")", code: source.slice(innerCode.length+1), value: result.value}
		
	}
	
	//=========//
	// Diagram //
	//=========//
	EAT.diagram = (source, scope, arrowOnly=false) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		const lines = code.split("\n")
		
		// CUTOUT DIAGRAM
		const diagram = []
		
		// reject empty starting line
		if (lines[0].is(WhiteSpace)) return EAT.fail(code)
		
		// reject non-arrow lines
		if (arrowOnly && !lines[0].includes("=>")) return EAT.fail(code)
		
		// scoop up first line
		const notes = {arrowFound: false, firstLine: true}
		result = {code, success, snippet} = EAT.diagramLine(code, notes)
		if (!success) return EAT.fail(code)
		diagram.push(snippet)
		
		// scoop up each line
		result = {code, success, snippet} = EAT.many (
			EAT.list (
				EAT.oneNonindent,
				EAT.diagramLine,
			)	
		)(code, notes)
		
		if (success) diagram.push(...snippet.split("\n").slice(1))
		
		// pad ends of diagram lines if they're too short
		const maxLength = Math.max(...diagram.map(line => line.length))
		for (const i in diagram) {
			const line = diagram[i]
			if (line.length < maxLength) {
				diagram[i] = line + [" "].repeated(maxLength - line.length).join("")
			}
		}
		
		// READ DIAGRAM
		// find arrow position
		let arrowX = undefined
		let arrowY = undefined
		for (let i = 0; i < diagram.length; i++) {
			const line = diagram[i]
			const arrowIndex = line.indexOf("=>")
			if (arrowIndex != -1) {
				arrowX = arrowIndex
				arrowY = i
				break
			}
		}
		
		if (arrowX == undefined) throw new Error(`[SpaceTode] Couldn't find arrow's x position.\n\nNOTE: I am trying to interpret a line of code as a diagram, but it is possible that you intended to write something else. The line in question is:\n\n${diagram[0]}\n`)
		if (arrowY == undefined) throw new Error(`[SpaceTode] Couldn't find arrow's y position. This shouldn't happen.`)
		
		// split into lhs and rhs
		let lhs = diagram.map(line => line.slice(0, arrowX))
		const mid = diagram.map(line => line.slice(arrowX, arrowX + "=>".length))
		let rhs = diagram.map(line => line.slice(arrowX + "=>".length))
		
		// reject if junk in middle
		for (let i = 0; i < mid.length; i++) {
			if (i == arrowY) continue
			const line = mid[i]
			if (!line.is(WhiteSpace)) throw new Error(`[SpaceTode] You can't have any symbols crossing over with a diagram's arrow.`)
		}
		
		// find the shortest margins of the diagram
		const lhsMarginLeft = Math.min(...lhs.map(getStringMarginLeft))
		const lhsMarginRight = Math.min(...lhs.map(getStringMarginRight))
		const rhsMarginLeft = Math.min(...rhs.map(getStringMarginLeft))
		const rhsMarginRight = Math.min(...rhs.map(getStringMarginRight))
		
		// trim each side down
		const lhsTrimmed = lhs.map(line => line.slice(lhsMarginLeft, line.length - lhsMarginRight))
		const rhsTrimmed = rhs.map(line => line.slice(rhsMarginLeft, line.length - rhsMarginRight))
		
		lhs = lhsTrimmed
		rhs = rhsTrimmed
		
		// check that the silhouettes of both sides are the same
		for (let i = 0; i < diagram.length; i++) {
		
			const lhsLine = lhs[i]
			const rhsLine = rhs[i]
			if (lhsLine.length != rhsLine.length) throw new Error(`[SpaceTode] Right-hand-side silhouette did not match left-hand-side silhouette.\n\nNOTE: I am trying to interpret a line of code as a diagram, but it is possible that you intended to write something else. The line in question is:\n\n${diagram[0]}\n`)
		
			for (let j = 0; j < lhs.length; j++) {
				if (lhs[i][j] == " " && rhs[i][j] != " ") throw new Error(`[SpaceTode] Right-hand-side silhouette did not match left-hand-side silhouette.`)
				if (rhs[i][j] == " " && lhs[i][j] != " ") throw new Error(`[SpaceTode] Right-hand-side silhouette did not match left-hand-side silhouette.`)
			}
		}
		
		// find origin
		let originX = undefined
		let originY = undefined
		if (lhs.length == 1 && lhs[0].trim().length == 1) {
			originX = 0
			originY = 0
		}
		else for (let i = 0; i < lhs.length; i++) {
			const line = lhs[i]
			for (let j = 0; j < line.length; j++) {
				const char = line[j]
				const symbol = getSymbol(char, scope)
				if (symbol && symbol.has("origin")) {
					if (originX != undefined) throw new Error(`[SpaceTode] You can't have more than one origin in the left-hand-side of a diagram.`)
					originX = j
					originY = i
				}
			}
		}
		
		if (originX == undefined) throw new Error(`[SpaceTode] Couldn't find origin in left-hand-side of diagram.\n\n${diagram.join("\n")}\n`)
		if (originY == undefined) throw new Error(`[SpaceTode] Couldn't find origin's y position. This shouldn't happen.`)
		
		// get positions of symbols
		const spaces = []
		for (let i = 0; i < lhs.length; i++) {
			const lhsLine = lhs[i]
			const rhsLine = rhs[i]
			for (let j = 0; j < lhsLine.length; j++) {
				const lhsChar = lhsLine[j]
				const rhsChar = rhsLine[j]
				
				if (lhsChar == " ") continue
				
				const x = j - originX
				const y = originY - i
				
				const input = getSymbol(lhsChar, scope)
				const output = getSymbol(rhsChar, scope)
				
				if (input == undefined) throw new Error(`[SpaceTode] Unrecognised symbol: ${lhsChar}`)
				if (output == undefined) throw new Error(`[SpaceTode] Unrecognised symbol: ${rhsChar}`)
				
				if (!input.has("origin") && !input.has("given") && !input.has("select") && !input.has("check")) {
					throw new Error(`[SpaceTode] Symbol '${lhsChar}' used on left-hand-side of diagram but doesn't have any left-hand-side parts, eg: given`)
				}
				
				if (!output.has("change") && !output.has("keep")) {
					throw new Error(`[SpaceTode] Symbol '${rhsChar}' used on right-hand-side of diagram but doesn't have any right-hand-side parts, eg: change`)
				}
				
				const space = {x, y, z:0, input, output, inputChar: lhsChar, outputChar: rhsChar}
				spaces.push(space)
			}
		}
		
		spaces.debug = {
			source: diagram.join("\n"),
		}
		
		const instruction = {type: INSTRUCTION.TYPE.DIAGRAM, value: spaces}
		scope.instructions.push(instruction)
		
		return {success: true, code: result.code, snippet: diagram.join("\n")}
		
	}
	
	EAT.diagramLine = (source, notes) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		const lines = code.split("\n")
		const line = lines[0]
		
		// reject if it's another todesplat line
		if (!notes.firstLine) {
			const dummyScope = makeScope()
			try {
				result = {success} = EAT.todeSplatLine(code, dummyScope, true)
				if (success) return EAT.fail(code)
			}
			catch {return EAT.fail(code)}
		}
		else notes.firstLine = false
		
		// reject tabs
		if (line.includes("	")) throw new Error(`[SpaceTode] You can't use tabs inside a diagram.\n\n${line}\n`)
		
		// find arrow
		if (line.includes("=>")) {
			if (!notes.arrowFound) notes.arrowFound = true
			else return EAT.fail(code)
		}
		
		return EAT.line(code)
		
	}
	
	//============//
	// Javascript //
	//============//
	EAT.javascript = (source, head="", innerHead="", innerTail="", tail="", lazy=false) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.block(EAT.javascriptInner)(code, head, innerHead, innerTail, tail, lazy)
		if (!success) return EAT.fail(code)
		
		return result
	}
	
	EAT.javascriptInner = (type) => (source, head="", innerHead="", innerTail="", tail="", lazy=false) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		if (type == EAT.BLOCK_INLINE) {
			return EAT.or (
				EAT.javascriptInlineMulti,
				EAT.javascriptInlineSingle,
			)(code, head, innerHead, innerTail, tail, lazy)
			
		}
		
		if (type == EAT.BLOCK_SINGLE) {
			result = {code, snippet, success} = EAT.many(EAT.regex(/[^}](?!\n)/))(code) //????
			if (!success) return EAT.fail(code)
			const funcCode = head + snippet + tail
			const func = new Function(funcCode)
			const value = lazy? func : func()
			result.value = value
			const niceFuncCode = `(() => {`+ funcCode + `})()`
			return {...result, snippet: funcCode, funcCode: niceFuncCode}
		}
		
		if (type == EAT.BLOCK_MULTI) {
			indentDepth++
			result = {code, snippet, success} = EAT.list (
				EAT.maybe(EAT.many(EAT.javascriptBraceLine)),
			)(code)
			let endResult = {code, success} = EAT.unindent(code)
			if (!success) return endResult
			const funcCode = head + snippet + tail
			const func = new Function(funcCode)
			const value = lazy? func : func()
			result.value = value
			const niceFuncCode = `(() => {`+ funcCode + `\n})()`
			return {...result, snippet: funcCode, funcCode: niceFuncCode, code}
		}
		
		return result
	}
	
	EAT.javascriptInlineSingle = (source, head="", innerHead="", innerTail="", tail="", lazy=false) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, snippet, success} = EAT.line(code)
		if (!success) return EAT.fail(code)
		const funcCode = head + "return " + innerHead + snippet + innerTail + tail
		const func = new Function(funcCode)
		const value = lazy? func : func()
		result.value = value
		const niceFuncCode = head + innerHead + snippet + innerTail + tail
		result.funcCode = niceFuncCode
		return result
	}
	
	EAT.javascriptInlineMulti = (source, head="", innerHead="", innerTail="", tail="", lazy=false) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		let js = ""
		result = {code, snippet, success} = EAT.line(code)
		if (!success) return EAT.fail(code)
		js += snippet
		
		result = {success} = EAT.indent(code)
		indentDepth--
		if (!success) {
			return EAT.fail(code)
		}
		
		indentDepth++
		result = {code, success, snippet} = EAT.many(EAT.javascriptInlineMultiLine)(code)
		js += snippet
		
		indentDepth--
		result = {code, success, snippet} = EAT.nonindent(code)
		if (!success) return EAT.fail(code)
		js += "\n"
		
		result = {code, success, snippet} = EAT.line(code)
		if (!success) return EAT.fail(code)
		js += snippet
		const funcCode = head + "return " + innerHead + js + innerTail + tail
		const func = new Function(funcCode)
		const value = lazy? func : func()
		result.value = value
		const niceFuncCode = head + innerHead + js + innerTail + tail
		result.funcCode = niceFuncCode
		
		return result
	}
	
	EAT.javascriptInlineMultiLine = (source) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {success} = EAT.nonindent(code)
		if (!success) return EAT.fail(code)
		
		result = {code, success} = EAT.newline(code)
		if (!success) return EAT.fail(code)
		
		result = {code, success} = EAT.line(code)
		if (!success) return EAT.fail(code)
		
		return {...result, snippet: "\n" + result.snippet}
	}
	
	EAT.javascriptBraceLine = (source) => {
		let result = undefined
		let success = undefined
		let snippet = undefined
		let code = source
		
		result = {code, success} = EAT.newline(code)
		
		const emptyResult = EAT.list (
			EAT.maybe(EAT.gap),
			EAT.newline,
			
		)(code)
		
		if (emptyResult.success) return {...emptyResult, code: "\n" + emptyResult.code}
		
		result = {code, success} = EAT.maybe(EAT.margin)(code)
		const actualMargin = result.snippet
		if (!success) return EAT.fail(code)
		
		const margin = getMargin(indentDepth)
		if (actualMargin.slice(0, margin.length) != margin) return EAT.fail(code)
		
		const marginDifference = actualMargin.length - margin.length
		const niceMargin = actualMargin.slice(0, marginDifference+1)
		
		result = {snippet} = EAT.line(code)
		result.snippet = "\n" + niceMargin + snippet
		
		return result

	}
	
}
